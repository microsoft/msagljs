!function(t){var e={};function i(n){if(e[n])return e[n].exports;var r=e[n]={i:n,l:!1,exports:{}};return t[n].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.m=t,i.c=e,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)i.d(n,r,function(e){return t[e]}.bind(null,r));return n},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=105)}([function(t,e,i){"use strict";i.d(e,"b",(function(){return n})),i.d(e,"a",(function(){return r})),i.d(e,"c",(function(){return s}));var n=1e-6,r="undefined"!=typeof Float32Array?Float32Array:Array,s=Math.random;Math.PI;Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)})},function(t,e,i){"use strict";i.d(e,"b",(function(){return n})),i.d(e,"d",(function(){return r})),i.d(e,"e",(function(){return s})),i.d(e,"a",(function(){return a})),i.d(e,"f",(function(){return l})),i.d(e,"c",(function(){return h}));i(16);Math.PI,Math.PI;const n={};function r(t,{precision:e=n.precision||4}={}){return t=function(t){return Math.round(t/n.EPSILON)*n.EPSILON}(t),"".concat(parseFloat(t.toPrecision(e)))}function s(t){return Array.isArray(t)||ArrayBuffer.isView(t)&&!(t instanceof DataView)}function o(t,e,i){if(s(t)){i=i||((n=t).clone?n.clone():new Array(n.length));for(let n=0;n<i.length&&n<t.length;++n)i[n]=e(t[n],n,i);return i}var n;return e(t)}function a(t,e,i){return o(t,t=>Math.max(e,Math.min(i,t)))}function l(t,e,i){return s(t)?t.map((t,n)=>l(t,e[n],i)):i*e+(1-i)*t}function h(t,e,i){const r=n.EPSILON;i&&(n.EPSILON=i);try{if(t===e)return!0;if(s(t)&&s(e)){if(t.length!==e.length)return!1;for(let i=0;i<t.length;++i)if(!h(t[i],e[i]))return!1;return!0}return t&&t.equals?t.equals(e):e&&e.equals?e.equals(t):!(!Number.isFinite(t)||!Number.isFinite(e))&&Math.abs(t-e)<=n.EPSILON*Math.max(1,Math.abs(t),Math.abs(e))}finally{n.EPSILON=r}}n.EPSILON=1e-12,n.debug=!1,n.precision=4,n.printTypes=!1,n.printDegrees=!1,n.printRowMajor=!0},function(t,e,i){"use strict";var n=this&&this.__spreadArrays||function(){for(var t=0,e=0,i=arguments.length;e<i;e++)t+=arguments[e].length;var n=Array(t),r=0;for(e=0;e<i;e++)for(var s=arguments[e],o=0,a=s.length;o<a;o++,r++)n[r]=s[o];return n};Object.defineProperty(e,"__esModule",{value:!0}),e.StringBuilder=e.String=void 0;var r=function(){function t(){}return t.IsNullOrWhiteSpace=function(t){try{return null==t||"undefined"==t||t.toString().replace(/\s/g,"").length<1}catch(t){return console.log(t),!1}},t.Join=function(e){for(var i=[],r=1;r<arguments.length;r++)i[r-1]=arguments[r];try{var s=i[0];if(Array.isArray(s)||s instanceof Array){for(var o=t.Empty,a=0;a<s.length;a++){var l=s[a];a<s.length-1?o+=l+e:o+=l}return o}if("object"==typeof s){var h=t.Empty,u=s,c=Object.keys(s);return c.forEach((function(t){h+=u[t]+e})),h=h.slice(0,h.length-e.length)}var d=i;return t.join.apply(t,n([e],d))}catch(e){return console.log(e),t.Empty}},t.Format=function(e){for(var i=[],n=1;n<arguments.length;n++)i[n-1]=arguments[n];try{return e.match(t.regexNumber)?t.format(t.regexNumber,e,i):e.match(t.regexObject)?t.format(t.regexObject,e,i,!0):e}catch(e){return console.log(e),t.Empty}},t.format=function(e,i,n,r){return void 0===r&&(r=!1),i.replace(e,(function(e,i){var s,o=e.split(":");return o.length>1&&(i=o[0].replace("{",""),e=o[1].replace("}","")),null==(s=r?n[0][i]:n[i])||null==s||e.match(/{\d+}/)||void 0!==(s=t.parsePattern(e,s))&&null!=s?s:t.Empty}))},t.parsePattern=function(e,i){switch(e){case"L":return i=i.toLocaleLowerCase();case"U":return i=i.toLocaleUpperCase();case"d":if("string"==typeof i)return t.getDisplayDateFromString(i);if(i instanceof Date)return t.Format("{0:00}.{1:00}.{2:0000}",i.getDate(),i.getMonth(),i.getFullYear());break;case"s":if("string"==typeof i)return t.getSortableDateFromString(i);if(i instanceof Date)return t.Format("{0:0000}-{1:00}-{2:00}",i.getFullYear(),i.getMonth(),i.getDate());break;case"n":"string"!=typeof i&&(i=i.toString());var r=i.replace(/,/g,".");if(isNaN(parseFloat(r))||r.length<=3)break;var s=r.split(/[^0-9]+/g),o=s;s.length>1&&(o=[t.join.apply(t,n([""],s.splice(0,s.length-1))),s[s.length-1]]);var a=o[0],l=a.length%3,h=l>0?a.substring(0,l):t.Empty,u=a.substring(l).match(/.{3}/g);return i=(h=h+"."+t.Join(".",u))+(o.length>1?","+o[1]:"");case"x":return this.decimalToHexString(i);case"X":return this.decimalToHexString(i,!0)}return"number"!=typeof i&&isNaN(i)||isNaN(+e)||t.IsNullOrWhiteSpace(i)?i:t.formatNumber(i,e)},t.decimalToHexString=function(t,e){void 0===e&&(e=!1);var i=parseFloat(t).toString(16);return e?i.toLocaleUpperCase():i},t.getDisplayDateFromString=function(t){var e;if((e=t.split("-")).length<=1)return t;var i=e[e.length-1],n=e[e.length-2],r=e[e.length-3];return(i=(i=i.split("T")[0]).split(" ")[0])+"."+n+"."+r},t.getSortableDateFromString=function(e){var i=e.replace(",","").split(".");if(i.length<=1)return e;var n=i[i.length-1].split(" "),r=t.Empty;n.length>1&&(r=n[n.length-1]);var s=i[i.length-1].split(" ")[0]+"-"+i[i.length-2]+"-"+i[i.length-3];return!t.IsNullOrWhiteSpace(r)&&r.length>1?s+="T"+r:s+="T00:00:00",s},t.formatNumber=function(t,e){var i=e.length,n=t.toString();if(i<=n.length)return n;var r=i-n.length;return new Array(r+=1).join("0")+n},t.join=function(e){for(var i=[],n=1;n<arguments.length;n++)i[n-1]=arguments[n];for(var r=t.Empty,s=0;s<i.length;s++)if(!("string"==typeof i[s]&&t.IsNullOrWhiteSpace(i[s])||"number"!=typeof i[s]&&"string"!=typeof i[s])){var o=""+i[s];r+=o;for(var a=s+1;a<i.length;a++)if(!t.IsNullOrWhiteSpace(i[a])){r+=e,s=a-1;break}}return r},t.regexNumber=/{(\d+(:\w*)?)}/g,t.regexObject=/{(\w+(:\w*)?)}/g,t.Empty="",t}();e.String=r;var s=function(){function t(t){this.Values=[],r.IsNullOrWhiteSpace(t)||(this.Values=new Array(t))}return t.prototype.ToString=function(){return this.Values.join("")},t.prototype.Append=function(t){this.Values.push(t)},t.prototype.AppendLine=function(t){this.Values.push("\r\n"+t)},t.prototype.AppendFormat=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];this.Values.push(r.Format.apply(r,n([t],e)))},t.prototype.AppendLineFormat=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];this.Values.push("\r\n"+r.Format.apply(r,n([t],e)))},t.prototype.Clear=function(){this.Values=[]},t}();e.StringBuilder=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(56);class r extends n.LinkedList{constructor(...t){super(...t)}get top(){return this.head}get size(){return this.length}push(t){this.prepend(t)}pop(){return this.removeHead()}}e.Stack=r},function(t,e,i){"use strict";i.d(e,"p",(function(){return r})),i.d(e,"e",(function(){return s})),i.d(e,"a",(function(){return o})),i.d(e,"g",(function(){return a})),i.d(e,"o",(function(){return l})),i.d(e,"n",(function(){return h})),i.d(e,"j",(function(){return u})),i.d(e,"k",(function(){return c})),i.d(e,"l",(function(){return d})),i.d(e,"m",(function(){return g})),i.d(e,"c",(function(){return f})),i.d(e,"d",(function(){return p})),i.d(e,"i",(function(){return m})),i.d(e,"h",(function(){return y})),i.d(e,"f",(function(){return b})),i.d(e,"b",(function(){return P}));var n=i(0);function r(t,e){if(t===e){var i=e[1],n=e[2],r=e[3],s=e[6],o=e[7],a=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=i,t[6]=e[9],t[7]=e[13],t[8]=n,t[9]=s,t[11]=e[14],t[12]=r,t[13]=o,t[14]=a}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15];return t}function s(t,e){var i=e[0],n=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],h=e[7],u=e[8],c=e[9],d=e[10],g=e[11],f=e[12],p=e[13],m=e[14],y=e[15],b=i*a-n*o,P=i*l-r*o,v=i*h-s*o,S=n*l-r*a,C=n*h-s*a,w=r*h-s*l,E=u*p-c*f,x=u*m-d*f,A=u*y-g*f,T=c*m-d*p,I=c*y-g*p,O=d*y-g*m,_=b*O-P*I+v*T+S*A-C*x+w*E;return _?(_=1/_,t[0]=(a*O-l*I+h*T)*_,t[1]=(r*I-n*O-s*T)*_,t[2]=(p*w-m*C+y*S)*_,t[3]=(d*C-c*w-g*S)*_,t[4]=(l*A-o*O-h*x)*_,t[5]=(i*O-r*A+s*x)*_,t[6]=(m*v-f*w-y*P)*_,t[7]=(u*w-d*v+g*P)*_,t[8]=(o*I-a*A+h*E)*_,t[9]=(n*A-i*I-s*E)*_,t[10]=(f*C-p*v+y*b)*_,t[11]=(c*v-u*C-g*b)*_,t[12]=(a*x-o*T-l*E)*_,t[13]=(i*T-n*x+r*E)*_,t[14]=(p*P-f*S-m*b)*_,t[15]=(u*S-c*P+d*b)*_,t):null}function o(t){var e=t[0],i=t[1],n=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],h=t[8],u=t[9],c=t[10],d=t[11],g=t[12],f=t[13],p=t[14],m=t[15];return(e*o-i*s)*(c*m-d*p)-(e*a-n*s)*(u*m-d*f)+(e*l-r*s)*(u*p-c*f)+(i*a-n*o)*(h*m-d*g)-(i*l-r*o)*(h*p-c*g)+(n*l-r*a)*(h*f-u*g)}function a(t,e,i){var n=e[0],r=e[1],s=e[2],o=e[3],a=e[4],l=e[5],h=e[6],u=e[7],c=e[8],d=e[9],g=e[10],f=e[11],p=e[12],m=e[13],y=e[14],b=e[15],P=i[0],v=i[1],S=i[2],C=i[3];return t[0]=P*n+v*a+S*c+C*p,t[1]=P*r+v*l+S*d+C*m,t[2]=P*s+v*h+S*g+C*y,t[3]=P*o+v*u+S*f+C*b,P=i[4],v=i[5],S=i[6],C=i[7],t[4]=P*n+v*a+S*c+C*p,t[5]=P*r+v*l+S*d+C*m,t[6]=P*s+v*h+S*g+C*y,t[7]=P*o+v*u+S*f+C*b,P=i[8],v=i[9],S=i[10],C=i[11],t[8]=P*n+v*a+S*c+C*p,t[9]=P*r+v*l+S*d+C*m,t[10]=P*s+v*h+S*g+C*y,t[11]=P*o+v*u+S*f+C*b,P=i[12],v=i[13],S=i[14],C=i[15],t[12]=P*n+v*a+S*c+C*p,t[13]=P*r+v*l+S*d+C*m,t[14]=P*s+v*h+S*g+C*y,t[15]=P*o+v*u+S*f+C*b,t}function l(t,e,i){var n,r,s,o,a,l,h,u,c,d,g,f,p=i[0],m=i[1],y=i[2];return e===t?(t[12]=e[0]*p+e[4]*m+e[8]*y+e[12],t[13]=e[1]*p+e[5]*m+e[9]*y+e[13],t[14]=e[2]*p+e[6]*m+e[10]*y+e[14],t[15]=e[3]*p+e[7]*m+e[11]*y+e[15]):(n=e[0],r=e[1],s=e[2],o=e[3],a=e[4],l=e[5],h=e[6],u=e[7],c=e[8],d=e[9],g=e[10],f=e[11],t[0]=n,t[1]=r,t[2]=s,t[3]=o,t[4]=a,t[5]=l,t[6]=h,t[7]=u,t[8]=c,t[9]=d,t[10]=g,t[11]=f,t[12]=n*p+a*m+c*y+e[12],t[13]=r*p+l*m+d*y+e[13],t[14]=s*p+h*m+g*y+e[14],t[15]=o*p+u*m+f*y+e[15]),t}function h(t,e,i){var n=i[0],r=i[1],s=i[2];return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*r,t[5]=e[5]*r,t[6]=e[6]*r,t[7]=e[7]*r,t[8]=e[8]*s,t[9]=e[9]*s,t[10]=e[10]*s,t[11]=e[11]*s,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function u(t,e,i,r){var s,o,a,l,h,u,c,d,g,f,p,m,y,b,P,v,S,C,w,E,x,A,T,I,O=r[0],_=r[1],L=r[2],R=Math.hypot(O,_,L);return R<n.b?null:(O*=R=1/R,_*=R,L*=R,s=Math.sin(i),a=1-(o=Math.cos(i)),l=e[0],h=e[1],u=e[2],c=e[3],d=e[4],g=e[5],f=e[6],p=e[7],m=e[8],y=e[9],b=e[10],P=e[11],v=O*O*a+o,S=_*O*a+L*s,C=L*O*a-_*s,w=O*_*a-L*s,E=_*_*a+o,x=L*_*a+O*s,A=O*L*a+_*s,T=_*L*a-O*s,I=L*L*a+o,t[0]=l*v+d*S+m*C,t[1]=h*v+g*S+y*C,t[2]=u*v+f*S+b*C,t[3]=c*v+p*S+P*C,t[4]=l*w+d*E+m*x,t[5]=h*w+g*E+y*x,t[6]=u*w+f*E+b*x,t[7]=c*w+p*E+P*x,t[8]=l*A+d*T+m*I,t[9]=h*A+g*T+y*I,t[10]=u*A+f*T+b*I,t[11]=c*A+p*T+P*I,e!==t&&(t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t)}function c(t,e,i){var n=Math.sin(i),r=Math.cos(i),s=e[4],o=e[5],a=e[6],l=e[7],h=e[8],u=e[9],c=e[10],d=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=s*r+h*n,t[5]=o*r+u*n,t[6]=a*r+c*n,t[7]=l*r+d*n,t[8]=h*r-s*n,t[9]=u*r-o*n,t[10]=c*r-a*n,t[11]=d*r-l*n,t}function d(t,e,i){var n=Math.sin(i),r=Math.cos(i),s=e[0],o=e[1],a=e[2],l=e[3],h=e[8],u=e[9],c=e[10],d=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=s*r-h*n,t[1]=o*r-u*n,t[2]=a*r-c*n,t[3]=l*r-d*n,t[8]=s*n+h*r,t[9]=o*n+u*r,t[10]=a*n+c*r,t[11]=l*n+d*r,t}function g(t,e,i){var n=Math.sin(i),r=Math.cos(i),s=e[0],o=e[1],a=e[2],l=e[3],h=e[4],u=e[5],c=e[6],d=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=s*r+h*n,t[1]=o*r+u*n,t[2]=a*r+c*n,t[3]=l*r+d*n,t[4]=h*r-s*n,t[5]=u*r-o*n,t[6]=c*r-a*n,t[7]=d*r-l*n,t}function f(t,e){var i=e[0],n=e[1],r=e[2],s=e[3],o=i+i,a=n+n,l=r+r,h=i*o,u=n*o,c=n*a,d=r*o,g=r*a,f=r*l,p=s*o,m=s*a,y=s*l;return t[0]=1-c-f,t[1]=u+y,t[2]=d-m,t[3]=0,t[4]=u-y,t[5]=1-h-f,t[6]=g+p,t[7]=0,t[8]=d+m,t[9]=g-p,t[10]=1-h-c,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function p(t,e,i,n,r,s,o){var a=1/(i-e),l=1/(r-n),h=1/(s-o);return t[0]=2*s*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*s*l,t[6]=0,t[7]=0,t[8]=(i+e)*a,t[9]=(r+n)*l,t[10]=(o+s)*h,t[11]=-1,t[12]=0,t[13]=0,t[14]=o*s*2*h,t[15]=0,t}function m(t,e,i,n,r){var s,o=1/Math.tan(e/2);return t[0]=o/i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=r&&r!==1/0?(s=1/(n-r),t[10]=(r+n)*s,t[14]=2*r*n*s):(t[10]=-1,t[14]=-2*n),t}function y(t,e,i,n,r,s,o){var a=1/(e-i),l=1/(n-r),h=1/(s-o);return t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*h,t[11]=0,t[12]=(e+i)*a,t[13]=(r+n)*l,t[14]=(o+s)*h,t[15]=1,t}function b(t,e,i,r){var s,o,a,l,h,u,c,d,g,f,p=e[0],m=e[1],y=e[2],b=r[0],P=r[1],v=r[2],S=i[0],C=i[1],w=i[2];return Math.abs(p-S)<n.b&&Math.abs(m-C)<n.b&&Math.abs(y-w)<n.b?function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}(t):(c=p-S,d=m-C,g=y-w,s=P*(g*=f=1/Math.hypot(c,d,g))-v*(d*=f),o=v*(c*=f)-b*g,a=b*d-P*c,(f=Math.hypot(s,o,a))?(s*=f=1/f,o*=f,a*=f):(s=0,o=0,a=0),l=d*a-g*o,h=g*s-c*a,u=c*o-d*s,(f=Math.hypot(l,h,u))?(l*=f=1/f,h*=f,u*=f):(l=0,h=0,u=0),t[0]=s,t[1]=l,t[2]=c,t[3]=0,t[4]=o,t[5]=h,t[6]=d,t[7]=0,t[8]=a,t[9]=u,t[10]=g,t[11]=0,t[12]=-(s*p+o*m+a*y),t[13]=-(l*p+h*m+u*y),t[14]=-(c*p+d*m+g*y),t[15]=1,t)}function P(t,e){var i=t[0],r=t[1],s=t[2],o=t[3],a=t[4],l=t[5],h=t[6],u=t[7],c=t[8],d=t[9],g=t[10],f=t[11],p=t[12],m=t[13],y=t[14],b=t[15],P=e[0],v=e[1],S=e[2],C=e[3],w=e[4],E=e[5],x=e[6],A=e[7],T=e[8],I=e[9],O=e[10],_=e[11],L=e[12],R=e[13],B=e[14],M=e[15];return Math.abs(i-P)<=n.b*Math.max(1,Math.abs(i),Math.abs(P))&&Math.abs(r-v)<=n.b*Math.max(1,Math.abs(r),Math.abs(v))&&Math.abs(s-S)<=n.b*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(o-C)<=n.b*Math.max(1,Math.abs(o),Math.abs(C))&&Math.abs(a-w)<=n.b*Math.max(1,Math.abs(a),Math.abs(w))&&Math.abs(l-E)<=n.b*Math.max(1,Math.abs(l),Math.abs(E))&&Math.abs(h-x)<=n.b*Math.max(1,Math.abs(h),Math.abs(x))&&Math.abs(u-A)<=n.b*Math.max(1,Math.abs(u),Math.abs(A))&&Math.abs(c-T)<=n.b*Math.max(1,Math.abs(c),Math.abs(T))&&Math.abs(d-I)<=n.b*Math.max(1,Math.abs(d),Math.abs(I))&&Math.abs(g-O)<=n.b*Math.max(1,Math.abs(g),Math.abs(O))&&Math.abs(f-_)<=n.b*Math.max(1,Math.abs(f),Math.abs(_))&&Math.abs(p-L)<=n.b*Math.max(1,Math.abs(p),Math.abs(L))&&Math.abs(m-R)<=n.b*Math.max(1,Math.abs(m),Math.abs(R))&&Math.abs(y-B)<=n.b*Math.max(1,Math.abs(y),Math.abs(B))&&Math.abs(b-M)<=n.b*Math.max(1,Math.abs(b),Math.abs(M))}},,function(t,e,i){"use strict";i.d(e,"a",(function(){return r})),i.d(e,"b",(function(){return s})),i.d(e,"c",(function(){return a}));var n=i(1);function r(t){if(!Number.isFinite(t))throw new Error("Invalid number ".concat(t));return t}function s(t,e,i=""){if(n.b.debug&&!function(t,e){if(t.length!==e)return!1;for(let e=0;e<t.length;++e)if(!Number.isFinite(t[e]))return!1;return!0}(t,e))throw new Error("math.gl: ".concat(i," some fields set to invalid numbers'"));return t}const o={};function a(t,e){o[t]||(o[t]=!0,console.warn("".concat(t," has been removed in version ").concat(e,", see upgrade guide for more information")))}},function(t,e,i){"use strict";i.d(e,"d",(function(){return r})),i.d(e,"e",(function(){return s})),i.d(e,"c",(function(){return o})),i.d(e,"b",(function(){return a})),i.d(e,"a",(function(){return l}));var n=i(9);function r(t){return"undefined"!=typeof WebGLRenderingContext&&t instanceof WebGLRenderingContext||("undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||Boolean(t&&Number.isFinite(t._version)))}function s(t){return"undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||Boolean(t&&2===t._version)}function o(t){return s(t)?t:null}function a(t){return Object(n.a)(r(t),"Invalid WebGLRenderingContext"),t}function l(t){return Object(n.a)(s(t),"Requires WebGL2"),t}},function(t,e,i){t.exports=i(33)},function(t,e,i){"use strict";function n(t,e){if(!t)throw new Error(e||"luma.gl: assertion failed.")}i.d(e,"a",(function(){return n}))},function(t,e,i){"use strict";(function(t){var n=i(1),r=i(64);i.d(e,"a",(function(){return r.a}));const s={self:"undefined"!=typeof self&&self,window:"undefined"!=typeof window&&window,global:void 0!==t&&t};(s.global||s.self||s.window).mathgl={config:n.b}}).call(this,i(21))},function(t,e,i){"use strict";i.d(e,"a",(function(){return r})),i.d(e,"e",(function(){return s})),i.d(e,"c",(function(){return o})),i.d(e,"j",(function(){return a})),i.d(e,"i",(function(){return l})),i.d(e,"k",(function(){return h})),i.d(e,"f",(function(){return u})),i.d(e,"g",(function(){return c})),i.d(e,"h",(function(){return d})),i.d(e,"b",(function(){return g})),i.d(e,"d",(function(){return m}));var n=i(0);function r(t,e,i){return t[0]=e[0]+i[0],t[1]=e[1]+i[1],t[2]=e[2]+i[2],t}function s(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t}function o(t,e,i){var n=e[0],r=e[1],s=e[2],o=i[0],a=i[1],l=i[2];return t[0]=r*l-s*a,t[1]=s*o-n*l,t[2]=n*a-r*o,t}function a(t,e,i){var n=e[0],r=e[1],s=e[2],o=i[3]*n+i[7]*r+i[11]*s+i[15];return o=o||1,t[0]=(i[0]*n+i[4]*r+i[8]*s+i[12])/o,t[1]=(i[1]*n+i[5]*r+i[9]*s+i[13])/o,t[2]=(i[2]*n+i[6]*r+i[10]*s+i[14])/o,t}function l(t,e,i){var n=e[0],r=e[1],s=e[2];return t[0]=n*i[0]+r*i[3]+s*i[6],t[1]=n*i[1]+r*i[4]+s*i[7],t[2]=n*i[2]+r*i[5]+s*i[8],t}function h(t,e,i){var n=i[0],r=i[1],s=i[2],o=i[3],a=e[0],l=e[1],h=e[2],u=r*h-s*l,c=s*a-n*h,d=n*l-r*a,g=r*d-s*c,f=s*u-n*d,p=n*c-r*u,m=2*o;return u*=m,c*=m,d*=m,g*=2,f*=2,p*=2,t[0]=a+u+g,t[1]=l+c+f,t[2]=h+d+p,t}function u(t,e,i,n){var r=[],s=[];return r[0]=e[0]-i[0],r[1]=e[1]-i[1],r[2]=e[2]-i[2],s[0]=r[0],s[1]=r[1]*Math.cos(n)-r[2]*Math.sin(n),s[2]=r[1]*Math.sin(n)+r[2]*Math.cos(n),t[0]=s[0]+i[0],t[1]=s[1]+i[1],t[2]=s[2]+i[2],t}function c(t,e,i,n){var r=[],s=[];return r[0]=e[0]-i[0],r[1]=e[1]-i[1],r[2]=e[2]-i[2],s[0]=r[2]*Math.sin(n)+r[0]*Math.cos(n),s[1]=r[1],s[2]=r[2]*Math.cos(n)-r[0]*Math.sin(n),t[0]=s[0]+i[0],t[1]=s[1]+i[1],t[2]=s[2]+i[2],t}function d(t,e,i,n){var r=[],s=[];return r[0]=e[0]-i[0],r[1]=e[1]-i[1],r[2]=e[2]-i[2],s[0]=r[0]*Math.cos(n)-r[1]*Math.sin(n),s[1]=r[0]*Math.sin(n)+r[1]*Math.cos(n),s[2]=r[2],t[0]=s[0]+i[0],t[1]=s[1]+i[1],t[2]=s[2]+i[2],t}function g(t,e){var i=t[0],n=t[1],r=t[2],s=e[0],o=e[1],a=e[2],l=Math.sqrt(i*i+n*n+r*r)*Math.sqrt(s*s+o*o+a*a),h=l&&function(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}(t,e)/l;return Math.acos(Math.min(Math.max(h,-1),1))}var f,p,m=function(t,e,i){return t[0]=e[0]*i[0],t[1]=e[1]*i[1],t[2]=e[2]*i[2],t};f=new n.a(3),n.a!=Float32Array&&(f[0]=0,f[1]=0,f[2]=0),p=f},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(56);class r extends n.LinkedList{constructor(...t){super(...t)}get front(){return this.head}enqueue(t){this.append(t)}dequeue(){return this.removeHead()}}e.Queue=r},function(t,e,i){"use strict";i.d(e,"a",(function(){return r})),i.d(e,"e",(function(){return s})),i.d(e,"b",(function(){return o})),i.d(e,"d",(function(){return a})),i.d(e,"c",(function(){return l})),i.d(e,"g",(function(){return h})),i.d(e,"f",(function(){return d}));var n=i(0);function r(t,e,i){return t[0]=e[0]+i[0],t[1]=e[1]+i[1],t}function s(t,e,i){return t[0]=e[0]*i,t[1]=e[1]*i,t}function o(t){var e=t[0],i=t[1];return Math.hypot(e,i)}function a(t,e){return t[0]=-e[0],t[1]=-e[1],t}function l(t,e,i,n){var r=e[0],s=e[1];return t[0]=r+n*(i[0]-r),t[1]=s+n*(i[1]-s),t}function h(t,e,i){var n=e[0],r=e[1];return t[0]=i[0]*n+i[4]*r+i[12],t[1]=i[1]*n+i[5]*r+i[13],t}var u,c,d=function(t,e,i){return t[0]=e[0]-i[0],t[1]=e[1]-i[1],t};u=new n.a(2),n.a!=Float32Array&&(u[0]=0,u[1]=0),c=u},,function(t,e,i){"use strict";(function(t,n){i.d(e,"e",(function(){return o})),i.d(e,"f",(function(){return a})),i.d(e,"c",(function(){return s})),i.d(e,"b",(function(){return l})),i.d(e,"d",(function(){return h})),i.d(e,"a",(function(){return u}));const r={self:"undefined"!=typeof self&&self,window:"undefined"!=typeof window&&window,global:void 0!==t&&t,document:"undefined"!=typeof document&&document,process:"object"==typeof n&&n},s=globalThis,o=r.self||r.window||r.global,a=r.window||r.self||r.global,l=r.document||{},h=r.process||{},u=console}).call(this,i(21),i(20))},function(t,e,i){"use strict";function n(t,e){if(!t)throw new Error("math.gl assertion ".concat(e))}i.d(e,"a",(function(){return n}))},function(t,e,i){"use strict";i.d(e,"c",(function(){return r})),i.d(e,"e",(function(){return h})),i.d(e,"a",(function(){return c})),i.d(e,"b",(function(){return d})),i.d(e,"d",(function(){return f}));var n=i(7);const r={3042:!1,32773:new Float32Array([0,0,0,0]),32777:32774,34877:32774,32969:1,32968:0,32971:1,32970:0,3106:new Float32Array([0,0,0,0]),3107:[!0,!0,!0,!0],2884:!1,2885:1029,2929:!1,2931:1,2932:513,2928:new Float32Array([0,1]),2930:!0,3024:!0,36006:null,2886:2305,33170:4352,2849:1,32823:!1,32824:0,10752:0,32938:1,32939:!1,3089:!1,3088:new Int32Array([0,0,1024,1024]),2960:!1,2961:0,2968:4294967295,36005:4294967295,2962:519,2967:0,2963:4294967295,34816:519,36003:0,36004:4294967295,2964:7680,2965:7680,2966:7680,34817:7680,34818:7680,34819:7680,2978:[0,0,1024,1024],3333:4,3317:4,37440:!1,37441:!1,37443:37444,35723:4352,36010:null,35977:!1,3330:0,3332:0,3331:0,3314:0,32878:0,3316:0,3315:0,32877:0},s=(t,e,i)=>e?t.enable(i):t.disable(i),o=(t,e,i)=>t.hint(i,e),a=(t,e,i)=>t.pixelStorei(i,e);function l(t){return Array.isArray(t)||ArrayBuffer.isView(t)}const h={3042:s,32773:(t,e)=>t.blendColor(...e),32777:"blendEquation",34877:"blendEquation",32969:"blendFunc",32968:"blendFunc",32971:"blendFunc",32970:"blendFunc",3106:(t,e)=>t.clearColor(...e),3107:(t,e)=>t.colorMask(...e),2884:s,2885:(t,e)=>t.cullFace(e),2929:s,2931:(t,e)=>t.clearDepth(e),2932:(t,e)=>t.depthFunc(e),2928:(t,e)=>t.depthRange(...e),2930:(t,e)=>t.depthMask(e),3024:s,35723:o,36006:(t,e)=>{const i=Object(n.e)(t)?36009:36160;return t.bindFramebuffer(i,e)},2886:(t,e)=>t.frontFace(e),33170:o,2849:(t,e)=>t.lineWidth(e),32823:s,32824:"polygonOffset",10752:"polygonOffset",35977:s,32938:"sampleCoverage",32939:"sampleCoverage",3089:s,3088:(t,e)=>t.scissor(...e),2960:s,2961:(t,e)=>t.clearStencil(e),2968:(t,e)=>t.stencilMaskSeparate(1028,e),36005:(t,e)=>t.stencilMaskSeparate(1029,e),2962:"stencilFuncFront",2967:"stencilFuncFront",2963:"stencilFuncFront",34816:"stencilFuncBack",36003:"stencilFuncBack",36004:"stencilFuncBack",2964:"stencilOpFront",2965:"stencilOpFront",2966:"stencilOpFront",34817:"stencilOpBack",34818:"stencilOpBack",34819:"stencilOpBack",2978:(t,e)=>t.viewport(...e),3333:a,3317:a,37440:a,37441:a,37443:a,3330:a,3332:a,3331:a,36010:(t,e)=>t.bindFramebuffer(36008,e),3314:a,32878:a,3316:a,3315:a,32877:a,framebuffer:(t,e)=>{const i=e&&"handle"in e?e.handle:e;return t.bindFramebuffer(36160,i)},blend:(t,e)=>e?t.enable(3042):t.disable(3042),blendColor:(t,e)=>t.blendColor(...e),blendEquation:(t,e)=>{e=l(e)?e:[e,e],t.blendEquationSeparate(...e)},blendFunc:(t,e)=>{e=l(e)&&2===e.length?[...e,...e]:e,t.blendFuncSeparate(...e)},clearColor:(t,e)=>t.clearColor(...e),clearDepth:(t,e)=>t.clearDepth(e),clearStencil:(t,e)=>t.clearStencil(e),colorMask:(t,e)=>t.colorMask(...e),cull:(t,e)=>e?t.enable(2884):t.disable(2884),cullFace:(t,e)=>t.cullFace(e),depthTest:(t,e)=>e?t.enable(2929):t.disable(2929),depthFunc:(t,e)=>t.depthFunc(e),depthMask:(t,e)=>t.depthMask(e),depthRange:(t,e)=>t.depthRange(...e),dither:(t,e)=>e?t.enable(3024):t.disable(3024),derivativeHint:(t,e)=>{t.hint(35723,e)},frontFace:(t,e)=>t.frontFace(e),mipmapHint:(t,e)=>t.hint(33170,e),lineWidth:(t,e)=>t.lineWidth(e),polygonOffsetFill:(t,e)=>e?t.enable(32823):t.disable(32823),polygonOffset:(t,e)=>t.polygonOffset(...e),sampleCoverage:(t,e)=>t.sampleCoverage(...e),scissorTest:(t,e)=>e?t.enable(3089):t.disable(3089),scissor:(t,e)=>t.scissor(...e),stencilTest:(t,e)=>e?t.enable(2960):t.disable(2960),stencilMask:(t,e)=>{e=l(e)?e:[e,e];const[i,n]=e;t.stencilMaskSeparate(1028,i),t.stencilMaskSeparate(1029,n)},stencilFunc:(t,e)=>{e=l(e)&&3===e.length?[...e,...e]:e;const[i,n,r,s,o,a]=e;t.stencilFuncSeparate(1028,i,n,r),t.stencilFuncSeparate(1029,s,o,a)},stencilOp:(t,e)=>{e=l(e)&&3===e.length?[...e,...e]:e;const[i,n,r,s,o,a]=e;t.stencilOpSeparate(1028,i,n,r),t.stencilOpSeparate(1029,s,o,a)},viewport:(t,e)=>t.viewport(...e)};function u(t,e,i){return void 0!==e[t]?e[t]:i[t]}const c={blendEquation:(t,e,i)=>t.blendEquationSeparate(u(32777,e,i),u(34877,e,i)),blendFunc:(t,e,i)=>t.blendFuncSeparate(u(32969,e,i),u(32968,e,i),u(32971,e,i),u(32970,e,i)),polygonOffset:(t,e,i)=>t.polygonOffset(u(32824,e,i),u(10752,e,i)),sampleCoverage:(t,e,i)=>t.sampleCoverage(u(32938,e,i),u(32939,e,i)),stencilFuncFront:(t,e,i)=>t.stencilFuncSeparate(1028,u(2962,e,i),u(2967,e,i),u(2963,e,i)),stencilFuncBack:(t,e,i)=>t.stencilFuncSeparate(1029,u(34816,e,i),u(36003,e,i),u(36004,e,i)),stencilOpFront:(t,e,i)=>t.stencilOpSeparate(1028,u(2964,e,i),u(2965,e,i),u(2966,e,i)),stencilOpBack:(t,e,i)=>t.stencilOpSeparate(1029,u(34817,e,i),u(34818,e,i),u(34819,e,i))},d={enable:(t,e)=>t({[e]:!0}),disable:(t,e)=>t({[e]:!1}),pixelStorei:(t,e,i)=>t({[e]:i}),hint:(t,e,i)=>t({[e]:i}),bindFramebuffer:(t,e,i)=>{switch(e){case 36160:return t({36006:i,36010:i});case 36009:return t({36006:i});case 36008:return t({36010:i});default:return null}},blendColor:(t,e,i,n,r)=>t({32773:new Float32Array([e,i,n,r])}),blendEquation:(t,e)=>t({32777:e,34877:e}),blendEquationSeparate:(t,e,i)=>t({32777:e,34877:i}),blendFunc:(t,e,i)=>t({32969:e,32968:i,32971:e,32970:i}),blendFuncSeparate:(t,e,i,n,r)=>t({32969:e,32968:i,32971:n,32970:r}),clearColor:(t,e,i,n,r)=>t({3106:new Float32Array([e,i,n,r])}),clearDepth:(t,e)=>t({2931:e}),clearStencil:(t,e)=>t({2961:e}),colorMask:(t,e,i,n,r)=>t({3107:[e,i,n,r]}),cullFace:(t,e)=>t({2885:e}),depthFunc:(t,e)=>t({2932:e}),depthRange:(t,e,i)=>t({2928:new Float32Array([e,i])}),depthMask:(t,e)=>t({2930:e}),frontFace:(t,e)=>t({2886:e}),lineWidth:(t,e)=>t({2849:e}),polygonOffset:(t,e,i)=>t({32824:e,10752:i}),sampleCoverage:(t,e,i)=>t({32938:e,32939:i}),scissor:(t,e,i,n,r)=>t({3088:new Int32Array([e,i,n,r])}),stencilMask:(t,e)=>t({2968:e,36005:e}),stencilMaskSeparate:(t,e,i)=>t({[1028===e?2968:36005]:i}),stencilFunc:(t,e,i,n)=>t({2962:e,2967:i,2963:n,34816:e,36003:i,36004:n}),stencilFuncSeparate:(t,e,i,n,r)=>t({[1028===e?2962:34816]:i,[1028===e?2967:36003]:n,[1028===e?2963:36004]:r}),stencilOp:(t,e,i,n)=>t({2964:e,2965:i,2966:n,34817:e,34818:i,34819:n}),stencilOpSeparate:(t,e,i,n,r)=>t({[1028===e?2964:34817]:i,[1028===e?2965:34818]:n,[1028===e?2966:34819]:r}),viewport:(t,e,i,n,r)=>t({2978:[e,i,n,r]})},g=(t,e)=>t.isEnabled(e),f={3042:g,2884:g,2929:g,3024:g,32823:g,32926:g,32928:g,3089:g,2960:g,35977:g}},,function(t,e,i){"use strict";(function(t){i.d(e,"c",(function(){return u})),i.d(e,"b",(function(){return c})),i.d(e,"a",(function(){return d}));var n=i(17),r=i(23),s=i(9),o=i(36);function a(t,e){const i=t[e].bind(t);t[e]=function(...e){const n=e[0];return n in t.state.cache&&t.state.enable?t.state.cache[n]:i(...e)},Object.defineProperty(t[e],"name",{value:e+"-from-cache",configurable:!1})}function l(t,e,i){const n=t[e].bind(t);t[e]=function(...e){const{valueChanged:r,oldValue:s}=i(t.state._updateCache,...e);return r&&n(...e),s},Object.defineProperty(t[e],"name",{value:e+"-to-cache",configurable:!1})}class h{constructor(t,{copyState:e=!1,log:i=(()=>{})}={}){this.gl=t,this.program=null,this.stateStack=[],this.enable=!0,this.cache=e?Object(r.a)(t):Object.assign({},n.c),this.log=i,this._updateCache=this._updateCache.bind(this),Object.seal(this)}push(t={}){this.stateStack.push({})}pop(){Object(s.a)(this.stateStack.length>0);const t=this.stateStack[this.stateStack.length-1];Object(r.c)(this.gl,t),this.stateStack.pop()}_updateCache(t){let e,i=!1;const n=this.stateStack.length>0&&this.stateStack[this.stateStack.length-1];for(const r in t){Object(s.a)(void 0!==r);const a=t[r],l=this.cache[r];Object(o.a)(a,l)||(i=!0,e=l,n&&!(r in n)&&(n[r]=l),this.cache[r]=a)}return{valueChanged:i,oldValue:e}}}function u(e,i={}){const{enable:r=!0,copyState:o}=i;if(Object(s.a)(void 0!==o),!e.state){const i=void 0!==t?t:window,{polyfillContext:r}=i;r&&r(e),e.state=new h(e,{copyState:o}),function(t){const e=t.useProgram.bind(t);t.useProgram=function(i){t.state.program!==i&&(e(i),t.state.program=i)}}(e);for(const t in n.b){l(e,t,n.b[t])}a(e,"getParameter"),a(e,"isEnabled")}return e.state.enable=r,e}function c(t){t.state||u(t,{copyState:!1}),t.state.push()}function d(t){Object(s.a)(t.state),t.state.pop()}}).call(this,i(21))},function(t,e){var i,n,r=t.exports={};function s(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function a(t){if(i===setTimeout)return setTimeout(t,0);if((i===s||!i)&&setTimeout)return i=setTimeout,setTimeout(t,0);try{return i(t,0)}catch(e){try{return i.call(null,t,0)}catch(e){return i.call(this,t,0)}}}!function(){try{i="function"==typeof setTimeout?setTimeout:s}catch(t){i=s}try{n="function"==typeof clearTimeout?clearTimeout:o}catch(t){n=o}}();var l,h=[],u=!1,c=-1;function d(){u&&l&&(u=!1,l.length?h=l.concat(h):c=-1,h.length&&g())}function g(){if(!u){var t=a(d);u=!0;for(var e=h.length;e;){for(l=h,h=[];++c<e;)l&&l[c].run();c=-1,e=h.length}l=null,u=!1,function(t){if(n===clearTimeout)return clearTimeout(t);if((n===o||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(t);try{n(t)}catch(e){try{return n.call(null,t)}catch(e){return n.call(this,t)}}}(t)}}function f(t,e){this.fun=t,this.array=e}function p(){}r.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var i=1;i<arguments.length;i++)e[i-1]=arguments[i];h.push(new f(t,e)),1!==h.length||u||a(g)},f.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=p,r.addListener=p,r.once=p,r.off=p,r.removeListener=p,r.removeAllListeners=p,r.emit=p,r.prependListener=p,r.prependOnceListener=p,r.listeners=function(t){return[]},r.binding=function(t){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(t){throw new Error("process.chdir is not supported")},r.umask=function(){return 0}},function(t,e){var i;i=function(){return this}();try{i=i||new Function("return this")()}catch(t){"object"==typeof window&&(i=window)}t.exports=i},function(t,e,i){"use strict";(function(t,n){i.d(e,"a",(function(){return r}));"undefined"!=typeof self&&self,"undefined"!=typeof window&&window,"undefined"!=typeof document&&document;const r=Boolean("object"!=typeof n||"[object process]"!==String(n)||n.browser),s=void 0!==n&&n.version&&/v([0-9]*)/.exec(n.version);s&&parseFloat(s[1])}).call(this,i(21),i(20))},function(t,e,i){"use strict";i.d(e,"c",(function(){return l})),i.d(e,"a",(function(){return h})),i.d(e,"b",(function(){return u})),i.d(e,"d",(function(){return c}));var n=i(17),r=i(19),s=i(9),o=i(7),a=i(36);function l(t,e){if(Object(s.a)(Object(o.d)(t),"setParameters requires a WebGL context"),Object(a.b)(e))return;const i={};for(const r in e){const s=Number(r),o=n.e[r];o&&("string"==typeof o?i[o]=!0:o(t,e[r],s))}const r=t.state&&t.state.cache;if(r)for(const s in i){(0,n.a[s])(t,e,r)}}function h(t,e){if("number"==typeof(e=e||n.c)){const i=e,r=n.d[i];return r?r(t,i):t.getParameter(i)}const i=Array.isArray(e)?e:Object.keys(e),r={};for(const e of i){const i=n.d[e];r[e]=i?i(t,Number(e)):t.getParameter(Number(e))}return r}function u(t){l(t,n.c)}function c(t,e,i){if(Object(a.b)(e))return i(t);const{nocatch:n=!0}=e;let s;if(Object(r.b)(t),l(t,e),n)s=i(t),Object(r.a)(t);else try{s=i(t)}finally{Object(r.a)(t)}return s}},function(t,e,i){"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/function n(t){return"function"==typeof t}function r(t){return"function"==typeof t||void 0===t}function s(t){return"object"==typeof t&&null!==t||"function"==typeof t}function o(t){return null==t}Object.defineProperty(e,"__esModule",{value:!0}),e.isPrimitive=e.isPropertyKey=e.isString=e.isBoolean=e.isNumber=e.isIterator=e.isAsyncIterable=e.isIterable=e.isDefined=e.isMissing=e.isInstance=e.isObject=e.isFunctionOrUndefined=e.isFunction=void 0,e.isFunction=n,e.isFunctionOrUndefined=r,e.isObject=s,e.isInstance=function(t,e){return!o(t)&&t instanceof e},e.isMissing=o,e.isDefined=function(t){return null!=t},e.isIterable=function(t){return null!=t&&Symbol.iterator in Object(t)},e.isAsyncIterable=function(t){return null!=t&&Symbol.asyncIterator in Object(t)},e.isIterator=function(t){return s(t)&&n(t.next)&&r(t.throw)&&r(t.return)&&r(t[Symbol.iterator])},e.isNumber=function(t){return"number"==typeof t},e.isBoolean=function(t){return"boolean"==typeof t},e.isString=function(t){return"string"==typeof t},e.isPropertyKey=function(t){return"string"==typeof t||"symbol"==typeof t||"number"==typeof t},e.isPrimitive=function(t){return"function"!=typeof t&&("object"!=typeof t||null===t)}},function(t,e,i){"use strict";(function(t){i.d(e,"a",(function(){return r})),i.d(e,"b",(function(){return s}));var n=i(30);function r(){return!("object"==typeof t&&"[object process]"===String(t)&&!t.browser)||Object(n.a)()}function s(){return r()&&"undefined"!=typeof document}}).call(this,i(20))},function(t,e,i){"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/Object.defineProperty(e,"__esModule",{value:!0}),e.SortedMap=void 0;const n=i(24),r=i(57),s=i(28),o=i(29);class a{constructor(...t){let e,i;if(this._keys=[],this._values=[],t.length>0){const r=t[0];n.isIterable(r)||void 0===r?(e=r,t.length>1&&(i=t[1])):i=r}if(void 0===i&&(i=o.Comparer.defaultComparer),this._comparer="function"==typeof i?o.Comparer.create(i):i,e)for(const[t,i]of e)this.set(t,i)}get comparer(){return this._comparer}get size(){return this._keys.length}has(t){return r.binarySearch(this._keys,t,this._comparer)>=0}get(t){const e=r.binarySearch(this._keys,t,this._comparer);return e>=0?this._values[e]:void 0}set(t,e){const i=r.binarySearch(this._keys,t,this._comparer);return i>=0?this._values[i]=e:(this._keys.splice(~i,0,t),this._values.splice(~i,0,e)),this}delete(t){const e=r.binarySearch(this._keys,t,this._comparer);return e>=0&&(this._keys.splice(e,1),this._values.splice(e,1),!0)}clear(){this._keys.length=0,this._values.length=0}keys(){return this._keys.values()}values(){return this._values.values()}*entries(){for(let t=0;t<this._keys.length;t++)yield[this._keys[t],this._values[t]]}[Symbol.iterator](){return this.entries()}forEach(t,e){for(const[i,n]of this)t.call(e,n,i,this)}get[s.KeyedCollection.size](){return this.size}[s.KeyedCollection.has](t){return this.has(t)}[s.KeyedCollection.get](t){return this.get(t)}[s.KeyedCollection.set](t,e){this.set(t,e)}[s.KeyedCollection.delete](t){return this.delete(t)}[s.KeyedCollection.clear](){this.clear()}[s.KeyedCollection.keys](){return this.keys()}[s.KeyedCollection.values](){return this.values()}}e.SortedMap=a,Object.defineProperty(a,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!0,value:"SortedMap"})},function(t,e,i){"use strict";(function(t){i.d(e,"b",(function(){return n})),i.d(e,"c",(function(){return r})),i.d(e,"a",(function(){return s}));const n="undefined"!=typeof navigator&&navigator.userAgent?navigator.userAgent.toLowerCase():"",r="undefined"!=typeof window?window:t;void 0!==t||window,"undefined"!=typeof document&&document;let s=!1;try{const t={get passive(){return s=!0,!0}};r.addEventListener("test",t,t),r.removeEventListener("test",t,t)}catch(t){}}).call(this,i(21))},function(t,e,i){"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/Object.defineProperty(e,"__esModule",{value:!0}),e.KeyedMultiCollection=e.ReadonlyKeyedMultiCollection=e.KeyedCollection=e.ReadonlyKeyedCollection=e.IndexedCollection=e.FixedSizeIndexedCollection=e.ReadonlyIndexedCollection=e.Collection=e.ReadonlyCollection=void 0;const n=i(24),r=i(86);var s,o,a,l,h,u,c,d,g;!function(t){t.size=Symbol.for("@esfx/collection-core!ReadonlyCollection.size"),t.has=Symbol.for("@esfx/collection-core!ReadonlyCollection.has"),t.isReadonlyCollection=function(e){return n.isIterable(e)&&t.size in e&&t.has in e},t.name="ReadonlyCollection",t.hasInstance=function(e){return n.isIterable(e)&&t.size in e&&t.has in e}}(s=e.ReadonlyCollection||(e.ReadonlyCollection={})),function(t){t.size=s.size,t.has=s.has,t.isReadonlyCollection=s.isReadonlyCollection,t.add=Symbol.for("@esfx/collection-core!Collection.add"),t.delete=Symbol.for("@esfx/collection-core!Collection.delete"),t.clear=Symbol.for("@esfx/collection-core!Collection.clear"),t.isCollection=function(e){return t.hasInstance(e)},t.name="Collection",t.hasInstance=function(e){return s.hasInstance(e)&&t.add in e&&t.delete in e&&t.clear in e}}(o=e.Collection||(e.Collection={})),function(t){t.size=s.size,t.has=s.has,t.isReadonlyCollection=s.isReadonlyCollection,t.indexOf=Symbol.for("@esfx/collection-core!ReadonlyIndexedCollection.indexOf"),t.getAt=Symbol.for("@esfx/collection-core!ReadonlyIndexedCollection.getAt"),t.isReadonlyIndexedCollection=function(e){return t.hasInstance(e)},t.name="ReadonlyIndexedCollection",t.hasInstance=function(e){return s.hasInstance(e)&&t.indexOf in e&&t.getAt in e}}(a=e.ReadonlyIndexedCollection||(e.ReadonlyIndexedCollection={})),function(t){t.size=s.size,t.has=s.has,t.isReadonlyCollection=s.isReadonlyCollection,t.indexOf=a.indexOf,t.getAt=a.getAt,t.isReadonlyIndexedCollection=a.isReadonlyIndexedCollection,t.setAt=Symbol.for("@esfx/collection-core!FixedSizeIndexedCollection.setAt"),t.isFixedSizeIndexedCollection=function(e){return t.hasInstance(e)},t.name="FixedSizeIndexedCollection",t.hasInstance=function(e){return a.hasInstance(e)&&t.setAt in e}}(l=e.FixedSizeIndexedCollection||(e.FixedSizeIndexedCollection={})),function(t){t.size=s.size,t.has=s.has,t.isReadonlyCollection=s.isReadonlyCollection,t.indexOf=a.indexOf,t.getAt=a.getAt,t.isReadonlyIndexedCollection=a.isReadonlyIndexedCollection,t.setAt=l.setAt,t.isFixedSizeIndexedCollection=l.isFixedSizeIndexedCollection,t.add=o.add,t.delete=o.delete,t.clear=o.clear,t.isCollection=o.isCollection,t.insertAt=Symbol.for("@esfx/collection-core!IndexedCollection.insertAt"),t.removeAt=Symbol.for("@esfx/collection-core!IndexedCollection.removeAt"),t.isIndexedCollection=function(e){return t.hasInstance(e)},t.name="IndexedCollection",t.hasInstance=function(e){return l.hasInstance(e)&&t.insertAt in e&&t.removeAt in e}}(h=e.IndexedCollection||(e.IndexedCollection={})),function(t){t.size=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.size"),t.has=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.has"),t.get=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.get"),t.keys=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.keys"),t.values=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.values"),t.isReadonlyKeyedCollection=function(e){return t.hasInstance(e)},t.name="ReadonlyKeyedCollection",t.hasInstance=function(e){return n.isIterable(e)&&t.size in e&&t.has in e&&t.get in e&&t.keys in e&&t.values in e}}(u=e.ReadonlyKeyedCollection||(e.ReadonlyKeyedCollection={})),function(t){t.size=u.size,t.has=u.has,t.get=u.get,t.keys=u.keys,t.values=u.values,t.isReadonlyKeyedCollection=u.isReadonlyKeyedCollection,t.set=Symbol.for("@esfx/collection-core!KeyedCollection.set"),t.delete=Symbol.for("@esfx/collection-core!KeyedCollection.delete"),t.clear=Symbol.for("@esfx/collection-core!KeyedCollection.clear"),t.isKeyedCollection=function(e){return t.hasInstance(e)},t.name="KeyedCollection",t.hasInstance=function(e){return u.hasInstance(e)&&t.set in e&&t.delete in e&&t.clear in e}}(c=e.KeyedCollection||(e.KeyedCollection={})),function(t){t.size=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.size"),t.has=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.has"),t.hasValue=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.hasValue"),t.get=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.get"),t.keys=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.keys"),t.values=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.values"),t.isReadonlyKeyedMultiCollection=function(e){return t.hasInstance(e)},t.name="ReadonlyKeyedMultiCollection",t.hasInstance=function(e){return n.isIterable(e)&&t.size in e&&t.has in e&&t.hasValue in e&&t.get in e&&t.keys in e&&t.values in e}}(d=e.ReadonlyKeyedMultiCollection||(e.ReadonlyKeyedMultiCollection={})),function(t){t.size=d.size,t.has=d.has,t.hasValue=d.hasValue,t.get=d.get,t.keys=d.keys,t.values=d.values,t.isReadonlyKeyedMultiCollection=d.isReadonlyKeyedMultiCollection,t.add=Symbol.for("@esfx/collection-core!KeyedMultiCollection.add"),t.delete=Symbol.for("@esfx/collection-core!KeyedMultiCollection.delete"),t.deleteValue=Symbol.for("@esfx/collection-core!KeyedMultiCollection.deleteValue"),t.clear=Symbol.for("@esfx/collection-core!KeyedMultiCollection.clear"),t.isKeyedMultiCollection=function(e){return t.hasInstance(e)},t.name="KeyedMultiCollection",t.hasInstance=function(e){return d.hasInstance(e)&&t.add in e&&t.delete in e&&t.deleteValue in e&&t.clear in e}}(g=e.KeyedMultiCollection||(e.KeyedMultiCollection={})),r.deprecateProperty(s,"isReadonlyCollection","Use 'ReadonlyCollection.hasInstance' instead."),r.deprecateProperty(o,"isReadonlyCollection","Use 'ReadonlyCollection.hasInstance' instead."),r.deprecateProperty(o,"isCollection","Use 'Collection.hasInstance' instead."),r.deprecateProperty(a,"isReadonlyCollection","Use 'ReadonlyCollection.hasInstance' instead."),r.deprecateProperty(a,"isReadonlyIndexedCollection","Use 'ReadonlyIndexedCollection.hasInstance' instead."),r.deprecateProperty(l,"isReadonlyCollection","Use 'ReadonlyCollection.hasInstance' instead."),r.deprecateProperty(l,"isReadonlyIndexedCollection","Use 'ReadonlyIndexedCollection.hasInstance' instead."),r.deprecateProperty(l,"isFixedSizeIndexedCollection","Use 'FixedSizeIndexedCollection.hasInstance' instead."),r.deprecateProperty(h,"isReadonlyCollection","Use 'ReadonlyCollection.hasInstance' instead."),r.deprecateProperty(h,"isReadonlyIndexedCollection","Use 'ReadonlyIndexedCollection.hasInstance' instead."),r.deprecateProperty(h,"isFixedSizeIndexedCollection","Use 'FixedSizeIndexedCollection.hasInstance' instead."),r.deprecateProperty(h,"isCollection","Use 'Collection.hasInstance' instead."),r.deprecateProperty(h,"isIndexedCollection","Use 'IndexedCollection.hasInstance' instead."),r.deprecateProperty(u,"isReadonlyKeyedCollection","Use 'ReadonlyKeyedCollection.hasInstance' instead."),r.deprecateProperty(c,"isReadonlyKeyedCollection","Use 'ReadonlyKeyedCollection.hasInstance' instead."),r.deprecateProperty(c,"isKeyedCollection","Use 'KeyedCollection.hasInstance' instead."),r.deprecateProperty(d,"isReadonlyKeyedMultiCollection","Use 'ReadonlyKeyedMultiCollection.hasInstance' instead."),r.deprecateProperty(g,"isReadonlyKeyedMultiCollection","Use 'ReadonlyKeyedMultiCollection.hasInstance' instead."),r.deprecateProperty(g,"isKeyedMultiCollection","Use 'KeyedMultiCollection.hasInstance' instead.")},function(t,e,i){"use strict";(function(t){
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
Object.defineProperty(e,"__esModule",{value:!0}),e.rawHash=e.tupleStructuralComparer=e.tupleComparer=e.structuralComparer=e.defaultComparer=e.Comparer=e.combineHashes=e.tupleStructuralEqualer=e.tupleEqualer=e.structuralEqualer=e.defaultEqualer=e.Equaler=e.StructuralComparable=e.StructuralEquatable=e.Comparable=e.Equatable=void 0;const n=i(90);var r,s,o,a,l,h;function u(e){let i=!1;return()=>{i||(i=!0,"object"==typeof t&&t.emitWarning?t.emitWarning(e,"Deprecation"):"object"==typeof console&&console.warn("Deprecation: "+e))}}!function(t){function e(e){let i;return null!=e&&t.equals in(i=Object(e))&&t.hash in i}t.equals=Symbol.for("@esfx/equatable:Equatable.equals"),t.hash=Symbol.for("@esfx/equatable:Equatable.hash"),t.name="Equatable",t.hasInstance=e,Object.defineProperty(t,Symbol.hasInstance,{configurable:!0,writable:!0,value:e})}(r=e.Equatable||(e.Equatable={})),function(t){const e=u("Use 'Equatable.hasInstance' instead.");t.isEquatable=function(i){return e(),t.hasInstance(i)}}(r=e.Equatable||(e.Equatable={})),function(t){function e(e){return null!=e&&t.compareTo in Object(e)}t.compareTo=Symbol.for("@esfx/equatable:Comparable.compareTo"),t.name="Comparable",t.hasInstance=e,Object.defineProperty(t,Symbol.hasInstance,{configurable:!0,writable:!0,value:e})}(s=e.Comparable||(e.Comparable={})),function(t){const e=u("Use 'Comparable.hasInstance' instead.");t.isComparable=function(i){return e(),t.hasInstance(i)}}(s=e.Comparable||(e.Comparable={})),function(t){function e(e){let i;return null!=e&&t.structuralEquals in(i=Object(e))&&t.structuralHash in i}t.structuralEquals=Symbol.for("@esfx/equatable:StructualEquatable.structuralEquals"),t.structuralHash=Symbol.for("@esfx/equatable:StructuralEquatable.structuralHash"),t.name="StructuralEquatable",t.hasInstance=e,Object.defineProperty(t,Symbol.hasInstance,{configurable:!0,writable:!0,value:e})}(o=e.StructuralEquatable||(e.StructuralEquatable={})),function(t){const e=u("Use 'StructuralEquatable.hasInstance' instead.");t.isStructuralEquatable=function(i){return e(),t.hasInstance(i)}}(o=e.StructuralEquatable||(e.StructuralEquatable={})),function(t){function e(e){return null!=e&&t.structuralCompareTo in Object(e)}t.structuralCompareTo=Symbol.for("@esfx/equatable:StructuralComparable.structuralCompareTo"),t.name="StructuralComparable",t.hasInstance=e,Object.defineProperty(t,Symbol.hasInstance,{configurable:!0,writable:!0,value:e})}(a=e.StructuralComparable||(e.StructuralComparable={})),function(t){const e=u("Use 'StructuralComparable.hasInstance' instead.");t.isStructuralComparable=function(i){return e(),t.hasInstance(i)}}(a=e.StructuralComparable||(e.StructuralComparable={})),function(t){const e=Object.defineProperty({},Symbol.toStringTag,{configurable:!0,value:"Equaler"});function i(i,n=t.defaultEqualer.hash){return Object.setPrototypeOf({equals:i,hash:n},e)}function s(t,e,i=7){if("number"!=typeof t)throw new TypeError("Integer expected: x");if("number"!=typeof e)throw new TypeError("Integer expected: y");if("number"!=typeof i)throw new TypeError("Integer expected: rotate");if(isNaN(t)||!isFinite(t))throw new RangeError("Argument must be a finite number value: x");if(isNaN(e)||!isFinite(e))throw new RangeError("Argument must be a finite number value: y");if(isNaN(i)||!isFinite(i))throw new RangeError("Argument must be a finite number value: rotate");for(;i<0;)i+=32;for(;i>=32;)i-=32;return(t<<i|t>>>32-i)^e}function a(t){return"object"==typeof t&&null!==t&&"function"==typeof t.equals&&"function"==typeof t.hash}t.defaultEqualer=i((t,e)=>r.hasInstance(t)?t[r.equals](e):r.hasInstance(e)?e[r.equals](t):Object.is(t,e),t=>r.hasInstance(t)?t[r.hash]():n.hashUnknown(t)),t.structuralEqualer=i((e,i)=>o.hasInstance(e)?e[o.structuralEquals](i,t.structuralEqualer):o.hasInstance(i)?i[o.structuralEquals](e,t.structuralEqualer):t.defaultEqualer.equals(e,i),e=>o.hasInstance(e)?e[o.structuralHash](t.structuralEqualer):t.defaultEqualer.hash(e)),t.tupleEqualer=i((e,i)=>{if(!Array.isArray(e)&&null!=e||!Array.isArray(i)&&null!=i)throw new TypeError("Array expected");if(e===i)return!0;if(!e||!i||e.length!==i.length)return!1;for(let n=0;n<e.length;n++)if(!t.defaultEqualer.equals(e[n],i[n]))return!1;return!0},e=>{if(null==e)return 0;if(!Array.isArray(e))throw new TypeError("Array expected");let i=0;for(const n of e)i=s(i,t.defaultEqualer.hash(n));return i}),t.tupleStructuralEqualer=i((e,i)=>{if(!Array.isArray(e)&&null!=e||!Array.isArray(i)&&null!=i)throw new TypeError("Array expected");if(e===i)return!0;if(!e||!i||e.length!==i.length)return!1;for(let n=0;n<e.length;n++)if(!t.structuralEqualer.equals(e[n],i[n]))return!1;return!0},e=>{if(null==e)return 0;if(!Array.isArray(e))throw new TypeError("Array expected");let i=0;for(const n of e)i=s(i,t.structuralEqualer.hash(n));return i}),t.create=i,t.combineHashes=s,t.hasInstance=a,Object.defineProperty(t,Symbol.hasInstance,{configurable:!0,writable:!0,value:a})}(l=e.Equaler||(e.Equaler={})),e.defaultEqualer=l.defaultEqualer,e.structuralEqualer=l.structuralEqualer,e.tupleEqualer=l.tupleEqualer,e.tupleStructuralEqualer=l.tupleEqualer,e.combineHashes=l.combineHashes,function(t){const e=Object.defineProperty({},Symbol.toStringTag,{configurable:!0,value:"Comparer"});function i(t){return Object.setPrototypeOf({compare:t},e)}function n(t){return"object"==typeof t&&null!==t&&"function"==typeof t.compare}t.defaultComparer=i((t,e)=>s.hasInstance(t)?t[s.compareTo](e):s.hasInstance(e)?-e[s.compareTo](t):t<e?-1:t>e?1:0),t.structuralComparer=i((e,i)=>a.hasInstance(e)?e[a.structuralCompareTo](i,t.structuralComparer):a.hasInstance(i)?-i[a.structuralCompareTo](e,t.structuralComparer):t.defaultComparer.compare(e,i)),t.tupleComparer=i((e,i)=>{if(!Array.isArray(e)&&null!=e||!Array.isArray(i)&&null!=i)throw new TypeError("Array expected");let n;if(n=t.defaultComparer.compare(e.length,i.length))return n;for(let r=0;r<e.length;r++)if(n=t.defaultComparer.compare(e[r],i[r]))return n;return 0}),t.tupleStructuralComparer=i((e,i)=>{if(!Array.isArray(e)&&null!=e||!Array.isArray(i)&&null!=i)throw new TypeError("Array expected");let n;if(n=t.defaultComparer.compare(e.length,i.length))return n;for(let r=0;r<e.length;r++)if(n=t.structuralComparer.compare(e[r],i[r]))return n;return 0}),t.create=i,t.hasInstance=n,Object.defineProperty(t,Symbol.hasInstance,{configurable:!0,writable:!0,value:n})}(h=e.Comparer||(e.Comparer={})),e.defaultComparer=h.defaultComparer,e.structuralComparer=h.structuralComparer,e.tupleComparer=h.tupleComparer,e.tupleStructuralComparer=h.tupleStructuralComparer,e.rawHash=function(t){return n.hashUnknown(t)}}).call(this,i(20))},function(t,e,i){"use strict";(function(t){function n(e){if("undefined"!=typeof window&&"object"==typeof window.process&&"renderer"===window.process.type)return!0;if(void 0!==t&&"object"==typeof t.versions&&Boolean(t.versions.electron))return!0;const i="object"==typeof navigator&&"string"==typeof navigator.userAgent&&navigator.userAgent,n=e||i;return!!(n&&n.indexOf("Electron")>=0)}i.d(e,"a",(function(){return n}))}).call(this,i(20))},function(t,e,i){"use strict";function n(t,e,i){const n=e[0],r=e[1],s=i[3]*n+i[7]*r||1;return t[0]=(i[0]*n+i[4]*r)/s,t[1]=(i[1]*n+i[5]*r)/s,t}function r(t,e,i){const n=e[0],r=e[1],s=e[2],o=i[3]*n+i[7]*r+i[11]*s||1;return t[0]=(i[0]*n+i[4]*r+i[8]*s)/o,t[1]=(i[1]*n+i[5]*r+i[9]*s)/o,t[2]=(i[2]*n+i[6]*r+i[10]*s)/o,t}function s(t,e,i){const n=e[0],r=e[1];return t[0]=i[0]*n+i[2]*r,t[1]=i[1]*n+i[3]*r,t[2]=e[2],t}i.d(e,"a",(function(){return n})),i.d(e,"c",(function(){return r})),i.d(e,"b",(function(){return s}))},function(t,e,i){"use strict";i.d(e,"b",(function(){return a})),i.d(e,"a",(function(){return l}));var n=i(9),r=i(7);const s=t=>Object(r.e)(t)?void 0:0,o={3074:t=>Object(r.e)(t)?void 0:36064,35723:t=>Object(r.e)(t)?void 0:4352,35977:s,32937:s,36795:(t,e)=>{const i=Object(r.e)(t)?t.getExtension("EXT_disjoint_timer_query_webgl2"):t.getExtension("EXT_disjoint_timer_query");return i&&i.GPU_DISJOINT_EXT?e(i.GPU_DISJOINT_EXT):0},37445:(t,e)=>{const i=t.getExtension("WEBGL_debug_renderer_info");return e(i&&i.UNMASKED_VENDOR_WEBGL||7936)},37446:(t,e)=>{const i=t.getExtension("WEBGL_debug_renderer_info");return e(i&&i.UNMASKED_RENDERER_WEBGL||7937)},34047:(t,e)=>{const i=t.luma.extensions.EXT_texture_filter_anisotropic;return i?e(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT):1},32883:s,35071:s,37447:s,36063:(t,e)=>{if(!Object(r.e)(t)){const i=t.getExtension("WEBGL_draw_buffers");return i?e(i.MAX_COLOR_ATTACHMENTS_WEBGL):0}},35379:s,35374:s,35377:s,34852:t=>{if(!Object(r.e)(t)){const e=t.getExtension("WEBGL_draw_buffers");return e?e.MAX_DRAW_BUFFERS_WEBGL:0}},36203:t=>t.getExtension("OES_element_index")?2147483647:65535,33001:t=>t.getExtension("OES_element_index")?16777216:65535,33e3:t=>16777216,37157:s,35373:s,35657:s,36183:s,37137:s,34045:s,35978:s,35979:s,35968:s,35376:s,35375:s,35659:s,37154:s,35371:s,35658:s,35076:s,35077:s,35380:s};const a={OES_vertex_array_object:{meta:{suffix:"OES"},createVertexArray:()=>{Object(n.a)(!1,"VertexArray requires WebGL2 or OES_vertex_array_object extension")},deleteVertexArray:()=>{},bindVertexArray:()=>{},isVertexArray:()=>!1},ANGLE_instanced_arrays:{meta:{suffix:"ANGLE"},vertexAttribDivisor(t,e){Object(n.a)(0===e,"WebGL instanced rendering not supported")},drawElementsInstanced:()=>{},drawArraysInstanced:()=>{}},WEBGL_draw_buffers:{meta:{suffix:"WEBGL"},drawBuffers:()=>{Object(n.a)(!1)}},EXT_disjoint_timer_query:{meta:{suffix:"EXT"},createQuery:()=>{Object(n.a)(!1)},deleteQuery:()=>{Object(n.a)(!1)},beginQuery:()=>{Object(n.a)(!1)},endQuery:()=>{},getQuery(t,e){return this.getQueryObject(t,e)},getQueryParameter(t,e){return this.getQueryObject(t,e)},getQueryObject:()=>{}}},l={readBuffer:(t,e,i)=>{Object(r.e)(t)&&e(i)},getVertexAttrib:(t,e,i,n)=>{const{webgl2:s,ext:o}=function(t,e){return{webgl2:Object(r.e)(t),ext:t.getExtension(e)}}(t,"ANGLE_instanced_arrays");let a;switch(n){case 35069:a=!!s&&void 0;break;case 35070:a=s||o?void 0:0}return void 0!==a?a:e(i,n)},getProgramParameter:(t,e,i,n)=>{if(!Object(r.e)(t))switch(n){case 35967:return 35981;case 35971:case 35382:return 0}return e(i,n)},getInternalformatParameter:(t,e,i,n,s)=>{if(!Object(r.e)(t))switch(s){case 32937:return new Int32Array([0])}return t.getInternalformatParameter(i,n,s)},getTexParameter(t,e,i,n){switch(n){case 34046:const{extensions:e}=t.luma,i=e.EXT_texture_filter_anisotropic;n=i&&i.TEXTURE_MAX_ANISOTROPY_EXT||34046}return e(i,n)},getParameter:function(t,e,i){const n=o[i],r="function"==typeof n?n(t,e,i):n;return void 0!==r?r:e(i)},hint:(t,e,i,n)=>e(i,n)}},function(t,e,i){"use strict";i.r(e),i.d(e,"VERSION",(function(){return n.a})),i.d(e,"self",(function(){return r.e})),i.d(e,"window",(function(){return r.f})),i.d(e,"global",(function(){return r.c})),i.d(e,"document",(function(){return r.b})),i.d(e,"process",(function(){return r.d})),i.d(e,"console",(function(){return r.a})),i.d(e,"isBrowser",(function(){return s.a})),i.d(e,"isBrowserMainThread",(function(){return s.b})),i.d(e,"getBrowser",(function(){return o.a})),i.d(e,"isMobile",(function(){return o.b})),i.d(e,"isElectron",(function(){return a.a})),i.d(e,"assert",(function(){return l}));var n=i(61),r=i(15),s=i(25),o=i(51),a=i(30);function l(t,e){if(!t)throw new Error(e||"Assertion failed")}},function(t,e,i){"use strict";(function(t){function n(){let e;if("undefined"!=typeof window&&window.performance)e=window.performance.now();else if(void 0!==t&&t.hrtime){const i=t.hrtime();e=1e3*i[0]+i[1]/1e6}else e=Date.now();return e}i.d(e,"a",(function(){return n}))}).call(this,i(20))},function(t,e,i){"use strict";i.d(e,"a",(function(){return r})),i.d(e,"b",(function(){return s}));var n=i(0);function r(t,e,i){return t[0]=e[0]*i,t[1]=e[1]*i,t[2]=e[2]*i,t[3]=e[3]*i,t}function s(t,e,i){var n=e[0],r=e[1],s=e[2],o=e[3];return t[0]=i[0]*n+i[4]*r+i[8]*s+i[12]*o,t[1]=i[1]*n+i[5]*r+i[9]*s+i[13]*o,t[2]=i[2]*n+i[6]*r+i[10]*s+i[14]*o,t[3]=i[3]*n+i[7]*r+i[11]*s+i[15]*o,t}var o,a;o=new n.a(4),n.a!=Float32Array&&(o[0]=0,o[1]=0,o[2]=0,o[3]=0),a=o},function(t,e,i){"use strict";function n(t){for(const e in t)return!1;return!0}function r(t,e){if(t===e)return!0;const i=Array.isArray(t)||ArrayBuffer.isView(t),n=Array.isArray(e)||ArrayBuffer.isView(e);if(i&&n&&t.length===e.length){for(let i=0;i<t.length;++i)if(t[i]!==e[i])return!1;return!0}return!1}i.d(e,"b",(function(){return n})),i.d(e,"a",(function(){return r}))},function(t,e,i){var n;
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */!function(r,s,o,a){"use strict";var l,h=["","webkit","Moz","MS","ms","o"],u=s.createElement("div"),c=Math.round,d=Math.abs,g=Date.now;function f(t,e,i){return setTimeout(S(t,i),e)}function p(t,e,i){return!!Array.isArray(t)&&(m(t,i[e],i),!0)}function m(t,e,i){var n;if(t)if(t.forEach)t.forEach(e,i);else if(void 0!==t.length)for(n=0;n<t.length;)e.call(i,t[n],n,t),n++;else for(n in t)t.hasOwnProperty(n)&&e.call(i,t[n],n,t)}function y(t,e,i){var n="DEPRECATED METHOD: "+e+"\n"+i+" AT \n";return function(){var e=new Error("get-stack-trace"),i=e&&e.stack?e.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",s=r.console&&(r.console.warn||r.console.log);return s&&s.call(r.console,n,i),t.apply(this,arguments)}}l="function"!=typeof Object.assign?function(t){if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var e=Object(t),i=1;i<arguments.length;i++){var n=arguments[i];if(null!=n)for(var r in n)n.hasOwnProperty(r)&&(e[r]=n[r])}return e}:Object.assign;var b=y((function(t,e,i){for(var n=Object.keys(e),r=0;r<n.length;)(!i||i&&void 0===t[n[r]])&&(t[n[r]]=e[n[r]]),r++;return t}),"extend","Use `assign`."),P=y((function(t,e){return b(t,e,!0)}),"merge","Use `assign`.");function v(t,e,i){var n,r=e.prototype;(n=t.prototype=Object.create(r)).constructor=t,n._super=r,i&&l(n,i)}function S(t,e){return function(){return t.apply(e,arguments)}}function C(t,e){return"function"==typeof t?t.apply(e&&e[0]||void 0,e):t}function w(t,e){return void 0===t?e:t}function E(t,e,i){m(I(e),(function(e){t.addEventListener(e,i,!1)}))}function x(t,e,i){m(I(e),(function(e){t.removeEventListener(e,i,!1)}))}function A(t,e){for(;t;){if(t==e)return!0;t=t.parentNode}return!1}function T(t,e){return t.indexOf(e)>-1}function I(t){return t.trim().split(/\s+/g)}function O(t,e,i){if(t.indexOf&&!i)return t.indexOf(e);for(var n=0;n<t.length;){if(i&&t[n][i]==e||!i&&t[n]===e)return n;n++}return-1}function _(t){return Array.prototype.slice.call(t,0)}function L(t,e,i){for(var n=[],r=[],s=0;s<t.length;){var o=e?t[s][e]:t[s];O(r,o)<0&&n.push(t[s]),r[s]=o,s++}return i&&(n=e?n.sort((function(t,i){return t[e]>i[e]})):n.sort()),n}function R(t,e){for(var i,n,r=e[0].toUpperCase()+e.slice(1),s=0;s<h.length;){if((n=(i=h[s])?i+r:e)in t)return n;s++}}var B=1;function M(t){var e=t.ownerDocument||t;return e.defaultView||e.parentWindow||r}var F="ontouchstart"in r,D=void 0!==R(r,"PointerEvent"),N=F&&/mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),k=["x","y"],V=["clientX","clientY"];function G(t,e){var i=this;this.manager=t,this.callback=e,this.element=t.element,this.target=t.options.inputTarget,this.domHandler=function(e){C(t.options.enable,[t])&&i.handler(e)},this.init()}function z(t,e,i){var n=i.pointers.length,r=i.changedPointers.length,s=1&e&&n-r==0,o=12&e&&n-r==0;i.isFirst=!!s,i.isFinal=!!o,s&&(t.session={}),i.eventType=e,function(t,e){var i=t.session,n=e.pointers,r=n.length;i.firstInput||(i.firstInput=j(e));r>1&&!i.firstMultiple?i.firstMultiple=j(e):1===r&&(i.firstMultiple=!1);var s=i.firstInput,o=i.firstMultiple,a=o?o.center:s.center,l=e.center=U(n);e.timeStamp=g(),e.deltaTime=e.timeStamp-s.timeStamp,e.angle=X(a,l),e.distance=q(a,l),function(t,e){var i=e.center,n=t.offsetDelta||{},r=t.prevDelta||{},s=t.prevInput||{};1!==e.eventType&&4!==s.eventType||(r=t.prevDelta={x:s.deltaX||0,y:s.deltaY||0},n=t.offsetDelta={x:i.x,y:i.y});e.deltaX=r.x+(i.x-n.x),e.deltaY=r.y+(i.y-n.y)}(i,e),e.offsetDirection=H(e.deltaX,e.deltaY);var h=W(e.deltaTime,e.deltaX,e.deltaY);e.overallVelocityX=h.x,e.overallVelocityY=h.y,e.overallVelocity=d(h.x)>d(h.y)?h.x:h.y,e.scale=o?(u=o.pointers,c=n,q(c[0],c[1],V)/q(u[0],u[1],V)):1,e.rotation=o?function(t,e){return X(e[1],e[0],V)+X(t[1],t[0],V)}(o.pointers,n):0,e.maxPointers=i.prevInput?e.pointers.length>i.prevInput.maxPointers?e.pointers.length:i.prevInput.maxPointers:e.pointers.length,function(t,e){var i,n,r,s,o=t.lastInterval||e,a=e.timeStamp-o.timeStamp;if(8!=e.eventType&&(a>25||void 0===o.velocity)){var l=e.deltaX-o.deltaX,h=e.deltaY-o.deltaY,u=W(a,l,h);n=u.x,r=u.y,i=d(u.x)>d(u.y)?u.x:u.y,s=H(l,h),t.lastInterval=e}else i=o.velocity,n=o.velocityX,r=o.velocityY,s=o.direction;e.velocity=i,e.velocityX=n,e.velocityY=r,e.direction=s}(i,e);var u,c;var f=t.element;A(e.srcEvent.target,f)&&(f=e.srcEvent.target);e.target=f}(t,i),t.emit("hammer.input",i),t.recognize(i),t.session.prevInput=i}function j(t){for(var e=[],i=0;i<t.pointers.length;)e[i]={clientX:c(t.pointers[i].clientX),clientY:c(t.pointers[i].clientY)},i++;return{timeStamp:g(),pointers:e,center:U(e),deltaX:t.deltaX,deltaY:t.deltaY}}function U(t){var e=t.length;if(1===e)return{x:c(t[0].clientX),y:c(t[0].clientY)};for(var i=0,n=0,r=0;r<e;)i+=t[r].clientX,n+=t[r].clientY,r++;return{x:c(i/e),y:c(n/e)}}function W(t,e,i){return{x:e/t||0,y:i/t||0}}function H(t,e){return t===e?1:d(t)>=d(e)?t<0?2:4:e<0?8:16}function q(t,e,i){i||(i=k);var n=e[i[0]]-t[i[0]],r=e[i[1]]-t[i[1]];return Math.sqrt(n*n+r*r)}function X(t,e,i){i||(i=k);var n=e[i[0]]-t[i[0]],r=e[i[1]]-t[i[1]];return 180*Math.atan2(r,n)/Math.PI}G.prototype={handler:function(){},init:function(){this.evEl&&E(this.element,this.evEl,this.domHandler),this.evTarget&&E(this.target,this.evTarget,this.domHandler),this.evWin&&E(M(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&x(this.element,this.evEl,this.domHandler),this.evTarget&&x(this.target,this.evTarget,this.domHandler),this.evWin&&x(M(this.element),this.evWin,this.domHandler)}};var Y={mousedown:1,mousemove:2,mouseup:4};function Q(){this.evEl="mousedown",this.evWin="mousemove mouseup",this.pressed=!1,G.apply(this,arguments)}v(Q,G,{handler:function(t){var e=Y[t.type];1&e&&0===t.button&&(this.pressed=!0),2&e&&1!==t.which&&(e=4),this.pressed&&(4&e&&(this.pressed=!1),this.callback(this.manager,e,{pointers:[t],changedPointers:[t],pointerType:"mouse",srcEvent:t}))}});var Z={pointerdown:1,pointermove:2,pointerup:4,pointercancel:8,pointerout:8},K={2:"touch",3:"pen",4:"mouse",5:"kinect"},$="pointerdown",J="pointermove pointerup pointercancel";function tt(){this.evEl=$,this.evWin=J,G.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}r.MSPointerEvent&&!r.PointerEvent&&($="MSPointerDown",J="MSPointerMove MSPointerUp MSPointerCancel"),v(tt,G,{handler:function(t){var e=this.store,i=!1,n=t.type.toLowerCase().replace("ms",""),r=Z[n],s=K[t.pointerType]||t.pointerType,o="touch"==s,a=O(e,t.pointerId,"pointerId");1&r&&(0===t.button||o)?a<0&&(e.push(t),a=e.length-1):12&r&&(i=!0),a<0||(e[a]=t,this.callback(this.manager,r,{pointers:e,changedPointers:[t],pointerType:s,srcEvent:t}),i&&e.splice(a,1))}});var et={touchstart:1,touchmove:2,touchend:4,touchcancel:8};function it(){this.evTarget="touchstart",this.evWin="touchstart touchmove touchend touchcancel",this.started=!1,G.apply(this,arguments)}function nt(t,e){var i=_(t.touches),n=_(t.changedTouches);return 12&e&&(i=L(i.concat(n),"identifier",!0)),[i,n]}v(it,G,{handler:function(t){var e=et[t.type];if(1===e&&(this.started=!0),this.started){var i=nt.call(this,t,e);12&e&&i[0].length-i[1].length==0&&(this.started=!1),this.callback(this.manager,e,{pointers:i[0],changedPointers:i[1],pointerType:"touch",srcEvent:t})}}});var rt={touchstart:1,touchmove:2,touchend:4,touchcancel:8};function st(){this.evTarget="touchstart touchmove touchend touchcancel",this.targetIds={},G.apply(this,arguments)}function ot(t,e){var i=_(t.touches),n=this.targetIds;if(3&e&&1===i.length)return n[i[0].identifier]=!0,[i,i];var r,s,o=_(t.changedTouches),a=[],l=this.target;if(s=i.filter((function(t){return A(t.target,l)})),1===e)for(r=0;r<s.length;)n[s[r].identifier]=!0,r++;for(r=0;r<o.length;)n[o[r].identifier]&&a.push(o[r]),12&e&&delete n[o[r].identifier],r++;return a.length?[L(s.concat(a),"identifier",!0),a]:void 0}v(st,G,{handler:function(t){var e=rt[t.type],i=ot.call(this,t,e);i&&this.callback(this.manager,e,{pointers:i[0],changedPointers:i[1],pointerType:"touch",srcEvent:t})}});function at(){G.apply(this,arguments);var t=S(this.handler,this);this.touch=new st(this.manager,t),this.mouse=new Q(this.manager,t),this.primaryTouch=null,this.lastTouches=[]}function lt(t,e){1&t?(this.primaryTouch=e.changedPointers[0].identifier,ht.call(this,e)):12&t&&ht.call(this,e)}function ht(t){var e=t.changedPointers[0];if(e.identifier===this.primaryTouch){var i={x:e.clientX,y:e.clientY};this.lastTouches.push(i);var n=this.lastTouches;setTimeout((function(){var t=n.indexOf(i);t>-1&&n.splice(t,1)}),2500)}}function ut(t){for(var e=t.srcEvent.clientX,i=t.srcEvent.clientY,n=0;n<this.lastTouches.length;n++){var r=this.lastTouches[n],s=Math.abs(e-r.x),o=Math.abs(i-r.y);if(s<=25&&o<=25)return!0}return!1}v(at,G,{handler:function(t,e,i){var n="touch"==i.pointerType,r="mouse"==i.pointerType;if(!(r&&i.sourceCapabilities&&i.sourceCapabilities.firesTouchEvents)){if(n)lt.call(this,e,i);else if(r&&ut.call(this,i))return;this.callback(t,e,i)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var ct=R(u.style,"touchAction"),dt=void 0!==ct,gt=function(){if(!dt)return!1;var t={},e=r.CSS&&r.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach((function(i){t[i]=!e||r.CSS.supports("touch-action",i)})),t}();function ft(t,e){this.manager=t,this.set(e)}ft.prototype={set:function(t){"compute"==t&&(t=this.compute()),dt&&this.manager.element.style&&gt[t]&&(this.manager.element.style[ct]=t),this.actions=t.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var t=[];return m(this.manager.recognizers,(function(e){C(e.options.enable,[e])&&(t=t.concat(e.getTouchAction()))})),function(t){if(T(t,"none"))return"none";var e=T(t,"pan-x"),i=T(t,"pan-y");if(e&&i)return"none";if(e||i)return e?"pan-x":"pan-y";if(T(t,"manipulation"))return"manipulation";return"auto"}(t.join(" "))},preventDefaults:function(t){var e=t.srcEvent,i=t.offsetDirection;if(this.manager.session.prevented)e.preventDefault();else{var n=this.actions,r=T(n,"none")&&!gt.none,s=T(n,"pan-y")&&!gt["pan-y"],o=T(n,"pan-x")&&!gt["pan-x"];if(r){var a=1===t.pointers.length,l=t.distance<2,h=t.deltaTime<250;if(a&&l&&h)return}if(!o||!s)return r||s&&6&i||o&&24&i?this.preventSrc(e):void 0}},preventSrc:function(t){this.manager.session.prevented=!0,t.preventDefault()}};function pt(t){this.options=l({},this.defaults,t||{}),this.id=B++,this.manager=null,this.options.enable=w(this.options.enable,!0),this.state=1,this.simultaneous={},this.requireFail=[]}function mt(t){return 16&t?"cancel":8&t?"end":4&t?"move":2&t?"start":""}function yt(t){return 16==t?"down":8==t?"up":2==t?"left":4==t?"right":""}function bt(t,e){var i=e.manager;return i?i.get(t):t}function Pt(){pt.apply(this,arguments)}function vt(){Pt.apply(this,arguments),this.pX=null,this.pY=null}function St(){Pt.apply(this,arguments)}function Ct(){pt.apply(this,arguments),this._timer=null,this._input=null}function wt(){Pt.apply(this,arguments)}function Et(){Pt.apply(this,arguments)}function xt(){pt.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function At(t,e){return(e=e||{}).recognizers=w(e.recognizers,At.defaults.preset),new Tt(t,e)}pt.prototype={defaults:{},set:function(t){return l(this.options,t),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(t){if(p(t,"recognizeWith",this))return this;var e=this.simultaneous;return e[(t=bt(t,this)).id]||(e[t.id]=t,t.recognizeWith(this)),this},dropRecognizeWith:function(t){return p(t,"dropRecognizeWith",this)||(t=bt(t,this),delete this.simultaneous[t.id]),this},requireFailure:function(t){if(p(t,"requireFailure",this))return this;var e=this.requireFail;return-1===O(e,t=bt(t,this))&&(e.push(t),t.requireFailure(this)),this},dropRequireFailure:function(t){if(p(t,"dropRequireFailure",this))return this;t=bt(t,this);var e=O(this.requireFail,t);return e>-1&&this.requireFail.splice(e,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(t){return!!this.simultaneous[t.id]},emit:function(t){var e=this,i=this.state;function n(i){e.manager.emit(i,t)}i<8&&n(e.options.event+mt(i)),n(e.options.event),t.additionalEvent&&n(t.additionalEvent),i>=8&&n(e.options.event+mt(i))},tryEmit:function(t){if(this.canEmit())return this.emit(t);this.state=32},canEmit:function(){for(var t=0;t<this.requireFail.length;){if(!(33&this.requireFail[t].state))return!1;t++}return!0},recognize:function(t){var e=l({},t);if(!C(this.options.enable,[this,e]))return this.reset(),void(this.state=32);56&this.state&&(this.state=1),this.state=this.process(e),30&this.state&&this.tryEmit(e)},process:function(t){},getTouchAction:function(){},reset:function(){}},v(Pt,pt,{defaults:{pointers:1},attrTest:function(t){var e=this.options.pointers;return 0===e||t.pointers.length===e},process:function(t){var e=this.state,i=t.eventType,n=6&e,r=this.attrTest(t);return n&&(8&i||!r)?16|e:n||r?4&i?8|e:2&e?4|e:2:32}}),v(vt,Pt,{defaults:{event:"pan",threshold:10,pointers:1,direction:30},getTouchAction:function(){var t=this.options.direction,e=[];return 6&t&&e.push("pan-y"),24&t&&e.push("pan-x"),e},directionTest:function(t){var e=this.options,i=!0,n=t.distance,r=t.direction,s=t.deltaX,o=t.deltaY;return r&e.direction||(6&e.direction?(r=0===s?1:s<0?2:4,i=s!=this.pX,n=Math.abs(t.deltaX)):(r=0===o?1:o<0?8:16,i=o!=this.pY,n=Math.abs(t.deltaY))),t.direction=r,i&&n>e.threshold&&r&e.direction},attrTest:function(t){return Pt.prototype.attrTest.call(this,t)&&(2&this.state||!(2&this.state)&&this.directionTest(t))},emit:function(t){this.pX=t.deltaX,this.pY=t.deltaY;var e=yt(t.direction);e&&(t.additionalEvent=this.options.event+e),this._super.emit.call(this,t)}}),v(St,Pt,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return["none"]},attrTest:function(t){return this._super.attrTest.call(this,t)&&(Math.abs(t.scale-1)>this.options.threshold||2&this.state)},emit:function(t){if(1!==t.scale){var e=t.scale<1?"in":"out";t.additionalEvent=this.options.event+e}this._super.emit.call(this,t)}}),v(Ct,pt,{defaults:{event:"press",pointers:1,time:251,threshold:9},getTouchAction:function(){return["auto"]},process:function(t){var e=this.options,i=t.pointers.length===e.pointers,n=t.distance<e.threshold,r=t.deltaTime>e.time;if(this._input=t,!n||!i||12&t.eventType&&!r)this.reset();else if(1&t.eventType)this.reset(),this._timer=f((function(){this.state=8,this.tryEmit()}),e.time,this);else if(4&t.eventType)return 8;return 32},reset:function(){clearTimeout(this._timer)},emit:function(t){8===this.state&&(t&&4&t.eventType?this.manager.emit(this.options.event+"up",t):(this._input.timeStamp=g(),this.manager.emit(this.options.event,this._input)))}}),v(wt,Pt,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return["none"]},attrTest:function(t){return this._super.attrTest.call(this,t)&&(Math.abs(t.rotation)>this.options.threshold||2&this.state)}}),v(Et,Pt,{defaults:{event:"swipe",threshold:10,velocity:.3,direction:30,pointers:1},getTouchAction:function(){return vt.prototype.getTouchAction.call(this)},attrTest:function(t){var e,i=this.options.direction;return 30&i?e=t.overallVelocity:6&i?e=t.overallVelocityX:24&i&&(e=t.overallVelocityY),this._super.attrTest.call(this,t)&&i&t.offsetDirection&&t.distance>this.options.threshold&&t.maxPointers==this.options.pointers&&d(e)>this.options.velocity&&4&t.eventType},emit:function(t){var e=yt(t.offsetDirection);e&&this.manager.emit(this.options.event+e,t),this.manager.emit(this.options.event,t)}}),v(xt,pt,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return["manipulation"]},process:function(t){var e=this.options,i=t.pointers.length===e.pointers,n=t.distance<e.threshold,r=t.deltaTime<e.time;if(this.reset(),1&t.eventType&&0===this.count)return this.failTimeout();if(n&&r&&i){if(4!=t.eventType)return this.failTimeout();var s=!this.pTime||t.timeStamp-this.pTime<e.interval,o=!this.pCenter||q(this.pCenter,t.center)<e.posThreshold;if(this.pTime=t.timeStamp,this.pCenter=t.center,o&&s?this.count+=1:this.count=1,this._input=t,0===this.count%e.taps)return this.hasRequireFailures()?(this._timer=f((function(){this.state=8,this.tryEmit()}),e.interval,this),2):8}return 32},failTimeout:function(){return this._timer=f((function(){this.state=32}),this.options.interval,this),32},reset:function(){clearTimeout(this._timer)},emit:function(){8==this.state&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),At.VERSION="2.0.7",At.defaults={domEvents:!1,touchAction:"compute",enable:!0,inputTarget:null,inputClass:null,preset:[[wt,{enable:!1}],[St,{enable:!1},["rotate"]],[Et,{direction:6}],[vt,{direction:6},["swipe"]],[xt],[xt,{event:"doubletap",taps:2},["tap"]],[Ct]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};function Tt(t,e){var i;this.options=l({},At.defaults,e||{}),this.options.inputTarget=this.options.inputTarget||t,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=t,this.input=new((i=this).options.inputClass||(D?tt:N?st:F?at:Q))(i,z),this.touchAction=new ft(this,this.options.touchAction),It(this,!0),m(this.options.recognizers,(function(t){var e=this.add(new t[0](t[1]));t[2]&&e.recognizeWith(t[2]),t[3]&&e.requireFailure(t[3])}),this)}function It(t,e){var i,n=t.element;n.style&&(m(t.options.cssProps,(function(r,s){i=R(n.style,s),e?(t.oldCssProps[i]=n.style[i],n.style[i]=r):n.style[i]=t.oldCssProps[i]||""})),e||(t.oldCssProps={}))}Tt.prototype={set:function(t){return l(this.options,t),t.touchAction&&this.touchAction.update(),t.inputTarget&&(this.input.destroy(),this.input.target=t.inputTarget,this.input.init()),this},stop:function(t){this.session.stopped=t?2:1},recognize:function(t){var e=this.session;if(!e.stopped){var i;this.touchAction.preventDefaults(t);var n=this.recognizers,r=e.curRecognizer;(!r||r&&8&r.state)&&(r=e.curRecognizer=null);for(var s=0;s<n.length;)i=n[s],2===e.stopped||r&&i!=r&&!i.canRecognizeWith(r)?i.reset():i.recognize(t),!r&&14&i.state&&(r=e.curRecognizer=i),s++}},get:function(t){if(t instanceof pt)return t;for(var e=this.recognizers,i=0;i<e.length;i++)if(e[i].options.event==t)return e[i];return null},add:function(t){if(p(t,"add",this))return this;var e=this.get(t.options.event);return e&&this.remove(e),this.recognizers.push(t),t.manager=this,this.touchAction.update(),t},remove:function(t){if(p(t,"remove",this))return this;if(t=this.get(t)){var e=this.recognizers,i=O(e,t);-1!==i&&(e.splice(i,1),this.touchAction.update())}return this},on:function(t,e){if(void 0!==t&&void 0!==e){var i=this.handlers;return m(I(t),(function(t){i[t]=i[t]||[],i[t].push(e)})),this}},off:function(t,e){if(void 0!==t){var i=this.handlers;return m(I(t),(function(t){e?i[t]&&i[t].splice(O(i[t],e),1):delete i[t]})),this}},emit:function(t,e){this.options.domEvents&&function(t,e){var i=s.createEvent("Event");i.initEvent(t,!0,!0),i.gesture=e,e.target.dispatchEvent(i)}(t,e);var i=this.handlers[t]&&this.handlers[t].slice();if(i&&i.length){e.type=t,e.preventDefault=function(){e.srcEvent.preventDefault()};for(var n=0;n<i.length;)i[n](e),n++}},destroy:function(){this.element&&It(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},l(At,{INPUT_START:1,INPUT_MOVE:2,INPUT_END:4,INPUT_CANCEL:8,STATE_POSSIBLE:1,STATE_BEGAN:2,STATE_CHANGED:4,STATE_ENDED:8,STATE_RECOGNIZED:8,STATE_CANCELLED:16,STATE_FAILED:32,DIRECTION_NONE:1,DIRECTION_LEFT:2,DIRECTION_RIGHT:4,DIRECTION_UP:8,DIRECTION_DOWN:16,DIRECTION_HORIZONTAL:6,DIRECTION_VERTICAL:24,DIRECTION_ALL:30,Manager:Tt,Input:G,TouchAction:ft,TouchInput:st,MouseInput:Q,PointerEventInput:tt,TouchMouseInput:at,SingleTouchInput:it,Recognizer:pt,AttrRecognizer:Pt,Tap:xt,Pan:vt,Swipe:Et,Pinch:St,Rotate:wt,Press:Ct,on:E,off:x,each:m,merge:P,extend:b,assign:l,inherit:v,bindFn:S,prefixed:R}),(void 0!==r?r:"undefined"!=typeof self?self:{}).Hammer=At,void 0===(n=function(){return At}.call(e,i,e,t))||(t.exports=n)}(window,document)},,,,function(t,e){},function(t,e,i){"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/Object.defineProperty(e,"__esModule",{value:!0});const n=i(96);n.__exportStar(i(26),e),n.__exportStar(i(97),e),n.__exportStar(i(58),e),n.__exportStar(i(60),e),n.__exportStar(i(99),e),n.__exportStar(i(100),e)},function(t,e,i){"use strict";i.d(e,"a",(function(){return s}));var n=i(1),r=i(16);class s extends(function(t){function e(){var e=Reflect.construct(t,Array.from(arguments));return Object.setPrototypeOf(e,Object.getPrototypeOf(this)),e}return e.prototype=Object.create(t.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t,e}(Array)){get ELEMENTS(){return Object(r.a)(!1),0}clone(){return(new this.constructor).copy(this)}from(t){return Array.isArray(t)?this.copy(t):this.fromObject(t)}fromArray(t,e=0){for(let i=0;i<this.ELEMENTS;++i)this[i]=t[i+e];return this.check()}to(t){return t===this?this:Object(n.e)(t)?this.toArray(t):this.toObject(t)}toTarget(t){return t?this.to(t):this}toArray(t=[],e=0){for(let i=0;i<this.ELEMENTS;++i)t[e+i]=this[i];return t}toFloat32Array(){return new Float32Array(this)}toString(){return this.formatString(n.b)}formatString(t){let e="";for(let i=0;i<this.ELEMENTS;++i)e+=(i>0?", ":"")+Object(n.d)(this[i],t);return"".concat(t.printTypes?this.constructor.name:"","[").concat(e,"]")}equals(t){if(!t||this.length!==t.length)return!1;for(let e=0;e<this.ELEMENTS;++e)if(!Object(n.c)(this[e],t[e]))return!1;return!0}exactEquals(t){if(!t||this.length!==t.length)return!1;for(let e=0;e<this.ELEMENTS;++e)if(this[e]!==t[e])return!1;return!0}negate(){for(let t=0;t<this.ELEMENTS;++t)this[t]=-this[t];return this.check()}lerp(t,e,i){void 0===i&&(i=e,e=t,t=this);for(let n=0;n<this.ELEMENTS;++n){const r=t[n];this[n]=r+i*(e[n]-r)}return this.check()}min(t){for(let e=0;e<this.ELEMENTS;++e)this[e]=Math.min(t[e],this[e]);return this.check()}max(t){for(let e=0;e<this.ELEMENTS;++e)this[e]=Math.max(t[e],this[e]);return this.check()}clamp(t,e){for(let i=0;i<this.ELEMENTS;++i)this[i]=Math.min(Math.max(this[i],t[i]),e[i]);return this.check()}add(...t){for(const e of t)for(let t=0;t<this.ELEMENTS;++t)this[t]+=e[t];return this.check()}subtract(...t){for(const e of t)for(let t=0;t<this.ELEMENTS;++t)this[t]-=e[t];return this.check()}scale(t){if(Array.isArray(t))return this.multiply(t);for(let e=0;e<this.ELEMENTS;++e)this[e]*=t;return this.check()}sub(t){return this.subtract(t)}setScalar(t){for(let e=0;e<this.ELEMENTS;++e)this[e]=t;return this.check()}addScalar(t){for(let e=0;e<this.ELEMENTS;++e)this[e]+=t;return this.check()}subScalar(t){return this.addScalar(-t)}multiplyScalar(t){for(let e=0;e<this.ELEMENTS;++e)this[e]*=t;return this.check()}divideScalar(t){return this.scale(1/t)}clampScalar(t,e){for(let i=0;i<this.ELEMENTS;++i)this[i]=Math.min(Math.max(this[i],t),e);return this.check()}multiplyByScalar(t){return this.scale(t)}get elements(){return this}check(){if(n.b.debug&&!this.validate())throw new Error("math.gl: ".concat(this.constructor.name," some fields set to invalid numbers'"));return this}validate(){let t=this.length===this.ELEMENTS;for(let e=0;e<this.ELEMENTS;++e)t=t&&Number.isFinite(this[e]);return t}}},,,,,,,,function(t,e,i){"use strict";i.d(e,"b",(function(){return o})),i.d(e,"a",(function(){return a}));var n=i(25),r=i(30);const s=globalThis;function o(){return void 0!==s.orientation}function a(t){if(!t&&!Object(n.a)())return"Node";if(Object(r.a)(t))return"Electron";const e="undefined"!=typeof navigator?navigator:{},i=t||e.userAgent||"";if(i.indexOf("Edge")>-1)return"Edge";const o=-1!==i.indexOf("MSIE "),a=-1!==i.indexOf("Trident/");return o||a?"IE":s.chrome?"Chrome":s.safari?"Safari":s.mozInnerScreenX?"Firefox":"Unknown"}},function(t,e){},,,,function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class n{constructor(...t){this._head=this._tail=null,this._length=0,t.length>0&&t.forEach(t=>{this.append(t)})}*iterator(){let t=this._head;for(;t;)yield t.value,t=t.next}[Symbol.iterator](){return this.iterator()}get head(){return this._head?this._head.value:null}get tail(){return this._tail?this._tail.value:null}get length(){return this._length}insert(t,e,i=!1){if(i&&this.isDuplicate(t))return!1;let n=new r(t),s=this._head;if(!s)return!1;for(;;){if(s.value===e)return n.next=s.next,n.prev=s,s.next=n,n.next?n.next.prev=n:this._tail=n,this._length++,!0;if(!s.next)return!1;s=s.next}}append(t,e=!1){if(e&&this.isDuplicate(t))return!1;let i=new r(t);return this._tail?(this._tail.next=i,i.prev=this._tail,this._tail=i):this._head=this._tail=i,this._length++,!0}prepend(t,e=!1){if(e&&this.isDuplicate(t))return!1;let i=new r(t);return this._head?(i.next=this._head,this._head.prev=i,this._head=i):this._head=this._tail=i,this._length++,!0}remove(t){let e=this._head;if(e){if(e.value===t)return this._head=e.next,this._head.prev=null,e.next=e.prev=null,this._length--,e.value;for(;;){if(e.value===t)return e.next?(e.prev.next=e.next,e.next.prev=e.prev,e.next=e.prev=null):(e.prev.next=null,this._tail=e.prev,e.next=e.prev=null),this._length--,e.value;if(!e.next)return;e=e.next}}}removeHead(){let t=this._head;if(t)return this._head.next?(this._head.next.prev=null,this._head=this._head.next,t.next=t.prev=null):(this._head=null,this._tail=null),this._length--,t.value}removeTail(){let t=this._tail;if(t)return this._tail.prev?(this._tail.prev.next=null,this._tail=this._tail.prev,t.next=t.prev=null):(this._head=null,this._tail=null),this._length--,t.value}first(t){let e=this.iterator(),i=[],n=Math.min(t,this.length);for(let t=0;t<n;t++){let t=e.next();i.push(t.value)}return i}toArray(){return[...this]}isDuplicate(t){return new Set(this.toArray()).has(t)}}e.LinkedList=n;class r{constructor(t){this.value=t,this.next=null,this.prev=null}}e.LinkedListItem=r},function(t,e,i){"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/Object.defineProperty(e,"__esModule",{value:!0}),e.binarySearch=void 0,e.binarySearch=function(t,e,i){if(0===t.length)return-1;let n=0,r=t.length-1;for(;n<=r;){const s=n+(r-n>>1),o=t[s];switch(Math.sign(i.compare(o,e))){case-1:n=s+1;break;case 0:return s;case 1:r=s-1}}return~n}},function(t,e,i){"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   HashMap is derived from the implementation of Dictionary<T> in .NET Core.

   .NET Core is licensed under the MIT License:

   The MIT License (MIT)

   Copyright (c) .NET Foundation and Contributors

   All rights reserved.

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
*/Object.defineProperty(e,"__esModule",{value:!0}),e.HashMap=void 0;const n=i(28),r=i(29),s=i(24),o=i(59);class a{constructor(...t){let e,i,n;if(t.length>0){const r=t[0];"number"==typeof r?(e=r,t.length>1&&(n=t[1])):s.isIterable(r)||void 0===r?(i=r,t.length>1&&(n=t[1])):n=r}if(void 0===e&&(e=0),void 0===n&&(n=r.Equaler.defaultEqualer),e<0)throw new RangeError;if(this._hashData=o.createHashData(n,e),i)for(const[t,e]of i)this.set(t,e)}get equaler(){return this._hashData.equaler}get size(){return this._hashData.size-this._hashData.freeSize}has(t){return o.findEntryIndex(this._hashData,t)>=0}get(t){return o.findEntryValue(this._hashData,t)}set(t,e){return o.insertEntry(this._hashData,t,e),this}delete(t){return o.deleteEntry(this._hashData,t)}clear(){o.clearEntries(this._hashData)}ensureCapacity(t){return o.ensureCapacity(this._hashData,t)}trimExcess(t){o.trimExcessEntries(this._hashData,t)}keys(){return o.iterateEntries(this._hashData.head,o.selectEntryKey)}values(){return o.iterateEntries(this._hashData.head,o.selectEntryValue)}entries(){return o.iterateEntries(this._hashData.head,o.selectEntryEntry)}[Symbol.iterator](){return this.entries()}forEach(t,e){o.forEachEntry(this,this._hashData.head,t,e)}get[n.ReadonlyKeyedCollection.size](){return this.size}[n.ReadonlyKeyedCollection.has](t){return this.has(t)}[n.ReadonlyKeyedCollection.get](t){return this.get(t)}[n.ReadonlyKeyedCollection.keys](){return this.keys()}[n.ReadonlyKeyedCollection.values](){return this.values()}[n.KeyedCollection.set](t,e){this.set(t,e)}[n.KeyedCollection.delete](t){return this.delete(t)}[n.KeyedCollection.clear](){this.clear()}}e.HashMap=a,Object.defineProperty(a,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!0,value:"HashMap"})},function(t,e,i){"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   HashMap is derived from the implementation of Dictionary<T> in .NET Core.
   HashSet is derived from the implementation of HashSet<T> in .NET Core.

   .NET Core is licensed under the MIT License:

   The MIT License (MIT)

   Copyright (c) .NET Foundation and Contributors

   All rights reserved.

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
*/Object.defineProperty(e,"__esModule",{value:!0}),e.forEachEntry=e.iterateEntries=e.selectEntryEntry=e.selectEntryValue=e.selectEntryKey=e.trimExcessEntries=e.ensureCapacity=e.clearEntries=e.deleteEntry=e.insertEntry=e.findEntryValue=e.findEntryIndex=e.resizeHashData=e.initializeHashData=e.createHashData=e.createHashEntry=void 0;const n=i(98);function r(){return{prevEntry:void 0,nextEntry:void 0,skipNextEntry:!1,next:0,hashCode:0,key:void 0,value:void 0}}function s(t,e){const i=n.getPrime(e);return t.freeList=-1,t.buckets=new Int32Array(i),t.entries=new Array(i),i}function o(t,e){const i=t.size,n=new Int32Array(e),r=t.entries?t.entries.slice():[];r.length=e;for(let t=0;t<i;t++){const i=r[t];if(i&&i.hashCode>=0){const r=i.hashCode%e;i.next=n[r]-1,n[r]=t+1}}t.buckets=n,t.entries=r}function a(t,e){let i=-1;const{buckets:n,entries:r,equaler:s}=t;if(n&&r){let t=s.hash(e)&2**31-1;for(i=n[t%n.length]-1;i>>>0<r.length&&(r[i].hashCode!==t||!s.equals(r[i].key,e));)i=r[i].next}return i}e.createHashEntry=r,e.createHashData=function(t,e){const i={prevEntry:void 0,nextEntry:void 0,skipNextEntry:!1,next:0,hashCode:0,key:void 0,value:void 0},n={buckets:void 0,entries:void 0,freeSize:0,freeList:0,size:0,equaler:t,head:i,tail:i};return s(n,e),n},e.initializeHashData=s,e.resizeHashData=o,e.findEntryIndex=a,e.findEntryValue=function(t,e){const i=a(t,e);return i>=0?t.entries[i].value:void 0},e.insertEntry=function(t,e,i){if(t.buckets||s(t,0),!t.buckets||!t.entries)throw new Error;const r=t.equaler.hash(e)&2**31-1;let a=r%t.buckets.length,l=t.buckets[a]-1;for(;l>>>0<t.entries.length;){const n=t.entries[l];if(n.hashCode===r&&t.equaler.equals(n.key,e))return void(n.value=i);l=n.next}let h,u=!1;if(t.freeSize>0)h=t.freeList,u=!0,t.freeSize--;else{const e=t.size;if(e===t.entries.length){if(o(t,n.expandPrime(t.size)),!t.buckets||!t.entries)throw new Error;a=r%t.buckets.length}h=e,t.size=e+1}const c=t.entries[h]||(t.entries[h]={prevEntry:void 0,nextEntry:void 0,skipNextEntry:!1,next:0,hashCode:0,key:void 0,value:void 0});u&&(t.freeList=c.next),c.hashCode=r,c.next=t.buckets[a]-1,c.key=e,c.value=i,c.skipNextEntry=!1;const d=t.tail;d.nextEntry=c,c.prevEntry=d,t.tail=c,t.buckets[a]=h+1},e.deleteEntry=function(t,e){if(t.buckets&&t.entries){const i=t.equaler.hash(e)&2**31-1,n=i%t.buckets.length;let r,s=-1;for(let o=t.buckets[n]-1;o>=0;o=r.next){if(r=t.entries[o],r.hashCode===i&&t.equaler.equals(r.key,e)){s<0?t.buckets[n]=r.next+1:t.entries[s].next=r.next;const e=r.prevEntry;return e.nextEntry=r.nextEntry,e.nextEntry&&(e.nextEntry.prevEntry=e),t.tail===r&&(t.tail=e),r.hashCode=-1,r.next=t.freeList,r.key=void 0,r.value=void 0,r.prevEntry=void 0,r.nextEntry=e,r.skipNextEntry=!0,t.freeList=o,t.freeSize++,!0}s=o}}return!1},e.clearEntries=function(t){if(t.size>0){t.buckets&&t.buckets.fill(0),t.entries&&t.entries.fill(void 0);let e=t.head.nextEntry;for(;e;){const i=e.nextEntry;e.prevEntry=void 0,e.nextEntry=t.head,e.skipNextEntry=!0,e=i}t.head.nextEntry=void 0,t.tail=t.head,t.size=0,t.freeList=-1,t.freeSize=0}},e.ensureCapacity=function(t,e){if(e<0)throw new RangeError;const i=t.entries?t.entries.length:0;if(i>=e)return i;if(!t.buckets)return s(t,e);const r=n.getPrime(e);return o(t,n.getPrime(e)),r},e.trimExcessEntries=function(t,e=t.size-t.freeSize){if(e<t.size)throw new RangeError;if(!t.buckets||!t.entries)return;const i=n.getPrime(e),r=t.entries;if(i>=(r?r.length:0))return;const o=t.size;if(s(t,i),!t.buckets||!t.entries)throw new Error;let a=0;for(let e=0;e<o;e++){const n=r[e].hashCode;if(n>=0){const s=n%i;t.entries[a]=r[e],t.entries[a].next=t.buckets[s]-1,t.buckets[s]=a+1,a++}}t.size=a,t.freeSize=0},e.selectEntryKey=function(t){return t.key},e.selectEntryValue=function(t){return t.value},e.selectEntryEntry=function(t){return[t.key,t.value]},e.iterateEntries=function*(t,e){let i=t;for(;i;){const t=i.skipNextEntry;i=i.nextEntry,t||i&&(yield e(i))}},e.forEachEntry=function(t,e,i,n){let r=e;for(;r;){const e=r.skipNextEntry;r=r.nextEntry,e||r&&i.call(n,r.value,r.key,t)}}},function(t,e,i){"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   HashSet is derived from the implementation of HashSet<T> in .NET Core.

   .NET Core is licensed under the MIT License:

   The MIT License (MIT)

   Copyright (c) .NET Foundation and Contributors

   All rights reserved.

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
*/Object.defineProperty(e,"__esModule",{value:!0}),e.HashSet=void 0;const n=i(28),r=i(29),s=i(24),o=i(59);class a{constructor(...t){let e,i,n;if(t.length>0){const r=t[0];"number"==typeof r?(e=r,t.length>1&&(n=t[1])):s.isIterable(r)?(i=r,t.length>1&&(n=t[1])):n=r}if(void 0===e&&(e=0),void 0===n&&(n=r.Equaler.defaultEqualer),e<0)throw new RangeError;if(this._hashData=o.createHashData(n,e),i)for(const t of i)this.add(t)}get equaler(){return this._hashData.equaler}get size(){return this._hashData.size-this._hashData.freeSize}has(t){return o.findEntryIndex(this._hashData,t)>=0}add(t){return o.insertEntry(this._hashData,t,t),this}tryAdd(t){const e=this.size;return o.insertEntry(this._hashData,t,t),this.size>e}delete(t){return o.deleteEntry(this._hashData,t)}clear(){o.clearEntries(this._hashData)}ensureCapacity(t){return o.ensureCapacity(this._hashData,t)}trimExcess(t){o.trimExcessEntries(this._hashData,t)}keys(){return o.iterateEntries(this._hashData.head,o.selectEntryKey)}values(){return o.iterateEntries(this._hashData.head,o.selectEntryValue)}entries(){return o.iterateEntries(this._hashData.head,o.selectEntryEntry)}[Symbol.iterator](){return this.values()}forEach(t,e){o.forEachEntry(this,this._hashData.head,t,e)}get[n.Collection.size](){return this.size}[n.Collection.has](t){return this.has(t)}[n.Collection.add](t){this.add(t)}[n.Collection.delete](t){return this.delete(t)}[n.Collection.clear](){this.clear()}}e.HashSet=a,Object.defineProperty(a,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!0,value:"HashSet"})},function(t,e,i){"use strict";i.d(e,"a",(function(){return r}));var n=i(25);const r="undefined"!=typeof __VERSION__?__VERSION__:"untranspiled source";Object(n.a)()},function(t,e){},function(t,e,i){"use strict";(function(t){var e=i(69),n=i(9),r=i(32);function s(t,{extension:e,target:i,target2:s}){const o=r.b[e];Object(n.a)(o);const{meta:a={}}=o,{suffix:l=""}=a,h=t.getExtension(e);for(const e of Object.keys(o)){const n=`${e}${l}`;let r=null;"meta"===e||"function"==typeof t[e]||(h&&"function"==typeof h[n]?r=(...t)=>h[n](...t):"function"==typeof o[e]&&(r=o[e].bind(i))),r&&(i[e]=r,s[e]=r)}}(void 0!==t?t:window).polyfillContext=function(t){t.luma=t.luma||{};const{luma:i}=t;return i.polyfilled||(Object(e.a)(t),function(t){t.luma.extensions={};const e=t.getSupportedExtensions()||[];for(const i of e)t.luma[i]=t.getExtension(i)}(t),function(t,e){for(const i of Object.getOwnPropertyNames(e))"overrides"!==i&&s(t,{extension:i,target:t.luma,target2:t})}(t,r.b),function(t,{target:e,target2:i}){Object.keys(r.a).forEach(n=>{if("function"==typeof r.a[n]){const s=t[n]?t[n].bind(t):()=>{},o=r.a[n].bind(null,t,s);e[n]=o,i[n]=o}})}(t,{target:i,target2:t}),i.polyfilled=!0),t}}).call(this,i(21))},function(t,e,i){"use strict";i.d(e,"a",(function(){return d}));var n=i(43),r=i(6),s=i(16);class o extends n.a{get ELEMENTS(){return Object(s.a)(!1),0}copy(t){return Object(s.a)(!1),this}get x(){return this[0]}set x(t){this[0]=Object(r.a)(t)}get y(){return this[1]}set y(t){this[1]=Object(r.a)(t)}len(){return Math.sqrt(this.lengthSquared())}magnitude(){return this.len()}lengthSquared(){let t=0;for(let e=0;e<this.ELEMENTS;++e)t+=this[e]*this[e];return t}magnitudeSquared(){return this.lengthSquared()}distance(t){return Math.sqrt(this.distanceSquared(t))}distanceSquared(t){let e=0;for(let i=0;i<this.ELEMENTS;++i){const n=this[i]-t[i];e+=n*n}return Object(r.a)(e)}dot(t){let e=0;for(let i=0;i<this.ELEMENTS;++i)e+=this[i]*t[i];return Object(r.a)(e)}normalize(){const t=this.magnitude();if(0!==t)for(let e=0;e<this.ELEMENTS;++e)this[e]/=t;return this.check()}multiply(...t){for(const e of t)for(let t=0;t<this.ELEMENTS;++t)this[t]*=e[t];return this.check()}divide(...t){for(const e of t)for(let t=0;t<this.ELEMENTS;++t)this[t]/=e[t];return this.check()}lengthSq(){return this.lengthSquared()}distanceTo(t){return this.distance(t)}distanceToSquared(t){return this.distanceSquared(t)}getComponent(t){return Object(s.a)(t>=0&&t<this.ELEMENTS,"index is out of range"),Object(r.a)(this[t])}setComponent(t,e){return Object(s.a)(t>=0&&t<this.ELEMENTS,"index is out of range"),this[t]=e,this.check()}addVectors(t,e){return this.copy(t).add(e)}subVectors(t,e){return this.copy(t).subtract(e)}multiplyVectors(t,e){return this.copy(t).multiply(e)}addScaledVector(t,e){return this.add(new this.constructor(t).multiplyScalar(e))}}var a=i(1),l=i(11),h=i(31);const u=[0,0,0],c={};class d extends o{static get ZERO(){return c.ZERO=c.ZERO||Object.freeze(new d(0,0,0,0))}constructor(t=0,e=0,i=0){super(-0,-0,-0),1===arguments.length&&Object(a.e)(t)?this.copy(t):(a.b.debug&&(Object(r.a)(t),Object(r.a)(e),Object(r.a)(i)),this[0]=t,this[1]=e,this[2]=i)}set(t,e,i){return this[0]=t,this[1]=e,this[2]=i,this.check()}copy(t){return this[0]=t[0],this[1]=t[1],this[2]=t[2],this.check()}fromObject(t){return a.b.debug&&(Object(r.a)(t.x),Object(r.a)(t.y),Object(r.a)(t.z)),this[0]=t.x,this[1]=t.y,this[2]=t.z,this.check()}toObject(t){return t.x=this[0],t.y=this[1],t.z=this[2],t}get ELEMENTS(){return 3}get z(){return this[2]}set z(t){this[2]=Object(r.a)(t)}angle(t){return l.b(this,t)}cross(t){return l.c(this,this,t),this.check()}rotateX({radians:t,origin:e=u}){return l.f(this,this,e,t),this.check()}rotateY({radians:t,origin:e=u}){return l.g(this,this,e,t),this.check()}rotateZ({radians:t,origin:e=u}){return l.h(this,this,e,t),this.check()}transform(t){return this.transformAsPoint(t)}transformAsPoint(t){return l.j(this,this,t),this.check()}transformAsVector(t){return Object(h.c)(this,this,t),this.check()}transformByMatrix3(t){return l.i(this,this,t),this.check()}transformByMatrix2(t){return Object(h.b)(this,this,t),this.check()}transformByQuaternion(t){return l.k(this,this,t),this.check()}}},function(t,e,i){"use strict";i.d(e,"a",(function(){return y}));var n=i(6),r=i(43),s=i(1),o=i(16);class a extends r.a{get ELEMENTS(){return Object(o.a)(!1),0}get RANK(){return Object(o.a)(!1),0}toString(){let t="[";if(s.b.printRowMajor){t+="row-major:";for(let e=0;e<this.RANK;++e)for(let i=0;i<this.RANK;++i)t+=" ".concat(this[i*this.RANK+e])}else{t+="column-major:";for(let e=0;e<this.ELEMENTS;++e)t+=" ".concat(this[e])}return t+="]",t}getElementIndex(t,e){return e*this.RANK+t}getElement(t,e){return this[e*this.RANK+t]}setElement(t,e,i){return this[e*this.RANK+t]=Object(n.a)(i),this}getColumn(t,e=new Array(this.RANK).fill(-0)){const i=t*this.RANK;for(let t=0;t<this.RANK;++t)e[t]=this[i+t];return e}setColumn(t,e){const i=t*this.RANK;for(let t=0;t<this.RANK;++t)this[i+t]=e[t];return this}}var l=i(31),h=i(4),u=i(13),c=i(11),d=i(35);const g=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),f=Object.freeze([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),p=Object.freeze({COL0ROW0:0,COL0ROW1:1,COL0ROW2:2,COL0ROW3:3,COL1ROW0:4,COL1ROW1:5,COL1ROW2:6,COL1ROW3:7,COL2ROW0:8,COL2ROW1:9,COL2ROW2:10,COL2ROW3:11,COL3ROW0:12,COL3ROW1:13,COL3ROW2:14,COL3ROW3:15}),m={};class y extends a{static get IDENTITY(){return m.IDENTITY=m.IDENTITY||Object.freeze(new y(g)),m.IDENTITY}static get ZERO(){return m.ZERO=m.ZERO||Object.freeze(new y(f)),m.ZERO}get INDICES(){return p}get ELEMENTS(){return 16}get RANK(){return 4}constructor(t){super(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),1===arguments.length&&Array.isArray(t)?this.copy(t):this.identity()}copy(t){return this[0]=t[0],this[1]=t[1],this[2]=t[2],this[3]=t[3],this[4]=t[4],this[5]=t[5],this[6]=t[6],this[7]=t[7],this[8]=t[8],this[9]=t[9],this[10]=t[10],this[11]=t[11],this[12]=t[12],this[13]=t[13],this[14]=t[14],this[15]=t[15],this.check()}set(t,e,i,n,r,s,o,a,l,h,u,c,d,g,f,p){return this[0]=t,this[1]=e,this[2]=i,this[3]=n,this[4]=r,this[5]=s,this[6]=o,this[7]=a,this[8]=l,this[9]=h,this[10]=u,this[11]=c,this[12]=d,this[13]=g,this[14]=f,this[15]=p,this.check()}setRowMajor(t,e,i,n,r,s,o,a,l,h,u,c,d,g,f,p){return this[0]=t,this[1]=r,this[2]=l,this[3]=d,this[4]=e,this[5]=s,this[6]=h,this[7]=g,this[8]=i,this[9]=o,this[10]=u,this[11]=f,this[12]=n,this[13]=a,this[14]=c,this[15]=p,this.check()}toRowMajor(t){return t[0]=this[0],t[1]=this[4],t[2]=this[8],t[3]=this[12],t[4]=this[1],t[5]=this[5],t[6]=this[9],t[7]=this[13],t[8]=this[2],t[9]=this[6],t[10]=this[10],t[11]=this[14],t[12]=this[3],t[13]=this[7],t[14]=this[11],t[15]=this[15],t}identity(){return this.copy(g)}fromQuaternion(t){return h.c(this,t),this.check()}frustum({left:t,right:e,bottom:i,top:n,near:r,far:s}){return s===1/0?y._computeInfinitePerspectiveOffCenter(this,t,e,i,n,r):h.d(this,t,e,i,n,r,s),this.check()}static _computeInfinitePerspectiveOffCenter(t,e,i,n,r,s){const o=2*s/(i-e),a=2*s/(r-n),l=(i+e)/(i-e),h=(r+n)/(r-n),u=-2*s;return t[0]=o,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=a,t[6]=0,t[7]=0,t[8]=l,t[9]=h,t[10]=-1,t[11]=-1,t[12]=0,t[13]=0,t[14]=u,t[15]=0,t}lookAt(t,e,i){return 1===arguments.length&&({eye:t,center:e,up:i}=t),e=e||[0,0,0],i=i||[0,1,0],h.f(this,t,e,i),this.check()}ortho({left:t,right:e,bottom:i,top:n,near:r=.1,far:s=500}){return h.h(this,t,e,i,n,r,s),this.check()}orthographic({fovy:t=45*Math.PI/180,aspect:e=1,focalDistance:i=1,near:n=.1,far:r=500}){if(t>2*Math.PI)throw Error("radians");const s=t/2,o=i*Math.tan(s),a=o*e;return(new y).ortho({left:-a,right:a,bottom:-o,top:o,near:n,far:r})}perspective({fovy:t,fov:e=45*Math.PI/180,aspect:i=1,near:n=.1,far:r=500}={}){if((t=t||e)>2*Math.PI)throw Error("radians");return h.i(this,t,i,n,r),this.check()}determinant(){return h.a(this)}getScale(t=[-0,-0,-0]){return t[0]=Math.sqrt(this[0]*this[0]+this[1]*this[1]+this[2]*this[2]),t[1]=Math.sqrt(this[4]*this[4]+this[5]*this[5]+this[6]*this[6]),t[2]=Math.sqrt(this[8]*this[8]+this[9]*this[9]+this[10]*this[10]),t}getTranslation(t=[-0,-0,-0]){return t[0]=this[12],t[1]=this[13],t[2]=this[14],t}getRotation(t=[-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],e=null){const i=this.getScale(e||[-0,-0,-0]),n=1/i[0],r=1/i[1],s=1/i[2];return t[0]=this[0]*n,t[1]=this[1]*r,t[2]=this[2]*s,t[3]=0,t[4]=this[4]*n,t[5]=this[5]*r,t[6]=this[6]*s,t[7]=0,t[8]=this[8]*n,t[9]=this[9]*r,t[10]=this[10]*s,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}getRotationMatrix3(t=[-0,-0,-0,-0,-0,-0,-0,-0,-0],e=null){const i=this.getScale(e||[-0,-0,-0]),n=1/i[0],r=1/i[1],s=1/i[2];return t[0]=this[0]*n,t[1]=this[1]*r,t[2]=this[2]*s,t[3]=this[4]*n,t[4]=this[5]*r,t[5]=this[6]*s,t[6]=this[8]*n,t[7]=this[9]*r,t[8]=this[10]*s,t}transpose(){return h.p(this,this),this.check()}invert(){return h.e(this,this),this.check()}multiplyLeft(t){return h.g(this,t,this),this.check()}multiplyRight(t){return h.g(this,this,t),this.check()}rotateX(t){return h.k(this,this,t),this.check()}rotateY(t){return h.l(this,this,t),this.check()}rotateZ(t){return h.m(this,this,t),this.check()}rotateXYZ([t,e,i]){return this.rotateX(t).rotateY(e).rotateZ(i)}rotateAxis(t,e){return h.j(this,this,t,e),this.check()}scale(t){return Array.isArray(t)?h.n(this,this,t):h.n(this,this,[t,t,t]),this.check()}translate(t){return h.o(this,this,t),this.check()}transform(t,e){return 4===t.length?(e=d.b(e||[-0,-0,-0,-0],t,this),Object(n.b)(e,4),e):this.transformAsPoint(t,e)}transformAsPoint(t,e){const{length:i}=t;switch(i){case 2:e=u.g(e||[-0,-0],t,this);break;case 3:e=c.j(e||[-0,-0,-0],t,this);break;default:throw new Error("Illegal vector")}return Object(n.b)(e,t.length),e}transformAsVector(t,e){switch(t.length){case 2:e=Object(l.a)(e||[-0,-0],t,this);break;case 3:e=Object(l.c)(e||[-0,-0,-0],t,this);break;default:throw new Error("Illegal vector")}return Object(n.b)(e,t.length),e}makeRotationX(t){return this.identity().rotateX(t)}makeTranslation(t,e,i){return this.identity().translate([t,e,i])}transformPoint(t,e){return Object(n.c)("Matrix4.transformPoint","3.0"),this.transformAsPoint(t,e)}transformVector(t,e){return Object(n.c)("Matrix4.transformVector","3.0"),this.transformAsPoint(t,e)}transformDirection(t,e){return Object(n.c)("Matrix4.transformDirection","3.0"),this.transformAsVector(t,e)}}},function(t,e,i){var n=i(101);t.exports=n.parse},function(t,e,i){var n=i(102);t.exports=function(t){var e,i,r,s;if(e=/^((?:rgb|hs[lv]|cmyk|xyz|lab)a?)\s*\(([^\)]*)\)/.exec(t)){var o=e[1],a="cmyk"===(l=o.replace(/a$/,""))?4:3;i=n[l],r=e[2].replace(/^\s+|\s+$/g,"").split(/\s*,\s*/).map((function(t,e){return/%$/.test(t)&&e===a?parseFloat(t)/100:(/%$/.test(t),parseFloat(t))})),o===l&&r.push(1),s=void 0===r[a]?1:r[a],r=r.slice(0,a),i[l]=function(){return r}}else if(/^#[A-Fa-f0-9]+$/.test(t)){var l;a=(l=t.replace(/^#/,"")).length;i=n.rgb,r=(r=l.split(3===a?/(.)/:/(..)/)).filter(Boolean).map((function(t){return 3===a?parseInt(t+t,16):parseInt(t,16)})),s=1,i.rgb=function(){return r},r[0]||(r[0]=0),r[1]||(r[1]=0),r[2]||(r[2]=0)}else(i=n.keyword).keyword=function(){return t},r=t,s=1;var h={rgb:void 0,hsl:void 0,hsv:void 0,cmyk:void 0,keyword:void 0,hex:void 0};try{h.rgb=i.rgb(r)}catch(t){}try{h.hsl=i.hsl(r)}catch(t){}try{h.hsv=i.hsv(r)}catch(t){}try{h.cmyk=i.cmyk(r)}catch(t){}try{h.keyword=i.keyword(r)}catch(t){}return h.rgb&&(h.hex="#"+h.rgb.map((function(t){var e=t.toString(16);return 1===e.length?"0"+e:e})).join("")),h.rgb&&(h.rgba=h.rgb.concat(s)),h.hsl&&(h.hsla=h.hsl.concat(s)),h.hsv&&(h.hsva=h.hsv.concat(s)),h.cmyk&&(h.cmyka=h.cmyk.concat(s)),h}},function(t,e,i){"use strict";(function(t,n){i.d(e,"a",(function(){return r}));"undefined"!=typeof self&&self,"undefined"!=typeof window&&window,"undefined"!=typeof document&&document,"object"!=typeof n||"[object process]"!==String(n)||n.browser;const r="undefined"!=typeof window&&void 0!==window.orientation,s=void 0!==n&&n.version&&/v([0-9]*)/.exec(n.version);s&&parseFloat(s[1])}).call(this,i(21),i(20))},function(t,e,i){"use strict";i.d(e,"a",(function(){return l}));var n=i(8);const r={};function s(t,e){var i;r[t]=!0,void 0!==e&&(i=e,n.global.console&&n.global.console.error&&n.global.console.error(i))}const o=function t(e){const i=e.gl;this.ext=e,this.isAlive=!0,this.hasBeenBound=!1,this.elementArrayBuffer=null,this.attribs=new Array(e.maxVertexAttribs);for(let e=0;e<this.attribs.length;e++){const n=new t.VertexAttrib(i);this.attribs[e]=n}this.maxAttrib=0};(o.VertexAttrib=function(t){this.enabled=!1,this.buffer=null,this.size=4,this.type=5126,this.normalized=!1,this.stride=16,this.offset=0,this.cached="",this.recache()}).prototype.recache=function(){this.cached=[this.size,this.type,this.normalized,this.stride,this.offset].join(":")};const a=function(t){const e=this;this.gl=t,function(t){const e=t.getError;t.getError=function(){let i;do{i=e.apply(t),0!==i&&(r[i]=!0)}while(0!==i);for(i in r)if(r[i])return delete r[i],parseInt(i,10);return 0}}(t);const i=this.original={getParameter:t.getParameter,enableVertexAttribArray:t.enableVertexAttribArray,disableVertexAttribArray:t.disableVertexAttribArray,bindBuffer:t.bindBuffer,getVertexAttrib:t.getVertexAttrib,vertexAttribPointer:t.vertexAttribPointer};t.getParameter=function(t){return t===e.VERTEX_ARRAY_BINDING_OES?e.currentVertexArrayObject===e.defaultVertexArrayObject?null:e.currentVertexArrayObject:i.getParameter.apply(this,arguments)},t.enableVertexAttribArray=function(t){const n=e.currentVertexArrayObject;n.maxAttrib=Math.max(n.maxAttrib,t);const r=n.attribs[t];return r.enabled=!0,i.enableVertexAttribArray.apply(this,arguments)},t.disableVertexAttribArray=function(t){const n=e.currentVertexArrayObject;n.maxAttrib=Math.max(n.maxAttrib,t);const r=n.attribs[t];return r.enabled=!1,i.disableVertexAttribArray.apply(this,arguments)},t.bindBuffer=function(t,n){switch(t){case 34962:e.currentArrayBuffer=n;break;case 34963:e.currentVertexArrayObject.elementArrayBuffer=n}return i.bindBuffer.apply(this,arguments)},t.getVertexAttrib=function(t,n){const r=e.currentVertexArrayObject,s=r.attribs[t];switch(n){case 34975:return s.buffer;case 34338:return s.enabled;case 34339:return s.size;case 34340:return s.stride;case 34341:return s.type;case 34922:return s.normalized;default:return i.getVertexAttrib.apply(this,arguments)}},t.vertexAttribPointer=function(t,n,r,s,o,a){const l=e.currentVertexArrayObject;l.maxAttrib=Math.max(l.maxAttrib,t);const h=l.attribs[t];return h.buffer=e.currentArrayBuffer,h.size=n,h.type=r,h.normalized=s,h.stride=o,h.offset=a,h.recache(),i.vertexAttribPointer.apply(this,arguments)},t.instrumentExtension&&t.instrumentExtension(this,"OES_vertex_array_object"),t.canvas&&t.canvas.addEventListener("webglcontextrestored",()=>{var t;t="OESVertexArrayObject emulation library context restored",n.global.console&&n.global.console.log&&n.global.console.log(t),e.reset_()},!0),this.reset_()};function l(t){if("function"==typeof t.createVertexArray)return;const e=t.getSupportedExtensions;t.getSupportedExtensions=function(){const t=e.call(this)||[];return t.indexOf("OES_vertex_array_object")<0&&t.push("OES_vertex_array_object"),t};const i=t.getExtension;t.getExtension=function(e){const n=i.call(this,e);return n||("OES_vertex_array_object"!==e?null:(t.__OESVertexArrayObject||(this.__OESVertexArrayObject=new a(this)),this.__OESVertexArrayObject))}}a.prototype.VERTEX_ARRAY_BINDING_OES=34229,a.prototype.reset_=function(){if(void 0!==this.vertexArrayObjects)for(let t=0;t<this.vertexArrayObjects.length;++t)this.vertexArrayObjects.isAlive=!1;const t=this.gl;this.maxVertexAttribs=t.getParameter(34921),this.defaultVertexArrayObject=new o(this),this.currentVertexArrayObject=null,this.currentArrayBuffer=null,this.vertexArrayObjects=[this.defaultVertexArrayObject],this.bindVertexArrayOES(null)},a.prototype.createVertexArrayOES=function(){const t=new o(this);return this.vertexArrayObjects.push(t),t},a.prototype.deleteVertexArrayOES=function(t){t.isAlive=!1,this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(t),1),this.currentVertexArrayObject===t&&this.bindVertexArrayOES(null)},a.prototype.isVertexArrayOES=function(t){return!!(t&&t instanceof o&&t.hasBeenBound&&t.ext===this)},a.prototype.bindVertexArrayOES=function(t){const e=this.gl;if(t&&!t.isAlive)return void s(1282,"bindVertexArrayOES: attempt to bind deleted arrayObject");const i=this.original,n=this.currentVertexArrayObject;this.currentVertexArrayObject=t||this.defaultVertexArrayObject,this.currentVertexArrayObject.hasBeenBound=!0;const r=this.currentVertexArrayObject;if(n===r)return;n&&r.elementArrayBuffer===n.elementArrayBuffer||i.bindBuffer.call(e,34963,r.elementArrayBuffer);let o=this.currentArrayBuffer;const a=Math.max(n?n.maxAttrib:0,r.maxAttrib);for(let t=0;t<=a;t++){const s=r.attribs[t],a=n?n.attribs[t]:null;if(n&&s.enabled===a.enabled||(s.enabled?i.enableVertexAttribArray.call(e,t):i.disableVertexAttribArray.call(e,t)),s.enabled){let r=!1;n&&s.buffer===a.buffer||(o!==s.buffer&&(i.bindBuffer.call(e,34962,s.buffer),o=s.buffer),r=!0),(r||s.cached!==a.cached)&&i.vertexAttribPointer.call(e,t,s.size,s.type,s.normalized,s.stride,s.offset)}}this.currentArrayBuffer!==o&&i.bindBuffer.call(e,34962,this.currentArrayBuffer)}},function(t,e,i){"use strict";function n(t,e,i){i=i||2;var n,a,l,h,u,g,f,m=e&&e.length,y=m?e[0]*i:t.length,b=r(t,0,y,i,!0),P=[];if(!b||b.next===b.prev)return P;if(m&&(b=function(t,e,i,n){var o,a,l,h,u,g=[];for(o=0,a=e.length;o<a;o++)l=e[o]*n,h=o<a-1?e[o+1]*n:t.length,(u=r(t,l,h,n,!1))===u.next&&(u.steiner=!0),g.push(p(u));for(g.sort(c),o=0;o<g.length;o++)i=s(i=d(g[o],i),i.next);return i}(t,e,b,i)),t.length>80*i){n=l=t[0],a=h=t[1];for(var v=i;v<y;v+=i)(u=t[v])<n&&(n=u),(g=t[v+1])<a&&(a=g),u>l&&(l=u),g>h&&(h=g);f=0!==(f=Math.max(l-n,h-a))?1/f:0}return o(b,P,i,n,a,f),P}function r(t,e,i,n,r){var s,o;if(r===I(t,e,i,n)>0)for(s=e;s<i;s+=n)o=x(s,t[s],t[s+1],o);else for(s=i-n;s>=e;s-=n)o=x(s,t[s],t[s+1],o);return o&&P(o,o.next)&&(A(o),o=o.next),o}function s(t,e){if(!t)return t;e||(e=t);var i,n=t;do{if(i=!1,n.steiner||!P(n,n.next)&&0!==b(n.prev,n,n.next))n=n.next;else{if(A(n),(n=e=n.prev)===n.next)break;i=!0}}while(i||n!==e);return e}function o(t,e,i,n,r,c,d){if(t){!d&&c&&function(t,e,i,n){var r=t;do{null===r.z&&(r.z=f(r.x,r.y,e,i,n)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==t);r.prevZ.nextZ=null,r.prevZ=null,function(t){var e,i,n,r,s,o,a,l,h=1;do{for(i=t,t=null,s=null,o=0;i;){for(o++,n=i,a=0,e=0;e<h&&(a++,n=n.nextZ);e++);for(l=h;a>0||l>0&&n;)0!==a&&(0===l||!n||i.z<=n.z)?(r=i,i=i.nextZ,a--):(r=n,n=n.nextZ,l--),s?s.nextZ=r:t=r,r.prevZ=s,s=r;i=n}s.nextZ=null,h*=2}while(o>1)}(r)}(t,n,r,c);for(var g,p,m=t;t.prev!==t.next;)if(g=t.prev,p=t.next,c?l(t,n,r,c):a(t))e.push(g.i/i),e.push(t.i/i),e.push(p.i/i),A(t),t=p.next,m=p.next;else if((t=p)===m){d?1===d?o(t=h(s(t),e,i),e,i,n,r,c,2):2===d&&u(t,e,i,n,r,c):o(s(t),e,i,n,r,c,1);break}}}function a(t){var e=t.prev,i=t,n=t.next;if(b(e,i,n)>=0)return!1;for(var r=t.next.next;r!==t.prev;){if(m(e.x,e.y,i.x,i.y,n.x,n.y,r.x,r.y)&&b(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function l(t,e,i,n){var r=t.prev,s=t,o=t.next;if(b(r,s,o)>=0)return!1;for(var a=r.x<s.x?r.x<o.x?r.x:o.x:s.x<o.x?s.x:o.x,l=r.y<s.y?r.y<o.y?r.y:o.y:s.y<o.y?s.y:o.y,h=r.x>s.x?r.x>o.x?r.x:o.x:s.x>o.x?s.x:o.x,u=r.y>s.y?r.y>o.y?r.y:o.y:s.y>o.y?s.y:o.y,c=f(a,l,e,i,n),d=f(h,u,e,i,n),g=t.prevZ,p=t.nextZ;g&&g.z>=c&&p&&p.z<=d;){if(g!==t.prev&&g!==t.next&&m(r.x,r.y,s.x,s.y,o.x,o.y,g.x,g.y)&&b(g.prev,g,g.next)>=0)return!1;if(g=g.prevZ,p!==t.prev&&p!==t.next&&m(r.x,r.y,s.x,s.y,o.x,o.y,p.x,p.y)&&b(p.prev,p,p.next)>=0)return!1;p=p.nextZ}for(;g&&g.z>=c;){if(g!==t.prev&&g!==t.next&&m(r.x,r.y,s.x,s.y,o.x,o.y,g.x,g.y)&&b(g.prev,g,g.next)>=0)return!1;g=g.prevZ}for(;p&&p.z<=d;){if(p!==t.prev&&p!==t.next&&m(r.x,r.y,s.x,s.y,o.x,o.y,p.x,p.y)&&b(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function h(t,e,i){var n=t;do{var r=n.prev,o=n.next.next;!P(r,o)&&v(r,n,n.next,o)&&w(r,o)&&w(o,r)&&(e.push(r.i/i),e.push(n.i/i),e.push(o.i/i),A(n),A(n.next),n=t=o),n=n.next}while(n!==t);return s(n)}function u(t,e,i,n,r,a){var l=t;do{for(var h=l.next.next;h!==l.prev;){if(l.i!==h.i&&y(l,h)){var u=E(l,h);return l=s(l,l.next),u=s(u,u.next),o(l,e,i,n,r,a),void o(u,e,i,n,r,a)}h=h.next}l=l.next}while(l!==t)}function c(t,e){return t.x-e.x}function d(t,e){var i=function(t,e){var i,n=e,r=t.x,s=t.y,o=-1/0;do{if(s<=n.y&&s>=n.next.y&&n.next.y!==n.y){var a=n.x+(s-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(a<=r&&a>o){if(o=a,a===r){if(s===n.y)return n;if(s===n.next.y)return n.next}i=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!i)return null;if(r===o)return i;var l,h=i,u=i.x,c=i.y,d=1/0;n=i;do{r>=n.x&&n.x>=u&&r!==n.x&&m(s<c?r:o,s,u,c,s<c?o:r,s,n.x,n.y)&&(l=Math.abs(s-n.y)/(r-n.x),w(n,t)&&(l<d||l===d&&(n.x>i.x||n.x===i.x&&g(i,n)))&&(i=n,d=l)),n=n.next}while(n!==h);return i}(t,e);if(!i)return e;var n=E(i,t),r=s(i,i.next);return s(n,n.next),e===i?r:e}function g(t,e){return b(t.prev,t,e.prev)<0&&b(e.next,t,t.next)<0}function f(t,e,i,n,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*r)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*r)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function p(t){var e=t,i=t;do{(e.x<i.x||e.x===i.x&&e.y<i.y)&&(i=e),e=e.next}while(e!==t);return i}function m(t,e,i,n,r,s,o,a){return(r-o)*(e-a)-(t-o)*(s-a)>=0&&(t-o)*(n-a)-(i-o)*(e-a)>=0&&(i-o)*(s-a)-(r-o)*(n-a)>=0}function y(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==e.i&&i.next.i!==e.i&&v(i,i.next,t,e))return!0;i=i.next}while(i!==t);return!1}(t,e)&&(w(t,e)&&w(e,t)&&function(t,e){var i=t,n=!1,r=(t.x+e.x)/2,s=(t.y+e.y)/2;do{i.y>s!=i.next.y>s&&i.next.y!==i.y&&r<(i.next.x-i.x)*(s-i.y)/(i.next.y-i.y)+i.x&&(n=!n),i=i.next}while(i!==t);return n}(t,e)&&(b(t.prev,t,e.prev)||b(t,e.prev,e))||P(t,e)&&b(t.prev,t,t.next)>0&&b(e.prev,e,e.next)>0)}function b(t,e,i){return(e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y)}function P(t,e){return t.x===e.x&&t.y===e.y}function v(t,e,i,n){var r=C(b(t,e,i)),s=C(b(t,e,n)),o=C(b(i,n,t)),a=C(b(i,n,e));return r!==s&&o!==a||(!(0!==r||!S(t,i,e))||(!(0!==s||!S(t,n,e))||(!(0!==o||!S(i,t,n))||!(0!==a||!S(i,e,n)))))}function S(t,e,i){return e.x<=Math.max(t.x,i.x)&&e.x>=Math.min(t.x,i.x)&&e.y<=Math.max(t.y,i.y)&&e.y>=Math.min(t.y,i.y)}function C(t){return t>0?1:t<0?-1:0}function w(t,e){return b(t.prev,t,t.next)<0?b(t,e,t.next)>=0&&b(t,t.prev,e)>=0:b(t,e,t.prev)<0||b(t,t.next,e)<0}function E(t,e){var i=new T(t.i,t.x,t.y),n=new T(e.i,e.x,e.y),r=t.next,s=e.prev;return t.next=e,e.prev=t,i.next=r,r.prev=i,n.next=i,i.prev=n,s.next=n,n.prev=s,n}function x(t,e,i,n){var r=new T(t,e,i);return n?(r.next=n.next,r.prev=n,n.next.prev=r,n.next=r):(r.prev=r,r.next=r),r}function A(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function T(t,e,i){this.i=t,this.x=e,this.y=i,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function I(t,e,i,n){for(var r=0,s=e,o=i-n;s<i;s+=n)r+=(t[o]-t[s])*(t[s+1]+t[o+1]),o=s;return r}t.exports=n,t.exports.default=n,n.deviation=function(t,e,i,n){var r=e&&e.length,s=r?e[0]*i:t.length,o=Math.abs(I(t,0,s,i));if(r)for(var a=0,l=e.length;a<l;a++){var h=e[a]*i,u=a<l-1?e[a+1]*i:t.length;o-=Math.abs(I(t,h,u,i))}var c=0;for(a=0;a<n.length;a+=3){var d=n[a]*i,g=n[a+1]*i,f=n[a+2]*i;c+=Math.abs((t[d]-t[f])*(t[g+1]-t[d+1])-(t[d]-t[g])*(t[f+1]-t[d+1]))}return 0===o&&0===c?0:Math.abs((c-o)/o)},n.flatten=function(t){for(var e=t[0][0].length,i={vertices:[],holes:[],dimensions:e},n=0,r=0;r<t.length;r++){for(var s=0;s<t[r].length;s++)for(var o=0;o<e;o++)i.vertices.push(t[r][s][o]);r>0&&(n+=t[r-1].length,i.holes.push(n))}return i}},function(t,e,i){"use strict";t.exports=r,t.exports.default=r;var n=1e20;function r(t,e,i,n,r,s){this.fontSize=t||24,this.buffer=void 0===e?3:e,this.cutoff=n||.25,this.fontFamily=r||"sans-serif",this.fontWeight=s||"normal",this.radius=i||8;var o=this.size=this.fontSize+2*this.buffer,a=o+2*this.buffer;this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=o,this.ctx=this.canvas.getContext("2d"),this.ctx.font=this.fontWeight+" "+this.fontSize+"px "+this.fontFamily,this.ctx.textAlign="left",this.ctx.fillStyle="black",this.gridOuter=new Float64Array(a*a),this.gridInner=new Float64Array(a*a),this.f=new Float64Array(a),this.z=new Float64Array(a+1),this.v=new Uint16Array(a),this.useMetrics=void 0!==this.ctx.measureText("A").actualBoundingBoxLeft,this.middle=Math.round(o/2*(navigator.userAgent.indexOf("Gecko/")>=0?1.2:1))}function s(t,e,i,n,r,s){for(var a=0;a<e;a++)o(t,a,e,i,n,r,s);for(var l=0;l<i;l++)o(t,l*e,1,e,n,r,s)}function o(t,e,i,r,s,o,a){var l,h,u,c;for(o[0]=0,a[0]=-n,a[1]=n,l=0;l<r;l++)s[l]=t[e+l*i];for(l=1,h=0,u=0;l<r;l++){do{c=o[h],u=(s[l]-s[c]+l*l-c*c)/(l-c)/2}while(u<=a[h]&&--h>-1);o[++h]=l,a[h]=u,a[h+1]=n}for(l=0,h=0;l<r;l++){for(;a[h+1]<l;)h++;c=o[h],t[e+l*i]=s[c]+(l-c)*(l-c)}}r.prototype._draw=function(t,e){var i,r,o,a,l,h,u,c,d,g=this.ctx.measureText(t),f=g.width,p=2*this.buffer;e&&this.useMetrics?(l=Math.floor(g.actualBoundingBoxAscent),c=this.buffer+Math.ceil(g.actualBoundingBoxAscent),h=this.buffer,u=this.buffer,i=(r=Math.min(this.size,Math.ceil(g.actualBoundingBoxRight-g.actualBoundingBoxLeft)))+p,o=(a=Math.min(this.size-h,Math.ceil(g.actualBoundingBoxAscent+g.actualBoundingBoxDescent)))+p,this.ctx.textBaseline="alphabetic"):(i=r=this.size,o=a=this.size,l=19*this.fontSize/24,h=u=0,c=this.middle,this.ctx.textBaseline="middle"),r&&a&&(this.ctx.clearRect(u,h,r,a),this.ctx.fillText(t,this.buffer,c),d=this.ctx.getImageData(u,h,r,a));var m=new Uint8ClampedArray(i*o);return function(t,e,i,r,s,o,a){o.fill(n,0,e*i),a.fill(0,0,e*i);for(var l=(e-r)/2,h=0;h<s;h++)for(var u=0;u<r;u++){var c=(h+l)*e+u+l,d=t.data[4*(h*r+u)+3]/255;if(1===d)o[c]=0,a[c]=n;else if(0===d)o[c]=n,a[c]=0;else{var g=Math.max(0,.5-d),f=Math.max(0,d-.5);o[c]=g*g,a[c]=f*f}}}(d,i,o,r,a,this.gridOuter,this.gridInner),s(this.gridOuter,i,o,this.f,this.v,this.z),s(this.gridInner,i,o,this.f,this.v,this.z),function(t,e,i,n,r,s,o){for(var a=0;a<e*i;a++){var l=Math.sqrt(n[a])-Math.sqrt(r[a]);t[a]=Math.round(255-255*(l/s+o))}}(m,i,o,this.gridOuter,this.gridInner,this.radius,this.cutoff),{data:m,metrics:{width:r,height:a,sdfWidth:i,sdfHeight:o,top:l,left:0,advance:f}}},r.prototype.draw=function(t){return this._draw(t,!1).data},r.prototype.drawWithMetrics=function(t){return this._draw(t,!0)}},,,,,,,,,,,,,,,function(t,e,i){"use strict";(function(t){
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
Object.defineProperty(e,"__esModule",{value:!0}),e.deprecateProperty=e.deprecate=void 0;const n=function(){try{return i(87).deprecate}catch(t){}}()||function(){const e="object"==typeof t&&"function"==typeof t.emitWarning?function e(i,n="Warning",r=e){t.emitWarning(i,n,r)}:"function"==typeof Error.captureStackTrace?function t(e,i="Warning",n=t){"string"==typeof e&&((e=new Error(e)).name=i),Error.captureStackTrace(e,n),console.warn(e)}:function(t,e="Warning"){"string"==typeof t?console.warn(e+":",t):console.warn(t)};return(t,i)=>{let n=!1;function r(...r){return n||(n=!0,e(i,"DeprecationWarning",t)),new.target?Reflect.construct(t,r,new.target):t.apply(this,r)}return Object.setPrototypeOf(r,t),t.prototype&&(r.prototype=t.prototype),r}}();function r(t,e){return n(t,e)}e.deprecate=r,e.deprecateProperty=function(t,e,i){let n=Object.getOwnPropertyDescriptor(t,e);if(n&&n.configurable){let s=!1;n.get&&(n.get=r(n.get,i),s=!0),n.set&&(n.set=r(n.set,i),s=!0),"function"==typeof n.value&&(n.value=r(n.value,i),s=!0),s&&Object.defineProperty(t,e,n)}return t}}).call(this,i(20))},function(t,e,i){(function(t){var n=Object.getOwnPropertyDescriptors||function(t){for(var e=Object.keys(t),i={},n=0;n<e.length;n++)i[e[n]]=Object.getOwnPropertyDescriptor(t,e[n]);return i},r=/%[sdj%]/g;e.format=function(t){if(!y(t)){for(var e=[],i=0;i<arguments.length;i++)e.push(a(arguments[i]));return e.join(" ")}i=1;for(var n=arguments,s=n.length,o=String(t).replace(r,(function(t){if("%%"===t)return"%";if(i>=s)return t;switch(t){case"%s":return String(n[i++]);case"%d":return Number(n[i++]);case"%j":try{return JSON.stringify(n[i++])}catch(t){return"[Circular]"}default:return t}})),l=n[i];i<s;l=n[++i])p(l)||!v(l)?o+=" "+l:o+=" "+a(l);return o},e.deprecate=function(i,n){if(void 0!==t&&!0===t.noDeprecation)return i;if(void 0===t)return function(){return e.deprecate(i,n).apply(this,arguments)};var r=!1;return function(){if(!r){if(t.throwDeprecation)throw new Error(n);t.traceDeprecation?console.trace(n):console.error(n),r=!0}return i.apply(this,arguments)}};var s,o={};function a(t,i){var n={seen:[],stylize:h};return arguments.length>=3&&(n.depth=arguments[2]),arguments.length>=4&&(n.colors=arguments[3]),f(i)?n.showHidden=i:i&&e._extend(n,i),b(n.showHidden)&&(n.showHidden=!1),b(n.depth)&&(n.depth=2),b(n.colors)&&(n.colors=!1),b(n.customInspect)&&(n.customInspect=!0),n.colors&&(n.stylize=l),u(n,t,n.depth)}function l(t,e){var i=a.styles[e];return i?"["+a.colors[i][0]+"m"+t+"["+a.colors[i][1]+"m":t}function h(t,e){return t}function u(t,i,n){if(t.customInspect&&i&&w(i.inspect)&&i.inspect!==e.inspect&&(!i.constructor||i.constructor.prototype!==i)){var r=i.inspect(n,t);return y(r)||(r=u(t,r,n)),r}var s=function(t,e){if(b(e))return t.stylize("undefined","undefined");if(y(e)){var i="'"+JSON.stringify(e).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return t.stylize(i,"string")}if(m(e))return t.stylize(""+e,"number");if(f(e))return t.stylize(""+e,"boolean");if(p(e))return t.stylize("null","null")}(t,i);if(s)return s;var o=Object.keys(i),a=function(t){var e={};return t.forEach((function(t,i){e[t]=!0})),e}(o);if(t.showHidden&&(o=Object.getOwnPropertyNames(i)),C(i)&&(o.indexOf("message")>=0||o.indexOf("description")>=0))return c(i);if(0===o.length){if(w(i)){var l=i.name?": "+i.name:"";return t.stylize("[Function"+l+"]","special")}if(P(i))return t.stylize(RegExp.prototype.toString.call(i),"regexp");if(S(i))return t.stylize(Date.prototype.toString.call(i),"date");if(C(i))return c(i)}var h,v="",E=!1,x=["{","}"];(g(i)&&(E=!0,x=["[","]"]),w(i))&&(v=" [Function"+(i.name?": "+i.name:"")+"]");return P(i)&&(v=" "+RegExp.prototype.toString.call(i)),S(i)&&(v=" "+Date.prototype.toUTCString.call(i)),C(i)&&(v=" "+c(i)),0!==o.length||E&&0!=i.length?n<0?P(i)?t.stylize(RegExp.prototype.toString.call(i),"regexp"):t.stylize("[Object]","special"):(t.seen.push(i),h=E?function(t,e,i,n,r){for(var s=[],o=0,a=e.length;o<a;++o)I(e,String(o))?s.push(d(t,e,i,n,String(o),!0)):s.push("");return r.forEach((function(r){r.match(/^\d+$/)||s.push(d(t,e,i,n,r,!0))})),s}(t,i,n,a,o):o.map((function(e){return d(t,i,n,a,e,E)})),t.seen.pop(),function(t,e,i){if(t.reduce((function(t,e){return e.indexOf("\n")>=0&&0,t+e.replace(/\u001b\[\d\d?m/g,"").length+1}),0)>60)return i[0]+(""===e?"":e+"\n ")+" "+t.join(",\n  ")+" "+i[1];return i[0]+e+" "+t.join(", ")+" "+i[1]}(h,v,x)):x[0]+v+x[1]}function c(t){return"["+Error.prototype.toString.call(t)+"]"}function d(t,e,i,n,r,s){var o,a,l;if((l=Object.getOwnPropertyDescriptor(e,r)||{value:e[r]}).get?a=l.set?t.stylize("[Getter/Setter]","special"):t.stylize("[Getter]","special"):l.set&&(a=t.stylize("[Setter]","special")),I(n,r)||(o="["+r+"]"),a||(t.seen.indexOf(l.value)<0?(a=p(i)?u(t,l.value,null):u(t,l.value,i-1)).indexOf("\n")>-1&&(a=s?a.split("\n").map((function(t){return"  "+t})).join("\n").substr(2):"\n"+a.split("\n").map((function(t){return"   "+t})).join("\n")):a=t.stylize("[Circular]","special")),b(o)){if(s&&r.match(/^\d+$/))return a;(o=JSON.stringify(""+r)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(o=o.substr(1,o.length-2),o=t.stylize(o,"name")):(o=o.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),o=t.stylize(o,"string"))}return o+": "+a}function g(t){return Array.isArray(t)}function f(t){return"boolean"==typeof t}function p(t){return null===t}function m(t){return"number"==typeof t}function y(t){return"string"==typeof t}function b(t){return void 0===t}function P(t){return v(t)&&"[object RegExp]"===E(t)}function v(t){return"object"==typeof t&&null!==t}function S(t){return v(t)&&"[object Date]"===E(t)}function C(t){return v(t)&&("[object Error]"===E(t)||t instanceof Error)}function w(t){return"function"==typeof t}function E(t){return Object.prototype.toString.call(t)}function x(t){return t<10?"0"+t.toString(10):t.toString(10)}e.debuglog=function(i){if(b(s)&&(s=t.env.NODE_DEBUG||""),i=i.toUpperCase(),!o[i])if(new RegExp("\\b"+i+"\\b","i").test(s)){var n=t.pid;o[i]=function(){var t=e.format.apply(e,arguments);console.error("%s %d: %s",i,n,t)}}else o[i]=function(){};return o[i]},e.inspect=a,a.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},a.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},e.isArray=g,e.isBoolean=f,e.isNull=p,e.isNullOrUndefined=function(t){return null==t},e.isNumber=m,e.isString=y,e.isSymbol=function(t){return"symbol"==typeof t},e.isUndefined=b,e.isRegExp=P,e.isObject=v,e.isDate=S,e.isError=C,e.isFunction=w,e.isPrimitive=function(t){return null===t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||"symbol"==typeof t||void 0===t},e.isBuffer=i(88);var A=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function T(){var t=new Date,e=[x(t.getHours()),x(t.getMinutes()),x(t.getSeconds())].join(":");return[t.getDate(),A[t.getMonth()],e].join(" ")}function I(t,e){return Object.prototype.hasOwnProperty.call(t,e)}e.log=function(){console.log("%s - %s",T(),e.format.apply(e,arguments))},e.inherits=i(89),e._extend=function(t,e){if(!e||!v(e))return t;for(var i=Object.keys(e),n=i.length;n--;)t[i[n]]=e[i[n]];return t};var O="undefined"!=typeof Symbol?Symbol("util.promisify.custom"):void 0;function _(t,e){if(!t){var i=new Error("Promise was rejected with a falsy value");i.reason=t,t=i}return e(t)}e.promisify=function(t){if("function"!=typeof t)throw new TypeError('The "original" argument must be of type Function');if(O&&t[O]){var e;if("function"!=typeof(e=t[O]))throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(e,O,{value:e,enumerable:!1,writable:!1,configurable:!0}),e}function e(){for(var e,i,n=new Promise((function(t,n){e=t,i=n})),r=[],s=0;s<arguments.length;s++)r.push(arguments[s]);r.push((function(t,n){t?i(t):e(n)}));try{t.apply(this,r)}catch(t){i(t)}return n}return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),O&&Object.defineProperty(e,O,{value:e,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(e,n(t))},e.promisify.custom=O,e.callbackify=function(e){if("function"!=typeof e)throw new TypeError('The "original" argument must be of type Function');function i(){for(var i=[],n=0;n<arguments.length;n++)i.push(arguments[n]);var r=i.pop();if("function"!=typeof r)throw new TypeError("The last argument must be of type Function");var s=this,o=function(){return r.apply(s,arguments)};e.apply(this,i).then((function(e){t.nextTick(o,null,e)}),(function(e){t.nextTick(_,e,o)}))}return Object.setPrototypeOf(i,Object.getPrototypeOf(e)),Object.defineProperties(i,n(e)),i}}).call(this,i(20))},function(t,e){t.exports=function(t){return t&&"object"==typeof t&&"function"==typeof t.copy&&"function"==typeof t.fill&&"function"==typeof t.readUInt8}},function(t,e){"function"==typeof Object.create?t.exports=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:t.exports=function(t,e){t.super_=e;var i=function(){};i.prototype=e.prototype,t.prototype=new i,t.prototype.constructor=t}},function(t,e,i){"use strict";(function(t){
/*!
   Copyright 2021 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
Object.defineProperty(e,"__esModule",{value:!0}),e.hashUnknown=void 0;const n=i(95);let r,s,o,a,l,h;const u=new DataView(new ArrayBuffer(8)),c=n.createSeed(),d=n.createSeed(),g=n.createSeed(),f=n.createSeed(),p=n.createSeed();let m=c,y=d,b=p,P=g,v=f;function S(t){return function(t){return Number.isInteger(t)&&t>=~(2**31-1)&&t<=2**31-1}(t)?t:function(t){return Number.isInteger(t)&&t>=0&&t<=2**32-1}(t)?function(t){return t>>0}(t):function(t){return u.setFloat64(0,t),u.getInt32(0,!0)^u.getInt32(4,!0)}(t)}function C(e,i,r){if(!t.isEncoding(i))throw new RangeError("Invalid encoding: "+i);return function(t,e){const i=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength);return n.hash(i,e)}(t.from(e,i),r)}function w(t,e){return(t<<7|t>>>25)^e}const E="function"==typeof BigInt?function(){const t=BigInt(0),e=BigInt(4294967295),i=BigInt(32);return function(n){if(n===t)return 0;let r=n<t?-1:n>t?1:0;for(n<t&&(n=-n);n!==t;)r=w(r,Number(n&e)),n>>=i;return r}}():function(t){return C(t.toString(),"ascii",b)};const x="description"in Symbol.prototype?t=>t.description:t=>{const e=t.toString();return e.startsWith("Symbol(")&&e.endsWith(")")?e.slice(7,-1):e};function A(t){const e=Symbol.keyFor(t);return void 0!==e?function(t,e){let i=l&&l.get(t);return void 0===i&&(i=C(e,"utf8",v),l||(l=new Map),l.set(t,i)),i}(t,e):function(t){let e=h&&h.get(t);if(void 0===e){o||(o={next:1}),e=w(P,o.next++);const i=x(t);i&&(e=C(i,"utf8",e)),h||(h=new Map),h.set(t,e)}return e}(t)}function T(t){let e=a&&a.get(t);return void 0===e&&(a||(a=new WeakMap),e=function(t){let e;return null===t?e=s||(s={next:1}):(e=r&&r.get(t),e||(r||(r=new WeakMap),r.set(t,e={next:1}))),e}(Object.getPrototypeOf(t)).next++,e=w(m,e),a.set(t,e)),e}function I(t){switch(typeof t){case"boolean":return function(t){return t?1:0}(t);case"number":return S(t);case"bigint":return E(t);case"string":return function(t){return C(t,"utf8",y)}(t);case"symbol":return A(t);case"function":return T(t);case"object":if(null!==t)return T(t);case"undefined":default:return 0}}e.hashUnknown=I,function(t){t.getState=function(){return{weakPrototypeCounters:r,nullPrototypeCounter:s,localSymbolCounter:o,weakObjectHashes:a,globalSymbolHashes:l,localSymbolHashes:h,objectSeed:m,stringSeed:y,bigIntSeed:b,localSymbolSeed:P,globalSymbolSeed:v}},t.setState=function(t){({weakPrototypeCounters:r,nullPrototypeCounter:s,localSymbolCounter:o,weakObjectHashes:a,globalSymbolHashes:l,localSymbolHashes:h,objectSeed:m=c,stringSeed:y=d,bigIntSeed:b=p,localSymbolSeed:P=g,globalSymbolSeed:v=f}=t)}}(I=e.hashUnknown||(e.hashUnknown={}))}).call(this,i(91).Buffer)},function(t,e,i){"use strict";(function(t){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
var n=i(92),r=i(93),s=i(94);function o(){return l.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(t,e){if(o()<e)throw new RangeError("Invalid typed array length");return l.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e)).__proto__=l.prototype:(null===t&&(t=new l(e)),t.length=e),t}function l(t,e,i){if(!(l.TYPED_ARRAY_SUPPORT||this instanceof l))return new l(t,e,i);if("number"==typeof t){if("string"==typeof e)throw new Error("If encoding is specified then the first argument must be a string");return c(this,t)}return h(this,t,e,i)}function h(t,e,i,n){if("number"==typeof e)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?function(t,e,i,n){if(e.byteLength,i<0||e.byteLength<i)throw new RangeError("'offset' is out of bounds");if(e.byteLength<i+(n||0))throw new RangeError("'length' is out of bounds");e=void 0===i&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,i):new Uint8Array(e,i,n);l.TYPED_ARRAY_SUPPORT?(t=e).__proto__=l.prototype:t=d(t,e);return t}(t,e,i,n):"string"==typeof e?function(t,e,i){"string"==typeof i&&""!==i||(i="utf8");if(!l.isEncoding(i))throw new TypeError('"encoding" must be a valid string encoding');var n=0|f(e,i),r=(t=a(t,n)).write(e,i);r!==n&&(t=t.slice(0,r));return t}(t,e,i):function(t,e){if(l.isBuffer(e)){var i=0|g(e.length);return 0===(t=a(t,i)).length||e.copy(t,0,0,i),t}if(e){if("undefined"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||"length"in e)return"number"!=typeof e.length||(n=e.length)!=n?a(t,0):d(t,e);if("Buffer"===e.type&&s(e.data))return d(t,e.data)}var n;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(t,e)}function u(t){if("number"!=typeof t)throw new TypeError('"size" argument must be a number');if(t<0)throw new RangeError('"size" argument must not be negative')}function c(t,e){if(u(e),t=a(t,e<0?0:0|g(e)),!l.TYPED_ARRAY_SUPPORT)for(var i=0;i<e;++i)t[i]=0;return t}function d(t,e){var i=e.length<0?0:0|g(e.length);t=a(t,i);for(var n=0;n<i;n+=1)t[n]=255&e[n];return t}function g(t){if(t>=o())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o().toString(16)+" bytes");return 0|t}function f(t,e){if(l.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var i=t.length;if(0===i)return 0;for(var n=!1;;)switch(e){case"ascii":case"latin1":case"binary":return i;case"utf8":case"utf-8":case void 0:return G(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*i;case"hex":return i>>>1;case"base64":return z(t).length;default:if(n)return G(t).length;e=(""+e).toLowerCase(),n=!0}}function p(t,e,i){var n=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===i||i>this.length)&&(i=this.length),i<=0)return"";if((i>>>=0)<=(e>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return O(this,e,i);case"utf8":case"utf-8":return A(this,e,i);case"ascii":return T(this,e,i);case"latin1":case"binary":return I(this,e,i);case"base64":return x(this,e,i);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return _(this,e,i);default:if(n)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),n=!0}}function m(t,e,i){var n=t[e];t[e]=t[i],t[i]=n}function y(t,e,i,n,r){if(0===t.length)return-1;if("string"==typeof i?(n=i,i=0):i>2147483647?i=2147483647:i<-2147483648&&(i=-2147483648),i=+i,isNaN(i)&&(i=r?0:t.length-1),i<0&&(i=t.length+i),i>=t.length){if(r)return-1;i=t.length-1}else if(i<0){if(!r)return-1;i=0}if("string"==typeof e&&(e=l.from(e,n)),l.isBuffer(e))return 0===e.length?-1:b(t,e,i,n,r);if("number"==typeof e)return e&=255,l.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?r?Uint8Array.prototype.indexOf.call(t,e,i):Uint8Array.prototype.lastIndexOf.call(t,e,i):b(t,[e],i,n,r);throw new TypeError("val must be string, number or Buffer")}function b(t,e,i,n,r){var s,o=1,a=t.length,l=e.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(t.length<2||e.length<2)return-1;o=2,a/=2,l/=2,i/=2}function h(t,e){return 1===o?t[e]:t.readUInt16BE(e*o)}if(r){var u=-1;for(s=i;s<a;s++)if(h(t,s)===h(e,-1===u?0:s-u)){if(-1===u&&(u=s),s-u+1===l)return u*o}else-1!==u&&(s-=s-u),u=-1}else for(i+l>a&&(i=a-l),s=i;s>=0;s--){for(var c=!0,d=0;d<l;d++)if(h(t,s+d)!==h(e,d)){c=!1;break}if(c)return s}return-1}function P(t,e,i,n){i=Number(i)||0;var r=t.length-i;n?(n=Number(n))>r&&(n=r):n=r;var s=e.length;if(s%2!=0)throw new TypeError("Invalid hex string");n>s/2&&(n=s/2);for(var o=0;o<n;++o){var a=parseInt(e.substr(2*o,2),16);if(isNaN(a))return o;t[i+o]=a}return o}function v(t,e,i,n){return j(G(e,t.length-i),t,i,n)}function S(t,e,i,n){return j(function(t){for(var e=[],i=0;i<t.length;++i)e.push(255&t.charCodeAt(i));return e}(e),t,i,n)}function C(t,e,i,n){return S(t,e,i,n)}function w(t,e,i,n){return j(z(e),t,i,n)}function E(t,e,i,n){return j(function(t,e){for(var i,n,r,s=[],o=0;o<t.length&&!((e-=2)<0);++o)i=t.charCodeAt(o),n=i>>8,r=i%256,s.push(r),s.push(n);return s}(e,t.length-i),t,i,n)}function x(t,e,i){return 0===e&&i===t.length?n.fromByteArray(t):n.fromByteArray(t.slice(e,i))}function A(t,e,i){i=Math.min(t.length,i);for(var n=[],r=e;r<i;){var s,o,a,l,h=t[r],u=null,c=h>239?4:h>223?3:h>191?2:1;if(r+c<=i)switch(c){case 1:h<128&&(u=h);break;case 2:128==(192&(s=t[r+1]))&&(l=(31&h)<<6|63&s)>127&&(u=l);break;case 3:s=t[r+1],o=t[r+2],128==(192&s)&&128==(192&o)&&(l=(15&h)<<12|(63&s)<<6|63&o)>2047&&(l<55296||l>57343)&&(u=l);break;case 4:s=t[r+1],o=t[r+2],a=t[r+3],128==(192&s)&&128==(192&o)&&128==(192&a)&&(l=(15&h)<<18|(63&s)<<12|(63&o)<<6|63&a)>65535&&l<1114112&&(u=l)}null===u?(u=65533,c=1):u>65535&&(u-=65536,n.push(u>>>10&1023|55296),u=56320|1023&u),n.push(u),r+=c}return function(t){var e=t.length;if(e<=4096)return String.fromCharCode.apply(String,t);var i="",n=0;for(;n<e;)i+=String.fromCharCode.apply(String,t.slice(n,n+=4096));return i}(n)}e.Buffer=l,e.SlowBuffer=function(t){+t!=t&&(t=0);return l.alloc(+t)},e.INSPECT_MAX_BYTES=50,l.TYPED_ARRAY_SUPPORT=void 0!==t.TYPED_ARRAY_SUPPORT?t.TYPED_ARRAY_SUPPORT:function(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&"function"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(t){return!1}}(),e.kMaxLength=o(),l.poolSize=8192,l._augment=function(t){return t.__proto__=l.prototype,t},l.from=function(t,e,i){return h(null,t,e,i)},l.TYPED_ARRAY_SUPPORT&&(l.prototype.__proto__=Uint8Array.prototype,l.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&l[Symbol.species]===l&&Object.defineProperty(l,Symbol.species,{value:null,configurable:!0})),l.alloc=function(t,e,i){return function(t,e,i,n){return u(e),e<=0?a(t,e):void 0!==i?"string"==typeof n?a(t,e).fill(i,n):a(t,e).fill(i):a(t,e)}(null,t,e,i)},l.allocUnsafe=function(t){return c(null,t)},l.allocUnsafeSlow=function(t){return c(null,t)},l.isBuffer=function(t){return!(null==t||!t._isBuffer)},l.compare=function(t,e){if(!l.isBuffer(t)||!l.isBuffer(e))throw new TypeError("Arguments must be Buffers");if(t===e)return 0;for(var i=t.length,n=e.length,r=0,s=Math.min(i,n);r<s;++r)if(t[r]!==e[r]){i=t[r],n=e[r];break}return i<n?-1:n<i?1:0},l.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(t,e){if(!s(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return l.alloc(0);var i;if(void 0===e)for(e=0,i=0;i<t.length;++i)e+=t[i].length;var n=l.allocUnsafe(e),r=0;for(i=0;i<t.length;++i){var o=t[i];if(!l.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(n,r),r+=o.length}return n},l.byteLength=f,l.prototype._isBuffer=!0,l.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var e=0;e<t;e+=2)m(this,e,e+1);return this},l.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var e=0;e<t;e+=4)m(this,e,e+3),m(this,e+1,e+2);return this},l.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var e=0;e<t;e+=8)m(this,e,e+7),m(this,e+1,e+6),m(this,e+2,e+5),m(this,e+3,e+4);return this},l.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?A(this,0,t):p.apply(this,arguments)},l.prototype.equals=function(t){if(!l.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===l.compare(this,t)},l.prototype.inspect=function(){var t="",i=e.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString("hex",0,i).match(/.{2}/g).join(" "),this.length>i&&(t+=" ... ")),"<Buffer "+t+">"},l.prototype.compare=function(t,e,i,n,r){if(!l.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===e&&(e=0),void 0===i&&(i=t?t.length:0),void 0===n&&(n=0),void 0===r&&(r=this.length),e<0||i>t.length||n<0||r>this.length)throw new RangeError("out of range index");if(n>=r&&e>=i)return 0;if(n>=r)return-1;if(e>=i)return 1;if(this===t)return 0;for(var s=(r>>>=0)-(n>>>=0),o=(i>>>=0)-(e>>>=0),a=Math.min(s,o),h=this.slice(n,r),u=t.slice(e,i),c=0;c<a;++c)if(h[c]!==u[c]){s=h[c],o=u[c];break}return s<o?-1:o<s?1:0},l.prototype.includes=function(t,e,i){return-1!==this.indexOf(t,e,i)},l.prototype.indexOf=function(t,e,i){return y(this,t,e,i,!0)},l.prototype.lastIndexOf=function(t,e,i){return y(this,t,e,i,!1)},l.prototype.write=function(t,e,i,n){if(void 0===e)n="utf8",i=this.length,e=0;else if(void 0===i&&"string"==typeof e)n=e,i=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e|=0,isFinite(i)?(i|=0,void 0===n&&(n="utf8")):(n=i,i=void 0)}var r=this.length-e;if((void 0===i||i>r)&&(i=r),t.length>0&&(i<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var s=!1;;)switch(n){case"hex":return P(this,t,e,i);case"utf8":case"utf-8":return v(this,t,e,i);case"ascii":return S(this,t,e,i);case"latin1":case"binary":return C(this,t,e,i);case"base64":return w(this,t,e,i);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return E(this,t,e,i);default:if(s)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),s=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function T(t,e,i){var n="";i=Math.min(t.length,i);for(var r=e;r<i;++r)n+=String.fromCharCode(127&t[r]);return n}function I(t,e,i){var n="";i=Math.min(t.length,i);for(var r=e;r<i;++r)n+=String.fromCharCode(t[r]);return n}function O(t,e,i){var n=t.length;(!e||e<0)&&(e=0),(!i||i<0||i>n)&&(i=n);for(var r="",s=e;s<i;++s)r+=V(t[s]);return r}function _(t,e,i){for(var n=t.slice(e,i),r="",s=0;s<n.length;s+=2)r+=String.fromCharCode(n[s]+256*n[s+1]);return r}function L(t,e,i){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>i)throw new RangeError("Trying to access beyond buffer length")}function R(t,e,i,n,r,s){if(!l.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>r||e<s)throw new RangeError('"value" argument is out of bounds');if(i+n>t.length)throw new RangeError("Index out of range")}function B(t,e,i,n){e<0&&(e=65535+e+1);for(var r=0,s=Math.min(t.length-i,2);r<s;++r)t[i+r]=(e&255<<8*(n?r:1-r))>>>8*(n?r:1-r)}function M(t,e,i,n){e<0&&(e=4294967295+e+1);for(var r=0,s=Math.min(t.length-i,4);r<s;++r)t[i+r]=e>>>8*(n?r:3-r)&255}function F(t,e,i,n,r,s){if(i+n>t.length)throw new RangeError("Index out of range");if(i<0)throw new RangeError("Index out of range")}function D(t,e,i,n,s){return s||F(t,0,i,4),r.write(t,e,i,n,23,4),i+4}function N(t,e,i,n,s){return s||F(t,0,i,8),r.write(t,e,i,n,52,8),i+8}l.prototype.slice=function(t,e){var i,n=this.length;if((t=~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),(e=void 0===e?n:~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),e<t&&(e=t),l.TYPED_ARRAY_SUPPORT)(i=this.subarray(t,e)).__proto__=l.prototype;else{var r=e-t;i=new l(r,void 0);for(var s=0;s<r;++s)i[s]=this[s+t]}return i},l.prototype.readUIntLE=function(t,e,i){t|=0,e|=0,i||L(t,e,this.length);for(var n=this[t],r=1,s=0;++s<e&&(r*=256);)n+=this[t+s]*r;return n},l.prototype.readUIntBE=function(t,e,i){t|=0,e|=0,i||L(t,e,this.length);for(var n=this[t+--e],r=1;e>0&&(r*=256);)n+=this[t+--e]*r;return n},l.prototype.readUInt8=function(t,e){return e||L(t,1,this.length),this[t]},l.prototype.readUInt16LE=function(t,e){return e||L(t,2,this.length),this[t]|this[t+1]<<8},l.prototype.readUInt16BE=function(t,e){return e||L(t,2,this.length),this[t]<<8|this[t+1]},l.prototype.readUInt32LE=function(t,e){return e||L(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},l.prototype.readUInt32BE=function(t,e){return e||L(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},l.prototype.readIntLE=function(t,e,i){t|=0,e|=0,i||L(t,e,this.length);for(var n=this[t],r=1,s=0;++s<e&&(r*=256);)n+=this[t+s]*r;return n>=(r*=128)&&(n-=Math.pow(2,8*e)),n},l.prototype.readIntBE=function(t,e,i){t|=0,e|=0,i||L(t,e,this.length);for(var n=e,r=1,s=this[t+--n];n>0&&(r*=256);)s+=this[t+--n]*r;return s>=(r*=128)&&(s-=Math.pow(2,8*e)),s},l.prototype.readInt8=function(t,e){return e||L(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},l.prototype.readInt16LE=function(t,e){e||L(t,2,this.length);var i=this[t]|this[t+1]<<8;return 32768&i?4294901760|i:i},l.prototype.readInt16BE=function(t,e){e||L(t,2,this.length);var i=this[t+1]|this[t]<<8;return 32768&i?4294901760|i:i},l.prototype.readInt32LE=function(t,e){return e||L(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},l.prototype.readInt32BE=function(t,e){return e||L(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},l.prototype.readFloatLE=function(t,e){return e||L(t,4,this.length),r.read(this,t,!0,23,4)},l.prototype.readFloatBE=function(t,e){return e||L(t,4,this.length),r.read(this,t,!1,23,4)},l.prototype.readDoubleLE=function(t,e){return e||L(t,8,this.length),r.read(this,t,!0,52,8)},l.prototype.readDoubleBE=function(t,e){return e||L(t,8,this.length),r.read(this,t,!1,52,8)},l.prototype.writeUIntLE=function(t,e,i,n){(t=+t,e|=0,i|=0,n)||R(this,t,e,i,Math.pow(2,8*i)-1,0);var r=1,s=0;for(this[e]=255&t;++s<i&&(r*=256);)this[e+s]=t/r&255;return e+i},l.prototype.writeUIntBE=function(t,e,i,n){(t=+t,e|=0,i|=0,n)||R(this,t,e,i,Math.pow(2,8*i)-1,0);var r=i-1,s=1;for(this[e+r]=255&t;--r>=0&&(s*=256);)this[e+r]=t/s&255;return e+i},l.prototype.writeUInt8=function(t,e,i){return t=+t,e|=0,i||R(this,t,e,1,255,0),l.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},l.prototype.writeUInt16LE=function(t,e,i){return t=+t,e|=0,i||R(this,t,e,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):B(this,t,e,!0),e+2},l.prototype.writeUInt16BE=function(t,e,i){return t=+t,e|=0,i||R(this,t,e,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):B(this,t,e,!1),e+2},l.prototype.writeUInt32LE=function(t,e,i){return t=+t,e|=0,i||R(this,t,e,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):M(this,t,e,!0),e+4},l.prototype.writeUInt32BE=function(t,e,i){return t=+t,e|=0,i||R(this,t,e,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):M(this,t,e,!1),e+4},l.prototype.writeIntLE=function(t,e,i,n){if(t=+t,e|=0,!n){var r=Math.pow(2,8*i-1);R(this,t,e,i,r-1,-r)}var s=0,o=1,a=0;for(this[e]=255&t;++s<i&&(o*=256);)t<0&&0===a&&0!==this[e+s-1]&&(a=1),this[e+s]=(t/o>>0)-a&255;return e+i},l.prototype.writeIntBE=function(t,e,i,n){if(t=+t,e|=0,!n){var r=Math.pow(2,8*i-1);R(this,t,e,i,r-1,-r)}var s=i-1,o=1,a=0;for(this[e+s]=255&t;--s>=0&&(o*=256);)t<0&&0===a&&0!==this[e+s+1]&&(a=1),this[e+s]=(t/o>>0)-a&255;return e+i},l.prototype.writeInt8=function(t,e,i){return t=+t,e|=0,i||R(this,t,e,1,127,-128),l.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[e]=255&t,e+1},l.prototype.writeInt16LE=function(t,e,i){return t=+t,e|=0,i||R(this,t,e,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):B(this,t,e,!0),e+2},l.prototype.writeInt16BE=function(t,e,i){return t=+t,e|=0,i||R(this,t,e,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):B(this,t,e,!1),e+2},l.prototype.writeInt32LE=function(t,e,i){return t=+t,e|=0,i||R(this,t,e,4,2147483647,-2147483648),l.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):M(this,t,e,!0),e+4},l.prototype.writeInt32BE=function(t,e,i){return t=+t,e|=0,i||R(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),l.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):M(this,t,e,!1),e+4},l.prototype.writeFloatLE=function(t,e,i){return D(this,t,e,!0,i)},l.prototype.writeFloatBE=function(t,e,i){return D(this,t,e,!1,i)},l.prototype.writeDoubleLE=function(t,e,i){return N(this,t,e,!0,i)},l.prototype.writeDoubleBE=function(t,e,i){return N(this,t,e,!1,i)},l.prototype.copy=function(t,e,i,n){if(i||(i=0),n||0===n||(n=this.length),e>=t.length&&(e=t.length),e||(e=0),n>0&&n<i&&(n=i),n===i)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(i<0||i>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),t.length-e<n-i&&(n=t.length-e+i);var r,s=n-i;if(this===t&&i<e&&e<n)for(r=s-1;r>=0;--r)t[r+e]=this[r+i];else if(s<1e3||!l.TYPED_ARRAY_SUPPORT)for(r=0;r<s;++r)t[r+e]=this[r+i];else Uint8Array.prototype.set.call(t,this.subarray(i,i+s),e);return s},l.prototype.fill=function(t,e,i,n){if("string"==typeof t){if("string"==typeof e?(n=e,e=0,i=this.length):"string"==typeof i&&(n=i,i=this.length),1===t.length){var r=t.charCodeAt(0);r<256&&(t=r)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!l.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<i)throw new RangeError("Out of range index");if(i<=e)return this;var s;if(e>>>=0,i=void 0===i?this.length:i>>>0,t||(t=0),"number"==typeof t)for(s=e;s<i;++s)this[s]=t;else{var o=l.isBuffer(t)?t:G(new l(t,n).toString()),a=o.length;for(s=0;s<i-e;++s)this[s+e]=o[s%a]}return this};var k=/[^+\/0-9A-Za-z-_]/g;function V(t){return t<16?"0"+t.toString(16):t.toString(16)}function G(t,e){var i;e=e||1/0;for(var n=t.length,r=null,s=[],o=0;o<n;++o){if((i=t.charCodeAt(o))>55295&&i<57344){if(!r){if(i>56319){(e-=3)>-1&&s.push(239,191,189);continue}if(o+1===n){(e-=3)>-1&&s.push(239,191,189);continue}r=i;continue}if(i<56320){(e-=3)>-1&&s.push(239,191,189),r=i;continue}i=65536+(r-55296<<10|i-56320)}else r&&(e-=3)>-1&&s.push(239,191,189);if(r=null,i<128){if((e-=1)<0)break;s.push(i)}else if(i<2048){if((e-=2)<0)break;s.push(i>>6|192,63&i|128)}else if(i<65536){if((e-=3)<0)break;s.push(i>>12|224,i>>6&63|128,63&i|128)}else{if(!(i<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;s.push(i>>18|240,i>>12&63|128,i>>6&63|128,63&i|128)}}return s}function z(t){return n.toByteArray(function(t){if((t=function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}(t).replace(k,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(t))}function j(t,e,i,n){for(var r=0;r<n&&!(r+i>=e.length||r>=t.length);++r)e[r+i]=t[r];return r}}).call(this,i(21))},function(t,e,i){"use strict";e.byteLength=function(t){var e=h(t),i=e[0],n=e[1];return 3*(i+n)/4-n},e.toByteArray=function(t){var e,i,n=h(t),o=n[0],a=n[1],l=new s(function(t,e,i){return 3*(e+i)/4-i}(0,o,a)),u=0,c=a>0?o-4:o;for(i=0;i<c;i+=4)e=r[t.charCodeAt(i)]<<18|r[t.charCodeAt(i+1)]<<12|r[t.charCodeAt(i+2)]<<6|r[t.charCodeAt(i+3)],l[u++]=e>>16&255,l[u++]=e>>8&255,l[u++]=255&e;2===a&&(e=r[t.charCodeAt(i)]<<2|r[t.charCodeAt(i+1)]>>4,l[u++]=255&e);1===a&&(e=r[t.charCodeAt(i)]<<10|r[t.charCodeAt(i+1)]<<4|r[t.charCodeAt(i+2)]>>2,l[u++]=e>>8&255,l[u++]=255&e);return l},e.fromByteArray=function(t){for(var e,i=t.length,r=i%3,s=[],o=0,a=i-r;o<a;o+=16383)s.push(u(t,o,o+16383>a?a:o+16383));1===r?(e=t[i-1],s.push(n[e>>2]+n[e<<4&63]+"==")):2===r&&(e=(t[i-2]<<8)+t[i-1],s.push(n[e>>10]+n[e>>4&63]+n[e<<2&63]+"="));return s.join("")};for(var n=[],r=[],s="undefined"!=typeof Uint8Array?Uint8Array:Array,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0,l=o.length;a<l;++a)n[a]=o[a],r[o.charCodeAt(a)]=a;function h(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var i=t.indexOf("=");return-1===i&&(i=e),[i,i===e?0:4-i%4]}function u(t,e,i){for(var r,s,o=[],a=e;a<i;a+=3)r=(t[a]<<16&16711680)+(t[a+1]<<8&65280)+(255&t[a+2]),o.push(n[(s=r)>>18&63]+n[s>>12&63]+n[s>>6&63]+n[63&s]);return o.join("")}r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63},function(t,e){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
e.read=function(t,e,i,n,r){var s,o,a=8*r-n-1,l=(1<<a)-1,h=l>>1,u=-7,c=i?r-1:0,d=i?-1:1,g=t[e+c];for(c+=d,s=g&(1<<-u)-1,g>>=-u,u+=a;u>0;s=256*s+t[e+c],c+=d,u-=8);for(o=s&(1<<-u)-1,s>>=-u,u+=n;u>0;o=256*o+t[e+c],c+=d,u-=8);if(0===s)s=1-h;else{if(s===l)return o?NaN:1/0*(g?-1:1);o+=Math.pow(2,n),s-=h}return(g?-1:1)*o*Math.pow(2,s-n)},e.write=function(t,e,i,n,r,s){var o,a,l,h=8*s-r-1,u=(1<<h)-1,c=u>>1,d=23===r?Math.pow(2,-24)-Math.pow(2,-77):0,g=n?0:s-1,f=n?1:-1,p=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,o=u):(o=Math.floor(Math.log(e)/Math.LN2),e*(l=Math.pow(2,-o))<1&&(o--,l*=2),(e+=o+c>=1?d/l:d*Math.pow(2,1-c))*l>=2&&(o++,l/=2),o+c>=u?(a=0,o=u):o+c>=1?(a=(e*l-1)*Math.pow(2,r),o+=c):(a=e*Math.pow(2,c-1)*Math.pow(2,r),o=0));r>=8;t[i+g]=255&a,g+=f,a/=256,r-=8);for(o=o<<r|a,h+=r;h>0;t[i+g]=255&o,g+=f,o/=256,h-=8);t[i+g-f]|=128*p}},function(t,e){var i={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==i.call(t)}},function(t,e,i){"use strict";
/*!
   Copyright 2021 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   NOTE: The `murmur3` algorithm is public domain.
*/function n(){return 4294967295*Math.random()>>>0}Object.defineProperty(e,"__esModule",{value:!0}),e.hash=e.defaultSeed=e.createSeed=void 0,e.createSeed=n,e.defaultSeed=n();const r=3432918353,s=461845907;e.hash=function(t,e){const i=new DataView(t);let n,o=e>>>0,a=0;for(;a<i.byteLength-4;)n=i.getUint32(a,!0),n*=r,n=n<<15|n>>>17,n*=s,o^=n,o=o<<13|o>>>19,o=5*o+3864292196,a+=4;if(a<i.byteLength){switch(n=0,i.byteLength-a){case 3:n|=i.getUint8(a+2)<<16;case 2:n|=i.getUint8(a+1)<<8;case 1:n|=i.getUint8(a+0)<<0}n*=r,n=n<<15|n>>>17,n*=s,o^=n}return o^=i.byteLength,o^=o>>>16,o*=2246822507,o^=o>>>13,o*=3266489909,o^=o>>>16,o}},function(t,e,i){"use strict";i.r(e),i.d(e,"__extends",(function(){return r})),i.d(e,"__assign",(function(){return s})),i.d(e,"__rest",(function(){return o})),i.d(e,"__decorate",(function(){return a})),i.d(e,"__param",(function(){return l})),i.d(e,"__metadata",(function(){return h})),i.d(e,"__awaiter",(function(){return u})),i.d(e,"__generator",(function(){return c})),i.d(e,"__createBinding",(function(){return d})),i.d(e,"__exportStar",(function(){return g})),i.d(e,"__values",(function(){return f})),i.d(e,"__read",(function(){return p})),i.d(e,"__spread",(function(){return m})),i.d(e,"__spreadArrays",(function(){return y})),i.d(e,"__spreadArray",(function(){return b})),i.d(e,"__await",(function(){return P})),i.d(e,"__asyncGenerator",(function(){return v})),i.d(e,"__asyncDelegator",(function(){return S})),i.d(e,"__asyncValues",(function(){return C})),i.d(e,"__makeTemplateObject",(function(){return w})),i.d(e,"__importStar",(function(){return x})),i.d(e,"__importDefault",(function(){return A})),i.d(e,"__classPrivateFieldGet",(function(){return T})),i.d(e,"__classPrivateFieldSet",(function(){return I}));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var n=function(t,e){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i])})(t,e)};function r(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function i(){this.constructor=t}n(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}var s=function(){return(s=Object.assign||function(t){for(var e,i=1,n=arguments.length;i<n;i++)for(var r in e=arguments[i])Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t}).apply(this,arguments)};function o(t,e){var i={};for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&e.indexOf(n)<0&&(i[n]=t[n]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(n=Object.getOwnPropertySymbols(t);r<n.length;r++)e.indexOf(n[r])<0&&Object.prototype.propertyIsEnumerable.call(t,n[r])&&(i[n[r]]=t[n[r]])}return i}function a(t,e,i,n){var r,s=arguments.length,o=s<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,i,n);else for(var a=t.length-1;a>=0;a--)(r=t[a])&&(o=(s<3?r(o):s>3?r(e,i,o):r(e,i))||o);return s>3&&o&&Object.defineProperty(e,i,o),o}function l(t,e){return function(i,n){e(i,n,t)}}function h(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)}function u(t,e,i,n){return new(i||(i=Promise))((function(r,s){function o(t){try{l(n.next(t))}catch(t){s(t)}}function a(t){try{l(n.throw(t))}catch(t){s(t)}}function l(t){var e;t.done?r(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(o,a)}l((n=n.apply(t,e||[])).next())}))}function c(t,e){var i,n,r,s,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function a(s){return function(a){return function(s){if(i)throw new TypeError("Generator is already executing.");for(;o;)try{if(i=1,n&&(r=2&s[0]?n.return:s[0]?n.throw||((r=n.return)&&r.call(n),0):n.next)&&!(r=r.call(n,s[1])).done)return r;switch(n=0,r&&(s=[2&s[0],r.value]),s[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,n=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(r=o.trys,(r=r.length>0&&r[r.length-1])||6!==s[0]&&2!==s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=e.call(t,o)}catch(t){s=[6,t],n=0}finally{i=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,a])}}}var d=Object.create?function(t,e,i,n){void 0===n&&(n=i),Object.defineProperty(t,n,{enumerable:!0,get:function(){return e[i]}})}:function(t,e,i,n){void 0===n&&(n=i),t[n]=e[i]};function g(t,e){for(var i in t)"default"===i||Object.prototype.hasOwnProperty.call(e,i)||d(e,t,i)}function f(t){var e="function"==typeof Symbol&&Symbol.iterator,i=e&&t[e],n=0;if(i)return i.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&n>=t.length&&(t=void 0),{value:t&&t[n++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}function p(t,e){var i="function"==typeof Symbol&&t[Symbol.iterator];if(!i)return t;var n,r,s=i.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(n=s.next()).done;)o.push(n.value)}catch(t){r={error:t}}finally{try{n&&!n.done&&(i=s.return)&&i.call(s)}finally{if(r)throw r.error}}return o}function m(){for(var t=[],e=0;e<arguments.length;e++)t=t.concat(p(arguments[e]));return t}function y(){for(var t=0,e=0,i=arguments.length;e<i;e++)t+=arguments[e].length;var n=Array(t),r=0;for(e=0;e<i;e++)for(var s=arguments[e],o=0,a=s.length;o<a;o++,r++)n[r]=s[o];return n}function b(t,e,i){if(i||2===arguments.length)for(var n,r=0,s=e.length;r<s;r++)!n&&r in e||(n||(n=Array.prototype.slice.call(e,0,r)),n[r]=e[r]);return t.concat(n||Array.prototype.slice.call(e))}function P(t){return this instanceof P?(this.v=t,this):new P(t)}function v(t,e,i){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,r=i.apply(t,e||[]),s=[];return n={},o("next"),o("throw"),o("return"),n[Symbol.asyncIterator]=function(){return this},n;function o(t){r[t]&&(n[t]=function(e){return new Promise((function(i,n){s.push([t,e,i,n])>1||a(t,e)}))})}function a(t,e){try{!function(t){t.value instanceof P?Promise.resolve(t.value.v).then(l,h):u(s[0][2],t)}(r[t](e))}catch(t){u(s[0][3],t)}}function l(t){a("next",t)}function h(t){a("throw",t)}function u(t,e){t(e),s.shift(),s.length&&a(s[0][0],s[0][1])}}function S(t){var e,i;return e={},n("next"),n("throw",(function(t){throw t})),n("return"),e[Symbol.iterator]=function(){return this},e;function n(n,r){e[n]=t[n]?function(e){return(i=!i)?{value:P(t[n](e)),done:"return"===n}:r?r(e):e}:r}}function C(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,i=t[Symbol.asyncIterator];return i?i.call(t):(t=f(t),e={},n("next"),n("throw"),n("return"),e[Symbol.asyncIterator]=function(){return this},e);function n(i){e[i]=t[i]&&function(e){return new Promise((function(n,r){(function(t,e,i,n){Promise.resolve(n).then((function(e){t({value:e,done:i})}),e)})(n,r,(e=t[i](e)).done,e.value)}))}}}function w(t,e){return Object.defineProperty?Object.defineProperty(t,"raw",{value:e}):t.raw=e,t}var E=Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e};function x(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var i in t)"default"!==i&&Object.prototype.hasOwnProperty.call(t,i)&&d(e,t,i);return E(e,t),e}function A(t){return t&&t.__esModule?t:{default:t}}function T(t,e,i,n){if("a"===i&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof e?t!==e||!n:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===i?n:"a"===i?n.call(t):n?n.value:e.get(t)}function I(t,e,i,n,r){if("m"===n)throw new TypeError("Private method is not writable");if("a"===n&&!r)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof e?t!==e||!r:!e.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===n?r.call(t,i):r?r.value=i:e.set(t,i),i}},function(t,e,i){"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/Object.defineProperty(e,"__esModule",{value:!0}),e.SortedSet=void 0;const n=i(57),r=i(24),s=i(28),o=i(29);class a{constructor(...t){let e,i;if(this._values=[],t.length>0){const n=t[0];r.isIterable(n)||void 0===n?(e=n,t.length>1&&(i=t[1])):i=n}if(void 0===i&&(i=o.Comparer.defaultComparer),this._comparer="function"==typeof i?o.Comparer.create(i):i,e)for(const t of e)this.add(t)}get comparer(){return this._comparer}get size(){return this._values.length}has(t){return n.binarySearch(this._values,t,this._comparer)>=0}add(t){const e=n.binarySearch(this._values,t,this._comparer);return e>=0?this._values[e]=t:this._values.splice(~e,0,t),this}delete(t){const e=n.binarySearch(this._values,t,this._comparer);return e>=0&&(this._values.splice(e,1),!0)}clear(){this._values.length=0}keys(){return this._values.values()}values(){return this._values.values()}*entries(){for(let t=0;t<this._values.length;t++)yield[this._values[t],this._values[t]]}[Symbol.iterator](){return this.values()}forEach(t,e){for(const i of this)t.call(e,i,i,this)}get[s.Collection.size](){return this.size}[s.Collection.has](t){return this.has(t)}[s.Collection.add](t){this.add(t)}[s.Collection.delete](t){return this.delete(t)}[s.Collection.clear](){this.clear()}}e.SortedSet=a,Object.defineProperty(a,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!0,value:"SortedSet"})},function(t,e,i){"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   "getPrime", "expandPrime", and "isPrime" are derived from the implementation
   of "HashHelpers" in .NET Core.

   .NET Core is licensed under the MIT License:

   The MIT License (MIT)
   
   Copyright (c) .NET Foundation and Contributors
   
   All rights reserved.
   
   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:
   
   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.
   
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
*/Object.defineProperty(e,"__esModule",{value:!0}),e.expandPrime=e.getPrime=e.isPrime=void 0;const n=[3,7,11,17,23,29,37,47,59,71,89,107,131,163,197,239,293,353,431,521,631,761,919,1103,1327,1597,1931,2333,2801,3371,4049,4861,5839,7013,8419,10103,12143,14591,17519,21023,25229,30293,36353,43627,52361,62851,75431,90523,108631,130363,156437,187751,225307,270371,324449,389357,467237,560689,672827,807403,968897,1162687,1395263,1674319,2009191,2411033,2893249,3471899,4166287,4999559,5999471,7199369];function r(t){if(1&t){const e=0|Math.sqrt(t);for(let i=3;i<=e;i+=2)if(!(t%i))return!1;return!0}return 2===t}function s(t){if(t<0)throw new RangeError;for(let e=0;e<n.length;e++){const i=n[e];if(i>=t)return i}for(let e=1|t;e<2**31-1;e+=2)if(r(e)&&(e-1)%101)return e;return t}e.isPrime=r,e.getPrime=s,e.expandPrime=function(t){const e=2*t;return e>2146435069&&2146435069>t?2146435069:s(e)}},function(t,e,i){"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/Object.defineProperty(e,"__esModule",{value:!0}),e.MultiMap=void 0;const n=i(24),r=i(29),s=i(28),o=i(58),a=i(60);class l{constructor(...t){let e,i,s;this._size=0,!function(t){return(t.length<1||n.isNumber(t[0]))&&(t.length<2||!n.isDefined(t[1])||n.isObject(t[1]))}(t)?(e=0,!function(t){return(t.length<1||!n.isDefined(t[0])||n.isIterable(t[0]))&&(t.length<2||!n.isDefined(t[1])||n.isObject(t[1]))}(t)?s={}:[i,s={}]=t):[e,s={}]=t;const{keyEqualer:a=r.Equaler.defaultEqualer,valueEqualer:l=r.Equaler.defaultEqualer}=s;if(this._map=new o.HashMap(e,a),this._keyEqualer=a,this._valueEqualer=l,i)for(const[t,e]of i)this.add(t,e)}get keyEqualer(){return this._keyEqualer}get valueEqualer(){return this._valueEqualer}get size(){return this._size}has(t){return this._map.has(t)}hasValue(t,e){const i=this._map.get(t);return!!i&&i.has(e)}get(t){return this._map.get(t)}add(t,e){let i=this._map.get(t);i||(i=new a.HashSet(this._valueEqualer),this._map.set(t,i));const n=i.size;return i.add(e),this._size+=i.size-n,this}delete(t){const e=this._map.get(t);return e?(this._size-=e.size,this._map.delete(t),e.size):0}deleteValue(t,e){const i=this._map.get(t);if(i){const n=i.size;if(i.delete(e))return this._size+=i.size-n,i.size<=0&&this._map.delete(t),!0}return!1}clear(){this._map.clear(),this._size=0}ensureCapacity(t){return this._map.ensureCapacity(t)}trimExcess(t){this._map.trimExcess(t)}keys(){return this._map.keys()}*values(){for(const t of this._map.values())yield*t}*entries(){for(const[t,e]of this._map)for(const i of e)yield[t,i]}[Symbol.iterator](){return this.entries()}forEach(t,e){for(const[i,n]of this._map)for(const r of n)t.call(e,r,i,this)}get[s.ReadonlyKeyedMultiCollection.size](){return this.size}[s.ReadonlyKeyedMultiCollection.has](t){return this.has(t)}[s.ReadonlyKeyedMultiCollection.hasValue](t,e){return this.hasValue(t,e)}[s.ReadonlyKeyedMultiCollection.get](t){return this.get(t)}[s.ReadonlyKeyedMultiCollection.keys](){return this.keys()}[s.ReadonlyKeyedMultiCollection.values](){return this.values()}[s.KeyedMultiCollection.add](t,e){this.add(t,e)}[s.KeyedMultiCollection.delete](t){return this.delete(t)}[s.KeyedMultiCollection.deleteValue](t,e){return this.deleteValue(t,e)}[s.KeyedMultiCollection.clear](){this.clear()}}e.MultiMap=l,Object.defineProperty(l,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!0,value:"MultiMap"})},function(t,e,i){"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   LinkedList is derived from the implementation of LinkedList in
   Promise Extensions for Javascript: https://github.com/rbuckton/prex

   Promise Extensions is licensed under the Apache 2.0 License:

   Promise Extensions for JavaScript
   Copyright (c) Microsoft Corporation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/var n,r,s;Object.defineProperty(e,"__esModule",{value:!0}),e.LinkedList=e.LinkedListNode=void 0;const o=i(24),a=i(28),l=i(29),h=Symbol("LinkedListNode.list"),u=Symbol("LinkedListNode.previous"),c=Symbol("LinkedListNode.next");class d{constructor(t){this[n]=void 0,this[r]=void 0,this[s]=void 0,this.value=t}get list(){return this[h]}get previous(){if(this[u]&&this.list&&this!==this.list.first)return this[u]}get next(){if(this[c]&&this.list&&this[c]!==this.list.first)return this[c]}detachSelf(){return!!this.list&&this.list.deleteNode(this)}}e.LinkedListNode=d,n=h,r=u,s=c,Object.defineProperty(d.prototype,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!0,value:"LinkedListNode"});class g{constructor(...t){let e,i;if(this._size=0,this._head=void 0,t.length>0&&(o.isIterable(t[0])||o.isMissing(t[0])?(e=t[0],t.length>1&&(i=t[1])):i=t[0]),o.isMissing(i)&&(i=l.Equaler.defaultEqualer),this._equaler="function"==typeof i?l.Equaler.create(i):i,e)for(const t of e)this.push(t)}get equaler(){return this._equaler}get first(){return this._head}get last(){if(this._head)return this._head[u]}get size(){return this._size}[Symbol.iterator](){return this.values()}*values(){for(const t of this.nodes())yield t.value}*nodes(){let t,e=this.first;for(;void 0!==e;)t=e,e=t.next,yield t}*drain(){for(const t of this.nodes())this.deleteNode(t),yield t.value}nodeOf(t,e){if(!o.isMissing(e)&&!o.isInstance(e,d))throw new TypeError("LinkedListNode expected: fromNode");if(!o.isMissing(e)&&e.list!==this)throw new TypeError("Wrong list.");for(let i=e||this.first;i;i=i.next)if(this._equaler.equals(i.value,t))return i}lastNodeOf(t,e){if(!o.isMissing(e)&&!o.isInstance(e,d))throw new TypeError("LinkedListNode expected: fromNode");if(!o.isMissing(e)&&e.list!==this)throw new TypeError("Wrong list.");for(let i=e||this.last;i;i=i.previous)if(this._equaler.equals(i.value,t))return i}find(t,e){if(!o.isFunction(t))throw new TypeError("Function expected: callback");let i,n=this.first;for(;void 0!==n;){i=n,n=i.next;const r=i.value;if(t.call(e,r,i,this))return r}}findLast(t,e){if(!o.isFunction(t))throw new TypeError("Function expected: callback");let i,n=this.last;for(;void 0!==n;){i=n,n=i.previous;const r=i.value;if(t.call(e,r,i,this))return r}}findNode(t,e){if(!o.isFunction(t))throw new TypeError("Function expected: callback");let i,n=this.first;for(;void 0!==n;)if(i=n,n=i.next,t.call(e,i.value,i,this))return i}findLastNode(t,e){if(!o.isFunction(t))throw new TypeError("Function expected: callback");let i,n=this.last;for(;void 0!==n;)if(i=n,n=i.previous,t.call(e,i.value,i,this))return i}has(t){return void 0!==this.nodeOf(t)}insertBefore(t,e){if(!o.isMissing(t)&&!o.isInstance(t,d))throw new TypeError("LinkedListNode expected: node");if(!o.isMissing(t)&&t.list!==this)throw new Error("Wrong list.");return this._insertNode(t||void 0,new d(e),0)}insertNodeBefore(t,e){if(!o.isMissing(t)&&!o.isInstance(t,d))throw new TypeError("LinkedListNode expected: node");if(!o.isInstance(e,d))throw new TypeError("LinkedListNode expected: newNode");if(!o.isMissing(t)&&t.list!==this)throw new Error("Wrong list.");if(!o.isMissing(e.list))throw new Error("Node is already attached to a list.");this._insertNode(t||void 0,e,0)}insertAfter(t,e){if(!o.isMissing(t)&&!o.isInstance(t,d))throw new TypeError("LinkedListNode expected: node");if(!o.isMissing(t)&&t.list!==this)throw new Error("Wrong list.");return this._insertNode(t||void 0,new d(e),1)}insertNodeAfter(t,e){if(!o.isMissing(t)&&!o.isInstance(t,d))throw new TypeError("LinkedListNode expected: node");if(!o.isInstance(e,d))throw new TypeError("LinkedListNode expected: newNode");if(!o.isMissing(t)&&t.list!==this)throw new Error("Wrong list.");if(!o.isMissing(e.list))throw new Error("Node is already attached to a list.");this._insertNode(t||void 0,e,1)}push(t){return this._insertNode(void 0,new d(t),1)}pushNode(t){if(!o.isInstance(t,d))throw new TypeError("LinkedListNode expected: newNode");if(!o.isMissing(t.list))throw new Error("Node is already attached to a list.");this._insertNode(void 0,t,1)}pop(){const t=this.popNode();return t?t.value:void 0}popNode(){const t=this.last;if(this.deleteNode(t))return t}shift(){const t=this.shiftNode();return t?t.value:void 0}shiftNode(){const t=this.first;if(this.deleteNode(t))return t}unshift(t){return this._insertNode(void 0,new d(t),0)}unshiftNode(t){if(!o.isInstance(t,d))throw new TypeError("LinkedListNode expected: newNode");if(!o.isMissing(t.list))throw new Error("Node is already attached to a list.");this._insertNode(void 0,t,0)}delete(t){const e=this.nodeOf(t);if(e&&this.deleteNode(e))return e}deleteNode(t){if(!o.isMissing(t)&&!o.isInstance(t,d))throw new TypeError("LinkedListNode expected: node");if(!o.isMissing(t)&&!o.isMissing(t.list)&&t.list!==this)throw new TypeError("Wrong list.");return!o.isMissing(t)&&!o.isMissing(t.list)&&this._deleteNode(t)}deleteAll(t,e){if(!o.isFunction(t))throw new TypeError("Function expected: predicate");let i=0,n=this.first;for(;n;){const r=n.next;t.call(e,n.value,n,this)&&n.list===this&&(this._deleteNode(n),++i),n=r}return i}clear(){for(;this.size>0;)this.deleteNode(this.last)}forEach(t,e){if(!o.isFunction(t))throw new TypeError("Function expected: callback");let i,n=this.first;for(;void 0!==n;)i=n,n=i.next,t.call(e,i.value,i,this)}map(t,e){if(!o.isFunction(t))throw new TypeError("Function expected: callback");const i=new g;let n,r=this.first;for(;void 0!==r;){n=r,r=n.next;const s=t.call(e,n.value,n,this);i.push(s)}return i}filter(t,e){if(!o.isFunction(t))throw new TypeError("Function expected: callback");const i=new g(this.equaler);let n,r=this.first;for(;void 0!==r;){n=r,r=n.next;const s=n.value;t.call(e,s,n,this)&&i.push(s)}return i}reduce(t,e){if(!o.isFunction(t))throw new TypeError("Function expected: callback");let i,n=arguments.length>1,r=e,s=this.first;for(;void 0!==s;){i=s,s=i.next;const e=i.value;n?r=t(r,e,i,this):(r=e,n=!0)}return r}reduceRight(t,e){if(!o.isFunction(t))throw new TypeError("Function expected: callback");let i,n=arguments.length>1,r=e,s=this.last;for(;void 0!==s;){i=s;const e=i.value;n?r=t(r,e,i,this):(r=e,n=!0),s=i.previous}return r}some(t,e){if(!o.isMissing(t)&&!o.isFunction(t))throw new TypeError("Function expected: callback");let i,n=this.first;for(;void 0!==n;)if(i=n,n=i.next,!t||t.call(e,i.value,i,this))return!0;return!1}every(t,e){if(!o.isFunction(t))throw new TypeError("Function expected: callback");let i,n=!1,r=this.first;for(;void 0!==r;){if(i=r,r=i.next,!t.call(e,i.value,i,this))return!1;n=!0}return n}_deleteNode(t){return t[c]===t?this._head=void 0:(t[c][u]=t[u],t[u][c]=t[c],this._head===t&&(this._head=t[c])),t[h]=void 0,t[c]=void 0,t[u]=void 0,this._size--,!0}_insertNode(t,e,i){if(e[h]=this,void 0===this._head)e[c]=e,e[u]=e,this._head=e;else switch(i){case 0:void 0===t?(t=this._head,this._head=e):t===this._head&&(this._head=e),e[c]=t,e[u]=t[u],t[u][c]=e,t[u]=e;break;case 1:void 0===t&&(t=this._head[u]),e[u]=t,e[c]=t[c],t[c][u]=e,t[c]=e}return this._size++,e}get[a.ReadonlyCollection.size](){return this.size}[a.ReadonlyCollection.has](t){return this.has(t)}[a.Collection.add](t){this.push(t)}[a.Collection.delete](t){return!!this.delete(t)}[a.Collection.clear](){this.clear()}}e.LinkedList=g,Object.defineProperty(g.prototype,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!0,value:"LinkedList"})},function(t,e,i){"use strict";function n(t,e,i,r){this.message=t,this.expected=e,this.found=i,this.location=r,this.name="SyntaxError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,n)}!function(t,e){function i(){this.constructor=t}i.prototype=e.prototype,t.prototype=new i}(n,Error),n.buildMessage=function(t,e){var i={literal:function(t){return'"'+r(t.text)+'"'},class:function(t){var e,i="";for(e=0;e<t.parts.length;e++)i+=t.parts[e]instanceof Array?s(t.parts[e][0])+"-"+s(t.parts[e][1]):s(t.parts[e]);return"["+(t.inverted?"^":"")+i+"]"},any:function(t){return"any character"},end:function(t){return"end of input"},other:function(t){return t.description}};function n(t){return t.charCodeAt(0).toString(16).toUpperCase()}function r(t){return t.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,(function(t){return"\\x0"+n(t)})).replace(/[\x10-\x1F\x7F-\x9F]/g,(function(t){return"\\x"+n(t)}))}function s(t){return t.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,(function(t){return"\\x0"+n(t)})).replace(/[\x10-\x1F\x7F-\x9F]/g,(function(t){return"\\x"+n(t)}))}return"Expected "+function(t){var e,n,r,s=new Array(t.length);for(e=0;e<t.length;e++)s[e]=(r=t[e],i[r.type](r));if(s.sort(),s.length>0){for(e=1,n=1;e<s.length;e++)s[e-1]!==s[e]&&(s[n]=s[e],n++);s.length=n}switch(s.length){case 1:return s[0];case 2:return s[0]+" or "+s[1];default:return s.slice(0,-1).join(", ")+", or "+s[s.length-1]}}(t)+" but "+function(t){return t?'"'+r(t)+'"':"end of input"}(e)+" found."},t.exports={SyntaxError:n,parse:function(t,e){e=void 0!==e?e:{};var i,r={},s={start:Ht},o=Ht,a=kt("strict",!0),l=kt("graph",!0),h=kt("digraph",!0),u=kt("{",!1),c=kt("}",!1),d=kt(";",!1),g=function(t,e){return e},f=kt("=",!1),p=kt("node",!0),m=kt("edge",!0),y=kt("[",!1),b=kt("]",!1),P=kt(",",!1),v=kt("->",!1),S=kt("--",!1),C=Gt("port"),w=kt(":",!1),E=kt("subgraph",!0),x=kt("n",!1),A=kt("ne",!1),T=kt("e",!1),I=kt("se",!1),O=kt("s",!1),_=kt("sw",!1),L=kt("w",!1),R=kt("nw",!1),B=Gt("UNICODE_STRING"),M=kt("$",!1),F=kt("_",!1),D=Gt("NUMBER"),N=kt("-",!1),k=kt(".",!1),V=/^[0-9]/,G=Vt([["0","9"]],!1,!1),z=kt("<",!1),j=kt(">",!1),U={type:"any"},W=kt('"',!1),H=function(t){return t.join("")},q=kt("\\",!1),X=/^[\n\r\u2028\u2029]/,Y=Vt(["\n","\r","\u2028","\u2029"],!1,!1),Q=Gt("end of line"),Z=kt("\n",!1),K=kt("\r\n",!1),$=kt("\r",!1),J=kt("\u2028",!1),tt=kt("\u2029",!1),et=(Vt(['"',"\\",["\0",""],""],!0,!1),kt('\\"',!1),Gt("COMMENT")),it=Gt("BLOCK_COMMENT"),nt=kt("/*",!1),rt=kt("*/",!1),st=Gt("C_COMMENT"),ot=kt("//",!1),at=/^[\n]/,lt=Vt(["\n"],!1,!1),ht=function(t){return t.join("")},ut=Gt("MACRO_COMMENT"),ct=kt("#",!1),dt=Gt("WHITESPACE"),gt=/^[\n\r]/,ft=Vt(["\n","\r"],!1,!1),pt=/^[ \t]/,mt=Vt([" ","\t"],!1,!1),yt=/^[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137-\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148-\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C-\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA-\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9-\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC-\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF-\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F-\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0-\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB-\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE-\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6-\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FC7\u1FD0-\u1FD3\u1FD6-\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6-\u1FF7\u210A\u210E-\u210F\u2113\u212F\u2134\u2139\u213C-\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65-\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73-\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3-\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]/,bt=Vt([["a","z"],"",["",""],["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],"","","","","","","",["",""],"","","","","","","","","","","","","","","","","","","","","","","","","",["",""],"","","",["",""],"","",["",""],"","","","","",["",""],"","","","",["",""],["",""],"","","","","","","","","","",["",""],"","","","","","","","",["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],"",["",""],"","","","","",["",""],["",""],"","","",["",""],"",["",""],["",""],["",""],"","","","","","","","","","","",["",""],"","",["",""],["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],["",""],["",""],["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],["",""],"",["",""],"","","","",["",""],["",""],"","",["",""],"",["",""],"","","","",["",""],["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],"","","",["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],"","","","","","","","","","","","","","","","","",["",""],["",""],["",""]],!1,!1),Pt=/^[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5-\u06E6\u07F4-\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C-\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D-\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA717-\uA71F\uA770\uA788\uA7F8-\uA7F9\uA9CF\uAA70\uAADD\uAAF3-\uAAF4\uFF70\uFF9E-\uFF9F]/,vt=Vt([["",""],["",""],["",""],"","","","","","",["",""],["",""],"","","","","","","","","","","",["",""],["",""],"",["",""],"","",["",""],["",""],"","","",["",""],"",["",""],["",""],"",["",""],"","",["",""],"","",["",""],"","","",["",""],"",["",""]],!1,!1),St=/^[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E-\u066F\u0671-\u06D3\u06D5\u06EE-\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0977\u0979-\u097F\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC-\u09DD\u09DF-\u09E1\u09F0-\u09F1\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0-\u0AE1\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B5C-\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58-\u0C59\u0C60-\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0-\u0CE1\u0CF1-\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E45\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065-\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE-\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5-\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A-\uA62B\uA66E\uA6A0-\uA6E5\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,Ct=Vt(["","","",["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],"",["",""],["",""],"","",["",""],["",""],"",["",""],["",""],["",""],"",["",""],["",""],"","",["",""],["",""],["",""],["",""],["",""],["",""],["",""],"",["",""],"","",["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],["",""],"","",["",""],["",""],["",""],["",""],["",""],["",""],["",""],"",["",""],["",""],"","",["",""],["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],["",""],"","",["",""],["",""],["",""],["",""],["",""],"","",["",""],["",""],["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],["",""],"",["",""],"","",["",""],["",""],["",""],"","",["",""],["",""],["",""],"",["",""],["",""],"",["",""],["",""],["",""],["",""],"",["",""],["",""],"",["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],"",["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],"","",["",""],"",["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],"",["",""],"",["",""],["",""],"","",["",""],["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],"",["",""],["",""],["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""]],!1,!1),wt=/^[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/,Et=Vt(["","","","",["",""],["",""],["",""],"","",""],!1,!1),xt=/^[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178-\u0179\u017B\u017D\u0181-\u0182\u0184\u0186-\u0187\u0189-\u018B\u018E-\u0191\u0193-\u0194\u0196-\u0198\u019C-\u019D\u019F-\u01A0\u01A2\u01A4\u01A6-\u01A7\u01A9\u01AC\u01AE-\u01AF\u01B1-\u01B3\u01B5\u01B7-\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A-\u023B\u023D-\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E-\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9-\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0-\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E-\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D-\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA\uFF21-\uFF3A]/,At=Vt([["A","Z"],["",""],["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],"","",["",""],"",["",""],["",""],["",""],["",""],["",""],["",""],["",""],"","",["",""],"","",["",""],["",""],"",["",""],"","","","","","","","","","","","","","","","","","","","","","","",["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],["",""],"",["",""],"","","","","","","","",["",""],"",["",""],["",""],["",""],"",["",""],"","","","","","","","","","","","","","",["",""],["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],["",""],["",""],["",""],["",""],"","","","",["",""],["",""],["",""],["",""],["",""],["",""],"","",["",""],["",""],"",["",""],"","","",["",""],["",""],["",""],"","",["",""],"",["",""],"","","",["",""],"","",["",""],"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",["",""],"","","","","","","","","","","","","","",["",""]],!1,!1),Tt=/^[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]/,It=Vt([["",""],["",""],["",""],"",["",""],["",""],["",""]],!1,!1),Ot=/^[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/,_t=Vt([["0","9"],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""],["",""]],!1,!1),Lt=0,Rt=0,Bt=[{line:1,column:1}],Mt=0,Ft=[],Dt=0;if("startRule"in e){if(!(e.startRule in s))throw new Error("Can't start parsing from rule \""+e.startRule+'".');o=s[e.startRule]}function Nt(){return t.substring(Rt,Lt)}function kt(t,e){return{type:"literal",text:t,ignoreCase:e}}function Vt(t,e,i){return{type:"class",parts:t,inverted:e,ignoreCase:i}}function Gt(t){return{type:"other",description:t}}function zt(e){var i,n=Bt[e];if(n)return n;for(i=e-1;!Bt[i];)i--;for(n={line:(n=Bt[i]).line,column:n.column};i<e;)10===t.charCodeAt(i)?(n.line++,n.column=1):n.column++,i++;return Bt[e]=n,n}function jt(t,e){var i=zt(t),n=zt(e);return{start:{offset:t,line:i.line,column:i.column},end:{offset:e,line:n.line,column:n.column}}}function Ut(t){Lt<Mt||(Lt>Mt&&(Mt=Lt,Ft=[]),Ft.push(t))}function Wt(t,e,i){return new n(n.buildMessage(t,e),t,e,i)}function Ht(){var t,e;if(t=[],(e=qt())!==r)for(;e!==r;)t.push(e),e=qt();else t=r;return t}function qt(){var e,i,n,s,o,d,g;return e=Lt,ae()!==r?("strict"===t.substr(Lt,6).toLowerCase()?(i=t.substr(Lt,6),Lt+=6):(i=r,0===Dt&&Ut(a)),i===r&&(i=null),i!==r&&ae()!==r?("graph"===t.substr(Lt,5).toLowerCase()?(n=t.substr(Lt,5),Lt+=5):(n=r,0===Dt&&Ut(l)),n===r&&("digraph"===t.substr(Lt,7).toLowerCase()?(n=t.substr(Lt,7),Lt+=7):(n=r,0===Dt&&Ut(h))),n!==r&&ae()!==r?((s=Jt())===r&&(s=null),s!==r&&ae()!==r?(123===t.charCodeAt(Lt)?(o="{",Lt++):(o=r,0===Dt&&Ut(u)),o!==r?((d=Xt())===r&&(d=null),d!==r&&ae()!==r?(125===t.charCodeAt(Lt)?(g="}",Lt++):(g=r,0===Dt&&Ut(c)),g!==r&&ae()!==r?(Rt=e,e=function(t,e,i,n){null===n&&(n=[]);var r={type:e.toLowerCase(),children:n};return t&&(r.strict=!0),i&&(r.id=i),r}(i,n,s,d)):(Lt=e,e=r)):(Lt=e,e=r)):(Lt=e,e=r)):(Lt=e,e=r)):(Lt=e,e=r)):(Lt=e,e=r)):(Lt=e,e=r),e}function Xt(){var e,i,n,s,o,a,l;if(e=Lt,ae()!==r)if((i=Yt())!==r)if(ae()!==r)if(59===t.charCodeAt(Lt)?(n=";",Lt++):(n=r,0===Dt&&Ut(d)),n===r&&(n=null),n!==r){for(s=[],o=Lt,ae()!==r&&(a=Yt())!==r&&ae()!==r?(59===t.charCodeAt(Lt)?(l=";",Lt++):(l=r,0===Dt&&Ut(d)),l===r&&(l=null),l!==r?(Rt=o,o=g(0,a)):(Lt=o,o=r)):(Lt=o,o=r);o!==r;)s.push(o),o=Lt,ae()!==r&&(a=Yt())!==r&&ae()!==r?(59===t.charCodeAt(Lt)?(l=";",Lt++):(l=r,0===Dt&&Ut(d)),l===r&&(l=null),l!==r?(Rt=o,o=g(0,a)):(Lt=o,o=r)):(Lt=o,o=r);s!==r?(Rt=e,e=[i].concat(s)):(Lt=e,e=r)}else Lt=e,e=r;else Lt=e,e=r;else Lt=e,e=r;else Lt=e,e=r;return e}function Yt(){var e,i,n,s,o;return e=Lt,(i=Jt())!==r&&(n=ae())!==r?(61===t.charCodeAt(Lt)?(s="=",Lt++):(s=r,0===Dt&&Ut(f)),s!==r&&ae()!==r&&(o=Jt())!==r?(Rt=e,e=i={type:"attr_stmt",target:"graph",attr_list:[{type:"attr",id:i,eq:o}]}):(Lt=e,e=r)):(Lt=e,e=r),e===r&&(e=function(){var e,i,n;e=Lt,"graph"===t.substr(Lt,5).toLowerCase()?(i=t.substr(Lt,5),Lt+=5):(i=r,0===Dt&&Ut(l));i===r&&("node"===t.substr(Lt,4).toLowerCase()?(i=t.substr(Lt,4),Lt+=4):(i=r,0===Dt&&Ut(p)),i===r&&("edge"===t.substr(Lt,4).toLowerCase()?(i=t.substr(Lt,4),Lt+=4):(i=r,0===Dt&&Ut(m))));i!==r&&(n=Qt())!==r?(Rt=e,e=i={type:"attr_stmt",target:i,attr_list:n}):(Lt=e,e=r);return e}())===r&&(e=function(){var e,i,n,s;e=Lt,(i=Kt())===r&&(i=Zt());i!==r&&(n=function e(){var i,n,s,o,a;i=Lt,(n=ae())!==r?("->"===t.substr(Lt,2)?(s="->",Lt+=2):(s=r,0===Dt&&Ut(v)),s===r&&("--"===t.substr(Lt,2)?(s="--",Lt+=2):(s=r,0===Dt&&Ut(S))),s!==r&&ae()!==r?((o=Kt())===r&&(o=Zt()),o!==r&&ae()!==r?((a=e())===r&&(a=null),a!==r?(Rt=i,n=[{type:"edgeRHS",edgeop:s,id:o}].concat(a||[]),i=n):(Lt=i,i=r)):(Lt=i,i=r)):(Lt=i,i=r)):(Lt=i,i=r);return i}())!==r?((s=Qt())===r&&(s=null),s!==r?(Rt=e,o=s,i={type:"edge_stmt",edge_list:[i].concat(n.map((function(t){return t.id}))),attr_list:o||[]},e=i):(Lt=e,e=r)):(Lt=e,e=r);var o;return e}())===r&&(e=Kt())===r&&(e=function(){var t,e,i;t=Lt,(e=Zt())!==r?((i=Qt())===r&&(i=null),i!==r?(Rt=t,t=e={type:"node_stmt",node_id:e,attr_list:i||[]}):(Lt=t,t=r)):(Lt=t,t=r);return t}())===r&&(e=Lt,(i=Jt())!==r?(61===t.charCodeAt(Lt)?(n="=",Lt++):(n=r,0===Dt&&Ut(f)),n!==r&&(s=Jt())!==r?e=i=[i,n,s]:(Lt=e,e=r)):(Lt=e,e=r)),e}function Qt(){var e,i,n,s,o,a;return e=Lt,ae()!==r?(91===t.charCodeAt(Lt)?(i="[",Lt++):(i=r,0===Dt&&Ut(y)),i!==r&&ae()!==r?((n=function e(){var i,n,s,o,a,l,h;i=Lt,(n=ae())!==r&&(s=Jt())!==r?(o=Lt,ae()!==r?(61===t.charCodeAt(Lt)?(a="=",Lt++):(a=r,0===Dt&&Ut(f)),a!==r&&(l=ae())!==r&&(h=Jt())!==r?(Rt=o,o=h):(Lt=o,o=r)):(Lt=o,o=r),o===r&&(o=null),o!==r&&ae()!==r?(44===t.charCodeAt(Lt)?(a=",",Lt++):(a=r,0===Dt&&Ut(P)),a===r&&(59===t.charCodeAt(Lt)?(a=";",Lt++):(a=r,0===Dt&&Ut(d))),a===r&&(a=null),a!==r?((l=e())===r&&(l=null),l!==r?(Rt=i,n=[{type:"attr",id:s,eq:o}].concat(l||[]),i=n):(Lt=i,i=r)):(Lt=i,i=r)):(Lt=i,i=r)):(Lt=i,i=r);return i}())===r&&(n=null),n!==r&&ae()!==r?(93===t.charCodeAt(Lt)?(s="]",Lt++):(s=r,0===Dt&&Ut(b)),s!==r&&ae()!==r?((o=Qt())===r&&(o=null),o!==r?(Rt=e,a=o,e=(n||[]).concat(a||[])):(Lt=e,e=r)):(Lt=e,e=r)):(Lt=e,e=r)):(Lt=e,e=r)):(Lt=e,e=r),e}function Zt(){var e,i,n,s,o;return e=Lt,(i=Jt())!==r?((n=function(){var e,i,n,s,o,a;Dt++,e=Lt,58===t.charCodeAt(Lt)?(i=":",Lt++):(i=r,0===Dt&&Ut(w));i!==r&&(n=Jt())!==r?(s=Lt,58===t.charCodeAt(Lt)?(o=":",Lt++):(o=r,0===Dt&&Ut(w)),o!==r&&(a=$t())!==r?(Rt=s,s=o=a):(Lt=s,s=r),s===r&&(s=null),s!==r?(Rt=e,i=function(t,e){return{type:"port",id:t,compass_pt:e||null}}(n,s),e=i):(Lt=e,e=r)):(Lt=e,e=r);e===r&&(e=Lt,58===t.charCodeAt(Lt)?(i=":",Lt++):(i=r,0===Dt&&Ut(w)),i!==r&&(n=$t())!==r?(Rt=e,i=function(t){return{type:"port",compass_pt:t||null}}(n),e=i):(Lt=e,e=r));Dt--,e===r&&(i=r,0===Dt&&Ut(C));return e}())===r&&(n=null),n!==r?(Rt=e,s=i,e=i=(o=n)?{type:"node_id",id:s,port:o}:{type:"node_id",id:s}):(Lt=e,e=r)):(Lt=e,e=r),e}function Kt(){var e,i,n,s,o,a,l;return e=Lt,i=Lt,"subgraph"===t.substr(Lt,8).toLowerCase()?(n=t.substr(Lt,8),Lt+=8):(n=r,0===Dt&&Ut(E)),n!==r&&(s=ae())!==r?((o=Jt())===r&&(o=null),o!==r&&(a=ae())!==r?(Rt=i,i=n=(l=o)?{type:"subgraph",id:l}:{type:"subgraph"}):(Lt=i,i=r)):(Lt=i,i=r),i===r&&(i=null),i!==r?(123===t.charCodeAt(Lt)?(n="{",Lt++):(n=r,0===Dt&&Ut(u)),n!==r?((s=Xt())===r&&(s=null),s!==r&&(o=ae())!==r?(125===t.charCodeAt(Lt)?(a="}",Lt++):(a=r,0===Dt&&Ut(c)),a!==r?(Rt=e,e=i=function(t,e){return(t=t||{type:"subgraph"}).children=e||[],t}(i,s)):(Lt=e,e=r)):(Lt=e,e=r)):(Lt=e,e=r)):(Lt=e,e=r),e}function $t(){var e;return 110===t.charCodeAt(Lt)?(e="n",Lt++):(e=r,0===Dt&&Ut(x)),e===r&&("ne"===t.substr(Lt,2)?(e="ne",Lt+=2):(e=r,0===Dt&&Ut(A)),e===r&&(101===t.charCodeAt(Lt)?(e="e",Lt++):(e=r,0===Dt&&Ut(T)),e===r&&("se"===t.substr(Lt,2)?(e="se",Lt+=2):(e=r,0===Dt&&Ut(I)),e===r&&(115===t.charCodeAt(Lt)?(e="s",Lt++):(e=r,0===Dt&&Ut(O)),e===r&&("sw"===t.substr(Lt,2)?(e="sw",Lt+=2):(e=r,0===Dt&&Ut(_)),e===r&&(119===t.charCodeAt(Lt)?(e="w",Lt++):(e=r,0===Dt&&Ut(L)),e===r&&("nw"===t.substr(Lt,2)?(e="nw",Lt+=2):(e=r,0===Dt&&Ut(R))))))))),e}function Jt(){var e;return(e=te())===r&&(e=function(){var t,e,i;t=Lt,(e=ne())!==r&&(i=te())!==r?(Rt=t,t=e=e+i):(Lt=t,t=r);return t}())===r&&(e=ne())===r&&(e=function(){var e,i,n,s;e=Lt,34===t.charCodeAt(Lt)?(i='"',Lt++):(i=r,0===Dt&&Ut(W));if(i!==r){for(n=[],s=se();s!==r;)n.push(s),s=se();n!==r?(34===t.charCodeAt(Lt)?(s='"',Lt++):(s=r,0===Dt&&Ut(W)),s!==r?(Rt=e,i=H(n),e=i):(Lt=e,e=r)):(Lt=e,e=r)}else Lt=e,e=r;return e}())===r&&(e=function(){var e,i;e=Lt,(i=function e(){var i,n,s,o;i=Lt,60===t.charCodeAt(Lt)?(n="<",Lt++):(n=r,0===Dt&&Ut(z));if(n!==r){for(s=[],(o=re())===r&&(o=e());o!==r;)s.push(o),(o=re())===r&&(o=e());s!==r?(62===t.charCodeAt(Lt)?(o=">",Lt++):(o=r,0===Dt&&Ut(j)),o!==r?(Rt=i,n="<"+s.join("")+">",i=n):(Lt=i,i=r)):(Lt=i,i=r)}else Lt=i,i=r;return i}())!==r&&(Rt=e,i={type:"id",value:(n=i).slice(1,n.length-1),html:!0});var n;return e=i}()),e}function te(){var t,e,i,n;if(Dt++,t=Lt,(e=ee())!==r){for(i=[],n=ie();n!==r;)i.push(n),n=ie();i!==r?(Rt=t,t=e=e+i.join("")):(Lt=t,t=r)}else Lt=t,t=r;return Dt--,t===r&&(e=r,0===Dt&&Ut(B)),t}function ee(){var e;return(e=function(){var e;(e=function(){var e;xt.test(t.charAt(Lt))?(e=t.charAt(Lt),Lt++):(e=r,0===Dt&&Ut(At));return e}())===r&&(e=function(){var e;yt.test(t.charAt(Lt))?(e=t.charAt(Lt),Lt++):(e=r,0===Dt&&Ut(bt));return e}())===r&&(e=function(){var e;wt.test(t.charAt(Lt))?(e=t.charAt(Lt),Lt++):(e=r,0===Dt&&Ut(Et));return e}())===r&&(e=function(){var e;Pt.test(t.charAt(Lt))?(e=t.charAt(Lt),Lt++):(e=r,0===Dt&&Ut(vt));return e}())===r&&(e=function(){var e;St.test(t.charAt(Lt))?(e=t.charAt(Lt),Lt++):(e=r,0===Dt&&Ut(Ct));return e}())===r&&(e=function(){var e;Tt.test(t.charAt(Lt))?(e=t.charAt(Lt),Lt++):(e=r,0===Dt&&Ut(It));return e}());return e}())===r&&(36===t.charCodeAt(Lt)?(e="$",Lt++):(e=r,0===Dt&&Ut(M)),e===r&&(95===t.charCodeAt(Lt)?(e="_",Lt++):(e=r,0===Dt&&Ut(F)))),e}function ie(){var e;return(e=ee())===r&&(e=function(){var e;Ot.test(t.charAt(Lt))?(e=t.charAt(Lt),Lt++):(e=r,0===Dt&&Ut(_t));return e}()),e}function ne(){var e,i,n,s,o,a,l,h,u;if(Dt++,e=Lt,i=Lt,45===t.charCodeAt(Lt)?(n="-",Lt++):(n=r,0===Dt&&Ut(N)),n===r&&(n=null),n!==r){if(s=Lt,46===t.charCodeAt(Lt)?(o=".",Lt++):(o=r,0===Dt&&Ut(k)),o!==r){if(a=[],V.test(t.charAt(Lt))?(l=t.charAt(Lt),Lt++):(l=r,0===Dt&&Ut(G)),l!==r)for(;l!==r;)a.push(l),V.test(t.charAt(Lt))?(l=t.charAt(Lt),Lt++):(l=r,0===Dt&&Ut(G));else a=r;a!==r?s=o=[o,a]:(Lt=s,s=r)}else Lt=s,s=r;if(s===r){if(s=Lt,o=[],V.test(t.charAt(Lt))?(a=t.charAt(Lt),Lt++):(a=r,0===Dt&&Ut(G)),a!==r)for(;a!==r;)o.push(a),V.test(t.charAt(Lt))?(a=t.charAt(Lt),Lt++):(a=r,0===Dt&&Ut(G));else o=r;if(o!==r){if(a=Lt,46===t.charCodeAt(Lt)?(l=".",Lt++):(l=r,0===Dt&&Ut(k)),l!==r){for(h=[],V.test(t.charAt(Lt))?(u=t.charAt(Lt),Lt++):(u=r,0===Dt&&Ut(G));u!==r;)h.push(u),V.test(t.charAt(Lt))?(u=t.charAt(Lt),Lt++):(u=r,0===Dt&&Ut(G));h!==r?a=l=[l,h]:(Lt=a,a=r)}else Lt=a,a=r;a===r&&(a=null),a!==r?s=o=[o,a]:(Lt=s,s=r)}else Lt=s,s=r}s!==r?i=n=[n,s]:(Lt=i,i=r)}else Lt=i,i=r;return i!==r&&(Rt=e,i=parseFloat(Nt())),Dt--,(e=i)===r&&(i=r,0===Dt&&Ut(D)),e}function re(){var e,i,n,s,o;if(e=Lt,i=[],n=Lt,s=Lt,Dt++,62===t.charCodeAt(Lt)?(o=">",Lt++):(o=r,0===Dt&&Ut(j)),o===r&&(60===t.charCodeAt(Lt)?(o="<",Lt++):(o=r,0===Dt&&Ut(z))),Dt--,o===r?s=void 0:(Lt=s,s=r),s!==r?(t.length>Lt?(o=t.charAt(Lt),Lt++):(o=r,0===Dt&&Ut(U)),o!==r?(Rt=n,n=s=o):(Lt=n,n=r)):(Lt=n,n=r),n!==r)for(;n!==r;)i.push(n),n=Lt,s=Lt,Dt++,62===t.charCodeAt(Lt)?(o=">",Lt++):(o=r,0===Dt&&Ut(j)),o===r&&(60===t.charCodeAt(Lt)?(o="<",Lt++):(o=r,0===Dt&&Ut(z))),Dt--,o===r?s=void 0:(Lt=s,s=r),s!==r?(t.length>Lt?(o=t.charAt(Lt),Lt++):(o=r,0===Dt&&Ut(U)),o!==r?(Rt=n,n=s=o):(Lt=n,n=r)):(Lt=n,n=r);else i=r;return i!==r&&(Rt=e,i=i.join("")),e=i}function se(){var e,i,n;return(e=function(){var e,i,n,s;e=Lt,i=Lt,92===t.charCodeAt(Lt)?(n="\\",Lt++):(n=r,0===Dt&&Ut(q));n!==r?(t.length>Lt?(s=t.charAt(Lt),Lt++):(s=r,0===Dt&&Ut(U)),s!==r?i=n=[n,s]:(Lt=i,i=r)):(Lt=i,i=r);i!==r&&(Rt=e,i='"'===(o=i)[1]?'"':o[0]+o[1]);var o;return e=i}())===r&&(e=Lt,i=Lt,Dt++,34===t.charCodeAt(Lt)?(n='"',Lt++):(n=r,0===Dt&&Ut(W)),n===r&&(n=function(){var e;X.test(t.charAt(Lt))?(e=t.charAt(Lt),Lt++):(e=r,0===Dt&&Ut(Y));return e}()),Dt--,n===r?i=void 0:(Lt=i,i=r),i!==r&&(n=function(){var e;t.length>Lt?(e=t.charAt(Lt),Lt++):(e=r,0===Dt&&Ut(U));return e}())!==r?(Rt=e,e=i=Nt()):(Lt=e,e=r),e===r&&(e=function(){var e,i;e=Lt,92===t.charCodeAt(Lt)?(i="\\",Lt++):(i=r,0===Dt&&Ut(q));i!==r&&function(){var e;Dt++,10===t.charCodeAt(Lt)?(e="\n",Lt++):(e=r,0===Dt&&Ut(Z));e===r&&("\r\n"===t.substr(Lt,2)?(e="\r\n",Lt+=2):(e=r,0===Dt&&Ut(K)),e===r&&(13===t.charCodeAt(Lt)?(e="\r",Lt++):(e=r,0===Dt&&Ut($)),e===r&&(8232===t.charCodeAt(Lt)?(e="\u2028",Lt++):(e=r,0===Dt&&Ut(J)),e===r&&(8233===t.charCodeAt(Lt)?(e="\u2029",Lt++):(e=r,0===Dt&&Ut(tt))))));Dt--,e===r&&(r,0===Dt&&Ut(Q));return e}()!==r?(Rt=e,e=i=""):(Lt=e,e=r);return e}())),e}function oe(){var e;return Dt++,(e=function(){var e,i,n,s,o,a;Dt++,e=Lt,"/*"===t.substr(Lt,2)?(i="/*",Lt+=2):(i=r,0===Dt&&Ut(nt));if(i!==r){for(n=[],s=Lt,o=Lt,Dt++,"*/"===t.substr(Lt,2)?(a="*/",Lt+=2):(a=r,0===Dt&&Ut(rt)),Dt--,a===r?o=void 0:(Lt=o,o=r),o!==r?(t.length>Lt?(a=t.charAt(Lt),Lt++):(a=r,0===Dt&&Ut(U)),a!==r?(Rt=s,s=o=a):(Lt=s,s=r)):(Lt=s,s=r);s!==r;)n.push(s),s=Lt,o=Lt,Dt++,"*/"===t.substr(Lt,2)?(a="*/",Lt+=2):(a=r,0===Dt&&Ut(rt)),Dt--,a===r?o=void 0:(Lt=o,o=r),o!==r?(t.length>Lt?(a=t.charAt(Lt),Lt++):(a=r,0===Dt&&Ut(U)),a!==r?(Rt=s,s=o=a):(Lt=s,s=r)):(Lt=s,s=r);n!==r?("*/"===t.substr(Lt,2)?(s="*/",Lt+=2):(s=r,0===Dt&&Ut(rt)),s!==r?(Rt=e,i=n.join(""),e=i):(Lt=e,e=r)):(Lt=e,e=r)}else Lt=e,e=r;Dt--,e===r&&(i=r,0===Dt&&Ut(it));return e}())===r&&(e=function(){var e,i,n,s,o,a;Dt++,e=Lt,"//"===t.substr(Lt,2)?(i="//",Lt+=2):(i=r,0===Dt&&Ut(ot));if(i!==r){for(n=[],s=Lt,o=Lt,Dt++,at.test(t.charAt(Lt))?(a=t.charAt(Lt),Lt++):(a=r,0===Dt&&Ut(lt)),Dt--,a===r?o=void 0:(Lt=o,o=r),o!==r?(t.length>Lt?(a=t.charAt(Lt),Lt++):(a=r,0===Dt&&Ut(U)),a!==r?(Rt=s,s=o=a):(Lt=s,s=r)):(Lt=s,s=r);s!==r;)n.push(s),s=Lt,o=Lt,Dt++,at.test(t.charAt(Lt))?(a=t.charAt(Lt),Lt++):(a=r,0===Dt&&Ut(lt)),Dt--,a===r?o=void 0:(Lt=o,o=r),o!==r?(t.length>Lt?(a=t.charAt(Lt),Lt++):(a=r,0===Dt&&Ut(U)),a!==r?(Rt=s,s=o=a):(Lt=s,s=r)):(Lt=s,s=r);n!==r?(at.test(t.charAt(Lt))?(s=t.charAt(Lt),Lt++):(s=r,0===Dt&&Ut(lt)),s===r&&(s=null),s!==r?(Rt=e,i=ht(n),e=i):(Lt=e,e=r)):(Lt=e,e=r)}else Lt=e,e=r;Dt--,e===r&&(i=r,0===Dt&&Ut(st));return e}())===r&&(e=function(){var e,i,n,s,o,a;Dt++,e=Lt,35===t.charCodeAt(Lt)?(i="#",Lt++):(i=r,0===Dt&&Ut(ct));if(i!==r){for(n=[],s=Lt,o=Lt,Dt++,at.test(t.charAt(Lt))?(a=t.charAt(Lt),Lt++):(a=r,0===Dt&&Ut(lt)),Dt--,a===r?o=void 0:(Lt=o,o=r),o!==r?(t.length>Lt?(a=t.charAt(Lt),Lt++):(a=r,0===Dt&&Ut(U)),a!==r?(Rt=s,s=o=a):(Lt=s,s=r)):(Lt=s,s=r);s!==r;)n.push(s),s=Lt,o=Lt,Dt++,at.test(t.charAt(Lt))?(a=t.charAt(Lt),Lt++):(a=r,0===Dt&&Ut(lt)),Dt--,a===r?o=void 0:(Lt=o,o=r),o!==r?(t.length>Lt?(a=t.charAt(Lt),Lt++):(a=r,0===Dt&&Ut(U)),a!==r?(Rt=s,s=o=a):(Lt=s,s=r)):(Lt=s,s=r);n!==r?(at.test(t.charAt(Lt))?(s=t.charAt(Lt),Lt++):(s=r,0===Dt&&Ut(lt)),s===r&&(s=null),s!==r?(Rt=e,i=ht(n),e=i):(Lt=e,e=r)):(Lt=e,e=r)}else Lt=e,e=r;Dt--,e===r&&(i=r,0===Dt&&Ut(ut));return e}()),Dt--,e===r&&(r,0===Dt&&Ut(et)),e}function ae(){var t,e;for(Dt++,t=[],(e=he())===r&&(e=oe());e!==r;)t.push(e),(e=he())===r&&(e=oe());return Dt--,t===r&&(e=r,0===Dt&&Ut(dt)),t}function le(){var e,i;if(e=[],gt.test(t.charAt(Lt))?(i=t.charAt(Lt),Lt++):(i=r,0===Dt&&Ut(ft)),i!==r)for(;i!==r;)e.push(i),gt.test(t.charAt(Lt))?(i=t.charAt(Lt),Lt++):(i=r,0===Dt&&Ut(ft));else e=r;return e}function he(){var e,i;if(e=[],pt.test(t.charAt(Lt))?(i=t.charAt(Lt),Lt++):(i=r,0===Dt&&Ut(mt)),i===r&&(i=le()),i!==r)for(;i!==r;)e.push(i),pt.test(t.charAt(Lt))?(i=t.charAt(Lt),Lt++):(i=r,0===Dt&&Ut(mt)),i===r&&(i=le());else e=r;return e}if((i=o())!==r&&Lt===t.length)return i;throw i!==r&&Lt<t.length&&Ut({type:"end"}),Wt(Ft,Mt<t.length?t.charAt(Mt):null,Mt<t.length?jt(Mt,Mt+1):jt(Mt,Mt))}}},function(t,e,i){var n=i(103),r=function(){return new h};for(var s in n){r[s+"Raw"]=function(t){return function(e){return"number"==typeof e&&(e=Array.prototype.slice.call(arguments)),n[t](e)}}(s);var o=/(\w+)2(\w+)/.exec(s),a=o[1],l=o[2];(r[a]=r[a]||{})[l]=r[s]=function(t){return function(e){"number"==typeof e&&(e=Array.prototype.slice.call(arguments));var i=n[t](e);if("string"==typeof i||void 0===i)return i;for(var r=0;r<i.length;r++)i[r]=Math.round(i[r]);return i}}(s)}var h=function(){this.convs={}};h.prototype.routeSpace=function(t,e){var i=e[0];return void 0===i?this.getValues(t):("number"==typeof i&&(i=Array.prototype.slice.call(e)),this.setValues(t,i))},h.prototype.setValues=function(t,e){return this.space=t,this.convs={},this.convs[t]=e,this},h.prototype.getValues=function(t){var e=this.convs[t];if(!e){var i=this.space,n=this.convs[i];e=r[i][t](n),this.convs[t]=e}return e},["rgb","hsl","hsv","cmyk","keyword"].forEach((function(t){h.prototype[t]=function(e){return this.routeSpace(t,arguments)}})),t.exports=r},function(t,e){function i(t){var e,i,n=t[0]/255,r=t[1]/255,s=t[2]/255,o=Math.min(n,r,s),a=Math.max(n,r,s),l=a-o;return a==o?e=0:n==a?e=(r-s)/l:r==a?e=2+(s-n)/l:s==a&&(e=4+(n-r)/l),(e=Math.min(60*e,360))<0&&(e+=360),i=(o+a)/2,[e,100*(a==o?0:i<=.5?l/(a+o):l/(2-a-o)),100*i]}function n(t){var e,i,n=t[0],r=t[1],s=t[2],o=Math.min(n,r,s),a=Math.max(n,r,s),l=a-o;return i=0==a?0:l/a*1e3/10,a==o?e=0:n==a?e=(r-s)/l:r==a?e=2+(s-n)/l:s==a&&(e=4+(n-r)/l),(e=Math.min(60*e,360))<0&&(e+=360),[e,i,a/255*1e3/10]}function s(t){var e=t[0],n=t[1],r=t[2];return[i(t)[0],100*(1/255*Math.min(e,Math.min(n,r))),100*(r=1-1/255*Math.max(e,Math.max(n,r)))]}function o(t){var e,i=t[0]/255,n=t[1]/255,r=t[2]/255;return[100*((1-i-(e=Math.min(1-i,1-n,1-r)))/(1-e)||0),100*((1-n-e)/(1-e)||0),100*((1-r-e)/(1-e)||0),100*e]}function a(t){return E[JSON.stringify(t)]}function l(t){var e=t[0]/255,i=t[1]/255,n=t[2]/255;return[100*(.4124*(e=e>.04045?Math.pow((e+.055)/1.055,2.4):e/12.92)+.3576*(i=i>.04045?Math.pow((i+.055)/1.055,2.4):i/12.92)+.1805*(n=n>.04045?Math.pow((n+.055)/1.055,2.4):n/12.92)),100*(.2126*e+.7152*i+.0722*n),100*(.0193*e+.1192*i+.9505*n)]}function h(t){var e=l(t),i=e[0],n=e[1],r=e[2];return n/=100,r/=108.883,i=(i/=95.047)>.008856?Math.pow(i,1/3):7.787*i+16/116,[116*(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116)-16,500*(i-n),200*(n-(r=r>.008856?Math.pow(r,1/3):7.787*r+16/116))]}function u(t){var e,i,n,r,s,o=t[0]/360,a=t[1]/100,l=t[2]/100;if(0==a)return[s=255*l,s,s];e=2*l-(i=l<.5?l*(1+a):l+a-l*a),r=[0,0,0];for(var h=0;h<3;h++)(n=o+1/3*-(h-1))<0&&n++,n>1&&n--,s=6*n<1?e+6*(i-e)*n:2*n<1?i:3*n<2?e+(i-e)*(2/3-n)*6:e,r[h]=255*s;return r}function c(t){var e=t[0]/60,i=t[1]/100,n=t[2]/100,r=Math.floor(e)%6,s=e-Math.floor(e),o=255*n*(1-i),a=255*n*(1-i*s),l=255*n*(1-i*(1-s));n*=255;switch(r){case 0:return[n,l,o];case 1:return[a,n,o];case 2:return[o,n,l];case 3:return[o,a,n];case 4:return[l,o,n];case 5:return[n,o,a]}}function d(t){var e,i,n,s,o=t[0]/360,a=t[1]/100,l=t[2]/100,h=a+l;switch(h>1&&(a/=h,l/=h),n=6*o-(e=Math.floor(6*o)),0!=(1&e)&&(n=1-n),s=a+n*((i=1-l)-a),e){default:case 6:case 0:r=i,g=s,b=a;break;case 1:r=s,g=i,b=a;break;case 2:r=a,g=i,b=s;break;case 3:r=a,g=s,b=i;break;case 4:r=s,g=a,b=i;break;case 5:r=i,g=a,b=s}return[255*r,255*g,255*b]}function f(t){var e=t[0]/100,i=t[1]/100,n=t[2]/100,r=t[3]/100;return[255*(1-Math.min(1,e*(1-r)+r)),255*(1-Math.min(1,i*(1-r)+r)),255*(1-Math.min(1,n*(1-r)+r))]}function p(t){var e,i,n,r=t[0]/100,s=t[1]/100,o=t[2]/100;return i=-.9689*r+1.8758*s+.0415*o,n=.0557*r+-.204*s+1.057*o,e=(e=3.2406*r+-1.5372*s+-.4986*o)>.0031308?1.055*Math.pow(e,1/2.4)-.055:e*=12.92,i=i>.0031308?1.055*Math.pow(i,1/2.4)-.055:i*=12.92,n=n>.0031308?1.055*Math.pow(n,1/2.4)-.055:n*=12.92,[255*(e=Math.min(Math.max(0,e),1)),255*(i=Math.min(Math.max(0,i),1)),255*(n=Math.min(Math.max(0,n),1))]}function m(t){var e=t[0],i=t[1],n=t[2];return i/=100,n/=108.883,e=(e/=95.047)>.008856?Math.pow(e,1/3):7.787*e+16/116,[116*(i=i>.008856?Math.pow(i,1/3):7.787*i+16/116)-16,500*(e-i),200*(i-(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116))]}function y(t){var e,i,n,r,s=t[0],o=t[1],a=t[2];return s<=8?r=(i=100*s/903.3)/100*7.787+16/116:(i=100*Math.pow((s+16)/116,3),r=Math.pow(i/100,1/3)),[e=e/95.047<=.008856?e=95.047*(o/500+r-16/116)/7.787:95.047*Math.pow(o/500+r,3),i,n=n/108.883<=.008859?n=108.883*(r-a/200-16/116)/7.787:108.883*Math.pow(r-a/200,3)]}function P(t){var e,i=t[0],n=t[1],r=t[2];return(e=360*Math.atan2(r,n)/2/Math.PI)<0&&(e+=360),[i,Math.sqrt(n*n+r*r),e]}function v(t){return p(y(t))}function S(t){var e,i=t[0],n=t[1];return e=t[2]/360*2*Math.PI,[i,n*Math.cos(e),n*Math.sin(e)]}function C(t){return w[t]}t.exports={rgb2hsl:i,rgb2hsv:n,rgb2hwb:s,rgb2cmyk:o,rgb2keyword:a,rgb2xyz:l,rgb2lab:h,rgb2lch:function(t){return P(h(t))},hsl2rgb:u,hsl2hsv:function(t){var e=t[0],i=t[1]/100,n=t[2]/100;if(0===n)return[0,0,0];return[e,100*(2*(i*=(n*=2)<=1?n:2-n)/(n+i)),100*((n+i)/2)]},hsl2hwb:function(t){return s(u(t))},hsl2cmyk:function(t){return o(u(t))},hsl2keyword:function(t){return a(u(t))},hsv2rgb:c,hsv2hsl:function(t){var e,i,n=t[0],r=t[1]/100,s=t[2]/100;return e=r*s,[n,100*(e=(e/=(i=(2-r)*s)<=1?i:2-i)||0),100*(i/=2)]},hsv2hwb:function(t){return s(c(t))},hsv2cmyk:function(t){return o(c(t))},hsv2keyword:function(t){return a(c(t))},hwb2rgb:d,hwb2hsl:function(t){return i(d(t))},hwb2hsv:function(t){return n(d(t))},hwb2cmyk:function(t){return o(d(t))},hwb2keyword:function(t){return a(d(t))},cmyk2rgb:f,cmyk2hsl:function(t){return i(f(t))},cmyk2hsv:function(t){return n(f(t))},cmyk2hwb:function(t){return s(f(t))},cmyk2keyword:function(t){return a(f(t))},keyword2rgb:C,keyword2hsl:function(t){return i(C(t))},keyword2hsv:function(t){return n(C(t))},keyword2hwb:function(t){return s(C(t))},keyword2cmyk:function(t){return o(C(t))},keyword2lab:function(t){return h(C(t))},keyword2xyz:function(t){return l(C(t))},xyz2rgb:p,xyz2lab:m,xyz2lch:function(t){return P(m(t))},lab2xyz:y,lab2rgb:v,lab2lch:P,lch2lab:S,lch2xyz:function(t){return y(S(t))},lch2rgb:function(t){return v(S(t))}};var w={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},E={};for(var x in w)E[JSON.stringify(w[x])]=x},function(t,e){},function(t,e,i){"use strict";i.r(e);var n={};i.r(n),i.d(n,"filename",(function(){return Gl})),i.d(n,"dirname",(function(){return zl})),i.d(n,"join",(function(){return jl}));var r,s,o,a,l,h=i(12);class u{constructor(){this.attrs=[],this._parent=null}clearAttr(){this.attrs=[]}setAttr(t,e){this.attrs[t]=e}getAttr(t){return this.attrs[t]}get parent(){return this._parent}set parent(t){this._parent=t}*getAncestors(){let t=this.parent;for(;null!=t;)yield t,t=t.parent}isDescendantOf(t){for(const e of this.getAncestors())if(e==t)return!0;return!1}}!function(t){t[t.None=0]="None",t[t.FromAncestor=1]="FromAncestor",t[t.ToAncestor=2]="ToAncestor"}(r||(r={}));class c extends u{constructor(t,e){super(),this.source=t,this.target=e,t!=e?(t.outEdges.add(this),e.inEdges.add(this)):t.selfEdges.add(this)}add(){this.source!=this.target?(this.source.outEdges.add(this),this.target.inEdges.add(this)):this.source.selfEdges.add(this)}remove(){this.source!=this.target?(this.source.outEdges.delete(this),this.target.inEdges.delete(this)):this.source.selfEdges.delete(this)}toString(){return"("+this.source.toString()+"->"+this.target.toString()+")"}isInterGraphEdge(){return this.source.parent!=this.target.parent}EdgeToAncestor(){return this.source instanceof p&&this.target.isDescendantOf(this.source)?r.FromAncestor:this.target instanceof p&&this.source.isDescendantOf(this.target)?r.ToAncestor:r.None}}class d{static assert(t,e=null){if(!t){if(null!=e)throw console.log(e),new Error(e);throw new Error("condition does not hold")}}}class g extends u{constructor(t){super(),this.inEdges=new Set,this.outEdges=new Set,this.selfEdges=new Set,this.id=t}get id(){return this._id}set id(t){this._id=t}toString(){return this.id}*_edges(){for(const t of this.inEdges)yield t;for(const t of this.outEdges)yield t;for(const t of this.selfEdges)yield t}addInEdge(t){d.assert(null!=t),d.assert(t.target==this),this.inEdges.add(t)}addOutEdge(t){this.outEdges.add(t)}addSelfEdge(t){this.selfEdges.add(t)}addEdde(t){if(this==t.source)t.target==this?this.addSelfEdge(t):this.addOutEdge(t);else{if(this!=t.target)throw new Error("attaching an edge to non adjacent node");this.addInEdge(t)}return t}get edges(){return this._edges()}get outDegree(){return this.outEdges.size}get inDegree(){return this.inEdges.size}get selfDegree(){return this.selfEdges.size}get degree(){return this.outDegree+this.inDegree+this.selfDegree}*getAncestors(){let t=this.parent;for(;null!=t;)yield t,t=t.parent}isUnderCollapsedGraph(){return null!=this.parent&&this.parent.isCollapsed}}class f{constructor(){this.nodeMap=new Map}*nodes_(){for(const t of this.nodeMap.values())yield t}*graphs_(){for(const t of this.nodes_())t instanceof p&&(yield t)}find(t){return this.nodeMap.get(t)}get nodesShallow(){return this.nodes_()}*nodesDeep(){for(const t of this.nodes_())if(yield t,t instanceof p)for(const e of t.nodeCollection.nodesDeep())yield e}get graphs(){return this.graphs_()}*_edges(){for(const t of this.nodeMap.values()){for(const e of t.outEdges)yield e;for(const e of t.selfEdges)yield e}}interGraphEdges(){throw new Error("not implemented")}hasNode(t){if(this.nodeMap.has(t))return!0;for(const e of this.nodeMap)if(e[1]instanceof p&&e[1].nodeCollection.hasNode(t))return!0;return!1}getNode(t){let e=this.nodeMap.get(t);if(null!=e)return e;for(const i of this.nodeMap)if(i[1]instanceof p&&(e=i[1].nodeCollection.getNode(t),null!=e))return e}get nodeShallowCount(){return this.nodeMap.size}get nodeDeepCount(){let t=this.nodeMap.size;for(const e of this.nodeMap.values())e instanceof p&&(t+=e.nodeCollection.nodeDeepCount);return t}get edgeCount(){let t=0;for(const e of this.nodeMap.values())t+=e.outDegree+e.selfDegree;return t}get edges(){return this._edges()}addNode(t){null==this.getNode(t.id)&&this.nodeMap.set(t.id,t)}addEdge(t){this.addNode(t.source),this.addNode(t.target),t.source!=t.target?(t.source.outEdges.add(t),t.target.inEdges.add(t)):t.source.selfEdges.add(t)}removeNode(t){for(const e of t.outEdges)e.target.inEdges.delete(e);for(const e of t.inEdges)e.source.outEdges.delete(e);this.nodeMap.delete(t.id);for(const e of this.nodeMap.values())if(e instanceof p){e.nodeCollection.nodeMap.delete(t.id)}}nodeIsConsistent(t){for(const e of t.outEdges){if(e.source!=t)return!1;if(e.source==e.target)return!1;if(!this.nodeMap.has(e.target.id))return!1}for(const e of t.inEdges)return e.target==t&&(e.source!=e.target&&!!this.nodeMap.has(e.source.id));for(const e of t.selfEdges){if(e.target!=e.source)return!1;if(e.source==t)return!1}return!0}isConsistent(){for(const t of this.nodeMap)if(!this.nodeIsConsistent(t[1]))return!1;return!0}}class p extends g{constructor(t="__graph__"){super(t),this.isCollapsed=!1,this.nodeCollection=new f}*graphs(){for(const t of this.nodeCollection.graphs)yield t}noEmptySubgraphs(){for(const t of this.subgraphs())if(0==t.shallowNodeCount)return!1;return!0}hasSubgraphs(){for(const t of this.shallowNodes)if(t instanceof p)return!0;return!1}*subgraphs(){for(const t of this.deepNodes)t instanceof p&&(yield t)}isEmpty(){return 0==this.shallowNodeCount}setEdge(t,e){const i=this.nodeCollection.find(t);if(null==i)return;const n=this.nodeCollection.find(e);if(null==n)return;const r=new c(i,n);return this.addEdge(r),r}get shallowNodes(){return this.nodeCollection.nodesShallow}get deepNodes(){return this.nodeCollection.nodesDeep()}findNode(t){return this.nodeCollection.find(t)}get edges(){return this.nodeCollection.edges}*deepEdges(){for(const t of this.deepNodes){for(const e of t.outEdges)yield e;for(const e of t.selfEdges)yield e}}isConsistent(){return this.nodeCollection.isConsistent()}nodeIsConsistent(t){return this.nodeCollection.nodeIsConsistent(t)}removeNode(t){this.nodeCollection.removeNode(t)}addNode(t){return t.parent=this,this.nodeCollection.addNode(t),t}addEdge(t){this.nodeCollection.addEdge(t)}get shallowNodeCount(){return this.nodeCollection.nodeShallowCount}get nodeCountDeep(){return this.nodeCollection.nodeDeepCount}get edgeCount(){return this.nodeCollection.edgeCount}liftNode(t){for(;null!=t&&t.parent!=this;)t=t.parent;return t}}class m{static solve(t,e,i,n,r,s){const o=t*r-n*e;if(!(Math.abs(o)<m.eps))return{x:(i*r-s*e)/o,y:(t*s-n*i)/o}}}m.eps=1e-8;class y{static RoundPoint(t){return new E(y.RoundDouble(t.x),y.RoundDouble(t.y))}static RoundDouble(t){return Math.round(t*y.mult)/y.mult}}function b(t,e){const i=t-e;return i<0?-1:0==i?0:1}function P(t,e){const i=b(t.y,e.y);return i||b(t.x,e.x)}function v(t,e){const i=t-e;return-y.distanceEpsilon<=i&&i<=y.distanceEpsilon}function S(t,e){return C(t,e)>0}function C(t,e){const i=t-e;return i<=-y.distanceEpsilon?-1:i>=y.distanceEpsilon?1:0}function w(t,e){return t.sub(e).length}y.distanceEpsilonPrecision=6,y.mult=Math.pow(10,6),y.defaultLeafBoxesOffset=.5,y.lineSegmentThreshold=.05,y.intersectionEpsilon=1e-4,y.distanceEpsilon=Math.pow(10,-y.distanceEpsilonPrecision),y.squareOfDistanceEpsilon=Math.pow(10,2*-y.distanceEpsilonPrecision),y.tolerance=1e-8,function(t){t[t.Clockwise=0]="Clockwise",t[t.Counterclockwise=1]="Counterclockwise",t[t.Collinear=2]="Collinear"}(s||(s={}));class E{constructor(t,e){this.x_=t,this.y_=e}static ProjectionToLine(t,e,i){let n=e.sub(t);const r=n.length;if(r<y.distanceEpsilon)return t;n=n.div(r);const s=i.sub(t).dot(n);return t.add(n.mul(s))}static RayIntersectsRayInteriors(t,e,i,n){const r=E.lineLineIntersection(t,t.add(e),i,i.add(n));if(r)return r.sub(t).dot(e.div(e.l1))>y.distanceEpsilon&&r.sub(i).dot(n.div(n.l1))>y.distanceEpsilon?r:void 0}static IntervalIntersectsRay(t,e,i,n){const r=E.lineLineIntersection(t,e,i,i.add(n));if(!r)return;const s=t.sub(r),o=r.sub(e);return s.dot(o)<=0||r.sub(i).dot(n)<0?void 0:s.dot(s)>y.squareOfDistanceEpsilon&&o.dot(o)>=y.squareOfDistanceEpsilon?r:void 0}static PointToTheLeftOfLineOrOnLine(t,e,i){return E.signedDoubledTriangleArea(t,e,i)>=0}static PointToTheLeftOfLine(t,e,i){return E.signedDoubledTriangleArea(t,e,i)>0}static PointIsInsideCone(t,e,i,n){return E.PointToTheRightOfLineOrOnLine(t,e,i)&&E.PointToTheLeftOfLineOrOnLine(t,e,n)}static PointToTheRightOfLineOrOnLine(t,e,i){return E.signedDoubledTriangleArea(e,i,t)<=0}static PointToTheRightOfLine(t,e,i){return E.signedDoubledTriangleArea(e,i,t)<0}static closeIntersections(t,e){return E.close(t,e,y.intersectionEpsilon)}get l1(){return Math.abs(this.x_)+Math.abs(this.y_)}dot(t){return this.x*t.x+this.y*t.y}get x(){return this.x_}get y(){return this.y_}compareTo(t){const e=b(this.x,t.x);return 0!=e?e:b(this.y,t.y)}toString(){return"("+this.x+","+this.y+")"}static close(t,e,i){return t.sub(e).length<=i}static closeSquare(t,e,i){const n=e.sub(t);return n.dot(n)<=i}static closeDistEps(t,e,i=y.distanceEpsilon){return t.sub(e).length<=i}normalize(){const t=this.length;return new E(this.x/t,this.y/t)}get length(){return Math.sqrt(this.x*this.x+this.y*this.y)}get lengthSquared(){return this.x*this.x+this.y*this.y}static middle(t,e){return t.add(e).div(2)}scale(t,e){return new E(this.x*t,this.y*e)}add(t){return new E(this.x+t.x,this.y+t.y)}sub(t){return new E(this.x-t.x,this.y-t.y)}mul(t){return new E(this.x*t,this.y*t)}div(t){return new E(this.x/t,this.y/t)}equal(t){return t.x==this.x&&t.y==this.y}neg(){return new E(-this.x,-this.y)}static lineLineIntersection(t,e,i,n){const r=e.sub(t),s=i.sub(n),o=i.sub(t),a=m.solve(r.x,s.x,o.x,r.y,s.y,o.y);return null!=a?t.add(r.mul(a.x)):void 0}static segSegIntersection(t,e,i,n){const r=e.sub(t),s=i.sub(n),o=i.sub(t),a=y.tolerance,l=m.solve(r.x,s.x,o.x,r.y,s.y,o.y);return null!=l&&l.x>-a&&l.x<1+a&&l.y>-a&&l.y<1+a?t.add(r.mul(l.x)):void 0}static parallelWithinEpsilon(t,e,i){const n=t.length,r=e.length;return n<i||r<i||(t=t.div(n),e=e.div(r),Math.abs(-t.x*e.y+t.y*e.x)<i)}static crossProduct(t,e){return t.x*e.y-t.y*e.x}static dot(t,e){return t.x*e.x+t.y*e.y}static add(t,e){return t.add(e)}rotate90Ccw(){return new E(-this.y,this.x)}rotate90Cw(){return new E(this.y,-this.x)}clone(){return new E(this.x,this.y)}rotate(t){const e=Math.cos(t),i=Math.sin(t);return new E(e*this.x-i*this.y,i*this.x+e*this.y)}static mkPoint(t,e,i,n){return e.mul(t).add(n.mul(i))}static convSum(t,e,i){return e.add(i.sub(e).mul(t))}static anglePCP(t,e,i){return E.angle(t.sub(e),i.sub(e))}static angle(t,e){const i=t.x,n=t.y,r=e.x,s=e.y,o=i*s-n*r,a=i*r+n*s;if(Math.abs(a)<y.tolerance)return Math.abs(o)<y.tolerance?0:o<-y.tolerance?3*Math.PI/2:Math.PI/2;if(Math.abs(o)<y.tolerance)return a<-y.tolerance?Math.PI:0;const l=Math.atan2(o,a);return o>=-y.tolerance?l:2*Math.PI+l}static signedDoubledTriangleArea(t,e,i){return(e.x-t.x)*(i.y-t.y)-(i.x-t.x)*(e.y-t.y)}static getTriangleOrientation(t,e,i){const n=E.signedDoubledTriangleArea(t,e,i);return n>y.distanceEpsilon?s.Counterclockwise:n<-y.distanceEpsilon?s.Clockwise:s.Collinear}static getTriangleOrientationWithIntersectionEpsilon(t,e,i){const n=E.signedDoubledTriangleArea(t,e,i);return n>y.intersectionEpsilon?s.Counterclockwise:n<-y.intersectionEpsilon?s.Clockwise:s.Collinear}static ClosestPointAtLineSegment(t,e,i){const n=i.sub(e),r=t.sub(e),s=n.dot(r),o=n.dot(n);return s<=0+y.tolerance?e:o<=s+y.tolerance?i:e.add(n.mul(s/o))}static pointToTheLeftOfLineOrOnLine(t,e,i){return E.signedDoubledTriangleArea(t,e,i)>=0}static pointToTheLeftOfLine(t,e,i){return E.signedDoubledTriangleArea(t,e,i)>0}static pointToTheRightOfLineOrOnLine(t,e,i){return E.signedDoubledTriangleArea(e,i,t)<=0}static pointToTheRightOfLine(t,e,i){return E.signedDoubledTriangleArea(e,i,t)<0}static canProject(t,e,i){const n=i.sub(e);if(t.sub(e).dot(n)<0)return!1;return!(t.sub(i).dot(n)>0)}static distToLineSegment(t,e,i){const n=i.sub(e),r=t.sub(e);let s,o;if((s=n.dot(r))<=y.tolerance)return{par:0,dist:r.length};if((o=n.dot(n))<=s+y.tolerance)return{par:1,dist:t.sub(i).length};const a=s/o;return{par:a,dist:e.add(n.mul(a)).length}}}class x{constructor(){this._next=null,this.prev=null}get point(){return this._point}set point(t){this._point=t}get next(){return this._next}set next(t){this._next=t}get nextOnPolyline(){return this.polyline.next(this)}get prevOnPolyline(){return this.polyline.prev(this)}getNext(){return this.next}setNext(t){this.next=t,null!=this.polyline&&this.polyline.setInitIsRequired()}getPrev(){return this.prev}setPrev(t){this.prev=t,null!=this.polyline&&this.polyline.setInitIsRequired()}static mkFromPoint(t){const e=new x;return e.point=t,e}}!function(t){t[t.Corner=0]="Corner",t[t.VertexA=1]="VertexA",t[t.otherCorner=2]="otherCorner",t[t.VertexB=3]="VertexB"}(o||(o={}));class A{contains(t){const e=t.sub(this.corner),i=y.distanceEpsilon,n=e.dot(this.bRot);if(n>this.abRot+i||n<-i)return!1;const r=e.dot(this.aRot);return r<=this.baRot+i&&r>=-i}get area(){return Math.abs(this.a.x*this.b.y-this.a.y*this.b.x)}vertex(t){switch(t){case o.Corner:return this.corner;case o.VertexA:return this.aPlusCorner;case o.otherCorner:return this.otherCorner;case o.VertexB:return this.bPlusCorner;default:return}}static parallelogramOfTwo(t,e){const i=new A,n=t.corner,r={minx:n.x,maxx:n.x,miny:n.y,maxy:n.y};return A.pumpMinMax(r,t.aPlusCorner),A.pumpMinMax(r,t.otherCorner),A.pumpMinMax(r,t.bPlusCorner),A.pumpMinMax(r,e.corner),A.pumpMinMax(r,e.aPlusCorner),A.pumpMinMax(r,e.otherCorner),A.pumpMinMax(r,e.bPlusCorner),i.corner=new E(r.minx,r.miny),i.a=new E(0,r.maxy-r.miny),i.b=new E(r.maxx-r.minx,0),i.aPlusCorner=i.a.add(i.corner),i.otherCorner=i.b.add(i.aPlusCorner),i.bPlusCorner=i.b.add(i.corner),i.aRot=new E(-i.a.y,i.a.x),i.aRot.length>.5&&(i.aRot=i.aRot.normalize()),i.bRot=new E(-i.b.y,i.b.x),i.bRot.length>.5&&(i.bRot=i.bRot.normalize()),i.abRot=i.a.dot(i.bRot),i.baRot=i.b.dot(i.aRot),i.abRot<0&&(i.abRot=-i.abRot,i.bRot=i.bRot.neg()),i.baRot<0&&(i.baRot=-i.baRot,i.aRot=i.aRot.neg()),i.isSeg=i.a.sub(i.b).length<y.distanceEpsilon,i}static pumpMinMax(t,e){e.x<t.minx?t.minx=e.x:e.x>t.maxx&&(t.maxx=e.x),e.y<t.miny?t.miny=e.y:e.y>t.maxy&&(t.maxy=e.y)}static intersect(t,e){return 0!=!(A.separByA(t,e)||A.separByA(e,t)||A.separByB(t,e)||A.separByB(e,t))&&(!t.isSeg||!e.isSeg||(!E.parallelWithinEpsilon(t.otherCorner.sub(t.corner),e.otherCorner.sub(e.corner),1e-5)||A.ParallelSegsIntersect(e,t)))}static ParallelSegsIntersect(t,e){const i=t.corner,n=t.otherCorner,r=e.corner,s=e.otherCorner,o=n.sub(i),a=o.dot(o);let l=r.sub(i).dot(o),h=s.sub(i).dot(o);if(l>h){const t=l;l=h,h=t}return!(h<0-y.distanceEpsilon||l>a+y.distanceEpsilon)}static separByB(t,e){const i=y.distanceEpsilon,n=e.vertex(0).sub(t.corner).dot(t.bRot),r=[o.VertexA,o.otherCorner,o.VertexB];if(n>t.abRot+i){for(const n of r)if(e.vertex(n).sub(t.corner).dot(t.bRot)<=t.abRot+i)return!1;return!0}if(n<-i){for(const n of r)if(e.vertex(n).sub(t.corner).dot(t.bRot)>=-i)return!1;return!0}return!1}static separByA(t,e){const i=y.distanceEpsilon;let n=e.corner.sub(t.corner);const r=E.dot(n,t.aRot);return r>t.baRot+i?(n=e.aPlusCorner.sub(t.corner),!(E.dot(n,t.aRot)<=t.baRot+i)&&(n=e.bPlusCorner.sub(t.corner),!(E.dot(n,t.aRot)<=t.baRot+i)&&(n=e.otherCorner.sub(t.corner),!(E.dot(n,t.aRot)<=t.baRot+i)))):r<-i&&(n=e.aPlusCorner.sub(t.corner),!(E.dot(n,t.aRot)>=-i)&&(n=e.bPlusCorner.sub(t.corner),!(E.dot(n,t.aRot)>=-i)&&(n=e.otherCorner.sub(t.corner),!(E.dot(n,t.aRot)>=-i))))}static parallelogramByCornerSideSide(t,e,i){const n=new A;return n.corner=t,n.a=e,n.b=i,n.aRot=new E(-e.y,e.x),n.aRot.length>.5&&(n.aRot=n.aRot.normalize()),n.bRot=new E(-i.y,i.x),n.bRot.length>.5&&(n.bRot=n.bRot.normalize()),n.abRot=n.bRot.dot(e),n.baRot=i.dot(n.aRot),n.abRot<0&&(n.abRot=-n.abRot,n.bRot=n.bRot.neg()),n.baRot<0&&(n.baRot=-n.baRot,n.aRot=n.aRot.neg()),n.isSeg=e.sub(i).length<y.distanceEpsilon,n.aPlusCorner=e.add(t),n.otherCorner=i.add(n.aPlusCorner),n.bPlusCorner=i.add(t),n}static getParallelogramOfAGroup(t){let e=0,i=0,n=0,r=0,s=!0;for(const o of t){const t=T(o);for(const o of t){const t=o.x,a=o.y;s?(s=!1,e=i=t,n=r=a):(t<e?e=t:t>i&&(i=t),a<n?n=a:a>r&&(r=a))}}return A.parallelogramByCornerSideSide(new E(e,n),new E(0,r-n),new E(i-e,0))}}function*T(t){yield t.corner,yield t.aPlusCorner,yield t.otherCorner,yield t.bPlusCorner}class I{constructor(t,e,i,n){this.parStart=0,this.parEnd=1,this.start=new E(t,e),this.end=new E(i,n)}offsetCurve(t,e){return null}trim(t,e){if((t=Math.max(this.parStart,t))>(e=Math.min(this.parEnd,e)))throw"wrong params in trimming";const i=this.value(t),n=this.value(e);return E.close(i,n,y.distanceEpsilon)?null:I.mkPP(i,n)}value(t){return this.start.add(this.end.sub(this.start).mul(t))}trimWithWrap(t,e){return null}pNodeOverICurve(){const t=this.end.sub(this.start).mul(.5);return{parallelogram:A.parallelogramByCornerSideSide(this.start,t,t),seg:this,leafBoxesOffset:0,node:{low:0,high:1,chord:this}}}normal(){let t=this.start.sub(this.end);return t=t.div(t.length),new E(-t.y,t.x)}static mkPP(t,e){return new I(t.x,t.y,e.x,e.y)}static mkLinePXY(t,e,i){return new I(t.x,t.y,e,i)}derivative(t){return this.end.sub(this.start)}secondDerivative(t){return new E(0,0)}thirdDerivative(t){return new E(0,0)}reverse(){return I.mkPP(this.end,this.start)}translate(t){this.start=this.start.add(t),this.end=this.end.add(t)}scaleFromOrigin(t,e){return I.mkPP(this.start.scale(t,e),this.end.scale(t,e))}getParameterAtLength(t){const e=this.end.sub(this.start).length;if(e<y.tolerance)return 0;const i=t/e;return i>1?1:i<0?0:i}transform(t){return I.mkPP(t.multiplyPoint(this.start),t.multiplyPoint(this.end))}closestParameterWithinBounds(t,e,i){let n=this.closestParameter(t);return n<e&&(n=e),n>i&&(n=i),n}lengthPartial(t,e){return this.value(e).sub(this.value(t)).length}get length(){return this.start.sub(this.end).length}get boundingBox(){return G.mkPP(this.start,this.end)}clone(){return I.mkPP(this.start.clone(),this.end.clone())}static closestParameterOnLineSegment(t,e,i){const n=i.sub(e),r=t.sub(e),s=n.dot(r);if(s<=0+y.tolerance)return 0;const o=n.dot(n);return o<=s+y.tolerance?1:s/o}closestParameter(t){return I.closestParameterOnLineSegment(t,this.start,this.end)}leftDerivative(t){return this.derivative(t)}rightDerivative(t){return this.derivative(t)}static IntersectPPPP(t,e,i,n){const r=E.lineLineIntersection(t,e,i,n);if(null!=r)return I.xIsBetweenPoints(t,e,r)&&I.xIsBetweenPoints(i,n,r)?r:void 0}static xIsBetweenPoints(t,e,i){return t.sub(i).dot(e.sub(i))<=y.distanceEpsilon}curvature(t){return 0}curvatureDerivative(t){return 0}curvatureSecondDerivative(t){return 0}static minDistBetweenLineSegments(t,e,i,n){const r=e.sub(t),s=n.sub(i),o=t.sub(i),a=E.crossProduct(r,s),l=r.dot(r),h=r.dot(s),u=s.dot(s),c=r.dot(o),d=s.dot(o);let g,f;const p=Math.abs(a);let m=p,b=p;p<y.tolerance?(g=0,m=1,f=d,b=u):(g=E.crossProduct(s,o),f=E.crossProduct(r,o),a<0&&(g=-g,f=-f),g<0?(g=0,f=d,b=u):g>m&&(g=m=1,f=d+h,b=u)),f<0?(f=0,-c<0?g=0:-c>l?g=m:(g=-c,m=l)):f>b&&(f=b=1,-c+h<0?g=0:-c+h>l?g=m:(g=-c+h,m=l));const P=Math.abs(g)<y.tolerance?0:g/m,v=Math.abs(f)<y.tolerance?0:f/b;return{parab:P,parcd:v,dist:o.add(r.mul(P).sub(s.mul(v))).length}}}class O{static distToSegm(t,e,i){const n=i.sub(e);if(n.length<y.intersectionEpsilon)return t.sub(e.add(i).div(2)).length;let r=new E(-n.y,n.x);return r=r.mul(1/r.length),Math.abs(t.sub(e).dot(r))}static createParallelogramOnSubSeg(t,e,i){let n=i.derivative(t);const r=i.derivative(e),s=new E(-r.y,r.x),o=i.value(t),a=i.value(e),l=a.sub(o).dot(s),h=n.dot(s),u=Math.abs(l)<y.distanceEpsilon;if(!u&&Math.abs(h)<y.distanceEpsilon)return;const c=u?0:l/h;return n=n.mul(c),A.parallelogramByCornerSideSide(o,n,a.sub(o).sub(n))}static createParallelogramNodeForCurveSeg(t,e,i,n){if(t==i.parStart&&e==i.parEnd&&E.close(i.start,i.end,y.distanceEpsilon))return O.createNodeWithSegmentSplit(t,e,i,n);const r=i.value(t),s=i.value(e),o=s.sub(r),a=i.value((t+e)/2);if(O.distToSegm(a,r,s)<=y.intersectionEpsilon&&o.dot(o)<y.lineSegmentThreshold*y.lineSegmentThreshold&&e-t<y.lineSegmentThreshold){const n=I.mkPP(r,s),o=n.pNodeOverICurve();o.seg=i;const a=o.node;return a.low=t,a.high=e,a.chord=n,o}if(O.WithinEpsilon(i,t,e,n)){const r=O.createParallelogramOnSubSeg(t,e,i);if(null!=r)return function(t,e,i,n,r){return{parallelogram:i,seg:n,leafBoxesOffset:r,node:{low:t,high:e,chord:null}}}(t,e,r,i,n)}return O.createNodeWithSegmentSplit(t,e,i,n)}static WithinEpsilon(t,e,i,n){const r=(i-e)/3,s=t.value(e),o=t.value(i);if(O.distToSegm(t.value(e+r),s,o)>n)return!1;return O.distToSegm(t.value(e+2*r),s,o)<=n}static createParallelogramNodeForCurveSegDefaultOffset(t){return O.createParallelogramNodeForCurveSeg(t.parStart,t.parEnd,t,y.defaultLeafBoxesOffset)}static createNodeWithSegmentSplit(t,e,i,n){const r={parallelogram:null,seg:i,leafBoxesOffset:1,node:{children:[]}},s=r.node;return s.children.push(O.createParallelogramNodeForCurveSeg(t,.5*(t+e),i,n)),s.children.push(O.createParallelogramNodeForCurveSeg(.5*(t+e),e,i,n)),r.parallelogram=A.parallelogramOfTwo(s.children[0].parallelogram,s.children[1].parallelogram),r}}class _{constructor(t,e,i,n,r){this.par0=t,this.par1=e,this.x=i,this.seg0=n,this.seg1=r}}class L{static closestPoint(t,e,i,n,r){let s,o=i,a=0,l=0,h=!1;do{const i=t.value(o),h=t.derivative(o),u=t.secondDerivative(o),c=h.dot(h)+i.sub(e).dot(u);if(Math.abs(c)<y.tolerance)return o;s=i.sub(e).dot(h.div(c)),o-=s,o>r+y.tolerance?(o=r,l++):o<n-y.tolerance&&(o=n,l++),a++}while(Math.abs(s)>y.tolerance&&!(h=a>=5||l>=5));return h&&t.value(i).sub(e).length<y.distanceEpsilon&&(o=i),o}}class R{constructor(t,e,i,n,r){this.parStart=t,this.parEnd=e,this.aAxis=i,this.bAxis=n,this.center=r,this.pNode=null,this.setBoundingBox()}offsetCurve(t,e){const i=e.sub(this.center),n=E.angle(this.aAxis,i);if(this.aAxis.mul(Math.cos(n)).add(this.bAxis.mul(Math.sin(n))).length<i.length){const e=this.aAxis.length,i=this.bAxis.length;return R.mkEllipsePPP(this.aAxis.normalize().mul(e+t),this.bAxis.normalize().mul(i+t),this.center)}{const e=this.aAxis.length,i=this.bAxis.length;return R.mkEllipsePPP(this.aAxis.normalize().mul(e-t),this.bAxis.normalize().mul(i-t),this.center)}}reverse(){return null}static mkEllipsePPP(t,e,i){return new R(0,2*Math.PI,t,e,i)}get start(){return this.value(this.parStart)}get end(){return this.value(this.parEnd)}trim(t,e){return new R(Math.max(t,this.parStart),Math.min(e,this.parEnd),this.aAxis,this.bAxis,this.center)}trimWithWrap(t,e){return null}get boundingBox(){return this.box}value(t){return this.center.add(E.mkPoint(Math.cos(t),this.aAxis,Math.sin(t),this.bAxis))}derivative(t){return E.mkPoint(-Math.sin(t),this.aAxis,Math.cos(t),this.bAxis)}secondDerivative(t){return E.mkPoint(-Math.cos(t),this.aAxis,-Math.sin(t),this.bAxis)}thirdDerivative(t){return E.mkPoint(Math.sin(t),this.aAxis,-Math.cos(t),this.bAxis)}pNodeOverICurve(){return null!=this.pNode?this.pNode:this.pNode=O.createParallelogramNodeForCurveSegDefaultOffset(this)}setBoundingBox(){if(v(this.parStart,0)&&v(this.parEnd,2*Math.PI))this.box=this.fullBox();else{let t;this.box=G.mkPP(this.start,this.end);for(let e=Math.ceil(this.parStart/(Math.PI/2));(t=e*Math.PI/2)<this.parEnd;e++)t>this.parStart&&this.box.add(this.value(t))}}static mkEllipse(t,e,i,n,r,s){return new R(t,e,i,n,new E(r,s))}static mkFullEllipsePPP(t,e,i){return new R(0,2*Math.PI,t,e,i)}static mkFullEllipseNNP(t,e,i){return new R(0,2*Math.PI,new E(t,0),new E(0,e),i)}static mkCircle(t,e){return R.mkFullEllipseNNP(t,t,e)}translate(t){this.center=this.center.add(t),this.box.center=this.box.center.add(t),this.pNode=null}scaleFromOrigin(t,e){return new R(this.parStart,this.parEnd,this.aAxis.mul(t),this.bAxis.mul(e),this.center.scale(t,e))}getParameterAtLength(t){let e=this.parStart,i=this.parEnd;const n=t+.001,r=t-.001;for(;i-e>y.distanceEpsilon;){const t=.5*(i+e),s=this.lengthPartial(this.parStart,t);if(s>n)i=t;else{if(!(s<r))return t;e=t}}return(i+e)/2}transform(t){if(null!=t){const e=t.multiplyPoint(this.aAxis).sub(t.offset()),i=t.multiplyPoint(this.bAxis).sub(t.offset());return new R(this.parStart,this.parEnd,e,i,t.multiplyPoint(this.center))}return this}closestParameterWithinBounds(t,e,i){const n=(i-e)/9;let r=e,s=Number.MAX_VALUE;for(let i=0;i<=8;i++){const o=e+i*n,a=t.sub(this.value(o)),l=a.dot(a);l<s&&(s=l,r=o)}0==r&&i==2*Math.PI&&(e=-Math.PI);let o=L.closestPoint(this,t,r,e,i);return o<0&&(o+=2*Math.PI),o}lengthPartial(t,e){return F.lengthWithInterpolationAndThreshold(this.trim(t,e),y.lineSegmentThreshold/100)}get length(){return F.lengthWithInterpolation(this)}clone(){return new R(this.parStart,this.parEnd,this.aAxis.clone(),this.bAxis.clone(),this.center.clone())}closestParameter(t){let e=0;const i=(this.parEnd-this.parStart)/9;let n=this.parStart,r=Number.MAX_VALUE;for(let e=0;e<=8;e++){const s=this.parStart+e*i,o=t.sub(this.value(s)),a=o.dot(o);a<r&&(r=a,n=s)}let s=!1;0==n&&this.parEnd==2*Math.PI&&(s=!0,e=this.parStart,this.parStart=-Math.PI);let o=L.closestPoint(this,t,n,this.parStart,this.parEnd);return o<0&&(o+=2*Math.PI),s&&(this.parStart=e),o}leftDerivative(t){return this.derivative(t)}rightDerivative(t){return this.derivative(t)}curvature(t){throw"NotImplementedException()"}curvatureDerivative(t){throw"NotImplementedException();"}curvatureSecondDerivative(t){throw"NotImplementedException()"}orientedCounterclockwise(){return E.crossProduct(this.aAxis,this.bAxis)>0}fullBox(){const t=this.aAxis.add(this.bAxis);return G.mkPP(this.center.add(t),this.center.sub(t))}isArc(){return Math.abs(this.aAxis.dot(this.bAxis))<y.tolerance&&Math.abs(this.aAxis.length-this.bAxis.length)<y.tolerance&&E.closeDistEps(this.aAxis.rotate90Ccw(),this.bAxis)}}class B{constructor(t,e,i,n,r,s,o,a){this.curveA=t,this.curveB=e,this.aMin=i,this.bMin=r,this.aMax=n,this.bMax=s,this.aGuess=o,this.bGuess=a,this.si=o,this.ti=a}initValues(){this.a=this.curveA.value(this.si),this.b=this.curveB.value(this.ti),this.a_b=this.a.sub(this.b),this.ad=this.curveA.derivative(this.si),this.add=this.curveA.secondDerivative(this.si),this.bd=this.curveB.derivative(this.ti),this.bdd=this.curveB.secondDerivative(this.ti)}Fs(){return this.a_b.dot(this.ad)}Fss(){return this.a_b.dot(this.add)+this.ad.dot(this.ad)}Fst(){return-this.bd.dot(this.ad)}Ftt(){return-this.a_b.dot(this.bdd)+this.bd.dot(this.bd)}Ft(){return-this.a_b.dot(this.bd)}delta(t,e,i,n){return t*n-i*e}solve(){let t=0;let e=0;let i,n=!1;if(this.initValues(),this.curveA instanceof I&&this.curveB instanceof I){let t=this.curveB.derivative(0);t=t.div(t.length);const e=this.curveA.normal(),i=Math.abs(e.dot(t));if(Math.abs(i)<y.distanceEpsilon||this.delta(this.Fss(),this.Fst(),this.Fst(),this.Ftt())<y.tolerance)return this.success=!0,void this.parallelLineSegLineSegMinDist()}do{const r=this.delta(this.Fss(),this.Fst(),this.Fst(),this.Ftt());if(Math.abs(r)<y.tolerance){this.success=!1,n=!0;break}i={s:this.delta(-this.Fs(),this.Fst(),-this.Ft(),this.Ftt())/r,t:this.delta(this.Fss(),-this.Fs(),this.Fst(),-this.Ft())/r};const s=this.si+i.s,o=this.ti+i.t;let a;s>this.aMax+y.distanceEpsilon||s<this.aMin-y.distanceEpsilon||o>this.bMax+y.distanceEpsilon||o<this.bMin-y.distanceEpsilon?(t++,this.chopDsDt(i),this.si+=i.s,this.ti+=i.t,a=!0):(a=!1,this.si=s,this.ti=o,this.si>this.aMax?this.si=this.aMax:this.si<this.aMin&&(this.si=this.aMin),this.ti>this.bMax?this.ti=this.bMax:this.ti<this.bMin&&(this.ti=this.bMin)),this.initValues(),e++,n=t>=10||e>=100||0==i.s&&0==i.t&&a}while((Math.abs(i.s)>=y.tolerance||Math.abs(i.t)>=y.tolerance)&&!n);if(n){const t=this.curveA.value(this.aGuess).sub(this.curveB.value(this.bGuess));if(t.dot(t)<y.distanceEpsilon*y.distanceEpsilon)return this.aSolution=this.aGuess,this.bSolution=this.bGuess,this.aPoint=this.curveA.value(this.aGuess),this.bPoint=this.curveB.value(this.bGuess),void(this.success=!0)}this.aSolution=this.si,this.bSolution=this.ti,this.aPoint=this.a,this.bPoint=this.b,this.success=!n}chopDsDt(t){if(0!=t.s&&0!=t.t){let e=1;this.si+t.s>this.aMax?e=(this.aMax-this.si)/t.s:this.si+t.s<this.aMin&&(e=(this.aMin-this.si)/t.s);let i=1;this.ti+t.t>this.bMax?i=(this.bMax-this.ti)/t.t:this.ti+t.t<this.bMin&&(i=(this.bMin-this.ti)/t.t);const n=Math.min(e,i);t.s*=n,t.t*=n}else 0==t.s?this.ti+t.t>this.bMax?t.t=this.bMax-this.ti:this.ti+t.t<this.bMin&&(t.t=this.bMin-this.ti):this.si+t.s>this.aMax?t.s=this.aMax-this.si:this.si+t.s<this.aMin&&(t.s=this.aMin-this.si)}parallelLineSegLineSegMinDist(){const t=this.curveA,e=this.curveB,i=t.start,n=t.end,r=e.start,s=e.end;let o=n.sub(i);const a=o.length;let l,h,u,c=0;if(a>y.distanceEpsilon){o=o.div(a),l=o.dot(n.sub(i)),h=o.dot(r.sub(i)),u=o.dot(s.sub(i));let t=!1;if(h>u){t=!0;const e=h;h=u,u=e}if(u<c)this.aSolution=0,this.bSolution=t?0:1;else if(h>l)this.aSolution=1,this.bSolution=t?1:0;else{const e=Math.min(l,u);this.aSolution=e/(l-c),this.bSolution=(e-h)/(u-h),t&&(this.bSolution=1-this.bSolution)}}else{let t=s.sub(r);const e=t.length;if(e>y.distanceEpsilon)if(t=t.div(e),c=0,l=t.dot(s.sub(r)),h=t.dot(i.sub(r)),h<c)this.bSolution=0,this.aSolution=1;else if(h>l)this.bSolution=1,this.aSolution=0;else{const t=Math.min(l,h);this.bSolution=t/(l-c),this.aSolution=0}else this.aSolution=0,this.bSolution=0}this.aPoint=this.curveA.value(this.aSolution),this.bPoint=this.curveB.value(this.bSolution)}}class M{constructor(t,e,i,n){this.b=new Array(4),this.parStart=0,this.parEnd=1,this.b[0]=t,this.b[1]=e,this.b[2]=i,this.b[3]=n,this.c=this.b[1].sub(this.b[0]).mul(3),this.e=this.b[2].sub(this.b[1]).mul(3).sub(this.c),this.l=this.b[3].sub(this.b[0]).sub(this.c).sub(this.e)}leftDerivative(t){return this.derivative(t)}rightDerivative(t){return this.derivative(t)}B(t){return this.b[t]}pNodeOverICurve(){return null!=this.pBoxNode?this.pBoxNode:this.pBoxNode=O.createParallelogramNodeForCurveSegDefaultOffset(this)}value(t){const e=t*t,i=e*t;return this.l.mul(i).add(this.e.mul(e).add(this.c.mul(t)).add(this.b[0]))}static adjustParamTo01(t){return t>1?1:t<0?0:t}trim(t,e){if((t=M.adjustParamTo01(t))>(e=M.adjustParamTo01(e)))return this.trim(e,t);if(t>1-y.tolerance)return new M(this.b[3],this.b[3],this.b[3],this.b[3]);const i=new Array(3),n=new Array(2),r=this.casteljau(t,i,n),s=new M(r,n[1],i[2],this.b[3]),o=s.casteljau((e-t)/(1-t),i,n);return new M(s.b[0],i[0],n[0],o)}trimWithWrap(t,e){throw"NotImplementedException()"}casteljau(t,e,i){const n=1-t;for(let i=0;i<3;i++)e[i]=E.mkPoint(n,this.b[i],t,this.b[i+1]);for(let r=0;r<2;r++)i[r]=E.mkPoint(n,e[r],t,e[r+1]);return E.mkPoint(n,i[0],t,i[1])}derivative(t){return this.l.mul(3*t*t).add(this.e.mul(2*t)).add(this.c)}secondDerivative(t){return E.mkPoint(6*t,this.l,2,this.e)}thirdDerivative(t){return this.l.mul(6)}get start(){return this.b[0]}get end(){return this.b[3]}reverse(){return new M(this.b[3],this.b[2],this.b[1],this.b[0])}translate(t){this.b[0]=this.b[0].add(t),this.b[1]=this.b[1].add(t),this.b[2]=this.b[2].add(t),this.b[3]=this.b[3].add(t),this.c=this.b[1].sub(this.b[0]).mul(3),this.e=this.b[2].sub(this.b[1]).mul(3).sub(this.c),this.l=this.b[3].sub(this.b[0]).sub(this.c).sub(this.e),this.pBoxNode=null}scaleFromOrigin(t,e){return new M(this.b[0].scale(t,e),this.b[1].scale(t,e),this.b[2].scale(t,e),this.b[3].scale(t,e))}offsetCurve(t,e){return null}lengthPartial(t,e){return this.trim(t,e).length}get length(){return M.lengthOnControlPolygon(this.b[0],this.b[1],this.b[2],this.b[3])}static lengthOnControlPolygon(t,e,i,n){const r=n.sub(t).length,s=e.sub(t).length+i.sub(e).length+n.sub(i).length;if(s-r>y.lineSegmentThreshold){const r=E.middle(t,e),s=E.middle(e,i),o=E.middle(i,n),a=E.middle(r,s),l=E.middle(o,s),h=E.middle(a,l);return M.lengthOnControlPolygon(t,r,a,h)+M.lengthOnControlPolygon(h,l,o,n)}return(s+r)/2}get boundingBox(){const t=G.mkPP(this.b[0],this.b[1]);return t.add(this.b[2]),t.add(this.b[3]),t}transform(t){return new M(t.multiplyPoint(this.b[0]),t.multiplyPoint(this.b[1]),t.multiplyPoint(this.b[2]),t.multiplyPoint(this.b[3]))}closestParameterWithinBounds(t,e,i){const n=(i-e)/8;let r=0,s=Number.MAX_VALUE;for(let i=0;i<9;i++){const o=t.sub(this.value(i*n+e)),a=o.dot(o);a<s&&(s=a,r=i*n+e)}return L.closestPoint(this,t,r,e,i)}clone(){return new M(this.b[0],this.b[1],this.b[2],this.b[3])}static mkBezier(t){return new M(t[0],t[1],t[2],t[3])}curvature(t){const e=this.G(t);return this.F(t)/e}F(t){return this.Xp(t)*this.Ypp(t)-this.Yp(t)*this.Xpp(t)}G(t){const e=this.Xp(t),i=this.Yp(t),n=e*e+i*i;return Math.sqrt(n*n*n)}Xp(t){return 3*this.l.x*t*t+2*this.e.x*t+this.c.x}Ypp(t){return 6*this.l.y*t+2*this.e.y}Yp(t){return 3*this.l.y*t*t+2*this.e.y*t+this.c.y}Xpp(t){return 6*this.l.x*t+2*this.e.x}Xppp(t){return 6*this.l.x}Yppp(t){return 6*this.l.y}curvatureDerivative(t){const e=this.G(t);return(this.Fp(t)*e-this.Gp(t)*this.F(t))/(e*e)}Fp(t){return this.Xp(t)*this.Yppp(t)-this.Yp(t)*this.Xppp(t)}Fpp(t){return this.Xpp(t)*this.Yppp(t)-this.Ypp(t)*this.Xppp(t)}closestParameter(t){let e=0,i=Number.MAX_VALUE;for(let n=0;n<9;n++){const r=t.sub(this.value(n*(1/8))),s=r.dot(r);s<i&&(i=s,e=n*(1/8))}return L.closestPoint(this,t,e,0,1)}curvatureSecondDerivative(t){const e=this.G(t);return(this.Qp(t)*e-2*this.Q(t)*this.Gp(t))/(e*e*e)}Q(t){return this.Fp(t)*this.G(t)-this.Gp(t)*this.F(t)}Qp(t){return this.Fpp(t)*this.G(t)-this.Gpp(t)*this.F(t)}Gpp(t){const e=this.Xp(t),i=this.Yp(t),n=this.Xpp(t),r=this.Ypp(t),s=this.Xppp(t),o=this.Yppp(t),a=Math.sqrt(e*e+i*i),l=e*n+i*r;return 3*(l*l/a+a*(n*n+e*s+r*r+i*o))}Gp(t){const e=this.Xp(t),i=this.Yp(t),n=this.Xpp(t),r=this.Ypp(t);return 3*Math.sqrt(e*e+i*i)*(e*n+i*r)}getParameterAtLength(t){let e=0,i=1;for(;i-e>y.tolerance;){const n=(i+e)/2,r=this.evaluateError(t,n);if(r>0)i=n;else{if(!(r<0))return n;e=n}}return(e+i)/2}evaluateError(t,e){const i=1-e,n=E.mkPoint(i,this.b[0],e,this.b[1]),r=E.mkPoint(i,this.b[1],e,this.b[2]),s=E.mkPoint(i,this.b[2],e,this.b[3]),o=E.mkPoint(i,n,e,r),a=E.mkPoint(i,r,e,s),l=E.mkPoint(i,o,e,a),h=M.lengthOnControlPolygon(this.b[0],n,o,l);return h>t+y.distanceEpsilon?1:h<t-y.distanceEpsilon?-1:0}}!function(t){t[t.Outside=0]="Outside",t[t.Boundary=1]="Boundary",t[t.Inside=2]="Inside"}(a||(a={}));class F{constructor(){this.segs=[],this.parEnd_=0}static CurvesIntersect(t,e){return t==e||null!=F.intersectionOne(t,e,!1)}static lengthWithInterpolationAndThreshold(t,e){throw new Error("not implemented")}static lengthWithInterpolation(t){throw"not implemented"}get parStart(){return 0}get parEnd(){return this.parEnd_}lengthPartial(t,e){const i={start:t,end:e};this.adjustStartEndEndParametersToDomain(i);const n=this.getSegIndexParam(t),r=this.getSegIndexParam(e);if(n.segIndex<r.segIndex){let t=this.segs[n.segIndex],e=t.lengthPartial(n.par,t.parEnd);for(let t=n.segIndex+1;t<r.segIndex;t++)e+=this.segs[t].length;return t=this.segs[r.segIndex],e+t.lengthPartial(t.parStart,r.par)}throw new Error("not implemented.")}reverse(){const t=new F;for(let e=this.segs.length-1;e>=0;e--)t.addSegment(this.segs[e].reverse());return t}mkCurveWithSegs(t){this.segs=t;for(const e of t)this.parEnd_+=F.paramSpan(e)}get start(){return this.segs[0].start}get end(){return this.segs[this.segs.length-1].end}scaleFromOrigin(t,e){const i=new F;for(const n of this.segs)i.addSegment(n.scaleFromOrigin(t,e));return i}trim(t,e){const i={start:t,end:e};this.adjustStartEndEndParametersToDomain(i);const n=this.getSegIndexParam(i.start),r=this.getSegIndexParam(i.end);if(n.segIndex==r.segIndex)return this.segs[n.segIndex].trim(n.par,r.par);let s=new F;n.par<this.segs[n.segIndex].parEnd&&(s=s.addSegment(this.segs[n.segIndex].trim(n.par,this.segs[n.segIndex].parEnd)));for(let t=n.segIndex+1;t<r.segIndex;t++)s=s.addSegment(this.segs[t]);return this.segs[r.segIndex].parStart<r.par&&(s=s.addSegment(this.segs[r.segIndex].trim(this.segs[r.segIndex].parStart,r.par))),s}translate(t){for(const e of this.segs)e.translate(t);this.pBNode=null}adjustStartEndEndParametersToDomain(t){if(t.start>t.end){const e=t.start;t.start=t.end,t.end=e}t.start<this.parStart&&(t.start=this.parStart),t.end>this.parEnd&&(t.end=this.parEnd)}trimWithWrap(t,e){if(t<e)return this.trim(t,e);const i=new F;return i.addSegment(this.trim(t,this.parEnd)),i.addSegment(this.trim(this.parStart,e)),i}addSegs(t){for(const e of t)this.addSegment(e);return this}addSegment(t){if(null==t)return this;if(t instanceof F)for(const e of t.segs)this.segs.push(e),this.parEnd_+=F.paramSpan(e);else this.segs.push(t),this.parEnd_+=F.paramSpan(t);return this}pNodeOverICurve(){if(null!=this.pBNode)return this.pBNode;const t=[],e=[];for(const i of this.segs){const n=i.pNodeOverICurve();t.push(n.parallelogram),e.push(n)}return this.pBNode={parallelogram:A.getParallelogramOfAGroup(t),seg:this,leafBoxesOffset:y.defaultLeafBoxesOffset,node:{children:e}},this.pBNode}static intersectionOne(t,e,i){let n=F.curveCurveXWithParallelogramNodesOne(t.pNodeOverICurve(),e.pNodeOverICurve());return i&&null!=n&&(n=F.liftIntersectionToCurves(t,e,n)),n}static getAllIntersections(t,e,i){return t instanceof I?F.getAllIntersectionsOfLineAndICurve(t,e,i):F.getAllIntersectionsInternal(t,e,i)}static getAllIntersectionsInternal(t,e,i){const n=[];if(F.curveCurveXWithParallelogramNodes(t.pNodeOverICurve(),e.pNodeOverICurve(),n),i)for(let i=0;i<n.length;i++)n[i]=F.liftIntersectionToCurves(t,e,n[i]);return n}static getAllIntersectionsOfLineAndICurve(t,e,i){return e instanceof k?F.getAllIntersectionsOfLineAndPolyline(t,e):e instanceof F?F.getAllIntersectionsOfLineAndCurve(t,e,i):e instanceof R&&e.isArc()?F.getAllIntersectionsOfLineAndArc(t,e):F.getAllIntersectionsInternal(t,e,i)}static getAllIntersectionsOfLineAndCurve(t,e,i){const n=[],r=t.pNodeOverICurve(),s=e.pNodeOverICurve();if(0==A.intersect(r.parallelogram,s.parallelogram))return n;let o=0;for(const r of e.segs){const s=F.getAllIntersections(t,r,!1);if(i){for(const t of s)t.par1+=o-r.parStart,t.seg1=e;o+=r.parEnd-r.parStart}for(const t of s)F.alreadyInside(n,t)||n.push(t)}return n}static closeIntersections(t,e){return E.close(t.x,e.x,y.intersectionEpsilon)}static closeIntersectionPoints(t,e){return E.close(t,e,y.intersectionEpsilon)}static alreadyInside(t,e){for(let i=0;i<t.length;i++){const n=t[i];if(F.closeIntersections(n,e))return!0}return!1}static getAllIntersectionsOfLineAndArc(t,e){let i=t.end.sub(t.start);const n=[],r=i.length;if(r<y.distanceEpsilon){const i=t.start.sub(e.center);if(v(i.length,e.aAxis.length)){let r=E.angle(e.aAxis,i);e.parStart-y.tolerance<=r&&(r=Math.max(r,e.parStart),r<=e.parEnd+y.tolerance&&(r=Math.min(e.parEnd,r),n.push(new _(0,r,t.start,t,e))))}return n}const s=i.rotate90Ccw().div(r),o=t.start.sub(e.center).dot(s),a=e.center.add(s.mul(o)),l=e.aAxis.length,h=Math.abs(o);if(l<h-y.distanceEpsilon)return n;if(i=s.rotate90Cw(),v(l,h))F.tryToAddPointToLineCircleCrossing(t,e,n,a,r,i);else{const s=Math.sqrt(l*l-o*o),h=i.mul(s);F.tryToAddPointToLineCircleCrossing(t,e,n,a.add(h),r,i),F.tryToAddPointToLineCircleCrossing(t,e,n,a.sub(h),r,i)}return n}static tryToAddPointToLineCircleCrossing(t,e,i,n,r,s){let o=n.sub(t.start).dot(s);if(o<-y.distanceEpsilon)return;if(o=Math.max(o,0),o>r+y.distanceEpsilon)return;o=Math.min(o,r),o/=r;let a=E.angle(e.aAxis,n.sub(e.center));e.parStart-y.tolerance<=a&&(a=Math.max(a,e.parStart),a<=e.parEnd+y.tolerance&&(a=Math.min(e.parEnd,a),i.push(new _(o,a,n,t,e))))}static getAllIntersectionsOfLineAndPolyline(t,e){const i=[];let n=0,r=e.startPoint;for(;null!=r&&null!=r.getNext();r=r.getNext()){const s=F.crossTwoLineSegs(t.start,t.end,r.point,r.getNext().point,0,1,0,1);null!=s&&(F.adjustSolution(t.start,t.end,r.point,r.getNext().point,s),F.oldIntersection(i,s.x)||i.push(new _(s.aSol,n+s.bSol,s.x,t,e))),n++}if(e.closed){const s=F.crossTwoLineSegs(t.start,t.end,r.point,e.start,0,1,0,1);null!=s&&(F.adjustSolution(t.start,t.end,r.point,e.start,s),F.oldIntersection(i,s.x)||i.push(new _(s.aSol,n+s.bSol,s.x,t,e)))}return i}static adjustSolution(t,e,i,n,r){F.closeIntersectionPoints(r.x,t)?(r.x=t,r.aSol=0):F.closeIntersectionPoints(r.x,e)&&(r.x=e,r.aSol=1),F.closeIntersectionPoints(r.x,i)?(r.x=i,r.bSol=Math.floor(r.bSol)):F.closeIntersectionPoints(r.x,n)&&(r.x=n,r.bSol=Math.ceil(r.bSol))}static curveCurveXWithParallelogramNodesOne(t,e){if(!A.intersect(t.parallelogram,e.parallelogram))return null;const i=t.node,n=e.node,r=i.hasOwnProperty("children"),s=n.hasOwnProperty("children");if(r&&s)for(const t of i.children)for(const e of n.children){const i=F.curveCurveXWithParallelogramNodesOne(t,e);if(null!=i)return i}else if(s)for(const e of n.children){const i=F.curveCurveXWithParallelogramNodesOne(t,e);if(null!=i)return i}else{if(!r)return F.crossOverIntervalsOne(t,e);for(const t of i.children){const i=F.curveCurveXWithParallelogramNodesOne(t,e);if(null!=i)return i}}return null}static curveCurveXWithParallelogramNodes(t,e,i){if(!A.intersect(t.parallelogram,e.parallelogram))return;const n=t.node.hasOwnProperty("children"),r=e.node.hasOwnProperty("children");if(n&&r)for(const n of t.node.children)for(const t of e.node.children)F.curveCurveXWithParallelogramNodes(n,t,i);else if(r)for(const n of e.node.children)F.curveCurveXWithParallelogramNodes(t,n,i);else if(n)for(const n of t.node.children)F.curveCurveXWithParallelogramNodes(n,e,i);else i=F.crossOverLeaves(t,e,i)}static crossOverIntervalsOne(t,e){const i=t.node,n=e.node,r=(i.high-i.low)/2,s=(n.high-n.low)/2;for(let o=1;o<2;o++){const a=o*r+i.low;for(let r=1;r<2;r++){const l=r*s+n.low;let h;if(null==i.chord&&null==n.chord?h=F.crossWithinIntervalsWithGuess(t.seg,e.seg,i.low,i.high,n.low,n.high,a,l):null!=i.chord&&null==n.chord?h=F.crossWithinIntervalsWithGuess(i.chord,e.seg,0,1,n.low,n.high,.5*o,l):null==i.chord?(h=F.crossWithinIntervalsWithGuess(t.seg,n.chord,i.low,i.high,0,1,a,.5*r),null!=h&&(h.bSol=n.low+h.bSol*(n.high-n.low))):(h=F.crossWithinIntervalsWithGuess(i.chord,n.chord,0,1,0,1,.5*o,.5*r),null!=h&&(h.aSol=i.low+h.aSol*(i.high-i.low),h.bSol=n.low+h.bSol*(n.high-n.low))),null!=h)return F.createIntersectionOne(t,e,h.aSol,h.bSol,h.x)}}return F.goDeeperOne(t,e)}static crossOverLeaves(t,e,i){const n=t.node,r=e.node;let s=!1;const o=(n.high-n.low)/2+n.low,a=(r.high-r.low)/2+r.low;let l;return null==n.chord&&null==r.chord?l=F.crossWithinIntervalsWithGuess(t.seg,e.seg,n.low,n.high,r.low,r.high,o,a):null!=n.chord&&null==r.chord?(l=F.crossWithinIntervalsWithGuess(n.chord,e.seg,0,1,r.low,r.high,.5,a),null!=l&&(l.aSol=n.low+l.aSol*(n.high-n.low))):null==n.chord?(l=F.crossWithinIntervalsWithGuess(t.seg,r.chord,n.low,n.high,0,1,o,.5),null!=l&&(l.bSol=r.low+l.bSol*(r.high-r.low))):(l=F.crossWithinIntervalsWithGuess(n.chord,r.chord,0,1,0,1,.5,.5),null!=l&&(l.bSol=r.low+l.bSol*(r.high-r.low),l.aSol=n.low+l.aSol*(n.high-n.low))),null!=l&&(F.addIntersection(t,e,i,l),s=!0),s||F.goDeeper(i,t,e),i}static addIntersection(t,e,i,n){const r=t.node;F.closeIntersectionPoints(n.x,t.seg.value(r.low))?(n.x=t.seg.value(r.low),n.aSol=r.low):F.closeIntersectionPoints(n.x,t.seg.value(r.high))&&(n.x=t.seg.value(r.high),n.aSol=r.high);const s=e.node;F.closeIntersectionPoints(n.x,e.seg.value(s.low))?(n.x=e.seg.value(s.low),n.bSol=s.low):F.closeIntersectionPoints(n.x,e.seg.value(s.high))&&(n.x=e.seg.value(s.high),n.bSol=s.high);if(!F.oldIntersection(i,n.x)){const r=new _(n.aSol,n.bSol,n.x,t.seg,e.seg);i.push(r)}}static oldIntersection(t,e){for(const i of t)if(e.sub(i.x).length<100*y.distanceEpsilon)return!0;return!1}static createIntersectionOne(t,e,i,n,r){const s=t.node,o=e.node;return F.closeIntersectionPoints(r,t.seg.value(s.low))?(r=t.seg.value(s.low),i=s.low):F.closeIntersectionPoints(r,t.seg.value(s.high))&&(r=t.seg.value(s.high),i=s.high),F.closeIntersectionPoints(r,e.seg.value(o.low))?(r=e.seg.value(o.low),n=o.low):F.closeIntersectionPoints(r,e.seg.value(o.high))&&(r=e.seg.value(o.high),n=o.high),new _(i,n,r,t.seg,e.seg)}static liftIntersectionToCurves_(t,e,i,n,r,s,o){const a=this.liftParameterToCurve(t,i-s.parStart,s),l=this.liftParameterToCurve(e,n-o.parStart,o);return new _(a,l,r,t,e)}static DropIntersectionToSegs(t){let e,i,n,r;if(t.seg0 instanceof F){const n=t.seg0.getSegParam(t.par0);e=n.seg,i=n.par}else i=t.par0,e=t.seg0;if(t.seg1 instanceof F){const e=t.seg1.getSegParam(t.par1);r=e.par,n=e.seg}else r=t.par1,n=t.seg1;return new _(i,r,t.x,e,n)}static liftIntersectionToCurves(t,e,i){return F.liftIntersectionToCurves_(t,e,i.par0,i.par1,i.x,i.seg0,i.seg1)}static liftParameterToCurve(t,e,i){if(t==i)return e;if(!t.hasOwnProperty("segs"))return;const n=t;let r=0;for(const t of n.segs){if(t==i)return e+r;r+=F.paramSpan(t)}throw"bug in liftParameterToCurve"}static paramSpan(t){return t.parEnd-t.parStart}static goDeeperOne(t,e){const i=t.node,n=e.node;if(t.leafBoxesOffset>y.distanceEpsilon&&e.leafBoxesOffset>y.distanceEpsilon){const r=O.createParallelogramNodeForCurveSeg(i.low,i.high,t.seg,t.leafBoxesOffset/2),s=O.createParallelogramNodeForCurveSeg(n.low,n.high,e.seg,e.leafBoxesOffset/2);return F.curveCurveXWithParallelogramNodesOne(r,s)}if(t.leafBoxesOffset>y.distanceEpsilon){const n=O.createParallelogramNodeForCurveSeg(i.low,i.high,t.seg,t.leafBoxesOffset/2);return F.curveCurveXWithParallelogramNodesOne(n,e)}if(e.leafBoxesOffset>y.distanceEpsilon){const i=O.createParallelogramNodeForCurveSeg(n.low,n.high,e.seg,e.leafBoxesOffset/2);return F.curveCurveXWithParallelogramNodesOne(t,i)}const r=t.seg.value(i.low),s=t.seg.value(i.high);if(!E.closeDistEps(r,s)){const i=e.seg.value(n.low),o=e.seg.value(n.high);if(!E.closeDistEps(i,o)){const n=t.seg instanceof I?t.seg:I.mkPP(r,s),a=e.seg instanceof I?e.seg:I.mkPP(i,o),l=F.crossWithinIntervalsWithGuess(n,a,0,1,0,1,.5,.5);if(null!=l)return F.adjustParameters(t,n,e,a,l),F.createIntersectionOne(t,e,l.aSol,l.bSol,l.x)}}return null}static goDeeper(t,e,i){const n=e.node,r=i.node;if(e.leafBoxesOffset>y.distanceEpsilon&&i.leafBoxesOffset>y.distanceEpsilon){const s=O.createParallelogramNodeForCurveSeg(n.low,n.high,e.seg,e.leafBoxesOffset/2),o=O.createParallelogramNodeForCurveSeg(r.low,r.high,i.seg,i.leafBoxesOffset/2);F.curveCurveXWithParallelogramNodes(s,o,t)}else if(e.leafBoxesOffset>y.distanceEpsilon){const r=O.createParallelogramNodeForCurveSeg(n.low,n.high,e.seg,e.leafBoxesOffset/2);F.curveCurveXWithParallelogramNodes(r,i,t)}else if(i.leafBoxesOffset>y.distanceEpsilon){const n=O.createParallelogramNodeForCurveSeg(r.low,r.high,i.seg,i.leafBoxesOffset/2);F.curveCurveXWithParallelogramNodes(e,n,t)}else{const s=e.seg.value(n.low),o=e.seg.value(n.high);if(!E.closeDistEps(s,o)){const n=i.seg.value(r.low),a=i.seg.value(r.high);if(!E.closeDistEps(n,a)){const r=e.seg instanceof I?e.seg:I.mkPP(s,o),l=i.seg instanceof I?i.seg:I.mkPP(n,a),h=F.crossWithinIntervalsWithGuess(r,l,0,1,0,1,.5,.5);null!=h&&(F.adjustParameters(e,r,i,l,h),F.addIntersection(e,i,t,h))}}}}static adjustParameters(t,e,i,n,r){if(e!=t.seg&&t.seg instanceof k==0)r.aSol=t.seg.closestParameter(r.x);else{const e=t.node;r.aSol=e.low+r.aSol*(e.high-e.low)}if(n!=i.seg&&i.seg instanceof k==0)r.bSol=i.seg.closestParameter(r.x);else{const t=i.node;r.bSol=t.low+r.bSol*(t.high-t.low)}}getSegParam(t){let e=this.parStart;for(const i of this.segs){const n=e+i.parEnd-i.parStart;if(t>=e&&t<=n)return{par:t-e+i.parStart,seg:i};e=n}const i=this.segs[this.segs.length-1];return{seg:i,par:i.parEnd}}getSegIndexParam(t){let e=0;const i=this.segs.length;for(let n=0;n<i;n++){const i=this.segs[n],r=e+i.parEnd-i.parStart;if(t>=e&&t<=r)return{segIndex:n,par:t-e+i.parStart};e=r}return{segIndex:i-1,par:this.segs[i-1].parEnd}}value(t){return(e=this.getSegParam(t)).seg.value(e.par);var e}derivative(t){return(e=this.getSegParam(t)).seg.derivative(e.par);var e}secondDerivative(t){return(e=this.getSegParam(t)).seg.secondDerivative(e.par);var e}thirdDerivative(t){return(e=this.getSegParam(t)).seg.thirdDerivative(e.par);var e}static crossWithinIntervalsWithGuess(t,e,i,n,r,s,o,a){if(t instanceof I&&e instanceof I){const o=F.crossTwoLineSegs(t.start,t.end,e.start,e.end,i,n,r,s);if(null!=o)return o}const l=F.minDistWithinIntervals(t,e,i,n,r,s,o,a);if(null==l)return;const h=l.aX.sub(l.bX);return h.dot(h)>=y.distanceEpsilon?void 0:{aSol:l.aSol,bSol:l.bSol,x:E.middle(l.aX,l.bX)}}static crossTwoLineSegs(t,e,i,n,r,s,o,a){const l=e.sub(t),h=i.sub(n),u=i.sub(t),c=m.solve(l.x,h.x,u.x,l.y,h.y,u.y);if(null==c)return;let d=c.x,g=c.y;const f=t.add(l.mul(d));return d<r-y.tolerance||(d=Math.max(d,r),d>s+y.tolerance||(d=Math.min(d,s),g<o-y.tolerance||(g=Math.max(g,o),g>a+y.tolerance)))?void 0:(g=Math.min(g,a),{aSol:d,bSol:g,x:f})}static PointRelativeToCurveLocation(t,e){if(!e.boundingBox.contains(t))return a.Outside;const i=2*e.boundingBox.diagonal,n=Math.PI/180;let r=0;for(let s=13;s<360;s+=13){const o=new E(Math.cos(s*n),Math.sin(s*n)),l=I.mkPP(t,t.add(o.mul(i))),h=this.getAllIntersectionsOfLineAndICurve(l,e,!0);if(F.AllIntersectionsAreGood(h,e)){for(const e of h)if(E.closeDistEps(e.x,t))return a.Boundary;if(h.length%2==1?r++:r--,r>=2)return a.Inside;if(r<=-2)return a.Outside}}return a.Boundary}static AllIntersectionsAreGood(t,e){let i=null;if(!e.hasOwnProperty("segs")){e instanceof k&&(i=e.toCurve())}if(i)for(const e of t)if(!F.RealCut(F.DropIntersectionToSegs(e),i,!1))return!1;return!0}static RealCut(t,e,i){const n=t.seg0,r=t.seg1,s=t.par0,o=t.par1,a=t.x,l=n.derivative(s).normalize(),h=r.derivative(o).normalize().rotate(Math.PI/2);if(E.closeDistEps(a,r.end)){let t=null;for(let i=0;i<e.segs.length-1;i++)if(e.segs[i]==r){t=e.segs[i+1];break}if(null==t)return!1;const i=l.rotate(Math.PI/2);return!(i.dot(r.derivative(r.parEnd))*i.dot(t.derivative(t.parStart))<y.tolerance)}if(E.closeDistEps(a,r.start)){let t=null;for(let i=e.segs.length-1;i>0;i--)if(e.segs[i]==r){t=e.segs[i-1];break}if(null==t)return!1;const i=l.rotate(Math.PI/2);return!(i.dot(r.derivative(r.parStart))*i.dot(t.derivative(t.parEnd))<y.tolerance)}const u=l.dot(h);return i?u>y.distanceEpsilon:Math.abs(u)>y.distanceEpsilon}static realCutWithClosedCurve(t,e,i){const n=t.seg0,r=t.seg1,s=t.par0,o=t.par1,a=t.x,l=n.derivative(s).normalize(),h=r.derivative(o).normalize().rotate(Math.PI/2);if(E.closeDistEps(a,r.end)){let t=null;for(let i=0;i<e.segs.length;i++)if(e.segs[i]==r){t=e.segs[(i+1)%e.segs.length];break}if(null==t)throw new Error;const i=l.rotate(Math.PI/2);return!(i.dot(r.derivative(r.parEnd))*i.dot(t.derivative(t.parStart))<y.tolerance)}if(E.closeDistEps(a,r.start)){let t=null;for(let i=0;i<e.segs.length;i++)if(e.segs[i]==r){t=e.segs[i>0?i-1:e.segs.length-1];break}const i=l.rotate(Math.PI/2);return!(i.dot(r.derivative(r.parStart))*i.dot(t.derivative(t.parEnd))<y.tolerance)}const u=l.dot(h);return i?u>y.distanceEpsilon:Math.abs(u)>y.distanceEpsilon}static minDistWithinIntervals(t,e,i,n,r,s,o,a){const l=new B(t,e,i,n,r,s,o,a);return l.solve(),l.success?{aSol:l.aSolution,bSol:l.bSolution,aX:l.aPoint,bX:l.bPoint}:void 0}offsetCurve(t,e){throw new Error("Method not implemented.")}get boundingBox(){if(0==this.segs.length)return G.mkEmpty();const t=this.segs[0].boundingBox.clone();for(let e=1;e<this.segs.length;e++)t.addRecSelf(this.segs[e].boundingBox);return t}clone(){const t=new F;for(const e of this.segs)t.addSegment(e.clone());return t}getParameterAtLength(t){let e=0;for(const i of this.segs){const n=i.length;if(n>=t)return e+i.getParameterAtLength(t);t-=n,e+=i.parEnd-i.parStart}return this.parEnd}get length(){let t=0;for(const e of this.segs)t+=e.length;return t}transform(t){const e=new F;for(const i of this.segs)e.addSegment(i.transform(t));return e}closestParameterWithinBounds(t,e,i){let n=0,r=Number.MAX_VALUE,s=0;for(const o of this.segs){if(s>i)break;const a=F.paramSpan(o);if(s+a>=e){const a=Math.max(o.parStart,o.parStart+(e-s)),l=Math.min(o.parEnd,o.parStart+(i-s)),h=o.closestParameterWithinBounds(t,a,l),u=t.sub(o.value(h)),c=u.dot(u);c<r&&(n=s+h-o.parStart,r=c)}s+=a}return n}closestParameter(t){let e=0,i=Number.MAX_VALUE,n=0;for(const r of this.segs){const s=r.closestParameter(t),o=t.sub(r.value(s)),a=o.dot(o);a<i&&(e=n+s-r.parStart,i=a),n+=F.paramSpan(r)}return e}static addLineSegment(t,e,i){return t.addSegment(I.mkPP(e,i))}static addLineSegmentCNNP(t,e,i,n){return F.addLineSegment(t,new E(e,i),n)}static addLineSegmentCNNNN(t,e,i,n,r){F.addLineSegment(t,new E(e,i),new E(n,r))}static continueWithLineSegmentNN(t,e,i){F.addLineSegment(t,t.end,new E(e,i))}static continueWithLineSegmentP(t,e){F.addLineSegment(t,t.end,e)}static closeCurve(t){return F.continueWithLineSegmentP(t,t.start),t}leftDerivative(t){const e=this.tryToGetLeftSegment(t);return null!=e?e.derivative(e.parEnd):this.derivative(t)}rightDerivative(t){const e=this.tryToGetRightSegment(t);return null!=e?e.derivative(e.parStart):this.derivative(t)}tryToGetLeftSegment(t){if(Math.abs(t-this.parStart)<y.tolerance)return this.start.equal(this.end)?this.segs[this.segs.length-1]:null;for(const e of this.segs)if(t-=F.paramSpan(e),Math.abs(t)<y.tolerance)return e;return null}tryToGetRightSegment(t){if(Math.abs(t-this.parEnd)<y.tolerance)return this.start==this.end?this.segs[0]:null;for(const e of this.segs){if(Math.abs(t)<y.tolerance)return e;t-=F.paramSpan(e)}return null}static ClosestPoint(t,e){return t.value(t.closestParameter(e))}static CurveIsInsideOther(t,e){if(!e.boundingBox.containsRect(t.boundingBox))return!1;const i=F.getAllIntersections(t,e,!0);if(0==i.length)return F.NonIntersectingCurveIsInsideOther(t,e);if(1==i.length)return t.start.equal(i[0].x)?F.PointRelativeToCurveLocation(t.value((t.parStart+t.parEnd)/2),e)==a.Inside:F.PointRelativeToCurveLocation(t.start,e)==a.Inside;for(const n of F.PointsBetweenIntersections(t,i))if(F.PointRelativeToCurveLocation(n,e)==a.Outside)return!1;return!0}static*PointsBetweenIntersections(t,e){e.sort((t,e)=>t.par0<e.par0?-1:t.par0>e.par0?1:0);for(let i=0;i<e.length-1;i++)yield t.value((e[i].par0+e[i+1].par0)/2);const i=e[e.length-1].par0,n=e[0].par0;let r=i+(t.parEnd-i+(n-t.parStart))/2;r>t.parEnd&&(r=t.parStart+(r-t.parEnd)),yield t.value(r)}static NonIntersectingCurveIsInsideOther(t,e){for(let i=t.parStart;i<t.parEnd;i+=.5){const n=F.PointRelativeToCurveLocation(t.value(i),e);if(a.Boundary!=n)return a.Inside==n}return a.Outside!=F.PointRelativeToCurveLocation(t.end,e)}static ClosedCurveInteriorsIntersect(t,e){if(!e.boundingBox.intersects(t.boundingBox))return!1;const i=F.getAllIntersections(t,e,!0);if(0==i.length)return F.NonIntersectingCurveIsInsideOther(t,e)||F.NonIntersectingCurveIsInsideOther(e,t);if(1==i.length)return t.start.equal(i[0].x)?F.PointRelativeToCurveLocation(t.value((t.parStart+t.parEnd)/2),e)!=a.Inside&&e.start.equal(i[0].x)?F.PointRelativeToCurveLocation(e.value((e.parStart+e.parEnd)/2),t)==a.Inside:F.PointRelativeToCurveLocation(e.start,t)==a.Inside:F.PointRelativeToCurveLocation(t.start,e)==a.Inside;for(const n of F.PointsBetweenIntersections(t,i))if(F.PointRelativeToCurveLocation(n,e)==a.Inside)return!0;return!0}curvature(t){const e=this.getSegParam(t);return e.seg.curvature(e.par)}curvatureDerivative(t){throw new Error("Not implemente")}curvatureSecondDerivative(t){throw new Error("Not implemented")}static createBezierSeg(t,e,i,n,r){const s=E.mkPoint(t,i.point,1-t,n.point),o=E.mkPoint(e,r.point,1-e,n.point),a=n.point.mul(2/3);return new M(s,s.div(3).add(a),a.add(o.div(3)),o)}static createBezierSegN(t,e,i,n){const r=i.mul(n);return new M(t,t.add(r),e.add(r),e)}static findCorner(t){const e=t.next;if(null==e.next)return;const i=e.next;return null!=i?{b:e,c:i}:void 0}static trimEdgeSplineWithNodeBoundaries(t,e,i,n){let r=i.parStart,s=i.parEnd;null!=t&&(r=F.findNewStart(i,r,t,n)),null!=e&&(s=F.findNewEnd(i,e,n,s));const o=Math.min(r,s),a=Math.max(r,s);return o<a?i.trim(o,a):i}static findNewEnd(t,e,i,n){const r=F.getAllIntersections(t,e,!0);if(0==r.length)return n=t.parEnd;if(i){n=t.parEnd;for(const t of r)t.par0<n&&(n=t.par0)}else{n=t.parStart;for(const t of r)t.par0>n&&(n=t.par0)}return n}static findNewStart(t,e,i,n){const r=F.getAllIntersections(t,i,!0);if(0!=r.length){if(n){e=t.parStart;for(const t of r)t.par0>e&&(e=t.par0)}else{e=t.parEnd;for(const t of r)t.par0<e&&(e=t.par0)}return e}e=t.parStart}static polylineAroundClosedCurve(t){if(t instanceof R)return F.refineEllipse(t);if(t instanceof k)return t;if(t instanceof F&&F.allSegsAreLines(t)){const e=new k;for(const i of t.segs)e.addPoint(i.start);if(e.closed=!0,!e.isClockwise())return e.reverse()}return t.boundingBox.perimeter()}static allSegsAreLines(t){for(const e of t.segs)if(!(e instanceof I))return!1;return!0}static refineEllipse(t){const e=t.boundingBox.perimeter(),i=Math.PI/4,n=t.boundingBox.width,r=t.boundingBox.height,s=Math.sqrt(n*n+r*r),o=[];for(let n=0;n<4;n++){const r=i+n*Math.PI/2,a=t.value(r),l=t.derivative(r).normalize().mul(s),h=I.mkPP(a.sub(l),a.add(l));for(const t of F.getAllIntersections(e,h,!0))o.push(t)}o.sort((t,e)=>t.par0<e.par0?-1:t.par0>e.par0?1:0);const a=new k;return o.forEach(t=>a.addPoint(t.x)),a.closed=!0,a}static polyFromBox(t){const e=new k;return e.addPoint(t.leftTop),e.addPoint(t.rightTop),e.addPoint(t.rightBottom),e.addPoint(t.leftBottom),e.closed=!0,e}}function D(t,e,i,n,r,s){let o=[];if(function(t,e,i,n,r,s){if(r instanceof I)return!0;for(const o of[1/3,.5,2/3]){const a=t*o+i*(1-o);if(0==E.closeSquare(r.value(a),E.mkPoint(o,e,1-o,n),s))return!1}return!0}(t,e,i,n,r,s))o.push(e),o.push(n);else{const a=.5*(t+i),l=r.value(a);o=D(t,e,a,l,r,s);const h=D(a,l,i,n,r,s).slice(1);o=o.concat(h)}return o}function N(t,e){return D(t.parStart,t.start,t.parEnd,t.end,t,e)}class k{constructor(){this.initIsRequired=!0,this.isClosed_=!1}RemoveStartPoint(){const t=this.startPoint.next;t.prev=null,this.startPoint=t,this.setInitIsRequired()}RemoveEndPoint(){const t=this.endPoint.prev;t.next=null,this.endPoint=t,this.setInitIsRequired()}setInitIsRequired(){this.initIsRequired=!0}addPointXY(t,e){this.addPoint(new E(t,e))}isClockwise(){return E.getTriangleOrientation(this.startPoint.point,this.startPoint.next.point,this.startPoint.next.next.point)==s.Clockwise}addPoint(t){const e=new x;e.polyline=this,e.point=t.clone(),null!=this.endPoint?(this.endPoint.next=e,e.prev=this.endPoint,this.endPoint=e):this.startPoint=this.endPoint=e,this.setInitIsRequired()}PrependPoint(t){const e=x.mkFromPoint(t);e.polyline=this,null!=this.startPoint?E.closeDistEps(t,this.startPoint.point)||(this.startPoint.prev=e,e.next=this.startPoint,this.startPoint=e):(this.endPoint=e,this.startPoint=e),this.setInitIsRequired()}*[Symbol.iterator](){for(let t=this.startPoint;null!=t;t=t.next)yield t.point}*polylinePoints(){for(let t=this.startPoint;null!=t;t=t.next)yield t}*skip(t){for(let e=this.startPoint;null!=e;e=e.next)t>0?t--:yield e}static parallelogramOfLineSeg(t,e){const i=e.sub(t).div(2);return A.parallelogramByCornerSideSide(t,i,i)}static mkFromPoints(t){const e=new k;for(const i of t)e.addPoint(i);return e}static mkClosedFromPoints(t){const e=k.mkFromPoints(t);return e.closed=!0,e}calculatePbNode(){const t=[],e=[];let i=this.startPoint,n=0;for(;null!=i.next;){const r=k.parallelogramOfLineSeg(i.point,i.next.point);t.push(r),e.push({parallelogram:r,seg:this,leafBoxesOffset:0,node:{low:n,high:n+1,chord:I.mkPP(i.point,i.next.point)}}),i=i.next,n++}if(this.isClosed_){const i=k.parallelogramOfLineSeg(this.endPoint.point,this.startPoint.point);t.push(i),e.push({parallelogram:i,seg:this,leafBoxesOffset:0,node:{low:n,high:n+1,chord:I.mkPP(this.endPoint.point,this.startPoint.point)}})}this.pBNode={parallelogram:A.getParallelogramOfAGroup(t),seg:this,leafBoxesOffset:0,node:{children:e}}}init(){this.bBox=G.rectangleOnPoint(this.startPoint.point);for(const t of this.skip(1))this.bBox.add(t.point);this.updateCount(),this.calculatePbNode(),this.initIsRequired=!1}updateCount(){this.count_=0;for(let t=this.startPoint;null!=t;t=t.next)this.count_++}get count(){return this.initIsRequired&&this.init(),this.count_}get closed(){return this.isClosed_}set closed(t){this.isClosed_=t}value(t){this.initIsRequired&&this.init();const e=this.getAdjustedParamAndStartEndPoints(t);return E.convSum(e.t,e.a,e.b)}getAdjustedParamAndStartEndPoints(t){let e=this.startPoint;for(;null!=e.next;){if(t<=1)return{a:e.point,b:e.next.point,t:t};e=e.next,t-=1}if(this.closed&&t<=1)return{a:this.endPoint.point,b:this.startPoint.point,t:t};throw new Error("out of the parameter domain")}derivative(t){const e=this.getAdjustedParamAndStartEndPoints(t);return e.b.sub(e.a)}secondDerivative(t){return new E(0,0)}thirdDerivative(t){return new E(0,0)}pNodeOverICurve(){return this.initIsRequired&&this.init(),this.pBNode}get boundingBox(){return this.initIsRequired&&this.init(),this.bBox}get parStart(){return 0}get parEnd(){return this.initIsRequired&&this.init(),this.closed?this.count_:this.count_-1}static polylineFromCurve(t){const e=new k;e.addPoint(t.start);for(const i of t.segs)e.addPoint(i.end);return e.closed=t.start==t.end,e}trim(t,e){let i=this.toCurve();return i=i.trim(t,e),k.polylineFromCurve(i)}trimWithWrap(t,e){throw new Error("Method not implemented.")}translate(t){let e=this.startPoint;for(;;){if(e.point=e.point.add(t),e==this.endPoint)break;e=e.getNext()}this.setInitIsRequired()}scaleFromOrigin(t,e){throw new Error("Method not implemented.")}get start(){return this.startPoint.point}get end(){return this.endPoint.point}reverse(){const t=new k;t.closed=this.closed;let e=this.endPoint;for(;;){if(t.addPoint(e.point),e==this.startPoint)break;e=e.getPrev()}return t}offsetCurve(t,e){throw new Error("Method not implemented.")}lengthPartial(t,e){throw new Error("Method not implemented.")}get length(){throw new Error("Method not implemented.")}getParameterAtLength(t){throw new Error("Method not implemented.")}transform(t){const e=new k;for(const i of this.polylinePoints())e.addPoint(t.multiplyPoint(i.point));return e.closed=this.closed,e}closestParameterWithinBounds(t,e,i){throw new Error("Method not implemented.")}closestParameter(t){let e=0,i=Number.MAX_VALUE,n=0,r=this.startPoint;for(;null!=r.next;){const s=I.mkPP(r.point,r.next.point),o=s.closestParameter(t),a=s.value(o).sub(t),l=a.dot(a);l<i&&(i=l,e=o+n),r=r.next,n++}if(this.closed){const r=I.mkPP(this.endPoint.point,this.startPoint.point),s=r.closestParameter(t),o=r.value(s).sub(t);o.dot(o)<i&&(e=s+n)}return e}clone(){const t=new k;t.closed=this.closed;let e=this.startPoint;for(;;){if(t.addPoint(e.point),e==this.endPoint)break;e=e.getNext()}return t}leftDerivative(t){throw new Error("Method not implemented.")}rightDerivative(t){throw new Error("Method not implemented.")}curvature(t){throw new Error("Method not implemented.")}curvatureDerivative(t){throw new Error("Method not implemented.")}curvatureSecondDerivative(t){throw new Error("Method not implemented.")}next(t){var e;return null!==(e=t.next)&&void 0!==e?e:this.closed?this.startPoint:null}prev(t){var e;return null!==(e=t.prev)&&void 0!==e?e:this.closed?this.endPoint:null}toCurve(){const t=new F;F.addLineSegment(t,this.startPoint.point,this.startPoint.next.point);let e=this.startPoint.next;for(;null!=(e=e.next);)F.continueWithLineSegmentP(t,e.point);return this.closed&&F.continueWithLineSegmentP(t,this.startPoint.point),t}}class V{constructor(t,e){this.width=t,this.height=e}pad(t){this.width+=2*t}}class G{constructor(t){this.left_=t.left,this.right_=t.right,this.top_=t.top,this.bottom=t.bottom}static mkSizeCenter(t,e){const i=t.width/2,n=t.height/2;return new G({left:e.x-i,right:e.x+i,bottom:e.y-n,top:e.y+n})}add_rect(t){return this.addRec(t)}contains_point(t){return this.contains(t)}contains_rect(t){return this.containsRect(t)}intersection_rect(t){return this.intersection(t)}intersects_rect(t){return this.intersects(t)}unite(t){return G.rectangleOfTwo(this,t)}contains_point_radius(t,e){return this.containsWithPadding(t,e)}intersects(t){return this.intersectsOnX(t)&&this.intersectsOnY(t)}intersection(t){if(!this.intersects(t)){const t=G.mkEmpty();return t.setToEmpty(),t}const e=Math.max(this.left,t.left),i=Math.min(this.right,t.right),n=Math.max(this.bottom,t.bottom),r=Math.min(this.top,t.top);return new G({left:e,bottom:n,right:i,top:r})}get center(){return this.leftTop.add(this.rightBottom).mul(.5)}set center(t){const e=t.sub(this.center);this.leftTop=this.leftTop.add(e),this.rightBottom=this.rightBottom.add(e)}intersectsOnY(t){return!(t.bottom_>this.top_+y.distanceEpsilon)&&!(t.top_<this.bottom_-y.distanceEpsilon)}intersectsOnX(t){return!(t.left>this.right_+y.distanceEpsilon)&&!(t.right<this.left_-y.distanceEpsilon)}static mkEmpty(){return new G({left:0,right:-1,bottom:0,top:-1})}get left(){return this.left_}set left(t){this.left_=t}get right(){return this.right_}set right(t){this.right_=t}get top(){return this.top_}set top(t){this.top_=t}get bottom(){return this.bottom_}set bottom(t){this.bottom_=t}get leftBottom(){return new E(this.left_,this.bottom_)}set leftBottom(t){this.left_=t.x,this.bottom=t.y}get rightTop(){return new E(this.right_,this.top_)}set rightTop(t){this.right_=t.x,this.top_=t.y}get leftTop(){return new E(this.left_,this.top_)}set leftTop(t){this.left_=t.x,this.top_=t.y}get rightBottom(){return new E(this.right_,this.bottom_)}set rightBottom(t){this.right_=t.x,this.bottom=t.y}static mkPP(t,e){const i=new G({left:t.x,right:t.x,top:t.y,bottom:t.y});return i.add(e),i}static rectangleOnPoint(t){return new G({left:t.x,right:t.x,top:t.y,bottom:t.y})}static rectangleFromLeftBottomAndSize(t,e,i){const n=t+i.x,r=e+i.y;return new G({left:t,right:n,top:r,bottom:e})}static getRectangleOnCoords(t,e,i,n){const r=new G({left:t,bottom:e,right:t,top:e});return r.add(new E(i,n)),r}static mkOnPoints(t){const e=G.mkEmpty();for(const i of t)e.add(i);return e}static rectangleOnRectangles(t){const e=G.mkEmpty();for(const i of t)e.addRecSelf(i);return e}get width(){return this.right_-this.left_}set width(t){const e=t/2,i=(this.left_+this.right_)/2;this.left_=i-e,this.right_=i+e}isEmpty(){return this.width<0}setToEmpty(){this.left=0,this.right=-1}get height(){return this.top_-this.bottom_}set height(t){const e=t/2,i=(this.top_+this.bottom_)/2;this.top_=i+e,this.bottom=i-e}static rectangleOfTwo(t,e){const i=new G({left:t.left_,right:t.right_,top:t.top_,bottom:t.bottom_});return i.addRecSelf(e),i}containsWithPadding(t,e){return this.left_-e-y.distanceEpsilon<=t.x&&t.x<=this.right_+e+y.distanceEpsilon&&this.bottom_-e-y.distanceEpsilon<=t.y&&t.y<=this.top_+e+y.distanceEpsilon}get area(){return(this.right_-this.left_)*(this.top_-this.bottom_)}add(t){this.isEmpty()?(this.left_=this.right_=t.x,this.top_=this.bottom=t.y):(this.left_>t.x&&(this.left_=t.x),this.top_<t.y&&(this.top_=t.y),this.right_<t.x&&(this.right_=t.x),this.bottom_>t.y&&(this.bottom=t.y))}addWithCheck(t){let e,i;return(e=t.x<this.left_)?this.left_=t.x:(e=this.right_<t.x)&&(this.right_=t.x),(i=t.y>this.top_)?this.top_=t.y:(i=this.bottom_>t.y)&&(this.bottom=t.y),e||i}addRecSelf(t){this.add(t.leftTop),this.add(t.rightBottom)}addRec(t){const e=this.clone();return e.add(t.leftTop),e.add(t.rightBottom),e}static translate(t,e){const i=t.clone();return i.center=t.center.add(e),i}contains(t){return this.containsWithPadding(t,0)}containsRect(t){return this.contains(t.leftTop)&&this.contains(t.rightBottom)}get diagonal(){return Math.sqrt(this.width*this.width+this.height*this.height)}padWidth(t){this.left-=t,this.right+=t}padHeight(t){this.top+=t,this.bottom-=t}pad(t){return t<-this.width/2&&(t=-this.width/2),t<-this.height/2&&(t=-this.height/2),this.padWidth(t),this.padHeight(t),this}padEverywhere(t){this.left-=t.left,this.right+=t.right,this.bottom-=t.bottom,this.top+=t.top}static intersect(t,e){return t.intersects(e)?G.mkPP(new E(Math.max(t.left,e.left),Math.max(t.bottom,e.bottom)),new E(Math.min(t.right,e.right),Math.min(t.top,e.top))):G.mkEmpty()}perimeter(){const t=new k;return t.addPoint(this.leftTop),t.addPoint(this.rightTop),t.addPoint(this.rightBottom),t.addPoint(this.leftBottom),t.closed=!0,t}scaleAroundCenter(t){this.width=this.width*t,this.height=this.height*t}clone(){return G.mkPP(this.leftTop,this.rightBottom)}get size(){return new V(this.width,this.height)}set size(t){this.width=t.width,this.height=t.height}static creatRectangleWithSize(t,e){const i=t.width/2,n=e.x-i,r=e.x+i,s=t.height/2,o=e.y-s,a=e.y+s;return new G({left:n,right:r,top:a,bottom:o})}addPointWithSize(t,e){const i=t.width/2,n=t.height/2;this.add(new E(e.x-i,e.y-n)),this.add(new E(e.x+i,e.y-n)),this.add(new E(e.x-i,e.y+n)),this.add(new E(e.x+i,e.y+n))}}class z{constructor(t){this.entity=t,this.bind()}bind(){this.entity&&this.entity.setAttr(0,this)}static getGeom(t){return t.getAttr(0)}}class j{constructor(t,e,i,n,r,s){this.elements=[[t,e,i],[n,r,s]]}get Elements(){return this.elements}getElem(t,e){return this.elements[t][e]}setElem(t,e,i){this.elements[t][e]=i}static Divide(t,e){return t.multiply(e.inverse())}isIdentity(){return v(this.elements[0][0],1)&&v(this.elements[0][1],0)&&v(this.elements[0][2],0)&&v(this.elements[1][0],0)&&v(this.elements[1][1],1)&&v(this.elements[1][2],0)}offset(){return new E(this.getElem(0,2),this.getElem(1,2))}static getIdentity(){return new j(1,0,0,0,1,0)}static rotation(t){const e=Math.cos(t),i=Math.sin(t);return new j(e,-i,0,i,e,0)}static scaleAroundCenterTransformation(t,e,i){const n=1-e;return new j(t,0,(1-t)*i.x,0,e,n*i.y)}multiplyPoint(t){return new E(this.getElem(0,0)*t.x+this.getElem(0,1)*t.y+this.getElem(0,2),this.getElem(1,0)*t.x+this.getElem(1,1)*t.y+this.getElem(1,2))}multiply(t){return null!=t?new j(this.getElem(0,0)*t.getElem(0,0)+this.getElem(0,1)*t.getElem(1,0),this.getElem(0,0)*t.getElem(0,1)+this.getElem(0,1)*t.getElem(1,1),this.getElem(0,0)*t.getElem(0,2)+this.getElem(0,1)*t.getElem(1,2)+this.getElem(0,2),this.getElem(1,0)*t.getElem(0,0)+this.getElem(1,1)*t.getElem(1,0),this.getElem(1,0)*t.getElem(0,1)+this.getElem(1,1)*t.getElem(1,1),this.getElem(1,0)*t.getElem(0,2)+this.getElem(1,1)*t.getElem(1,2)+this.getElem(1,2)):null}inverse(){const t=this.getElem(0,0)*this.getElem(1,1)-this.getElem(1,0)*this.getElem(0,1),e=this.getElem(1,1)/t,i=-this.getElem(0,1)/t,n=-this.getElem(1,0)/t,r=this.getElem(0,0)/t,s=-e*this.getElem(0,2)-i*this.getElem(1,2),o=-n*this.getElem(0,2)-r*this.getElem(1,2);return new j(e,i,s,n,r,o)}}!function(t){t[t.None=0]="None",t[t.North=1]="North",t[t.East=2]="East",t[t.South=4]="South",t[t.West=8]="West"}(l||(l={}));class U{static get DifferenceEpsilon(){return U.differenceEpsilon}static EqualPP(t,e){return U.Equal(t.x,e.x)&&U.Equal(t.y,e.y)}static Equal(t,e){return 0==U.Compare(t,e)}static Compare(t,e){let i=0;return t+U.DifferenceEpsilon<e?i=-1:e+U.DifferenceEpsilon<t&&(i=1),i}static ComparePP(t,e){let i=U.Compare(t.x,e.x);return 0==i&&(i=U.Compare(t.y,e.y)),i}static LessOrEqual(t,e){const i=U.Compare(t,e);return i<0||0==i}static Less(t,e){return U.Compare(t,e)<0}static GetDirections(t,e){return W.DirectionFromPointToPoint(t,e)}static IsPureDirection(t,e){return W.IsPureDirection(U.GetDirections(t,e))}static IsPureDirectionD(t){return W.IsPureDirection(t)}static IsPureLower(t,e){const i=U.GetDirections(t,e);return l.East==i||l.North==i}static GetPureDirectionVV(t,e){return U.GetDirections(t.point,e.point)}}U.differenceEpsilon=y.distanceEpsilon/2;class W{constructor(t){this.Dir=t}get Right(){return new W(W.RotateRight(this.Dir))}static RotateRight(t){switch(t){case l.North:return l.East;case l.East:return l.South;case l.South:return l.West;case l.West:return l.North;default:throw new Error}}static RotateLeft(t){switch(t){case l.North:return l.West;case l.West:return l.South;case l.South:return l.East;case l.East:return l.North;default:throw new Error}}static ToIndex(t){switch(t){case l.North:return 0;case l.East:return 1;case l.South:return 2;case l.West:return 3;default:throw new Error}}static VectorDirection(t){let e=l.None;return t.x>U.DifferenceEpsilon?e=l.East:t.x<-U.DifferenceEpsilon&&(e=l.West),t.y>U.DifferenceEpsilon?e|=l.North:t.y<-U.DifferenceEpsilon&&(e|=l.South),e}static VectorDirectionPP(t,e){let i=l.None;const n=e.x-t.x,r=e.y-t.y;return n>U.DifferenceEpsilon?i=l.East:-n>U.DifferenceEpsilon&&(i=l.West),r>U.DifferenceEpsilon?i|=l.North:-r>U.DifferenceEpsilon&&(i|=l.South),i}static DirectionFromPointToPoint(t,e){return W.VectorDirectionPP(t,e)}static OppositeDir(t){switch(t){case l.North:return l.South;case l.West:return l.East;case l.South:return l.North;case l.East:return l.West;default:return l.None}}static IsPureDirection(t){switch(t){case l.North:case l.East:case l.South:case l.West:return!0;default:return!1}}static IsPureDirectionPP(t,e){return W.IsPureDirection(W.DirectionFromPointToPoint(t,e))}static DirectionsAreParallel(t,e){return t==e||t==W.OppositeDir(e)}ToPoint(){let t=0,e=0;return(this.Dir&l.East)==l.East&&t++,(this.Dir&l.North)==l.North&&e++,(this.Dir&l.West)==l.West&&t--,(this.Dir&l.South)==l.South&&e--,new E(t,e)}static toPoint(t){return new W(t).ToPoint()}static negate(t){return new W(W.OppositeDir(t.Dir))}}class H{static createHexagon(t,e,i){const n=e/2,r=t/2,s=i.x,o=i.y;return k.mkClosedFromPoints([new E(-1*r+s,-1*n+o),new E(r+s,-1*n+o),new E(r+(n+s),0+o),new E(r+s,n+o),new E(-1*r+s,n+o),new E(-1*(r-n)+s,0+o)])}static createOctagon(t,e,i){const n=t/2,r=e/2,s=new Array(8);s[0]=new E(n+H.octagonPad*n,r-r*H.octagonPad),s[3]=new E(-1*s[0].x,s[0].y),s[4]=new E(s[3].x,-1*s[3].y),s[7]=new E(s[0].x,-1*s[0].y),s[1]=new E(n-n*H.octagonPad,r+r*H.octagonPad),s[2]=new E(-1*s[1].x,s[1].y),s[6]=new E(s[1].x,-1*s[1].y),s[5]=new E(s[2].x,-1*s[2].y);for(let t=0;t<8;t++)s[t]=s[t].add(i);return k.mkClosedFromPoints(s)}static createInvertedHouse(t,e,i){const n=H.createHouse(t,e,i);return H.rotateCurveAroundCenterByDegree(n,i,180)}static createHouse(t,e,i){const n=t/2,r=e/2,s=i.x,o=i.y,a=new F;return F.addLineSegmentCNNNN(a,s-n,o-r,s+n,o-r),F.continueWithLineSegmentNN(a,s+n,o+r),F.continueWithLineSegmentNN(a,s,o+2*r),F.continueWithLineSegmentNN(a,s-n,o+r),F.closeCurve(a)}static CreateDiamond(t,e,i){const n=t,r=e,s=i.x,o=i.y,a=new F,l=[new E(s,o-r),new E(s+n,o),new E(s,o+r),new E(s-n,o)];return a.addSegs([I.mkPP(l[0],l[1]),I.mkPP(l[1],l[2]),I.mkPP(l[2],l[3]),I.mkPP(l[3],l[0])]),a}static rotateCurveAroundCenterByDegree(t,e,i){return H.rotateCurveAroundCenterByRadian(t,e,i*Math.PI/180)}static rotateCurveAroundCenterByRadian(t,e,i){const n=Math.cos(i),r=Math.sin(i),s=new j(1,0,e.x,0,1,e.y).multiply(new j(n,-r,0,r,n,0)).multiply(new j(1,0,-e.x,0,1,-e.y));return t.transform(s)}static mkCircle(t,e){return R.mkCircle(t,e)}static createRectangle(t,e,i){const n=t/2,r=e/2,s=i.x,o=i.y,a=new F,l=[new E(s-n,o-r),new E(s+n,o-r),new E(s+n,o+r),new E(s-n,o+r)];return a.addSegs([I.mkPP(l[0],l[1]),I.mkPP(l[1],l[2]),I.mkPP(l[2],l[3]),I.mkPP(l[3],l[0])]),a}static isRoundedRect(t){if(!(t instanceof F))return;const e=t.segs;if(8!=e.length&&4!=e.length)return;const i=8==e.length;let n,r;for(let t=0;t<4;t++){const s=i?2*t+1:t;if(0==t){if(!(e[s]instanceof R))return;const t=e[s];n=t.aAxis.length,r=t.bAxis.length}else{if(!(e[s]instanceof R))return;const t=e[s];if(n!=t.aAxis.length||r!=t.bAxis.length)return}}return{radX:n,radY:r}}static mkRectangleWithRoundedCorners(t,e,i,n,r=new E(0,0)){if(0==i||0==n)return H.createRectangle(t,e,r);const s=new F,o=t/2;i>o/2&&(i=o/2);const a=e/2;n>a/2&&(n=a/2);const l=r.x,h=r.y,u=o-i,c=a-n,d=h+a,g=h-a,f=l-o,p=l+o,m=new E(i,0),y=new E(0,n);return u>0&&s.addSegment(I.mkPP(new E(l-u,g),new E(l+u,g))),s.addSegment(R.mkEllipse(1.5*Math.PI,2*Math.PI,m,y,l+u,h-c)),c>0&&s.addSegment(I.mkPP(new E(p,h-c),new E(p,h+c))),s.addSegment(R.mkEllipse(0,.5*Math.PI,m,y,l+u,h+c)),u>0&&s.addSegment(I.mkPP(new E(l+u,d),new E(l-u,d))),s.addSegment(R.mkEllipse(.5*Math.PI,Math.PI,m,y,l-u,h+c)),c>0&&s.addSegment(I.mkPP(new E(f,h+c),new E(f,h-c))),s.addSegment(R.mkEllipse(Math.PI,1.5*Math.PI,m,y,l-u,h-c)),s}}H.octagonPad=1/4;class q extends z{constructor(){super(...arguments),this.padding=1}get node(){return this.entity}get boundaryCurve(){return this._boundaryCurve}set boundaryCurve(t){(null!=t&&t.boundingBox.height<q.minHeight||t.boundingBox.width<q.minWidth)&&(t=H.mkCircle(q.minWidth,t.boundingBox.center)),this._boundaryCurve=t}get id(){return this.node.id}toString(){return this.id}static mkNode(t,e){const i=new q(e);return i.boundaryCurve=t,i}get center(){return this.boundaryCurve.boundingBox.center}set center(t){const e=t.sub(this.center);this.boundaryCurve.translate(e)}fitBoundaryCurveToTarget(t){if(null!=this.boundaryCurve){const e=H.isRoundedRect(this.boundaryCurve);if(null==e){const e=t.width/this.boundaryCurve.boundingBox.width,i=t.height/this.boundaryCurve.boundingBox.height;this.boundaryCurve=this.boundaryCurve.scaleFromOrigin(e,i),this.boundaryCurve.translate(t.center.sub(this.boundaryCurve.boundingBox.center))}else this.boundaryCurve=H.mkRectangleWithRoundedCorners(t.width,t.height,e.radX,e.radY,t.center)}}*inEdges(){for(const t of this.node.inEdges)yield z.getGeom(t)}*outEdges(){for(const t of this.node.outEdges)yield z.getGeom(t)}*selfEdges(){for(const t of this.node.selfEdges)yield z.getGeom(t)}get boundingBox(){return this.boundaryCurve?this.boundaryCurve.boundingBox:null}set boundingBox(t){this.boundaryCurve&&(Math.abs(t.width-this.width)<1e-4&&Math.abs(t.height-this.height)<1e-4?this.center=t.center:this.fitBoundaryCurveToTarget(t))}get width(){return this.boundaryCurve.boundingBox.width}get height(){return this.boundaryCurve.boundingBox.height}transform(t,e=!0){null!=this.boundaryCurve&&(this.boundaryCurve=this.boundaryCurve.transform(t))}underCollapsedCluster(){return null!=this.node&&this.node.isUnderCollapsedGraph()}}q.minHeight=2,q.minWidth=3;class X{constructor(){this.previouisBezierCoefficient=.5,this.nextBezierCoefficient=.5,this.previousTangentCoefficient=1/3,this.nextTangentCoefficient=1/3}static mkSiteP(t){const e=new X;return e.point=t,e}static mkSiteSP(t,e){const i=new X;return i.point=e,i.prev=t,t.next=i,i}static mkSiteSPS(t,e,i){const n=new X;return n.prev=t,n.point=e,n.next=i,t.next=n,i.prev=n,n}get turn(){return null==this.next||null==this.prev?0:E.getTriangleOrientation(this.prev.point,this.point,this.next.point)}clone(){const t=new X;return t.previouisBezierCoefficient=this.previouisBezierCoefficient,t.point=this.point,t}}class Y{constructor(t){this.headSite=t}static mkFromPoints(t){let e=null,i=null;for(const n of t)if(null==i)i=X.mkSiteP(n),e=new Y(i);else{const t=X.mkSiteP(n);t.prev=i,i.next=t,i=t}return e}clone(){let t,e=this.headSite,i=null,n=null;for(;null!=e;)t=e.clone(),t.prev=i,null!=i?i.next=t:n=t,e=e.next,i=t;return new Y(n)}get lastSite(){let t=this.headSite;for(;null!=t.next;)t=t.next;return t}*getSegments(){let t=this.headSite,e=t.next;for(;null!=e;)yield I.mkPP(t.point,e.point),t=e,e=e.next}*[Symbol.iterator](){let t=this.headSite;for(;null!=t;)yield t.point,t=t.next}createCurve(){const t=new F;let e=this.headSite;for(;;){const i=F.findCorner(e);if(null==i)break;const n=Y.createBezierSegOnSite(i.b);0==t.segs.length?E.closeDistEps(e.point,n.start)||F.addLineSegment(t,e.point,n.start):E.closeDistEps(t.end,n.start)||F.continueWithLineSegmentP(t,n.start),t.addSegment(n),e=i.b}if(0==t.segs.length)if(E.closeDistEps(e.point,e.next.point)){const i=5;t.segs.push(new M(e.point,e.point.add(new E(i,i)),e.point.add(new E(-i,i)),(void 0).point))}else F.addLineSegment(t,e.point,e.next.point);else E.closeDistEps(t.end,e.next.point)||F.continueWithLineSegmentP(t,e.next.point);return t}static createBezierSegOnSite(t){const e=t.previouisBezierCoefficient,i=t.nextBezierCoefficient,n=t.prev,r=t.next,s=n.point.mul(e).add(t.point.mul(1-e)),o=r.point.mul(i).add(t.point.mul(1-i)),a=s.mul(t.previousTangentCoefficient).add(t.point.mul(1-t.previousTangentCoefficient)),l=o.mul(t.nextTangentCoefficient).add(t.point.mul(1-t.nextTangentCoefficient));return M.mkBezier([s,a,l,o])}}class Q{constructor(){this.length=Q.defaultArrowheadLength,this.width=0}clone(){const t=new Q;return t.length=this.length,t.width=this.width,t.tipPosition=this.tipPosition,t}static calculateArrowheads(t){if(null==t.sourceArrowhead&&null==t.targetArrowhead)return!0;const e=Q.findTrimStartForArrowheadAtSource(t);if(null==e)return!1;const i=Q.findTrimEndForArrowheadAtTarget(t);if(null==i)return!1;if(e>i-y.intersectionEpsilon||F.closeIntersectionPoints(t.curve.value(e),t.curve.value(i)))return!1;const n=t.curve.trim(e,i);return null!=n&&(null!=t.sourceArrowhead&&(t.sourceArrowhead.tipPosition=t.curve.start),null!=t.targetArrowhead&&(t.targetArrowhead.tipPosition=t.curve.end),t.curve=n,!0)}static getIntersectionsWithArrowheadCircle(t,e,i){const n=R.mkFullEllipseNNP(e,e,i);return F.getAllIntersections(n,t,!0)}static findTrimEndForArrowheadAtTarget(t){const e=y.distanceEpsilon*y.distanceEpsilon;let i=t.curve.parEnd;if(null==t.targetArrowhead||t.targetArrowhead.length<=y.distanceEpsilon)return i;const n=t.curve;let r,s,o=t.targetArrowhead.length,a=10;do{if(a--,0==a)return;s=Q.getIntersectionsWithArrowheadCircle(n,o,n.end),i=0!=s.length?Math.max(...s.map(t=>t.par1)):n.parEnd,r=t.curve.value(i),o/=2}while(r.sub(n.start).lengthSquared<e||0==s.length);return i}static findTrimStartForArrowheadAtSource(t){if(null==t.sourceArrowhead||t.sourceArrowhead.length<=y.distanceEpsilon)return t.curve.parStart;const e=y.distanceEpsilon*y.distanceEpsilon;let i,n=t.sourceArrowhead.length;const r=t.curve;let s,o,a=10;for(;--a>0;){if(s=Q.getIntersectionsWithArrowheadCircle(r,n,r.start),0==s.length)return r.parStart;if(o=Math.min(...s.map(t=>t.par1)),i=s.filter(t=>t.par1==o)[0].x,i.sub(r.end).lengthSquared>=e)return o;n/=2}}static trimSplineAndCalculateArrowheads(t,e,i){return Q.trimSplineAndCalculateArrowheadsII(t,t.source.boundaryCurve,t.target.boundaryCurve,e,i)}static trimSplineAndCalculateArrowheadsII(t,e,i,n,r){if(t.curve=F.trimEdgeSplineWithNodeBoundaries(e,i,n,r),null==t.curve)return!1;if((null==t.sourceArrowhead||t.sourceArrowhead.length<y.distanceEpsilon)&&(null==t.targetArrowhead||t.targetArrowhead.length<y.distanceEpsilon))return!0;let s=!1;const o=null!=t.sourceArrowhead?t.sourceArrowhead.length:0,a=null!=t.targetArrowhead?t.targetArrowhead.length:0,l=t.curve.end.sub(t.curve.start).length;null!=t.sourceArrowhead&&(t.sourceArrowhead.length=Math.min(l,o)),null!=t.targetArrowhead&&(t.targetArrowhead.length=Math.min(l,a));let h=10;for(;(null!=t.sourceArrowhead&&t.sourceArrowhead.length>y.intersectionEpsilon||null!=t.targetArrowhead&&t.targetArrowhead.length>y.intersectionEpsilon)&&!s&&(s=Q.calculateArrowheads(t),s||(null!=t.sourceArrowhead&&(t.sourceArrowhead.length*=.5),null!=t.targetArrowhead&&(t.targetArrowhead.length*=.5)),h--,0!=h););return s||(null!=t.sourceArrowhead&&(t.sourceArrowhead.tipPosition=n.start),null!=t.targetArrowhead&&(t.targetArrowhead.tipPosition=n.end)),null!=t.sourceArrowhead&&(t.sourceArrowhead.length=o),null!=t.targetArrowhead&&(t.targetArrowhead.length=a),s}static createBigEnoughSpline(t){const e=t.source.center;let i=t.target.center;const n=i.sub(e);let r;n.length<.001?(r=new E(1,0),i=e.add(r.rotate(Math.PI/2))):r=n.rotate(Math.PI/2);let s=1;null!=t.sourceArrowhead&&(s+=t.sourceArrowhead.length),null!=t.targetArrowhead&&(s+=t.targetArrowhead.length),r=r.normalize().mul(1.5*s);for(let n=1;n<1e4;n*=2){const s=F.createBezierSegN(e,i,r,n);if(Q.trimSplineAndCalculateArrowheadsII(t,t.source.boundaryCurve,t.target.boundaryCurve,s,!1))return}Q.createEdgeCurveWithNoTrimming(t,e,i)}static createEdgeCurveWithNoTrimming(t,e,i){const n=i.sub(e).normalize();let r=e,s=i;const o=t.targetArrowhead;null!=o&&(o.tipPosition=i,s=i.sub(n.mul(o.length)));const a=t.sourceArrowhead;null!=a&&(a.tipPosition=e,r=e.add(n.mul(a.length))),t.curve=I.mkPP(r,s)}}Q.defaultArrowheadLength=5;class Z extends z{constructor(t){super(t),this.targetArrowhead=new Q,this.lineWidth=1}get sourcePort(){return this._sourcePort}set sourcePort(t){this._sourcePort=t}get targetPort(){return this._targetPort}set targetPort(t){this._targetPort=t}Translate(t){if(0!=t.x||0!=t.y){if(null!=this.curve&&this.curve.translate(t),null!=this.smoothedPolyline)for(let e=this.smoothedPolyline.headSite,i=this.smoothedPolyline.headSite;null!=e;e=e.next,i=i.next)e.point=i.point.add(t);null!=this.sourceArrowhead&&(this.sourceArrowhead.tipPosition=this.sourceArrowhead.tipPosition.add(t)),null!=this.targetArrowhead&&(this.targetArrowhead.tipPosition=this.targetArrowhead.tipPosition.add(t))}}GetMaxArrowheadLength(){let t=0;return null!=this.sourceArrowhead&&(t=this.sourceArrowhead.length),null!=this.targetArrowhead&&this.targetArrowhead.length>t?this.targetArrowhead.length:t}transform(t){if(null!=this.curve){if(this.curve=this.curve.transform(t),null!=this.underlyingPolyline)for(let e=this.underlyingPolyline.headSite,i=this.underlyingPolyline.headSite;null!=e;e=e.next,i=i.next)e.point=t.multiplyPoint(e.point);null!=this.sourceArrowhead&&(this.sourceArrowhead.tipPosition=t.multiplyPoint(this.sourceArrowhead.tipPosition)),null!=this.targetArrowhead&&(this.targetArrowhead.tipPosition=t.multiplyPoint(this.targetArrowhead.tipPosition)),null!=this.label&&(this.label.center=t.multiplyPoint(this.label.center))}}get labelBBox(){return this.label.boundingBox}get edge(){return this.entity}get source(){return z.getGeom(this.edge.source)}get boundingBox(){const t=G.mkEmpty();if(null!=this.underlyingPolyline)for(const e of this.underlyingPolyline)t.add(e);null!=this.curve&&t.addRecSelf(this.curve.boundingBox),null!=this.sourceArrowhead&&t.add(this.sourceArrowhead.tipPosition),null!=this.targetArrowhead&&t.add(this.targetArrowhead.tipPosition),this.edge.label&&t.addRecSelf(this.label.boundingBox);const e=this.lineWidth;return t.left-=e,t.top+=e,t.right+=e,t.bottom-=e,t}isInterGraphEdge(){return this.edge.isInterGraphEdge()}get target(){return z.getGeom(this.edge.target)}toString(){return this.source.toString()+"->"+this.target}static RouteSelfEdge(t,e,i){const n=t.boundingBox.width,r=t.boundingBox.height,s=t.boundingBox.center,o=new E(s.x-n/4,s.y),a=new E(s.x-n/4,s.y-r/2-e),l=new E(s.x+n/4,s.y-r/2-e),h=new E(s.x+n/4,s.y);return i.smoothedPolyline=Y.mkFromPoints([o,a,l,h]),i.smoothedPolyline.createCurve()}underCollapsedCluster(){return this.source.underCollapsedCluster()||this.target.underCollapsedCluster()}EdgeToAncestor(){return this.edge.EdgeToAncestor()}}class K{constructor(t){this.cancelToken=t}ProgressStep(){}}class ${}$.GoldenRatio=(1+Math.sqrt(5))/2,$.GoldenRatioRemainder=2-$.GoldenRatio;class J extends K{constructor(t,e){super(null),this.desiredAspectRatio=1.2,this.bestPacking=null,this.cachedCosts=new Map,this.rectangles=t,this.desiredAspectRatio=e}get PackedWidth(){return null!=this.bestPacking?this.bestPacking.PackedWidth:0}get PackedHeight(){return null!=this.bestPacking?this.bestPacking.PackedHeight:0}Pack(t,e,i){const n=J.GetGoldenSectionStep(t,e),r=Math.max(i/10,(e-t)/J.MaxSteps);e+=r,this.bestPackingCost=Number.MAX_VALUE,1==this.rectangles.length?this.PackLimit(t):2==this.rectangles.length?(this.PackLimit(t),this.PackLimit(e)):this.rectangles.length>2&&J.GoldenSectionSearch(t=>this.PackLimit(t),t,n,e,r);const s=this.bestPacking.getRects();for(let t=0;t<this.rectangles.length;t++)this.rectangles[t]=s[t]}PackLimit(t){let e=this.cachedCosts.get(t);if(null==e){const i=this.createPacking(this.rectangles,t);i.run(),this.cachedCosts.set(t,e=Math.abs(i.PackedAspectRatio-this.desiredAspectRatio)),e<this.bestPackingCost&&(this.bestPackingCost=e,this.bestPacking=i)}return e}static GoldenSectionSearch(t,e,i,n,r){if(Math.abs(e-n)<r)return t(e)<t(n)?e:n;const s=J.GetGoldenSectionStep(i,n),o=t(i),a=t(s),l=()=>J.GoldenSectionSearch(t,s,i,e,r),h=()=>J.GoldenSectionSearch(t,i,s,n,r);if(a<o)return h();if(a>o)return l();const u=h(),c=l();return t(c)<t(u)?c:u}static GetGoldenSectionStep(t,e){return t<e?t+$.GoldenRatioRemainder*(e-t):t-$.GoldenRatioRemainder*(t-e)}}J.MaxSteps=1e3;var tt,et,it=i(3);class nt extends K{get PackedWidth(){return this.packedWidth}set PackedWidth(t){this.packedWidth=t}get PackedHeight(){return this.packedHeight}set PackedHeight(t){this.packedHeight=t}get PackedAspectRatio(){return this.PackedWidth/this.PackedHeight}getRects(){const t=[];for(const[e,i]of this.rectsToCenters)e.center=i,t.push(e);return t}}class rt extends nt{constructor(t,e,i=!1){super(null),this.rectsToCenters=new Map,this.rectanglesByDescendingHeight=i?t:rt.SortRectangles(t),this.wrapWidth=e}static SortRectangles(t){return t.sort((t,e)=>e.height-t.height),t}run(){this.Pack()}Pack(){this.PackedWidth=0,this.PackedHeight=0;const t=new it.Stack;let e=!1,i=0,n=0,r=0;const s=this.rectanglesByDescendingHeight;for(let o=0;e||o<s.length;){const a=s[o],l=t.length>0?t.top:null;if(null==l||l.right+a.width<=this.wrapWidth&&i+a.height<=l.top){const s=new E(l?l.right:0,i).add(new E(a.width/2,a.height/2));a.center=s,this.rectsToCenters.set(a,s),n=Math.max(n,a.right),r=Math.max(r,a.top),t.push(a),e=!1}else i=l.top,t.pop(),e=!0;e||o++}this.PackedWidth=n,this.PackedHeight=r}}class st extends J{constructor(t,e){super(rt.SortRectangles(t),e),this.createPacking=(t,e)=>new rt(t,e,!0)}run(){let t=Number.MAX_VALUE,e=0,i=0;for(const n of this.rectangles){const r=n.width;i+=r,t=Math.min(t,r),e=Math.max(e,r)}this.Pack(e,i,t)}}function ot(t){if(0==t.length)return null;if(1==t.length)return t[0];const e={b0:t[0].irect,seed0:1},i=function(t,e){let i,n=at(e.b0,t[e.seed0].irect);for(let i=2;i<t.length;i++){const r=at(e.b0,t[i].irect);r>n&&(e.seed0=i,n=r)}for(let n=0;n<t.length;n++)if(n!=e.seed0){i=n;break}n=t[e.seed0].irect.add_rect(t[i].irect).area;for(let r=0;r<t.length;r++){if(r==e.seed0)continue;const s=t[e.seed0].irect.add_rect(t[r].irect).area;s>n&&(i=r,n=s)}return i}(t,e),n=[],r=[];n.push(t[e.seed0]),r.push(t[i]);const s={box0:t[e.seed0].irect,box1:t[i].irect};!function(t,e,i,n,r,s){for(let o=0;o<t.length;o++){if(o==e||o==i)continue;const a=s.box0.add_rect(t[o].irect),l=a.area-s.box0.area,h=s.box1.add_rect(t[o].irect),u=h.area-s.box1.area;2*n.length<r.length?(n.push(t[o]),s.box0=a):2*r.length<n.length?(r.push(t[o]),s.box1=h):l<u?(n.push(t[o]),s.box0=a):u<l?(r.push(t[o]),s.box1=h):s.box0.area<s.box1.area?(n.push(t[o]),s.box0=a):(r.push(t[o]),s.box1=h)}}(t,e.seed0,i,n,r,s);const o=ht(t.length);return o.irect=s.box0.add_rect(s.box1),o.Left=ot(n),o.Right=ot(r),o}function at(t,e){return t.add_rect(e).area}function lt(t,e){if(null==t||null==e)return null;return ot(Array.from(t).map(t=>ut(t,e(t))))}function ht(t){const e=new ct;return e.Count=t,e}function ut(t,e){const i=new ct;return i.UserData=t,i.irect=e,i.Count=1,i}!function(t){t[t.Continue=0]="Continue",t[t.Stop=1]="Stop"}(tt||(tt={}));class ct{toString(){return this.IsLeaf?this.Count.toString()+" "+this.UserData:this.Count.toString()}get IsLeaf(){return null==this.left}get Left(){return this.left}set Left(t){null!=this.left&&this.left.Parent==this&&(this.left.Parent=null),this.left=t,null!=this.left&&(this.left.Parent=this)}get Right(){return this.right}set Right(t){null!=this.right&&this.right.Parent==this&&(this.right.Parent=null),this.right=t,null!=this.right&&(this.right.Parent=this)}get IsLeftChild(){return this==this.Parent.Left}FirstHitNodePF(t,e){var i;return this.irect.contains_point(t)?this.IsLeaf?null!=e?e(t,this.UserData)==tt.Stop?this:null:this:null!==(i=this.Left.FirstHitNodePF(t,e))&&void 0!==i?i:this.Right.FirstHitNodePF(t,e):null}FirstIntersectedNode(t){var e;return t.intersects_rect(this.irect)?this.IsLeaf?this:null!==(e=this.Left.FirstIntersectedNode(t))&&void 0!==e?e:this.Right.FirstIntersectedNode(t):null}FirstHitNodeWithPredicate(t,e){var i;return this.irect.contains_point(t)?this.IsLeaf?e(t,this.UserData)==tt.Stop?this:null:null!==(i=this.Left.FirstHitNodeWithPredicate(t,e))&&void 0!==i?i:this.Right.FirstHitNodeWithPredicate(t,e):null}FirstHitNode(t){var e;return this.irect.contains_point(t)?this.IsLeaf?this:null!==(e=this.Left.FirstHitNode(t))&&void 0!==e?e:this.Right.FirstHitNode(t):null}*AllHitItems(t,e){const i=new it.Stack;for(i.push(this);i.size>0;){const n=i.pop();n.irect.intersects_rect(t)&&(n.IsLeaf?(null==e||e(n.UserData))&&(yield n.UserData):(i.push(n.left),i.push(n.right)))}}*AllHitItems_(t){const e=new it.Stack;for(e.push(this);e.size>0;){const i=e.pop();i.irect.contains_point(t)&&(i.IsLeaf?yield i.UserData:(e.push(i.left),e.push(i.right)))}}VisitTree(t,e){!function t(e,i,n){return e.irect.intersects_rect(n)?i(e.UserData)==tt.Continue?null!=e.Left?t(e.Left,i,n)==tt.Continue&&t(e.Right,i,n)==tt.Continue?tt.Continue:tt.Stop:tt.Continue:tt.Stop:tt.Continue}(this,t,e)}Clone(){const t=ht(this.Count);return t.UserData=this.UserData,t.irect=this.irect,null!=this.Left&&(t.Left=this.Left.Clone()),null!=this.Right&&(t.Right=this.Right.Clone()),t}*GetNodeItemsIntersectingRectangle(t){for(const e of this.GetLeafRectangleNodesIntersectingRectangle(t))yield e.UserData}*GetLeafRectangleNodesIntersectingRectangle(t){const e=new it.Stack;for(e.push(this);e.size>0;){const i=e.pop();i.irect.intersects_rect(t)&&(i.IsLeaf?yield i:(e.push(i.left),e.push(i.right)))}}*GetAllLeaves(){for(const t of this.GetAllLeafNodes())yield t.UserData}*GetAllLeafNodes(){for(const t of this.EnumRectangleNodes(!0))yield t}*EnumRectangleNodes(t){const e=new it.Stack;for(e.push(this);e.size>0;){const i=e.pop();!i.IsLeaf&&t||(yield i),i.IsLeaf||(e.push(i.left),e.push(i.right))}}TraverseHierarchy(t,e){e(t),null!=t.Left&&this.TraverseHierarchy(t.Left,e),null!=t.Right&&this.TraverseHierarchy(t.Right,e)}}function dt(t){return new pt(ot(t.map(([t,e])=>ut(e,t))))}function gt(t){for(let e=t.Parent;null!=e;e=e.Parent)e.Count--,e.irect=e.Left.irect.add_rect(e.Right.irect)}function ft(t){return 2*t.Left.Count>=t.Right.Count&&2*t.Right.Count>=t.Left.Count}class pt{constructor(t){this._rootNode=t}Clear(){this.RootNode=null}NumberOfIntersectedIsLessThanBound(t,e,i){return function t(e,i,n,r){return!e.irect.intersects_rect(i)||(e.IsLeaf?!r(e.UserData)||0!=--n.bound:t(e.Left,i,n,r)&&t(e.Right,i,n,r))}(this._rootNode,t,{bound:e},i)}get RootNode(){return this._rootNode}set RootNode(t){this._rootNode=t}*GetAllLeaves(){if(null!=this._rootNode&&this.Count>0)for(const t of this._rootNode.GetAllLeaves())yield t}get Count(){return null==this._rootNode?0:this._rootNode.Count}Add(t,e){this.AddNode(ut(e,t))}AddNode(t){null==this._rootNode?this._rootNode=t:this.Count<=2?this._rootNode=ot(Array.from(this._rootNode.GetAllLeafNodes()).concat([t])):this.AddNodeToTreeRecursive(t,this._rootNode)}Rebuild(){this._rootNode=ot(Array.from(this._rootNode.GetAllLeafNodes()))}AddNodeToTreeRecursive(t,e){if(e.IsLeaf)e.Left=ut(e.UserData,e.irect),e.Right=t,e.Count=2;else{let i,n;if(e.Count++,2*e.Left.Count<e.Right.Count)this.AddNodeToTreeRecursive(t,e.Left),e.Left.irect=e.Left.irect.add_rect(t.irect);else if(2*e.Right.Count<e.Left.Count)this.AddNodeToTreeRecursive(t,e.Right),e.Right.irect=e.Right.irect.add_rect(t.irect);else{i=e.Left.irect.add_rect(t.irect);const r=i.area-e.Left.irect.area;n=e.Right.irect.add_rect(t.irect);const s=n.area-e.Right.irect.area;r<s?(this.AddNodeToTreeRecursive(t,e.Left),e.Left.irect=i):r>s?(this.AddNodeToTreeRecursive(t,e.Right),e.Right.irect=n):i.area<n.area?(this.AddNodeToTreeRecursive(t,e.Left),e.Left.irect=i):(this.AddNodeToTreeRecursive(t,e.Right),e.Right.irect=n)}}e.irect=e.Left.irect.add_rect(e.Right.irect)}GetAllIntersecting(t){return null==this._rootNode||0==this.Count?[]:Array.from(this._rootNode.GetNodeItemsIntersectingRectangle(t))}OneIntersecting(t){if(null==this._rootNode||0==this.Count)return;const e=this._rootNode.FirstIntersectedNode(t);return null!=e?{intersectedLeaf:e.UserData}:void 0}GetAllLeavesIntersectingRectangle(t){return null==this._rootNode||0==this.Count?[]:this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t)}IsIntersecting(t){if(null==this._rootNode||0==this.Count)return!1;for(const e of this._rootNode.GetNodeItemsIntersectingRectangle(t))return!0;return!1}Contains(t,e){if(null==this._rootNode)return!1;for(const i of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t))if(i.UserData==e)return!0;return!1}Remove(t,e){if(null==this._rootNode)return;let i=void 0;for(const n of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t))n.UserData==e&&(i=n);return null!=i?(1==this.RootNode.Count?this.RootNode=null:this.RemoveLeaf(i),i.UserData):void 0}RemoveLeaf(t){const e=function(t){for(let e=t.Parent;null!=e;e=e.Parent)if(!ft(e))return e;return null}(t);if(null!=e)!function(t,e){const i=new Array;for(const n of t.GetAllLeafNodes())n!=e&&i.push(n);const n=ot(i);t.Count=n.Count,t.Left=n.Left,t.Right=n.Right,t.irect=n.Left.irect.add_rect(n.Right.irect)}(e,t),gt(e);else{const e=t.Parent;null==e?this._rootNode=new ct:(!function(t,e){t.UserData=e.UserData,t.Left=e.Left,t.Right=e.Right,t.Count--,t.irect=e.irect}(e,t.IsLeftChild?e.Right:e.Left),gt(e))}}UnbalancedNode(t){for(let e=t.Parent;null!=e;e=e.Parent)if(!ft(e))return e;return null}}function mt(t,e){const i=new Array;for(const t of e)i.push({g:t,lb:t.boundingBox.leftBottom.clone()});const n=e.map(t=>t.boundingBox),r=new st(n,1.5);r.run();for(const{g:t,lb:e}of i){const i=t.boundingBox.leftBottom.sub(e);t.translate(i)}t.boundingBox=new G({left:0,bottom:0,right:r.PackedWidth,top:r.PackedHeight}),t.addLabelToGraphBB(t.boundingBox)}class yt extends q{constructor(t){super(t),this.MinimalWidth=0,this.MinimalHeight=0,this.Margins=10}*intersectedObjects(t,e=!0){null==this._rtree&&(this._rtree=this.buildRTree());const i=this._rtree.GetAllIntersecting(t),n=t.perimeter();for(const t of i)if(t instanceof q&&(yield t),!e&&t instanceof Z){const e=t.curve;null==F.intersectionOne(e,n,!1)&&F.PointRelativeToCurveLocation(e.start,n)!=a.Inside||(yield t)}}buildRTree(){return dt(Array.from(this.deepNodes()).concat(Array.from(this.deepEdges())).map(t=>[t.boundingBox,t]))}isEmpty(){return this.graph.isEmpty()}setSettingsRecursively(t){this.layoutSettings=t;for(const e of this.deepNodes()){e.layoutSettings=t}}get layoutSettings(){return this._layoutSettings}set layoutSettings(t){this._layoutSettings=t}translate(t){if(0==t.x&&0==t.y)return;const e=new j(1,0,t.x,0,1,t.y);this.transform(e)}get labelSize(){return this._labelSize}set labelSize(t){this._labelSize=t}get boundingBox(){return this._boundingBox}set boundingBox(t){this._boundingBox=t}transform(t,e=!0){if(!t.isIdentity()){null!=this.boundaryCurve&&(this.boundaryCurve=this.boundaryCurve.transform(t));for(const i of this.shallowNodes())i.transform(t,e);for(const e of this.edges())e.transform(t);e&&this.updateBoundingBox()}}*deepNodes(){for(const t of this.graph.deepNodes)yield z.getGeom(t)}setEdge(t,e){const i=this.graph.setEdge(t,e);return new Z(i)}pumpTheBoxToTheGraphWithMargins(t){const e={b:G.mkEmpty()};return this.pumpTheBoxToTheGraph(e),e.b.pad(Math.max(this.Margins,t)),this.MinimalWidth>0&&(e.b.width=Math.max(e.b.width,this.MinimalWidth)),this.MinimalHeight>0&&(e.b.height=Math.max(e.b.height,this.MinimalHeight)),this._boundingBox=e.b,e.b}get center(){return this.boundingBox?this.boundingBox.center:new E(0,0)}set center(t){const e=t.sub(this.center),i=new j(1,0,e.x,0,1,e.y);this.transform(i)}pumpTheBoxToTheGraph(t){for(const e of this.edges())if(!e.underCollapsedCluster()){if(null!=e.curve){const i=e.curve.boundingBox;i.pad(e.lineWidth),t.b.addRecSelf(i)}null!=e.label&&t.b.addRecSelf(e.label.boundingBox)}for(const e of this.shallowNodes())!e.underCollapsedCluster()&&e.boundingBox&&t.b.addRecSelf(e.boundingBox)}get left(){return this.boundingBox.left}get right(){return this.boundingBox.right}get top(){return this.boundingBox.top}get bottom(){return this.boundingBox.bottom}CheckClusterConsistency(){throw new Error("Method not implemented.")}get edgeCount(){return this.graph.edgeCount}*shallowNodes(){for(const t of this.graph.shallowNodes)yield z.getGeom(t)}*edges(){for(const t of this.graph.edges)yield z.getGeom(t)}*deepEdges(){for(const t of this.graph.deepEdges())yield z.getGeom(t)}static mk(t,e=new V(0,0)){const i=new yt(new p(t));return i.labelSize=e,i}*subgraphs(){for(const t of this.graph.subgraphs())yield z.getGeom(t)}static mkWithGraphAndLabel(t,e){const i=new yt(t);return i.labelSize=e,i}get height(){return this.boundingBox.height}get width(){return this.boundingBox.width}get shallowNodeCount(){return this.graph.shallowNodeCount}get graph(){return this.entity}liftNode(t){const e=this.graph.liftNode(t.node);return e?z.getGeom(e):null}findNode(t){const e=this.graph.findNode(t);return e?z.getGeom(e):null}addNode(t){return this.graph.addNode(t.node),t}updateBoundingBox(){if(this.graph.isEmpty())return;const t=G.mkEmpty();let e=0;for(const i of this.graph.edges){const n=z.getGeom(i);null!=n.curve&&(t.addRecSelf(n.boundingBox),e=Math.max(e,n.lineWidth))}for(const i of this.shallowNodes())i.boundingBox&&(t.addRecSelf(i.boundingBox),e=Math.max(e,i.padding));this.addLabelToGraphBB(t),t.pad(Math.max(e,this.Margins)),this.boundingBox=t}addLabelToGraphBB(t){this.labelSize&&(t.top+=this.labelSize.height+2,t.width<this.labelSize.width&&(t.width=this.labelSize.width))}FlipYAndMoveLeftTopToOrigin(){const t=new j(1,0,-this.left,0,-1,this.top);this.transform(t,!1);for(const e of this.deepNodes())if(e instanceof yt){if(!e.graph.isEmpty()){const i=e.boundingBox;e.boundingBox=G.mkSizeCenter(new V(i.width,i.height),t.multiplyPoint(i.center))}}const e=this.boundingBox;this.boundingBox=G.mkSizeCenter(new V(e.width,e.height),t.multiplyPoint(e.center))}}class bt extends z{constructor(t,e){super(e),this.boundingBox=G.mkPP(new E(0,0),new E(t.width,t.height))}get label(){return this.entity}get width(){return this.boundingBox.width}set width(t){this.boundingBox.width=t}get height(){return this.boundingBox.height}set height(t){this.boundingBox.height=t}get center(){return this.boundingBox.center}set center(t){this.boundingBox.center=t}}function Pt(t){const e=new Ct;return e.SetEdges(t,Ct.vertexCount(t)),e}function vt(t){const e=new Ct;return e.SetEdges(t,Ct.vertexCount(t)),e}function St(t,e){const i=new Ct;return i.SetEdges(t,e),i}class Ct{constructor(){this.nodeCount=0}*incidentEdges(t){for(const e of this.outEdges[t])yield e;for(const e of this.inEdges[t])yield e}static deleteFromArray(t,e){const i=t.indexOf(e,0);i>-1&&t.splice(i,1)}removeEdge(t){Ct.deleteFromArray(this.edges,t),t.source!=t.target?(Ct.deleteFromArray(this.outEdges[t.source],t),Ct.deleteFromArray(this.inEdges[t.target],t)):Ct.deleteFromArray(this.selfEdges[t.source],t)}static vertexCount(t){let e=0;for(const i of t)i.source>=e&&(e=i.source),i.target>=e&&(e=i.target);return++e}SetEdges(t,e){this.edges=t,this.nodeCount=e;const i=new Array(this.nodeCount).fill(0),n=new Array(this.nodeCount).fill(0),r=new Array(this.nodeCount).fill(0);this.outEdges=new Array(this.nodeCount),this.inEdges=new Array(this.nodeCount),this.selfEdges=new Array(this.nodeCount);for(const t of this.edges)t.source!=t.target?(i[t.source]++,n[t.target]++):r[t.source]++;for(let t=0;t<this.nodeCount;t++)this.outEdges[t]=new Array(i[t]),i[t]=0,this.inEdges[t]=new Array(n[t]),n[t]=0,this.selfEdges[t]=new Array(r[t]),r[t]=0;for(const t of this.edges){const e=t.source,s=t.target;e!=s?(this.outEdges[e][i[e]++]=t,this.inEdges[s][n[s]++]=t):this.selfEdges[e][r[e]++]=t}}inEdgesCount(t){return this.inEdges[t].length}outEdgesCount(t){return this.outEdges[t].length}selfEdgesCount(t){return this.selfEdges[t].length}addEdge(t){this.edges.push(t),t.source!=t.target?(this.outEdges[t.source].push(t),this.inEdges[t.target].push(t)):this.selfEdges[t.source].push(t)}*nodesOfConnectedGraph(){if(0==this.edges.length)return;const t=new Set,e=new h.Queue;let i=this.edges[0].source;for(Ct.enqueue(t,e,i),yield i;e.length>0;){i=e.dequeue();for(const n of this.outEdges[i]){const i=n.target;t.has(i)||(Ct.enqueue(t,e,i),yield i)}for(const n of this.inEdges[i]){const i=n.source;t.has(i)||(Ct.enqueue(t,e,i),yield i)}}}*pred(t){for(const e of this.inEdges[t])yield e.source}*succ(t){for(const e of this.outEdges[t])yield e.target}static enqueue(t,e,i){e.enqueue(i),t.add(i)}}class wt{constructor(t,e){this.x=t,this.y=e}get source(){return this.x}get target(){return this.y}isDiagonal(){return this.x==this.y}}class Et{constructor(t){this.arrayOfMaps=new Array(t);for(let e=0;e<t;e++)this.arrayOfMaps[e]=new Map}set(t,e,i){this.arrayOfMaps[t].set(e,i)}setPair(t,e){this.set(t.x,t.y,e)}delete(t,e){t<0||t>=this.arrayOfMaps.length||this.arrayOfMaps[t].delete(e)}has(t,e){return!(t<0||t>=this.arrayOfMaps.length)&&this.arrayOfMaps[t].has(e)}get(t,e){return t<0||t>=this.arrayOfMaps.length?null:this.arrayOfMaps[t].get(e)}getI(t){return this.get(t.x,t.y)}*keys(){for(let t=0;t<this.arrayOfMaps.length;t++){const e=this.arrayOfMaps[t];for(const i of e)yield new wt(t,i[0])}}*keyValues(){for(let t=0;t<this.arrayOfMaps.length;t++){const e=this.arrayOfMaps[t];for(const i of e)yield[new wt(t,i[0]),i[1]]}}*values(){for(let t=0;t<this.arrayOfMaps.length;t++){const e=this.arrayOfMaps[t];for(const t of e)yield t[1]}}}!function(t){t[t.NotVisited=0]="NotVisited",t[t.InStack=1]="InStack",t[t.Visited=2]="Visited"}(et||(et={}));class xt{constructor(t,e){this.v=t,this.i=e}}class At{static getFeedbackSetWithConstraints(t,e){throw new Error("Method not implemented.")}static push(t,e,i,n){e[i]=et.InStack,t.push(new xt(i,n))}static getFeedbackSet(t){const e=new Et(t.nodeCount);if(null==t||0==t.nodeCount)return[];const i=new Array(t.nodeCount).fill(et.NotVisited);for(let n=0;n<t.nodeCount;n++){if(i[n]==et.Visited)continue;const r=new it.Stack;let s=0;for(At.push(r,i,n,s);r.size>0;){const o=r.pop();n=o.v,i[n]=et.Visited,s=o.i;let a=t.outEdges[n];for(;s<a.length;s++){const o=a[s];if(o.source==o.target)continue;const l=i[o.target];l==et.InStack?e.set(o.source,o.target,o):l==et.NotVisited&&(At.push(r,i,n,s+1),n=o.target,i[o.target]=et.Visited,a=t.outEdges[n],s=-1)}}}return Array.from(e.values())}}var Tt,It,Ot,_t=i(2);class Lt{constructor(t,e,i,n=1){this.Source=t,this.Target=e,this.CrossingWeight=i,this.Weight=n}toString(){return _t.String.Format("{0}->{1}",this.Source,this.Target)}}class Rt{static FindClosestPoints(t,e){const i=F.minDistWithinIntervals(t,e,t.parStart,t.parEnd,e.parStart,e.parEnd,(t.parStart+t.parEnd)/2,(e.parStart+e.parEnd)/2);if(i)return{curveClosestPoint:i.aX,labelSideClosest:i.bX}}static GetSegmentInFrontOfLabel(t,e){if(t instanceof F)for(const i of t.segs)if((i.start.y-e)*(i.end.y-e)<=0)return i;return null}static ShiftLabel(t,e,i){const n=t.lineWidth/2,r=e.sub(i),s=r.length;s>n&&(t.label.center=t.label.center.add(r.div(s*(s-n))))}static updateLabel(t,e){let i=null;e.labelIsToTheRightOfTheSpline?(t.label.center=new E(e.x+e.rightAnchor/2,e.y),i=I.mkPP(t.labelBBox.leftTop,t.labelBBox.leftBottom)):e.labelIsToTheLeftOfTheSpline&&(t.label.center=new E(e.x-e.leftAnchor/2,e.y),i=I.mkPP(t.labelBBox.rightTop,t.labelBBox.rightBottom));const n=Rt.GetSegmentInFrontOfLabel(t.curve,t.label.center.y);if(null!=n&&0==F.getAllIntersections(t.curve,F.polyFromBox(t.labelBBox),!1).length){const e=Rt.FindClosestPoints(n,i);if(e)Rt.ShiftLabel(t,e.curveClosestPoint,e.labelSideClosest);else{let e,r;const s=n.closestParameter(i.start),o=n.closestParameter(i.end);n.value(s).sub(i.start).length<n.value(o).sub(i.end).length?(e=n.value(s),r=i.start):(e=n.value(o),r=i.end),Rt.ShiftLabel(t,e,r)}}}}class Bt{constructor(t,e,i,n=1,r=1){this.reversed=!1,this.source=t,this.target=e,this.edge=i,this.weight=n,this.separation=r}get CrossingWeight(){return 1}get hasLabel(){return null!=this.edge.label}get labelWidth(){return this.edge.label.width}get labelHeight(){return this.edge.label.height}reverse(){const t=this.source;this.source=this.target,this.target=t,this.reversed=!this.reversed}toString(){return"edge("+this.source+"->"+this.target+")"}get curve(){return this.edge.curve}set curve(t){this.edge.curve=t}get underlyingPolyline(){return this.edge.underlyingPolyline}set underlyingPolyline(t){this.edge.underlyingPolyline=t}get LayerSpan(){return null!=this.LayerEdges?this.LayerEdges.length:0}isSelfEdge(){return this.source==this.target}reversedClone(){const t=new Bt(this.target,this.source,this.edge);if(null!=this.LayerEdges){const e=this.LayerEdges.length;t.LayerEdges=new Array(e);for(let i=0;i<e;i++){const n=this.LayerEdges[e-1-i];t.LayerEdges[i]=new Lt(n.Target,n.Source,n.CrossingWeight)}t.LayerEdges[0].Source=this.target,t.LayerEdges[this.LayerEdges.length-1].Target=this.source}return t}get count(){return this.LayerEdges.length}getNode(t){if(t>=0){if(t<this.LayerEdges.length)return this.LayerEdges[t].Source;if(t==this.LayerEdges.length)return this.LayerEdges[t-1].Target}throw new Error("wrong index "+t)}updateEdgeLabelPosition(t){if(null!=this.edge.label){const e=this.LayerEdges.length/2,i=this.LayerEdges[e];Rt.updateLabel(this.edge,t[i.Source])}}[Symbol.iterator](){return this.nodes()}*nodes(){yield this.LayerEdges[0].Source;for(const t of this.LayerEdges)yield t.Target}}class Mt{constructor(){this.arrayOfSets=new Array}has(t){return this.hasxy(t.x,t.y)}remove(t){if(!(t.x<0||t.x>=this.arrayOfSets.length))return this.arrayOfSets[t.x].delete(t.y)}hasxy(t,e){if(t<0||t>=this.arrayOfSets.length)return!1;const i=this.arrayOfSets[t];return null!=i&&i.has(e)}static mk(t){const e=new Mt;for(const i of t)e.add(i);return e}*values(){for(let t=0;t<this.arrayOfSets.length;t++){const e=this.arrayOfSets[t];if(e)for(const i of e.values())yield new wt(t,i)}}add(t){let e=this.arrayOfSets[t.x];null==e&&(this.arrayOfSets[t.x]=e=new Set),e.add(t.y)}addNN(t,e){let i=this.arrayOfSets[t];null==i&&(this.arrayOfSets[t]=i=new Set),i.add(e)}clear(){for(const t of this.arrayOfSets)t&&t.clear()}}function*Ft(t){const e=new Array(t.nodeCount).fill(!1),i=new h.Queue;for(let n=0;n<t.nodeCount;n++)if(!e[n]){const r=new Array;for(Nt(n,i,e);i.length>0;){const n=i.dequeue();r.push(n);for(const r of Dt(t,n))Nt(r,i,e)}yield r}}function*Dt(t,e){for(const i of t.outEdges[e])yield i.target;for(const i of t.inEdges[e])yield i.source}function Nt(t,e,i){0==i[t]&&(e.enqueue(t),i[t]=!0)}class kt{constructor(){this.maxLayerOfGeomGraph=new Set,this.minLayerOfGeomGraph=new Set,this.sameLayerConstraints=new Array,this.upDownConstraints=new Array,this.gluedUpDownIntConstraints=new Mt,this.sameLayerDictionaryOfRepresentatives=new Map,this.representativeToItsLayer=new Map,this.maxLayerInt=new Array,this.minLayerInt=new Array,this.sameLayerInts=new Array,this.upDownInts=new Array}getFeedbackSetExternal(t,e){throw new Error("Method not implemented.")}pinNodeToMaxLayer(t){this.maxLayerOfGeomGraph.add(t)}pinNodeToMinLayer(t){this.minLayerOfGeomGraph.add(t)}get isEmpty(){return 0==this.maxLayerOfGeomGraph.size&&0==this.minLayerOfGeomGraph.size&&0==this.sameLayerConstraints.length&&0==this.upDownConstraints.length}clear(){this.maxLayerOfGeomGraph.clear(),this.minLayerOfGeomGraph.clear(),this.sameLayerConstraints=[],this.upDownConstraints=[]}getFeedbackSetImp(t,e){return this.nodeIdToIndex=e,this.intGraph=t,this.maxRepresentative=-1,this.minRepresentative=-1,this.createIntegerConstraints(),this.glueTogetherSameConstraintsMaxAndMin(),this.addMaxMinConstraintsToGluedConstraints(),this.removeCyclesFromGluedConstraints(),this.getFeedbackSet()}removeCyclesFromGluedConstraints(){const t=St(Array.from(this.gluedUpDownIntConstraints.values()),this.intGraph.nodeCount),e=At.getFeedbackSetWithConstraints(t,null);for(const t of e)this.gluedUpDownIntConstraints.remove(t)}addMaxMinConstraintsToGluedConstraints(){if(-1!=this.maxRepresentative)for(let t=0;t<this.intGraph.nodeCount;t++){const e=this.nodeToRepr(t);e!=this.maxRepresentative&&this.gluedUpDownIntConstraints.add(new wt(this.maxRepresentative,e))}if(-1!=this.minRepresentative)for(let t=0;t<this.intGraph.nodeCount;t++){const e=this.nodeToRepr(t);e!=this.minRepresentative&&this.gluedUpDownIntConstraints.add(new wt(e,this.minRepresentative))}}glueTogetherSameConstraintsMaxAndMin(){this.createDictionaryOfSameLayerRepresentatives();this.upDownInts.map(this.gluedIntPairNN);this.gluedUpDownIntConstraints=new Mt}gluedIntPairNN(t){return new wt(this.nodeToRepr(t[0]),this.nodeToRepr(t[1]))}gluedIntPairI(t){return new wt(this.nodeToRepr(t.source),this.nodeToRepr(t.target))}gluedIntPair(t){return new wt(this.nodeToRepr(t.source),this.nodeToRepr(t.target))}gluedIntEdge(t){const e=this.nodeToRepr(t.source),i=this.nodeToRepr(t.target),n=new Bt(e,i,t.edge);return n.separation=t.separation,n.weight=0,n}nodeToRepr(t){const e=this.sameLayerDictionaryOfRepresentatives.get(t);return e||t}createDictionaryOfSameLayerRepresentatives(){const t=this.createGraphOfSameLayers();for(const e of Ft(t))this.glueSameLayerNodesOfALayer(e)}createGraphOfSameLayers(){return St(this.createEdgesOfSameLayers(),this.intGraph.nodeCount)}createEdgesOfSameLayers(){const t=new Array;return-1!=this.maxRepresentative&&this.maxLayerInt.filter(t=>t!=this.maxRepresentative).map(t=>new wt(this.maxRepresentative,t)).forEach(e=>t.push(e)),-1!=this.minRepresentative&&this.minLayerInt.filter(t=>t!=this.minRepresentative).map(t=>new wt(this.minRepresentative,t)).forEach(e=>t.push(e)),this.sameLayerInts.forEach(e=>t.push(new wt(e[0],e[1]))),t}glueSameLayerNodesOfALayer(t){if(t.length>1){let e=-1;if(this.componentsIsMaxLayer(t))for(const i of t)this.sameLayerDictionaryOfRepresentatives.set(i,e=this.maxRepresentative);else if(this.componentIsMinLayer(t))for(const i of t)this.sameLayerDictionaryOfRepresentatives.set(i,e=this.minRepresentative);else for(const i of t)-1==e&&(e=i),this.sameLayerDictionaryOfRepresentatives.set(i,e);this.representativeToItsLayer.set(e,t)}}componentIsMinLayer(t){return t.findIndex(t=>this.minRepresentative==t)>=0}componentsIsMaxLayer(t){return t.findIndex(t=>this.maxRepresentative==t)>=0}createIntegerConstraints(){this.createMaxIntConstraints(),this.createMinIntConstraints(),this.createUpDownConstraints(),this.createSameLayerConstraints()}createSameLayerConstraints(){this.sameLayerInts=this.createIntConstraintsFromStringCouples(this.sameLayerConstraints)}createUpDownConstraints(){this.upDownInts=this.createIntConstraintsFromStringCouples(this.upDownConstraints)}createIntConstraintsFromStringCouples(t){return t.map(t=>[this.nodeIndex(t[0]),this.nodeIndex(t[1])]).filter(t=>-1!=t[0]&&-1!=t[1])}createMinIntConstraints(){this.minLayerInt=this.createIntConstraintsFromExtremeLayer(this.minLayerOfGeomGraph),this.minLayerInt.length>0&&(this.minRepresentative=this.minLayerInt[0])}createMaxIntConstraints(){this.maxLayerInt=this.createIntConstraintsFromExtremeLayer(this.maxLayerOfGeomGraph),this.maxLayerInt.length>0&&(this.maxRepresentative=this.maxLayerInt[0])}createIntConstraintsFromExtremeLayer(t){return Array.from(t).map(t=>this.nodeIndex(t)).filter(t=>-1!=t)}nodeIndex(t){const e=this.nodeIdToIndex.get(t.node.id);return e||-1}getFeedbackSet(){return this.gluedIntGraph=this.createGluedGraph(),Array.from(this.unglueIntPairs(At.getFeedbackSetWithConstraints(this.gluedIntGraph,this.gluedUpDownIntConstraints)))}*unglueIntPairs(t){for(const e of t)for(const t of this.unglueEdge(e))yield t}*unglueEdge(t){for(const e of this.unglueNode(t.source))for(const i of this.intGraph.outEdges[e])this.nodeToRepr(i.target)==t.target&&(yield i)}createGluedGraph(){const t=new Mt;return this.intGraph.edges.forEach(e=>t.add(this.gluedIntPairI(e))),St(Array.from(t.values()),this.intGraph.nodeCount)}unglueNode(t){const e=this.representativeToItsLayer.get(t);return e||[t]}getGluedNodeCounts(){const t=new Array(this.nodeIdToIndex.size).fill(0);for(let e=0;e<t.length;e++)t[this.nodeToRepr(e)]++;return t}}class Vt{constructor(){this.leftRightConstraints=new Array,this.leftRightNeighbors=new Array,this.nodeToBlockRoot=new Map,this.upDownVerticalConstraints=new Array,this.BlockRootToBlock=new Map}get IsEmpty(){return 0==this.leftRightNeighbors.length&&0==this.upDownVerticalConstraints.length&&0==this.leftRightConstraints.length}AddSameLayerNeighbors(t){for(let e=0;e<t.length-1;e++)this.AddSameLayerNeighborsPair(t[e],t[e+1])}AddSameLayerNeighborsPair(t,e){this.leftRightNeighbors.push([t,e])}NodeToBlockRootSoft(t){const e=this.nodeToBlockRoot.get(t);return e||t}CreateMappingOfNeibBlocks(){const t=this.BasicGraphFromLeftRightIntNeibs();for(let e=0;e<t.nodeCount;e++)if(0==t.inEdges[e].length&&!this.nodeToBlockRoot.has(e)){const i=new Array;let n=e;for(let r=t.outEdges[n];r.length>0;r=t.outEdges[n])n=r[0].y,i.push(n),this.nodeToBlockRoot.set(n,e);i.length>0&&this.BlockRootToBlock.set(e,i)}}BasicGraphFromLeftRightIntNeibs(){return Pt(Array.from(this.LeftRightIntNeibs.values()).map(t=>new wt(t.x,t.y)))}NodeIndex(t){const e=this.nodeIdToIndex.get(t.id);return e||-1}PrepareForOrdering(t,e){this.nodeIdToIndex=t,this.MapNodesToToIntegers(e),this.CreateMappingOfNeibBlocks(),this.LiftLeftRightRelationsToNeibBlocks()}LiftLeftRightRelationsToNeibBlocks(){this.LeftRighInts=Mt.mk(this.leftRightConstraints.map(t=>function(t,e){return[t,e]}(this.NodeIndex(t[0]),this.NodeIndex(t[1]))).filter(t=>-1!=t[0]&&-1!=t[1]).map(t=>new wt(this.NodeToBlockRootSoft(t[0]),this.NodeToBlockRootSoft(t[1]))).filter(t=>t.x!=t.x));const t=At.getFeedbackSet(Pt(Array.from(this.LeftRighInts.values())));for(const e of t)this.LeftRighInts.remove(new wt(e.source,e.target))}MapNodesToToIntegers(t){this.LeftRightIntNeibs=Mt.mk(Array.from(this.leftRightNeighbors.values()).map(t=>[this.NodeIndex(t[0]),this.NodeIndex(t[1])]).filter(t=>-1!=t[0]&&-1!=t[1]).map(t=>new wt(t[0],t[1]))),this.VerticalInts=Mt.mk(this.upDownVerticalConstraints.map(t=>[this.NodeIndex(t[0]),this.NodeIndex(t[1])]).filter(e=>-1!=e[0]&&-1!=e[1]&&t[e[0]]>t[e[1]]).map(t=>new wt(t[0],t[1])))}}!function(t){t[t.TB=0]="TB",t[t.LR=1]="LR",t[t.BT=2]="BT",t[t.RL=3]="RL",t[t.None=4]="None"}(Tt||(Tt={}));class Gt{constructor(){this.capacityOverflowCoefficient=Gt.DefaultCapacityOverflowCoefficientMultiplier,this.RotateBundles=!1,this.MaxHubRadius=50,this.MinHubRadius=.1,this.CreateUnderlyingPolyline=!1,this.pathLengthImportance=Gt.DefaultPathLengthImportance,this.inkImportance=Gt.DefaultInkImportance,this.edgeSeparation=Gt.DefaultEdgeSeparation,this.angleThreshold=Math.PI/180*45,this.hubRepulsionImportance=100,this.bundleRepulsionImportance=100,this.minimalRatioOfGoodCdtEdges=.9,this.highestQuality=!0,this.KeepOriginalSpline=!1,this.KeepOverlaps=!1,this.StopAfterShortestPaths=!1}get CapacityOverflowCoefficient(){return this.capacityOverflowCoefficient}set CapacityOverflowCoefficient(t){this.capacityOverflowCoefficient=t}get PathLengthImportance(){return this.pathLengthImportance}set PathLengthImportance(t){this.pathLengthImportance=t}get InkImportance(){return this.inkImportance}set InkImportance(t){this.inkImportance=t}get EdgeSeparation(){return this.edgeSeparation}set EdgeSeparation(t){this.edgeSeparation=t}get UseCubicBezierSegmentsInsideOfHubs(){return this.useCubicBezierSegmentsInsideOfHubs}set UseCubicBezierSegmentsInsideOfHubs(t){this.useCubicBezierSegmentsInsideOfHubs=t}get AngleThreshold(){return this.angleThreshold}set AngleThreshold(t){this.angleThreshold=t}get HubRepulsionImportance(){return this.hubRepulsionImportance}set HubRepulsionImportance(t){this.hubRepulsionImportance=t}get BundleRepulsionImportance(){return this.bundleRepulsionImportance}set BundleRepulsionImportance(t){this.bundleRepulsionImportance=t}get MinimalRatioOfGoodCdtEdges(){return this.minimalRatioOfGoodCdtEdges}set MinimalRatioOfGoodCdtEdges(t){this.minimalRatioOfGoodCdtEdges=t}get HighestQuality(){return this.highestQuality}set HighestQuality(t){this.highestQuality=t}}Gt.DefaultCapacityOverflowCoefficientMultiplier=1e3,Gt.DefaultPathLengthImportance=500,Gt.DefaultInkImportance=.01,Gt.DefaultEdgeSeparation=.5,function(t){t[t.Spline=0]="Spline",t[t.SplineBundling=1]="SplineBundling",t[t.StraightLine=2]="StraightLine",t[t.SugiyamaSplines=3]="SugiyamaSplines",t[t.Rectilinear=4]="Rectilinear",t[t.RectilinearToCenter=5]="RectilinearToCenter",t[t.None=6]="None"}(It||(It={}));class zt{constructor(){this.coneAngle=Math.PI/180*30,this.padding=3,this.polylinePadding=1.5,this.routingToParentConeAngle=Math.PI/6,this.simpleSelfLoopsForParentEdgesThreshold=200,this.incrementalRoutingThreshold=5e6,this.routeMultiEdgesAsBundles=!0,this.KeepOriginalSpline=!1,this.EdgeRoutingMode=It.Spline}get EdgeRoutingMode(){return this.edgeRoutingMode}set EdgeRoutingMode(t){t==It.SplineBundling&&null==this.BundlingSettings&&null==this.BundlingSettings&&(this.BundlingSettings=new Gt),this.edgeRoutingMode=t}get ConeAngle(){return this.coneAngle}set ConeAngle(t){this.coneAngle=t}get Padding(){return this.padding}set Padding(t){this.padding=t}get PolylinePadding(){return this.polylinePadding}set PolylinePadding(t){this.polylinePadding=t}get RoutingToParentConeAngle(){return this.routingToParentConeAngle}set RoutingToParentConeAngle(t){this.routingToParentConeAngle=t}get SimpleSelfLoopsForParentEdgesThreshold(){return this.simpleSelfLoopsForParentEdgesThreshold}set SimpleSelfLoopsForParentEdgesThreshold(t){this.simpleSelfLoopsForParentEdgesThreshold=t}get IncrementalRoutingThreshold(){return this.incrementalRoutingThreshold}set IncrementalRoutingThreshold(t){this.incrementalRoutingThreshold=t}get RouteMultiEdgesAsBundles(){return this.routeMultiEdgesAsBundles}set RouteMultiEdgesAsBundles(t){this.routeMultiEdgesAsBundles=t}}!function(t){t[t.None=0]="None",t[t.Top=1]="Top",t[t.Bottom=2]="Bottom"}(Ot||(Ot={}));class jt{constructor(){this.runRoutingOnly=!1,this.edgeRoutingSettings=new zt,this.minimalWidth=0,this.minimalHeight=0,this.nodeSeparation=10,this.packingAspectRatio=1.5}get MinimalWidth(){return this.minimalWidth}set MinimalWidth(t){this.minimalWidth=Math.max(t,0)}get MinimalHeight(){return this.minimalHeight}set MinimalHeight(t){this.minimalHeight=Math.max(t,0)}get NodeSeparation(){return this.nodeSeparation}set NodeSeparation(t){this.nodeSeparation=t}get PackingAspectRatio(){return this.packingAspectRatio}set PackingAspectRatio(t){this.packingAspectRatio=t}}class Ut extends jt{constructor(){super(),this.margins={left:0,top:0,bottom:0,right:0},this.sameRanks=new Array,this.verticalConstraints=new kt,this.horizontalConstraints=new Vt,this.NoGainAdjacentSwapStepsBound=5,this.RepetitionCoefficientForOrdering=1,this.AspectRatio=0,this.MaxNumberOfPassesInOrdering=24,this.BrandesThreshold=600,this.LabelCornersPreserveCoefficient=.1,this.MinNodeHeight=9,this.MinNodeWidth=13.5,this.SnapToGridByY=Ot.None,this.yLayerSep=30,this.transform=j.getIdentity(),this.GridSizeByY=0,this.GridSizeByX=0,this.edgeRoutingSettings.EdgeRoutingMode=It.SugiyamaSplines}get LayerSeparation(){return this.yLayerSep}set LayerSeparation(t){this.yLayerSep=Math.max(30,t)}ActualLayerSeparation(t){return t?this.LayerSeparation/2:this.LayerSeparation}transformIsRotation(t){const e=j.rotation(t);for(let t=0;t<2;t++)for(let i=0;i<3;i++)if(!v(e.elements[t][i],this.transform.elements[t][i]))return!1;return!0}get layerDirection(){return this.transformIsRotation(0)?Tt.TB:this.transformIsRotation(Math.PI/2)?Tt.LR:this.transformIsRotation(-Math.PI/2)?Tt.RL:this.transformIsRotation(Math.PI)?Tt.BT:Tt.None}set layerDirection(t){switch(t){case Tt.TB:break;case Tt.LR:this.transform=j.rotation(Math.PI/2);break;case Tt.RL:this.transform=j.rotation(-Math.PI/2);break;case Tt.BT:this.transform=j.rotation(Math.PI);break;default:throw new Error("unexpected layout direction")}}}class Wt{constructor(){this.isEmpty=!0}AddValue(t){this.isEmpty?(this.max=t,this.min=t,this.isEmpty=!1):t<this.min?this.min=t:t>this.max&&(this.max=t)}get length(){return this.max-this.min}static sign(t){return t>y.distanceEpsilon?1:t<-y.distanceEpsilon?-1:0}}class Ht extends Ct{constructor(t,e){super(),this.SetEdges(t,e)}}class qt{constructor(t){this.MultipleMiddles=new Set,this.Multiedges=new Et(t)}*RegularMultiedges(){for(const[t,e]of this.Multiedges.keyValues())t.x!=t.y&&(yield e)}*AllIntEdges(){for(const t of this.Multiedges.values())for(const e of t)yield e}addFeedbackSet(t){for(const e of t){const t=new wt(e.source,e.target),i=new wt(e.target,e.source),n=this.Multiedges.get(t.x,t.y);for(const t of n)t.reverse();if(this.Multiedges.has(i.x,i.y)){const t=this.Multiedges.get(i.x,i.y);for(const e of n)t.push(e)}else this.Multiedges.set(i.x,i.y,n);this.Multiedges.delete(t.x,t.y)}}registerOriginalEdgeInMultiedges(t){let e=this.Multiedges.get(t.source,t.target);null==e&&this.Multiedges.set(t.source,t.target,e=[]),e.push(t)}*SkeletonEdges(){for(const[t,e]of this.Multiedges.keyValues())t.x!=t.y&&(yield e[0])}GetMultiedge(t,e){return this.GetMultiedgeI(new wt(t,e))}GetMultiedgeI(t){return this.Multiedges.has(t.x,t.y)?this.Multiedges.get(t.x,t.y):new Array}}function Xt(t,e){for(let i=0;i<t.length;i++)e[i]=t[i]}class Yt{constructor(t){this.initialize(t)}initialize(t){this.y=t,this.verticesToX=null,this.layers=null}DropEmptyLayers(){const t=new Array(this.Layers.length);let e=0;for(let i=0;i<this.Layers.length;i++)t[i]=e,0==this.Layers[i].length&&e++;if(0==e)return this;const i=new Array(this.y.length);for(let e=0;e<i.length;e++)i[e]=this.y[e]-t[this.y[e]];const n=new Array(this.layers.length-e);for(let e=0;e<this.layers.length;e++)this.layers[e].length>0&&(n[e-t[e]]=Array.from(this.layers[e]));const r=new Yt(i);return r.layers=n,r}updateLayers(t){null==this.layers&&this.InitLayers();for(let e=0;e<this.layers.length;e++)Xt(t[e],this.layers[e]);this.UpdateXFromLayers()}UpdateXFromLayers(){null==this.layers&&this.InitLayers(),null==this.verticesToX&&(this.verticesToX=new Array(this.y.length));for(const t of this.layers){let e=0;for(const i of t)this.verticesToX[i]=e++}}get x(){return null!=this.verticesToX||(this.verticesToX=new Array(this.y.length),this.UpdateXFromLayers()),this.verticesToX}ReversedClone(){const t=new Array(this.y.length),e=this.Layers.length-1;for(let i=0;i<this.y.length;i++)t[i]=e-this.y[i];return new Yt(t)}get Layers(){return null!=this.layers||this.InitLayers(),this.layers}set Layers(t){this.layers=t}InitLayers(){let t=0;for(const e of this.y)e+1>t&&(t=e+1);const e=new Array(t).fill(0);for(const t of this.y)e[t]++;this.layers=new Array(t);for(let i=0;i<t;i++)this.layers[i]=new Array(e[i]),e[i]=0;for(let t=0;t<this.y.length;t++){const i=this.y[t];this.layers[i][e[i]++]=t}}}class Qt extends K{constructor(t,e,i,n){super(n),this.jumpers=new Set,this.possibleJumperFeasibleIntervals=new Map,this.nodeCount=i,this.dag=t,this.layering=e,this.Init()}static Balance(t,e,i,n){new Qt(t,e,i,n).run()}run(){for(;this.jumpers.size>0;)this.Jump(this.ChooseJumper())}Init(){this.CalculateLayerCounts(),this.InitJumpers()}Jump(t){this.jumpers.delete(t);const e=this.possibleJumperFeasibleIntervals.get(t),i=this.CalcJumpInfo(e.x,e.y,t);if(null==i)return;this.layering[t]=i.layerToJumpTo;const n=this.nodeCount[t];this.vertsCounts[i.jumperLayer]-=n,this.vertsCounts[i.layerToJumpTo]+=n,this.UpdateRegionsForPossibleJumpersAndInsertJumpers(i.jumperLayer,t)}IsJumper(t){return this.possibleJumperFeasibleIntervals.has(t)}UpdateRegionsForPossibleJumpersAndInsertJumpers(t,e){const i=new Set;for(const t of this.dag.pred(e))this.IsJumper(t)&&(this.CalculateRegionAndInsertJumper(t),i.add(t));for(const t of this.dag.succ(e))this.IsJumper(t)&&(this.CalculateRegionAndInsertJumper(t),i.add(t));const n=new Array;for(const e of this.possibleJumperFeasibleIntervals)i.has(e[0])||e[1].x>t&&e[1].y<t&&n.push(e[0]);for(const t of n)this.CalculateRegionAndInsertJumper(t)}InitJumpers(){const t=new Array(this.dag.nodeCount).fill(0);for(const e of this.dag.edges)t[e.source]-=e.weight,t[e.target]+=e.weight;this.possibleJumperFeasibleIntervals=new Map;for(let e=0;e<this.dag.nodeCount;e++)0==t[e]&&this.CalculateRegionAndInsertJumper(e)}CalculateRegionAndInsertJumper(t){const e=new wt(this.Up(t),this.Down(t));this.possibleJumperFeasibleIntervals.set(t,e),this.InsertJumper(e.x,e.y,t)}InsertJumper(t,e,i){null!=this.CalcJumpInfo(t,e,i)&&this.jumpers.add(i)}CalcJumpInfo(t,e,i){const n=this.layering[i];let r=-1,s=this.vertsCounts[n]-2*this.nodeCount[i];for(let e=t-1;e>n;e--)this.vertsCounts[e]<s&&(s=this.vertsCounts[e],r=e);for(let t=n-1;t>e;t--)this.vertsCounts[t]<s&&(s=this.vertsCounts[t],r=t);if(-1!=r)return{jumperLayer:n,layerToJumpTo:r}}Up(t){let e=Number.MAX_SAFE_INTEGER;for(const i of this.dag.inEdges[t]){const t=this.layering[i.source]-i.separation+1;t<e&&(e=t)}return e==Number.MAX_SAFE_INTEGER&&(e=this.layering[t]+1),e}Down(t){let e=Number.NEGATIVE_INFINITY;for(const i of this.dag.outEdges[t]){const t=this.layering[i.target]+i.separation-1;t>e&&(e=t)}return e==Number.NEGATIVE_INFINITY&&(e=this.layering[t]-1),e}CalculateLayerCounts(){this.vertsCounts=new Array(Math.max(...this.layering)+1).fill(0);for(const t of this.layering)this.vertsCounts[t]+=this.nodeCount[t]}ChooseJumper(){for(const t of this.jumpers)return t;throw new Error("there are no jumpers to choose")}}class Zt{constructor(t){this.Initialize(t)}Initialize(t){this.BaseGraph=t,this.totalNumberOfNodes=t.nodeCount;for(const t of this.BaseGraph.edges)if(null!=t.LayerEdges)for(const e of t.LayerEdges){const t=Math.max(e.Source,e.Target)+1;t>this.totalNumberOfNodes&&(this.totalNumberOfNodes=t)}this.firstVirtualNode=Number.POSITIVE_INFINITY;for(const t of this.BaseGraph.edges)if(null!=t.LayerEdges)for(let e=1;e<t.LayerEdges.length;e++){const i=t.LayerEdges[e];this.firstVirtualNode=Math.min(this.firstVirtualNode,i.Source)}this.firstVirtualNode==Number.POSITIVE_INFINITY&&(this.firstVirtualNode=this.BaseGraph.nodeCount,this.totalNumberOfNodes=this.BaseGraph.nodeCount),this.virtualNodesToInEdges=new Array(this.totalNumberOfNodes-this.firstVirtualNode),this.virtualNodesToOutEdges=new Array(this.totalNumberOfNodes-this.firstVirtualNode);for(const t of this.BaseGraph.edges)if(t.LayerSpan>0)for(const e of t.LayerEdges)e.Target!=t.target&&(this.virtualNodesToInEdges[e.Target-this.firstVirtualNode]=e),e.Source!=t.source&&(this.virtualNodesToOutEdges[e.Source-this.firstVirtualNode]=e)}*edges_(){for(const t of this.BaseGraph.edges)if(t.LayerSpan>0)for(const e of t.LayerEdges)yield e}get Edges(){return this.edges_()}*InEdges(t){if(t<this.BaseGraph.nodeCount)for(const e of this.BaseGraph.inEdges[t])e.source!=e.target&&null!=e.LayerEdges&&(yield Zt.LastEdge(e));else t>=this.firstVirtualNode&&(yield this.InEdgeOfVirtualNode(t))}static LastEdge(t){return t.LayerEdges[t.LayerEdges.length-1]}InEdgeOfVirtualNode(t){return this.virtualNodesToInEdges[t-this.firstVirtualNode]}*OutEdges(t){if(t<this.BaseGraph.nodeCount)for(const e of this.BaseGraph.outEdges[t])e.source!=e.target&&null!=e.LayerEdges&&(yield Zt.FirstEdge(e));else t>=this.firstVirtualNode&&(yield this.OutEdgeOfVirtualNode(t))}OutDegreeIsMoreThanOne(t){return t<this.BaseGraph.nodeCount&&this.BaseGraph.outEdges[t].length>1}InDegreeIsMoreThanOne(t){return t<this.BaseGraph.nodeCount&&this.BaseGraph.inEdges[t].length>1}OutEdgeOfVirtualNode(t){return this.virtualNodesToOutEdges[t-this.firstVirtualNode]}static FirstEdge(t){return t.LayerEdges[0]}InEdgesCount(t){return this.RealInEdgesCount(t)}RealInEdgesCount(t){return t<this.BaseGraph.nodeCount?this.BaseGraph.inEdges[t].filter(t=>null!=t.LayerEdges).length:1}OutEdgesCount(t){return this.RealOutEdgesCount(t)}RealOutEdgesCount(t){return t<this.BaseGraph.nodeCount?this.BaseGraph.outEdges[t].filter(t=>null!=t.LayerEdges).length:1}get NodeCount(){return this.totalNumberOfNodes}IsRealNode(t){return t<this.BaseGraph.nodeCount}IsVirtualNode(t){return!this.IsRealNode(t)}ReversedClone(){const t=this.CreateReversedEdges();return new Zt(new Ht(t,this.BaseGraph.nodeCount))}CreateReversedEdges(){const t=new Array;for(const e of this.BaseGraph.edges)e.isSelfEdge()||t.push(e.reversedClone());return t}*Succ(t){for(const e of this.OutEdges(t))yield e.Target}*Pred(t){for(const e of this.InEdges(t))yield e.Source}}var Kt=i(26);class $t{constructor(t,e,i,n){this.la=e,this.database=i,this.layeredGraph=t,this.intGraph=n}static InsertLayers(t,e,i,n){const r=new $t(t,e,i,n);return r.InsertLayers(),{layeredGraph:r.nLayeredGraph,la:r.Nla.DropEmptyLayers()}}get NLayering(){return this.Nla.y}InsertLayers(){this.EditOldLayering(),this.CreateFullLayeredGraph(),this.InitNewLayering(),this.MapVirtualNodesToEdges(),this.FillUnsortedNewOddLayers(),this.WidenOriginalLayers(),this.SortNewOddLayers()}EditOldLayering(){let t=this.intGraph.nodeCount;for(const e of this.database.RegularMultiedges()){let i=0;const n=e[0];if(i=2*n.LayerSpan,i>0){for(const e of n.LayerEdges)e.Target!=n.target&&(t++,this.UpdateOldLayer(t++,e.Target));t+=(i-1)*(e.length-1)+1}}}UpdateOldLayer(t,e){const i=this.la.x[e],n=this.la.y[e];this.la.Layers[n][i]=t}WidenOriginalLayers(){for(let t=0;t<this.la.Layers.length;t++){const e=this.Nla.Layers[2*t];let i=0;for(const n of this.la.Layers[t]){const t=this.virtNodesToIntEdges[n];if(null!=t){const r=this.NLayering[t.source]-this.NLayering[n],s=this.database.Multiedges.get(t.source,t.target);for(const o of s)if(o!=t){const t=o.LayerEdges[r].Source;e[i]=t,this.Nla.x[t]=i++}else e[i]=n,this.Nla.x[n]=i++}else e[i]=n,this.Nla.x[n]=i++}}}FillUnsortedNewOddLayers(){const t=new Array(this.Nla.Layers.length).fill(0);for(let e=this.intGraph.nodeCount;e<this.nLayeredGraph.NodeCount;e++){const i=this.NLayering[e];i%2==1&&(this.Nla.Layers[i][t[i]++]=e)}}MapVirtualNodesToEdges(){this.virtNodesToIntEdges=new Array(this.NLayering.length);for(const t of this.database.AllIntEdges())if(t.source!=t.target&&null!=t.LayerEdges)for(const e of t.LayerEdges)e.Target!=t.target&&(this.virtNodesToIntEdges[e.Target]=t)}CreateFullLayeredGraph(){this.totalNodes=this.intGraph.nodeCount;for(const t of this.database.RegularMultiedges()){let e=0,i=!0;for(const n of t)if(i&&(i=!1,e=2*n.LayerSpan),e>0){n.LayerEdges=new Array(e);for(let t=0;t<e;t++){const i={currentVV:this.totalNodes},r=Jt.GetSource(i,n,t);this.totalNodes=i.currentVV;const s=Jt.GetTarget(this.totalNodes,n,t,e);n.LayerEdges[t]=new Lt(r,s,n.CrossingWeight)}$t.RegisterDontStepOnVertex(this.database,n)}}this.nLayeredGraph=new Zt(this.intGraph)}SortNewOddLayers(){for(let t=1;t<this.Nla.Layers.length;t+=2){const e=new Kt.SortedMap,i=this.Nla.Layers[t];for(const t of i){let i=-1;for(const e of this.nLayeredGraph.InEdges(t))i=e.Source;let n=-1;for(const e of this.nLayeredGraph.OutEdges(t))n=e.Target;const r=this.Nla.x[i]+this.Nla.x[n];if(e.has(r)){const i=e.get(r);if("number"==typeof i){const n=new Array;n.push(i),n.push(t),e.set(r,n)}else{i.push(t)}}else e.set(r,t)}let n=0;for(const t of e.values())if("number"==typeof t)i[n++]=t;else for(const e of t)i[n++]=e;for(let t=0;t<i.length;t++)this.Nla.x[i[t]]=t}}InitNewLayering(){this.Nla=new Yt(new Array(this.totalNodes));for(let t=0;t<this.layeredGraph.NodeCount;t++)this.NLayering[t]=2*this.la.y[t];for(const[t,e]of this.database.Multiedges.keyValues())if(t.x!=t.y&&this.la.y[t.x]!=this.la.y[t.y]){const i=2*this.la.y[t.x];for(const t of e){let e=i-1;for(const i of t.LayerEdges)i.Target!=t.target&&(this.NLayering[i.Target]=e--)}}const t=new Array(2*this.la.Layers.length-1),e=new Array(t.length).fill(0);for(const t of this.NLayering)e[t]++;for(let i=0;i<e.length;i++)t[i]=new Array(e[i]);this.Nla=new Yt(this.NLayering),this.Nla.Layers=t}static RegisterDontStepOnVertex(t,e){if(t.Multiedges.get(e.source,e.target).length>1){const i=e.LayerEdges[e.LayerEdges.length/2];t.MultipleMiddles.add(i.Source)}}}class Jt{constructor(t,e,i,n){this.virtNodesToIntEdges=new Map,this.la=e,this.database=i,this.layeredGraph=t,this.intGraph=n}get NLayering(){return this.Nla.y}static InsertPaths(t,e,i,n){const r=new Jt(t,e,i,n);return r.InsertPaths(),{layeredGraph:r.NLayeredGraph,la:r.Nla}}InsertPaths(){this.CreateFullLayeredGraph(),this.InitNewLayering(),this.MapVirtualNodesToEdges(),this.WidenOriginalLayers()}WidenOriginalLayers(){for(let t=0;t<this.la.Layers.length;t++){const e=this.Nla.Layers[t];let i=0;for(const n of this.la.Layers[t]){const t=this.virtNodesToIntEdges.get(n);if(null!=t){const r=this.NLayering[t.source]-this.NLayering[n],s=this.database.Multiedges.get(t.source,t.target);for(const o of s)if(!this.EdgeIsFlat(o))if(o!=t){const t=o.LayerEdges[r].Source;e[i]=t,this.Nla.x[t]=i++}else e[i]=n,this.Nla.x[n]=i++}else e[i]=n,this.Nla.x[n]=i++}}}EdgeIsFlat(t){return this.la.y[t.source]==this.la.y[t.target]}MapVirtualNodesToEdges(){for(const t of this.database.RegularMultiedges())for(const e of t)if(!this.EdgeIsFlat(e))for(const t of e.LayerEdges)t.Target!=e.target&&this.virtNodesToIntEdges.set(t.Target,e)}CreateFullLayeredGraph(){let t=this.layeredGraph.NodeCount;for(const[e,i]of this.database.Multiedges.keyValues())if(e.x!=e.y){let e=!0,n=0;for(const r of i){if(e)e=!1,n=r.LayerSpan;else if(r.LayerEdges=new Array(n),1==n)r.LayerEdges[0]=new Lt(r.source,r.target,r.CrossingWeight);else for(let e=0;e<n;e++){const i={currentVV:t},s=Jt.GetSource(i,r,e);t=i.currentVV;const o=Jt.GetTarget(t,r,e,n);r.LayerEdges[e]=new Lt(s,o,r.CrossingWeight)}$t.RegisterDontStepOnVertex(this.database,r)}}this.NLayeredGraph=new Zt(this.intGraph)}static GetTarget(t,e,i,n){return i<n-1?t:e.target}static GetSource(t,e,i){return 0==i?e.source:t.currentVV++}InitNewLayering(){this.Nla=new Yt(new Array(this.NLayeredGraph.NodeCount));for(let t=0;t<this.layeredGraph.NodeCount;t++)this.NLayering[t]=this.la.y[t];for(const[t,e]of this.database.Multiedges.keyValues())if(t.x!=t.y&&this.la.y[t.x]!=this.la.y[t.y]){let t=0,i=!0;for(const n of e){i&&(i=!1,t=this.la.y[n.source]);let e=t-1;for(const t of n.LayerEdges)this.NLayering[t.Target]=e--}}const t=new Array(this.la.Layers.length),e=new Array(t.length).fill(0);for(const t of this.NLayering)e[t]++;for(let i=0;i<e.length;i++)t[i]=new Array(e[i]);this.Nla=new Yt(this.NLayering),this.Nla.Layers=t}}const te=BigInt("6364136223846793005"),ee=(BigInt(1)<<BigInt(32))-BigInt(1),ie=(BigInt(1)<<BigInt(64))-BigInt(1);class ne{constructor(t,e){this._state=BigInt(0),this._inc=(BigInt(e)<<BigInt(1)|BigInt(1))&ie,this._random_b(),this._state=this._state+BigInt(t)&ie,this._random_b()}_random_b(){const t=this._state;this._state=t*te+this._inc&ie;const e=(t>>BigInt(18)^t)>>BigInt(27),i=t>>BigInt(59);return(e>>i|e<<(i^BigInt(31)))&ee}_advance(t){t&=ie;let e=BigInt(1),i=te,n=BigInt(0),r=this._inc;for(;t>0;)t&BigInt(1)&&(e=e*i&ie,n=n*i+r&ie),r=(i+BigInt(1))*r&ie,i=i*i&ie,t>>=BigInt(1);this._state=e*this._state+n&ie}randint(t){if(t>ee)throw new TypeError("Bound too large: "+t);if(t<=0)throw new TypeError("Empty sample space for r: 0  r < "+t);const e=BigInt(t),i=(ee^e)%e;for(;;){const t=this._random_b();if(t>=i)return Number(t%e)}}random(){return Number(this._random_b())/Math.pow(2,32)}}let re;function se(t){return null==re&&(re=new ne(0,0)),re.randint(t)}function oe(){return null==re&&(re=new ne(0,0)),re.random()}class ae{constructor(t,e,i){this.numberOfCrossings=e,this.la=t,this.virtVertexStart=i}LayerGroupDisbalance(t,e,i){return 1==e?this.LayerGroupDisbalanceWithOrigSeparators(t,i):this.LayerGroupDisbalanceWithVirtSeparators(t,e)}LayerGroupDisbalanceWithVirtSeparators(t,e){let i=0;for(let n=0;n<t.length;){const r=this.CurrentOrigGroupDelta(n,t,e);n=r.i,i+=r.ret}return i}CurrentOrigGroupDelta(t,e,i){let n=0,r=t;for(;r<e.length&&e[r]<this.virtVertexStart;r++)n++;return t=r+1,{ret:Math.abs(i-n),i:t}}LayerGroupDisbalanceWithOrigSeparators(t,e){let i=0;for(let n=0;n<t.length;){const r=this.CurrentVirtGroupDelta(n,t,e);i+=r.ret,n=r.i}return i}CurrentVirtGroupDelta(t,e,i){let n=0,r=t;for(;r<e.length&&e[r]>=this.virtVertexStart;r++)n++;return t=r+1,{ret:Math.abs(i-n),i:t}}static less(t,e){return t.numberOfCrossings<e.numberOfCrossings}static greater(t,e){return t.numberOfCrossings>e.numberOfCrossings}IsPerfect(){return 0==this.numberOfCrossings}}class le{constructor(t){this.x=t}Compare(t,e){const i=this.x[t.Source]-this.x[e.Source];return 0!=i?i:this.x[t.Target]-this.x[e.Target]}}class he{constructor(t){this.x=t}Compare(t,e){const i=this.x[t.Target]-this.x[e.Target];return 0!=i?i:this.x[t.Source]-this.x[e.Source]}}class ue{constructor(t,e){P(t,e)<0?(this.first=t,this.second=e):(this.first=e,this.second=t)}get First(){return this.first}get Second(){return this.second}get Length(){return w(this.first,this.second)}CompareTo(t){const e=P(this.first,t.first);return 0!=e?e:P(this.second,t.second)}static equal(t,e){return t.first.equal(e.first)&&t.second.equal(e.second)}toString(){return this.first+" "+this.second}}class ce{constructor(){this.size_=0,this.mapOfSets=new Map}delete(t){return this.deletexy(t.x,t.y)}clear(){this.mapOfSets.clear(),this.size_=0}get size(){return this.size_}static mk(t){const e=new ce;for(const i of t)e.add(i);return e}addxy(t,e){let i=this.mapOfSets.get(t);null==i&&this.mapOfSets.set(t,i=new Set),i.has(e)||this.size_++,i.add(e)}add(t){return this.addxy(t.x,t.y),this}deletexy(t,e){const i=this.mapOfSets.get(t);return!(null==i||!i.delete(e))&&(this.size_--,!0)}hasxy(t,e){return this.mapOfSets.has(t)&&this.mapOfSets.get(t).has(e)}has(t){return this.hasxy(t.x,t.y)}forEach(t,e){for(const i of this)t(i,i,e)}*entries(){for(const t of this)yield[t,t]}keys(){return this.values()}*values(){for(const t of this.mapOfSets)for(const e of t[1])yield new E(t[0],e)}[(Symbol.toStringTag,Symbol.iterator)](){return this.values()}}function de(t,e){const i=new Set;for(const n of t)e.has(n)||i.add(n);return i}function ge(t,e){const i=new Set(t);for(const t of e)i.add(t);return i}function fe(t,e){for(const i of e)t.push(i)}function pe(t,e){const i=new Set;if(t.size<e.size)for(const n of t)e.has(n)&&i.add(n);else for(const n of e)t.has(n)&&i.add(n);return i}function me(t,e){for(const i of e)t.add(i)}function ye(t,e){if(t.size!=e.size)return!1;for(const i of t)if(!e.has(i))return!1;return!0}function be(t,e){const i=[];for(const n of t)for(const t of e(n))i.push(t);return i}function Pe(t,e,i){let n=t.get(e);n||(n=new Set,t.set(e,n)),n.add(i)}function ve(t,e,i){let n=t.get(e);n||(n=new Array,t.set(e,n)),n.push(i)}function Se(t,e,i){let n=t.get(e);n||(n=new Set,t.set(e,n)),n.add(i)}function Ce(t,e,i){!function(t,e,i){const n=t.get(e);n&&n.delete(i)}(t,new ue(e[0],e[1]),i)}function we(){return 0==se(2)}function Ee(t,e,i){const n=i.Layers[t+1],r=i.Layers[t];return r.length<=n.length?function(t,e,i){const n=xe(t,e),r=new le(i.x);n.sort((t,e)=>r.Compare(t,e));let s=1;for(;s<t.length;)s*=2;const o=new Array(2*s-1).fill(0);s--;let a=0;for(const t of n){let e=s+i.x[t.Target];const n=t.CrossingWeight;for(o[e]+=n;e>0;)e%2!=0&&(a+=n*o[e+1]),e=Math.floor((e-1)/2),o[e]+=n}return a}(r,e,i):function(t,e,i,n){const r=xe(e,i),s=new he(n.x);r.sort((t,e)=>s.Compare(t,e));let o=1;for(;o<t.length;)o*=2;const a=new Array(2*o-1).fill(0);o--;let l=0;for(const t of r){let e=o+n.x[t.Source];const i=t.CrossingWeight;for(a[e]+=i;e>0;)e%2!=0&&(l+=i*a[e+1]),e=Math.floor((e-1)/2),a[e]+=i}return l}(n,r,e,i)}function xe(t,e){return be(t,t=>Array.from(e.InEdges(t)))}function Ae(t,e){let i=0;for(let n=0;n<e.Layers.length-1;n++)i+=Ee(n,t,e);return i}class Te extends K{constructor(t,e,i,n,r,s,o){super(o),this.tryReverse=!0,this.MaxNumberOfAdjacentExchanges=50,this.cancelToken=o,this.tryReverse=e,this.startOfVirtNodes=n,this.layerArrays=i,this.layering=i.y,this.nOfLayers=i.Layers.length,this.layers=i.Layers,this.properLayeredGraph=t,this.hasCrossWeights=r,this.SugSettings=s}get NoGainStepsBound(){return this.SugSettings.NoGainAdjacentSwapStepsBound*this.SugSettings.RepetitionCoefficientForOrdering}get SeedOfRandom(){return se(100)}get MaxOfIterations(){return this.SugSettings.MaxNumberOfPassesInOrdering*this.SugSettings.RepetitionCoefficientForOrdering}static OrderLayers(t,e,i,n,r){let s=!1;for(const e of t.Edges)if(1!=e.CrossingWeight){s=!0;break}new Te(t,!0,e,i,s,n,r).run()}run(){if(this.Calculate(),this.tryReverse){const t=this.layerArrays.ReversedClone(),e=new Te(this.properLayeredGraph.ReversedClone(),!1,t,this.startOfVirtNodes,this.hasCrossWeights,this.SugSettings,this.cancelToken);if(e.run(),e.measure<this.measure){for(let e=0;e<this.nOfLayers;e++)Xt(t.Layers[e],this.layerArrays.Layers[this.nOfLayers-1-e]);this.layerArrays.UpdateXFromLayers()}}}Calculate(){this.Init(),this.layerArraysCopy=Te.CloneLayers(this.layers,this.layerArraysCopy);let t=0;this.measure=new ae(this.layerArraysCopy,Ae(this.properLayeredGraph,this.layerArrays),this.startOfVirtNodes);for(let e=0;e<this.MaxOfIterations&&t<this.NoGainStepsBound&&!this.measure.IsPerfect();e++){const i=e%2==0;this.LayerByLayerSweep(i),this.AdjacentExchange();const n=new ae(this.layerArrays.Layers,Ae(this.properLayeredGraph,this.layerArrays),this.startOfVirtNodes);this.measure<n?(this.Restore(),t++):(n<this.measure||we())&&(t=0,this.layerArraysCopy=Te.CloneLayers(this.layers,this.layerArraysCopy),this.measure=n)}}static CloneLayers(t,e){if(null==e){e=new Array(t.length);for(let i=0;i<t.length;i++)e[i]=t[i].map(t=>t)}else for(let i=0;i<t.length;i++)Xt(t[i],e[i]);return e}Restore(){this.layerArrays.updateLayers(this.layerArraysCopy)}LayerByLayerSweep(t){if(t)for(let t=1;t<this.nOfLayers;t++)this.SweepLayer(t,!0);else for(let t=this.nOfLayers-2;t>=0;t--)this.SweepLayer(t,!1)}SweepLayer(t,e){const i=this.layers[t],n=new Array(i.length);for(let t=0;t<n.length;t++)n[t]=this.WMedian(i[t],e);this.Sort(t,n);const r=this.layerArrays.Layers[t];for(let t=0;t<r.length;t++)this.layerArrays.x[r[t]]=t}Sort(t,e){const i=new Kt.SortedMap,n=this.layers[t];let r=0;for(const t of e){const e=n[r++];if(-1!=t)if(i.has(t)){const n=i.get(t);if("number"!=typeof n){const t=n;if(we())t.push(e);else{const i=se(t.length),n=t[i];t[i]=e,t.push(n)}}else{const r=n,s=new Array;i.set(t,s),we()?(s.push(r),s.push(e)):(s.push(e),s.push(r))}}else i.set(t,e)}const s=i.values();for(r=0;r<n.length;)if(-1!=e[r]){const t=s.next().value;if("number"==typeof t)n[r++]=t;else{const i=t;for(const t of i){for(;-1==e[r];)r++;n[r++]=t}}}else r++}WMedian(t,e){let i,n;if(e?(i=this.properLayeredGraph.OutEdges(t),n=this.properLayeredGraph.OutEdgesCount(t)):(i=this.properLayeredGraph.InEdges(t),n=this.properLayeredGraph.InEdgesCount(t)),0==n)return-1;const r=new Array(n);let s=0;if(e)for(const t of i)r[s++]=this.X[t.Target];else for(const t of i)r[s++]=this.X[t.Source];r.sort((t,e)=>t-e);const o=Math.floor(n/2);if(n%2==1)return r[o];if(2==n)return.5*(r[0]+r[1]);const a=r[o-1]-r[0],l=r[n-1]-r[o];return Math.floor((r[o-1]*a+r[o]*l)/(a+l))}Init(){const t=new Array(this.nOfLayers).fill(0),e=new it.Stack;for(let t=0;t<this.properLayeredGraph.NodeCount;t++)0==this.properLayeredGraph.InEdgesCount(t)&&e.push(t);const i=new Array(this.properLayeredGraph.NodeCount).fill(!1);for(;e.size>0;){const n=e.pop(),r=this.layerArrays.y[n];this.layerArrays.Layers[r][t[r]]=n,this.layerArrays.x[n]=t[r],t[r]++;for(const t of this.properLayeredGraph.Succ(n))i[t]||(i[t]=!0,e.push(t))}this.X=this.layerArrays.x}AdjacentExchange(){this.InitArrays();let t=0,e=!0;for(;e&&t++<this.MaxNumberOfAdjacentExchanges;){e=!1;for(let t=0;t<this.layers.length;t++)e=this.AdjExchangeLayer(t)||e;for(let t=this.layers.length-2;t>=0;t--)e=this.AdjExchangeLayer(t)||e}}AllocArrays(){const t=this.properLayeredGraph.NodeCount;this.predecessors=new Array(t),this.successors=new Array(t),this.pOrder=new Array(t),this.sOrder=new Array(t),this.hasCrossWeights&&(this.outCrossingCount=new Array(t),this.inCrossingCount=new Array(t));for(let e=0;e<t;e++){let t=this.properLayeredGraph.InEdgesCount(e);if(this.predecessors[e]=new Array(t),this.hasCrossWeights){const t=this.inCrossingCount[e]=new Map;for(const i of this.properLayeredGraph.InEdges(e))t.set(i.Source,i.CrossingWeight)}if(this.pOrder[e]=new Map,t=this.properLayeredGraph.OutEdgesCount(e),this.successors[e]=new Array(t),this.sOrder[e]=new Map,this.hasCrossWeights){const t=this.outCrossingCount[e]=new Map;for(const i of this.properLayeredGraph.OutEdges(e))t.set(i.Target,i.CrossingWeight)}}}InitArrays(){null==this.successors&&this.AllocArrays();for(let t=0;t<this.properLayeredGraph.NodeCount;t++)this.pOrder[t]=new Map,this.sOrder[t]=new Map;for(const t of this.layers)this.InitPsArraysForLayer(t)}CalcPair(t,e){const i=this.successors[t],n=this.successors[e],r=this.predecessors[t],s=this.predecessors[e];if(this.hasCrossWeights){const o=this.outCrossingCount[t],a=this.outCrossingCount[e],l=this.inCrossingCount[t],h=this.inCrossingCount[e];return{cuv:this.CountOnArraysUV(i,n,o,a)+this.CountOnArraysUV(r,s,l,h),cvu:this.CountOnArraysUV(n,i,a,o)+this.CountOnArraysUV(s,r,h,l)}}return{cuv:this.CountOnArrays(i,n)+this.CountOnArrays(r,s),cvu:this.CountOnArrays(n,i)+this.CountOnArrays(s,r)}}InitPsArraysForLayer(t){for(const e of t){for(const t of this.properLayeredGraph.Pred(e)){const i=this.sOrder[t],n=i.size;this.successors[t][n]=e,i.set(e,n)}for(const t of this.properLayeredGraph.Succ(e)){const i=this.pOrder[t],n=i.size;this.predecessors[t][n]=e,i.set(e,n)}}}CountOnArrays(t,e){let i=0;const n=e.length-1;let r=-1,s=0;for(const o of t){const t=this.X[o];for(;r<n&&this.X[e[r+1]]<t;r++)s++;i+=s}return i}CountOnArraysUV(t,e,i,n){let r=0;const s=e.length-1;let o=-1,a=0;for(const l of t){const t=this.X[l];let h;for(;o<s&&this.X[h=e[o+1]]<t;o++)a+=n.get(h);r+=a*i.get(l)}return r}AdjExchangeLayer(t){const e=this.layers[t];return!!this.ExchangeWithGainWithNoDisturbance(e)||(this.DisturbLayer(e),this.ExchangeWithGainWithNoDisturbance(e))}Swap(t,e){const i=this.X[t],n=this.X[e],r=this.layering[t],s=this.layers[r];s[i]=e,s[n]=t,this.X[t]=n,this.X[e]=i,this.UpdateSsContainingUv(t,e),this.UpdatePsContainingUv(t,e)}UpdatePsContainingUv(t,e){if(this.successors[t].length<=this.successors[e].length)for(const i of this.successors[t]){const n=this.pOrder[i];if(n.has(e)){const r=n.get(e),s=this.predecessors[i];s[r-1]=e,s[r]=t,n.set(e,r-1),n.set(t,r)}}else for(const i of this.successors[e]){const n=this.pOrder[i];if(n.has(t)){const r=n.get(e),s=this.predecessors[i];s[r-1]=e,s[r]=t,n.set(e,r-1),n.set(t,r)}}}UpdateSsContainingUv(t,e){if(this.predecessors[t].length<=this.predecessors[e].length)for(const i of this.predecessors[t]){const n=this.sOrder[i];if(n.has(e)){const r=n.get(e),s=this.successors[i];s[r-1]=e,s[r]=t,n.set(e,r-1),n.set(t,r)}}else for(const i of this.predecessors[e]){const n=this.sOrder[i];if(n.has(t)){const r=n.get(e),s=this.successors[i];s[r-1]=e,s[r]=t,n.set(e,r-1),n.set(t,r)}}}DisturbLayer(t){for(let e=0;e<t.length-1;e++)this.AdjacentSwapToTheRight(t,e)}ExchangeWithGainWithNoDisturbance(t){let e,i=!1;do{e=this.ExchangeWithGain(t),i=i||e}while(e);return i}ExchangeWithGain(t){for(let e=0;e<t.length-1;e++)if(this.SwapWithGain(t[e],t[e+1]))return this.SwapToTheLeft(t,e),this.SwapToTheRight(t,e+1),!0;return!1}SwapToTheLeft(t,e){for(let i=e-1;i>=0;i--)this.AdjacentSwapToTheRight(t,i)}SwapToTheRight(t,e){for(let i=e;i<t.length-1;i++)this.AdjacentSwapToTheRight(t,i)}AdjacentSwapToTheRight(t,e){const i=t[e],n=t[e+1],r=this.SwapGain(i,n);(r>0||0==r&&we())&&this.Swap(i,n)}SwapGain(t,e){const i=this.CalcPair(t,e);return i.cuv-i.cvu}UvAreOfSameKind(t,e){return t<this.startOfVirtNodes&&e<this.startOfVirtNodes||t>=this.startOfVirtNodes&&e>=this.startOfVirtNodes}NeighborsForbidTheSwap(t,e){return this.UpperNeighborsForbidTheSwap(t,e)||this.LowerNeighborsForbidTheSwap(t,e)}LowerNeighborsForbidTheSwap(t,e){let i,n;return 0!=(i=this.properLayeredGraph.OutEdgesCount(t))&&0!=(n=this.properLayeredGraph.OutEdgesCount(e))&&this.X[this.successors[t][i>>1]]<this.X[this.successors[e][n>>1]]}UpperNeighborsForbidTheSwap(t,e){const i=this.properLayeredGraph.InEdgesCount(t),n=this.properLayeredGraph.InEdgesCount(e);return 0!=i&&0!=n&&this.X[this.predecessors[t][i>>1]]<this.X[this.predecessors[e][n>>1]]}CalcDeltaBetweenGroupsToTheLeftAndToTheRightOfTheSeparator(t,e,i){const n=this.GetKindDelegate(i);let r=0;for(let i=e-1;i>=0&&!n(t[i]);i--)r++;let s=0;for(let i=e+1;i<t.length&&!n(t[i]);i++)s++;return r-s}IsOriginal(t){return t<this.startOfVirtNodes}IsVirtual(t){return t>=this.startOfVirtNodes}GetKindDelegate(t){return this.IsVirtual(t)?this.IsVirtual:this.IsOriginal}SwapWithGain(t,e){return this.SwapGain(t,e)>0&&(this.Swap(t,e),!0)}}class Ie{constructor(){this.size_=0,this.mapOfMaps=new Map}deleteP(t){return this.delete(t.x,t.y)}clear(){this.mapOfMaps.clear(),this.size_=0}get size(){return this.size_}setxy(t,e,i){let n=this.mapOfMaps.get(t);null==n&&this.mapOfMaps.set(t,n=new Map),n.has(e)||this.size_++,n.set(e,i)}set(t,e){this.setxy(t.x,t.y,e)}delete(t,e){const i=this.mapOfMaps.get(t);return null!=i&&(i.delete(e)&&this.size_--,!0)}hasxy(t,e){const i=this.mapOfMaps.get(t);return null!=i&&i.has(e)}has(t){return this.hasxy(t.x,t.y)}getxy(t,e){const i=this.mapOfMaps.get(t);if(null!=i)return i.get(e)}get(t){return this.getxy(t.x,t.y)}*keys(){for(const t of this.mapOfMaps)for(const e of t[1])yield new E(t[0],e[0])}*[Symbol.iterator](){for(const t of this.mapOfMaps)for(const e of t[1])yield[new E(t[0],e[0]),e[1]]}*values(){for(const t of this.mapOfMaps)for(const e of t[1])yield e[1]}}class Oe{constructor(t,e,i){this.properLayeredGraph=t,this.layerArrays=e,this.nodePositions=i}static UpdateLayerArrays0(t,e,i){new Oe(t,e,i).UpdateLayerArrays()}static UpdateLayerArrays1(t,e){const i=Oe.BuildInitialNodePositions(t,e);this.UpdateLayerArrays0(t,e,i)}static BuildInitialNodePositions(t,e){const i=new Map;for(let n=0;n<e.Layers.length;n++){let r=0,s=0;for(;r<e.Layers[n].length;){for(;r<e.Layers[n].length&&t.IsVirtualNode(e.Layers[n][r]);)r++;for(let t=s;t<r;t++)i.set(e.Layers[n][t],new E(n,s));r<e.Layers[n].length&&i.set(e.Layers[n][r],new E(n,r)),r++,s=r}}return i}UpdateLayerArrays(){let t=this.CreateInitialOrdering();t=this.BuildOrdering(t),this.RestoreLayerArrays(t)}CreateInitialOrdering(){const t=new Ie;for(const e of this.layerArrays.Layers)for(const i of e){const e=this.nodePositions.get(i);t.hasxy(e.x,e.y)||t.setxy(e.x,e.y,[]),t.getxy(e.x,e.y).push(i)}return t}BuildOrdering(t){const e=new Ie,i=new Map;for(const n of this.layerArrays.Layers)for(const r of n){const n=this.nodePositions.get(r);e.hasxy(n.x,n.y)||(this.BuildNodeOrdering(t.get(n),i),e.set(n,t.get(n)))}return e}BuildNodeOrdering(t,e){t.sort(this.Comparison(e));for(let i=0;i<t.length;i++)e.set(t[i],i)}firstSucc(t){for(const e of this.properLayeredGraph.Succ(t))return e}firstPred(t){for(const e of this.properLayeredGraph.Pred(t))return e}Comparison(t){return(e,i)=>{const n=this.firstSucc(e),r=this.firstSucc(i);let s=this.firstPred(e),o=this.firstPred(i);const a=this.nodePositions.get(n),l=this.nodePositions.get(r),h=this.nodePositions.get(s),u=this.nodePositions.get(o);if(!a.equal(l))return h.equal(u)?a.compareTo(l):h.compareTo(u);if(this.properLayeredGraph.IsVirtualNode(n)){if(!h.equal(u))return h.compareTo(u);return b(t.get(n),t.get(r))}for(;this.nodePositions.get(s).equal(this.nodePositions.get(o))&&this.properLayeredGraph.IsVirtualNode(s);)s=this.firstPred(s),o=this.firstPred(o);return this.nodePositions.get(s).equal(this.nodePositions.get(o))?b(e,i):this.nodePositions.get(s).compareTo(this.nodePositions.get(o))}}RestoreLayerArrays(t){for(const e of this.layerArrays.Layers){let i=0,n=0;for(;i<e.length;){for(;i<e.length&&this.nodePositions.get(e[n]).equal(this.nodePositions.get(e[i]));)i++;const r=t.get(this.nodePositions.get(e[n]));for(let t=n;t<i;t++)e[t]=r[t-n];n=i}}this.layerArrays.UpdateXFromLayers()}}class _e{static getOrder(t,e){const i=St(e.map(([t,e])=>new wt(t,e)),t);return _e.getOrderOnGraph(i)}static getOrderOnGraph(t){const e=new Array(t.nodeCount).fill(!1),i=new it.Stack,n=[];let r;for(let s=0;s<t.nodeCount;s++){if(e[s])continue;let o=s;e[o]=!0;let a=0;for(r=t.outEdges[s];;){for(;a<r.length;a++){const n=r[a].target;e[n]||(e[n]=!0,i.push({edges:r,index:a+1,current_u:o}),o=n,r=t.outEdges[o],a=-1)}if(n.push(o),!(i.length>0))break;{const t=i.pop();r=t.edges,a=t.index,o=t.current_u}}}return n.reverse()}}class Le{constructor(t){this.graph=t}GetLayers(){const t=_e.getOrderOnGraph(this.graph),e=new Array(this.graph.nodeCount).fill(0);let i=this.graph.nodeCount;for(;i-- >0;){const n=t[i];for(const t of this.graph.inEdges[n]){const i=t.source,r=e[n]+t.separation;e[i]<r&&(e[i]=r)}}return e}checkTopoOrder(t){for(const e of this.graph.edges)if(Re(e,t))return!1;return!0}}function Re(t,e){const i=e.findIndex(e=>e==t.source),n=e.findIndex(e=>e==t.target);return-1==i||-1==n||i>=n}class Be{constructor(t){this.inTree=!1,this.cut=Be.infinity,this.iedge=t}get source(){return this.iedge.source}get target(){return this.iedge.target}get separation(){return this.iedge.separation}get crossingWeight(){return this.iedge.CrossingWeight}get weight(){return this.iedge.weight}}Be.infinity=Number.MAX_SAFE_INTEGER;class Me{constructor(t,e,i,n,r){this.v=t,this.outEnum=e,this.i=i,this.inEnum=n,this.j=r}}class Fe{constructor(t,e){this.layers=null,this.treeVertices=[],this.vertices=[],this.leaves=[],this.graph=function(t){const e=new Array;for(const i of t.edges)e.push(new Be(i));return St(e,t.nodeCount)}(t),this.networkCancelToken=e;for(let t=0;t<this.graph.nodeCount;t++)this.vertices.push({inTree:!1,lim:-1,low:-1,parent:null})}get weight(){return this.graph.edges.map(t=>t.weight*(this.layers[t.source]-this.layers[t.target])).reduce((t,e)=>t+e,0)}get nodeCount(){return this.vertices.length}setLow(t,e){this.vertices[t].low=e}setLim(t,e){this.vertices[t].lim=e}setParent(t,e){this.vertices[t].parent=e}GetLayers(){return null==this.layers&&this.run(),this.layers}shiftLayerToZero(){const t=Math.min(...this.layers);for(let e=0;e<this.layers.length;e++)this.layers[e]-=t}addVertexToTree(t){this.vertices[t].inTree=!0}vertexInTree(t){return this.vertices[t].inTree}lim(t){return this.vertices[t].lim}low(t){return this.vertices[t].low}parent(t){return this.vertices[t].parent}feasibleTree(){for(this.initLayers();this.tightTree()<this.nodeCount;){const t=this.getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack();if(null==t)break;let e=this.slack(t);this.vertexInTree(t.source)&&(e=-e);for(const t of this.treeVertices)this.layers[t]+=e}this.initCutValues()}vertexSourceTargetVal(t,e){const i=e.source,n=e.target;return this.lim(i)>this.lim(n)?this.lim(t)<=this.lim(n)&&this.low(n)<=this.lim(t)?0:1:this.lim(t)<=this.lim(i)&&this.low(i)<=this.lim(t)?1:0}incidentEdges(t){return this.graph.incidentEdges(t)}allLowCutsHaveBeenDone(t){for(const e of this.incidentEdges(t))if(e.inTree&&e.cut==Be.infinity&&e!=this.parent(t))return!1;return!0}edgeSourceTargetVal(t,e){return this.vertexSourceTargetVal(t.source,e)-this.vertexSourceTargetVal(t.target,e)}initCutValues(){this.initLimLowAndParent();let t=new it.Stack;for(const e of this.leaves)t.push(e);let e=new it.Stack;for(;t.length>0;){for(;t.length>0;){const i=t.pop(),n=this.parent(i);if(null==n)continue;let r=0;for(const t of this.incidentEdges(i))if(0==t.inTree){const e=this.edgeSourceTargetVal(t,n);0!=e&&(r+=e*t.weight)}else if(t==n)r+=t.weight;else{const e=n.source==t.target||n.target==t.source?1:-1;r+=this.edgeContribution(t,i)*e}n.cut=r;const s=n.source==i?n.target:n.source;this.allLowCutsHaveBeenDone(s)&&e.push(s)}const i=t;t=e,e=i}}edgeContribution(t,e){let i=t.cut-t.weight;for(const n of this.incidentEdges(e))if(0==n.inTree){const e=this.edgeSourceTargetVal(n,t);-1==e?i+=n.weight:1==e&&(i-=n.weight)}return i}initLimLowAndParent(){this.initLowLimParentAndLeavesOnSubtree(1,0)}initLowLimParentAndLeavesOnSubtree(t,e){const i=new it.Stack;let n=this.graph.outEdges[e],r=-1,s=this.graph.inEdges[e],o=-1;for(i.push(new Me(e,n,r,s,o)),this.vertices[e].low=t;i.length>0;){const a=i.pop();let l;e=a.v,n=a.outEnum,r=a.i,s=a.inEnum,o=a.j;do{for(l=!0;++r<n.length;){const a=n[r];!a.inTree||this.vertices[a.target].low>0||(i.push(new Me(e,n,r,s,o)),e=a.target,this.setParent(e,a),this.setLow(e,t),n=this.graph.outEdges[e],r=-1,s=this.graph.inEdges[e],o=-1)}for(;++o<s.length;){const a=s[o];if(a.inTree&&!(this.vertices[a.source].low>0)){i.push(new Me(e,n,r,s,o)),e=a.source,this.setLow(e,t),this.setParent(e,a),n=this.graph.outEdges[e],r=-1,s=this.graph.inEdges[e],o=-1,l=!1;break}}}while(!l);this.setLim(e,t++),this.lim(e)==this.low(e)&&this.leaves.push(e)}}updateLimLowLeavesAndParentsUnderNode(t){const e=this.vertices[t].low,i=this.vertices[t].lim;this.leaves=[];for(let t=0;t<this.nodeCount;t++)e<=this.vertices[t].lim&&this.vertices[t].lim<=i?this.setLow(t,0):this.low(t)==this.lim(t)&&this.leaves.push(t);this.initLowLimParentAndLeavesOnSubtree(e,t)}slack(t){return this.layers[t.source]-this.layers[t.target]-t.separation}getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack(){let t=null,e=Be.infinity;for(const i of this.treeVertices){for(const n of this.graph.outEdges[i]){if(this.vertexInTree(n.source)&&this.vertexInTree(n.target))continue;const i=this.slack(n);if(i<e&&(t=n,e=i,1==i))return n}for(const n of this.graph.inEdges[i]){if(this.vertexInTree(n.source)&&this.vertexInTree(n.target))continue;const i=this.slack(n);if(i<e&&(t=n,e=i,1==i))return n}}return t}tightTree(){this.treeVertices=[];for(const t of this.graph.edges)t.inTree=!1;for(let t=1;t<this.nodeCount;t++)this.vertices[t].inTree=!1;this.vertices[0].inTree=!0,this.treeVertices.push(0);const t=new it.Stack;for(t.push(0);t.length>0;){const e=t.pop();for(const i of this.graph.outEdges[e])this.vertexInTree(i.target)||this.layers[i.source]-this.layers[i.target]==i.separation&&(t.push(i.target),this.addVertexToTree(i.target),this.treeVertices.push(i.target),i.inTree=!0);for(const i of this.graph.inEdges[e])this.vertexInTree(i.source)||this.layers[i.source]-this.layers[i.target]==i.separation&&(t.push(i.source),this.addVertexToTree(i.source),this.treeVertices.push(i.source),i.inTree=!0)}return this.treeVertices.length}leaveEnterEdge(){let t,e,i=0;for(const e of this.graph.edges)e.inTree&&e.cut<i&&(i=e.cut,t=e);if(null==t)return null;let n=!1,r=Be.infinity;for(const i of this.graph.edges){const s=this.slack(i);if(0==i.inTree&&-1==this.edgeSourceTargetVal(i,t)&&(s<r||s==r&&(n=1==se(2)))){if(r=s,e=i,0==r&&!n)break;n=!1}}if(null==e)throw new Error;return{leaving:t,entering:e}}exchange(t,e){const i=this.commonPredecessorOfSourceAndTargetOfF(e);this.createPathForCutUpdates(t,e,i),this.updateLimLowLeavesAndParentsUnderNode(i),this.updateCuts(t),this.updateLayersUnderNode(i)}updateLayersUnderNode(t){const e=new it.Stack;e.push(t);for(let e=0;e<this.nodeCount;e++)this.low(t)<=this.lim(e)&&this.lim(e)<=this.lim(t)&&e!=t&&(this.layers[e]=Be.infinity);for(;e.length>0;){const t=e.pop();for(const i of this.graph.outEdges[t])i.inTree&&this.layers[i.target]==Be.infinity&&(this.layers[i.target]=this.layers[t]-i.separation,e.push(i.target));for(const i of this.graph.inEdges[t])i.inTree&&this.layers[i.source]==Be.infinity&&(this.layers[i.source]=this.layers[t]+i.separation,e.push(i.source))}}updateCuts(t){let e=new it.Stack,i=new it.Stack;for(e.push(t.source),e.push(t.target);e.length>0;){for(;e.length>0;){const t=e.pop(),n=this.parent(t);if(null==n)continue;if(n.cut!=Be.infinity)continue;let r=0;for(const e of this.incidentEdges(t))if(0==e.inTree)r+=this.edgeSourceTargetVal(e,n)*e.weight;else if(e==n)r+=e.weight;else{const i=n.source==e.target||n.target==e.source?1:-1;r+=this.edgeContribution(e,t)*i}n.cut=r;const s=n.source==t?n.target:n.source;this.allLowCutsHaveBeenDone(s)&&i.push(s)}const t=e;e=i,i=t}}createPathForCutUpdates(t,e,i){let n=e.target;for(;n!=i;){const t=this.parent(n);t.cut=Be.infinity,n=t.source==n?t.target:t.source}e.cut=Be.infinity,t.inTree=!1,e.inTree=!0}commonPredecessorOfSourceAndTargetOfF(t){let e,i;this.lim(t.source)<this.lim(t.target)?(e=this.lim(t.source),i=this.lim(t.target)):(e=this.lim(t.target),i=this.lim(t.source));let n=t.source;for(;0==(this.low(n)<=e&&i<=this.lim(n));){const t=this.parent(n);t.cut=Be.infinity,n=t.source==n?t.target:t.source}return n}checkCutValues(){for(const t of this.graph.edges)if(t.inTree){let e=0;for(const i of this.graph.edges)e+=this.edgeSourceTargetVal(i,t)*i.weight;t.cut!=e&&console.log(_t.String.Format("cuts are wrong for {0}; should be {1} but is {2}",t,e,t.cut))}}initLayers(){const t=new Le(this.graph);return this.layers=t.GetLayers()}run(){if(0==this.graph.edges.length&&0==this.graph.nodeCount)this.layers=[];else{let t;for(this.feasibleTree();null!=(t=this.leaveEnterEdge());)this.exchange(t.leaving,t.entering);this.shiftLayerToZero()}}}class De{constructor(t,e){this.graph=t,this.Cancel=e}GetLayers(){return new Fe(this.graph,this.Cancel).GetLayers()}ShrunkComponent(t){const e=[];for(const i of t){const n=i[0],r=i[1];for(const i of this.graph.outEdges[n]){const n=new Bt(r,t.get(i.target),i.edge);n.separation=i.separation,n.weight=i.weight,e.push(n)}}return new Ht(e,t.size)}}class Ne{constructor(t){this.padding=0,this.alreadySitsOnASpline=!1,this.labelIsToTheLeftOfTheSpline=!1,this.labelIsToTheRightOfTheSpline=!1,this.labelCornersPreserveCoefficient=t}toString(){return"la:ra "+this.la+" "+this.ra+" ta:ba "+this.ta+" "+this.ba+" x:y "+this.x_+" "+this.y_}get leftAnchor(){return this.la}set leftAnchor(t){this.la=Math.max(t,0)}get rightAnchor(){return this.ra}set rightAnchor(t){this.ra=Math.max(t,0)}get topAnchor(){return this.ta}set topAnchor(t){this.ta=Math.max(t,0)}get bottomAnchor(){return this.ba}set bottomAnchor(t){this.ba=Math.max(t,0)}get left(){return this.x_-this.la}get right(){return this.x_+this.ra}get top(){return this.y_+this.ta}set top(t){this.y_+=t-this.ta}get bottom(){return this.y_-this.ba}set bottom(t){this.y_+=t-this.ba}get leftTop(){return new E(this.left,this.top)}get leftBottom(){return new E(this.left,this.bottom)}get rightBottom(){return new E(this.right,this.bottom)}get node(){return this.node_}set node(t){this.node_=t,this.polygonalBoundary_=null}get rightTop(){return new E(this.right,this.top)}static mkAnchor(t,e,i,n,r,s){const o=new Ne(s);return o.la=t,o.ra=e,o.ta=i,o.ba=n,o.node=r,o}get x(){return this.x_}set x(t){this.polygonalBoundary_=null,this.x_=t}get y(){return this.y_}set y(t){this.polygonalBoundary_=null,this.y_=t}get origin(){return new E(this.x,this.y)}get width(){return this.la+this.ra}get height(){return this.ta+this.ba}get hasLabel(){return this.labelIsToTheLeftOfTheSpline||this.labelIsToTheLeftOfTheSpline}get LabelWidth(){if(this.labelIsToTheLeftOfTheSpline)return this.leftAnchor;if(this.labelIsToTheRightOfTheSpline)return this.rightAnchor;throw new Error}get polygonalBoundary(){return null!=this.polygonalBoundary_?this.polygonalBoundary_:this.polygonalBoundary_=Ne.pad(this.creatPolygonalBoundaryWithoutPadding(),this.padding)}static pad(t,e){return 0==e?t:Ne.curveIsConvex(t)?Ne.padConvexCurve(t,e):Ne.padConvexCurve(t.boundingBox.perimeter(),e)}static padCorner(t,e,i,n,r){const s=Ne.getPaddedCorner(e,i,n,r);t.addPoint(s.a),2==s.numberOfPoints&&t.addPoint(s.b)}static padConvexCurve(t,e){const i=new k;Ne.padCorner(i,t.endPoint.prev,t.endPoint,t.startPoint,e),Ne.padCorner(i,t.endPoint,t.startPoint,t.startPoint.next,e);for(let n=t.startPoint;null!=n.next.next;n=n.next)Ne.padCorner(i,n,n.next,n.next.next,e);return i.closed=!0,i}static getPaddedCorner(t,e,i,n){const r=t.point,o=e.point,a=i.point,l=E.getTriangleOrientation(r,o,a)==s.Counterclockwise,h=o.sub(r),u=h.rotate((l?-Math.PI:Math.PI)/2).normalize(),c=h.normalize().add(o.sub(a).normalize());if(c.length<y.intersectionEpsilon)return{a:o.add(u.mul(n)),b:null,numberOfPoints:1};const d=c.normalize().mul(n),g=d.rotate(Math.PI/2),f=(n-d.dot(u))/g.dot(u);return{a:d.add(g.mul(f)).add(o),b:d.sub(g.mul(f)).add(o),numberOfPoints:2}}static*orientations(t){yield E.getTriangleOrientation(t.endPoint.point,t.startPoint.point,t.startPoint.next.point),yield E.getTriangleOrientation(t.endPoint.prev.point,t.endPoint.point,t.startPoint.point);let e=t.startPoint;for(;null!=e.next.next;)yield E.getTriangleOrientation(e.point,e.next.point,e.next.next.point),e=e.next}static curveIsConvex(t){let e=s.Collinear;for(const i of Ne.orientations(t))if(i!=s.Collinear)if(e==s.Collinear)e=i;else if(i!=e)return!1;return!0}creatPolygonalBoundaryWithoutPadding(){return this.hasLabel?this.labelIsToTheLeftOfTheSpline?this.polygonOnLeftLabel():this.polygonOnRightLabel():null==this.nodeBoundary?this.standardRectBoundary():F.polylineAroundClosedCurve(this.nodeBoundary)}get nodeBoundary(){return null==this.node?null:this.node.boundaryCurve}standardRectBoundary(){const t=new k;return t.addPoint(this.leftTop),t.addPoint(this.rightTop),t.addPoint(this.rightBottom),t.addPoint(this.leftBottom),t.closed=!0,t}polygonOnLeftLabel(){const t=this.left+(1-this.labelCornersPreserveCoefficient)*this.LabelWidth;return k.mkClosedFromPoints([new E(t,this.top),this.rightTop,this.rightBottom,new E(t,this.bottom),new E(this.left,this.y)])}polygonOnRightLabel(){const t=this.right-(1-this.labelCornersPreserveCoefficient)*this.LabelWidth;return k.mkClosedFromPoints([new E(t,this.top),new E(this.right,this.y),new E(t,this.bottom),this.leftBottom,this.leftTop])}move(t){this.x+=t.x,this.y+=t.y}}class ke{constructor(t,e,i,n,r){this.xCoords=new Array(4),this.la=t,this.graph=e,this.nOfOriginalVertices=i,this.nOfVertices=this.graph.NodeCount,this.markedEdges=new Mt,this.h=this.la.Layers.length,this.root=new Array(this.nOfVertices),this.align=new Array(this.nOfVertices),this.anchors=n,this.nodeSep=r}get CurrentEnumRightUp(){return(this.LR?0:1)+2*(this.BT?0:1)}IsVirtual(t){return t>=this.nOfOriginalVertices}Source(t){return this.BT?t.Source:t.Target}Target(t){return this.BT?t.Target:t.Source}static CalculateXCoordinates(t,e,i,n,r){new ke(t,e,i,n,r).Calculate()}Calculate(){this.SortInAndOutEdges(),this.RightUpSetup(),this.CalcBiasedAlignment(),this.LeftUpSetup(),this.CalcBiasedAlignment(),this.RightDownSetup(),this.CalcBiasedAlignment(),this.LeftDownSetup(),this.CalcBiasedAlignment(),this.HorizontalBalancing()}SortInAndOutEdges(){this.FillLowMedians(),this.FillUpperMedins()}FillUpperMedins(){this.upperMedians=new Array(this.graph.NodeCount);for(let t=0;t<this.graph.NodeCount;t++)this.FillUpperMediansForNode(t)}CompareByX(t,e){return this.la.x[t]-this.la.x[e]}FillUpperMediansForNode(t){let e=this.graph.InEdgesCount(t);if(e>0){const i=new Array(e);e=0;for(const n of this.graph.InEdges(t))i[e++]=n.Source;i.sort((t,e)=>this.CompareByX(t,e));const n=Math.floor(e/2);this.upperMedians[t]=2*n==e?new wt(i[n-1],i[n]):i[n]}else this.upperMedians[t]=-1}FillLowMedians(){this.lowMedians=new Array(this.graph.NodeCount);for(let t=0;t<this.graph.NodeCount;t++)this.FillLowMediansForNode(t)}FillLowMediansForNode(t){let e=this.graph.OutEdgesCount(t);if(e>0){const i=new Array(e);e=0;for(const n of this.graph.OutEdges(t))i[e++]=n.Target;i.sort((t,e)=>this.CompareByX(t,e));const n=Math.floor(e/2);this.lowMedians[t]=2*n==e?new wt(i[n-1],i[n]):i[n]}else this.lowMedians[t]=-1}HorizontalBalancing(){let t=-1;const e=new Array(4),i=new Array(4);let n=Number.MAX_VALUE;for(let r=0;r<4;r++){const s={a:0,b:0};this.AssignmentBounds(r,s),e[r]=s.a,i[r]=s.b;const o=i[r]-e[r];o<n&&(t=r,n=o)}for(let n=0;n<4;n++){let r;if(r=ke.IsLeftMostAssignment(n)?e[t]-e[n]:i[t]-i[n],this.x=this.xCoords[n],0!=r)for(let t=0;t<this.nOfVertices;t++)this.x[t]=this.x[t]+r}const r=new Array(4);for(let t=0;t<this.nOfVertices;t++)r[0]=this.xCoords[0][t],r[1]=this.xCoords[1][t],r[2]=this.xCoords[2][t],r[3]=this.xCoords[3][t],r.sort((t,e)=>t-e),this.anchors[t].x=(r[1]+r[2])/2}static IsLeftMostAssignment(t){return 0==t||2==t}AssignmentBounds(t,e){if(0==this.nOfVertices)e.a=0,e.b=0;else{this.x=this.xCoords[t],e.a=e.b=this.x[0];for(let t=1;t<this.nOfVertices;t++){const i=this.x[t];i<e.a?e.a=i:i>e.b&&(e.b=i)}}}CalcBiasedAlignment(){this.ConflictElimination(),this.Align()}LeftUpSetup(){this.LR=!1,this.BT=!0}LeftDownSetup(){this.LR=!1,this.BT=!1}RightDownSetup(){this.LR=!0,this.BT=!1}RightUpSetup(){this.LR=!0,this.BT=!0}ConflictElimination(){this.RemoveMarksFromEdges(),this.MarkConflictingEdges()}*UpperEdgeMedians(t){const e=this.BT?this.upperMedians[t]:this.lowMedians[t];if(!("number"==typeof e)){const t=e;this.LR?(yield t.x,yield t.y):(yield t.y,yield t.x)}else{const t=e;t>=0&&(yield t)}}MarkConflictingEdges(){let t=this.LowerOf(0,this.h-1);const e=t,i=this.UpperOf(0,this.h-1),n=this.NextLower(i);for(;this.IsBelow(t,i);t=this.NextUpper(t))this.IsBelow(e,t)&&this.IsBelow(t,n)&&this.ConflictsWithAtLeastOneInnerEdgeForALayer(t)}NextUpper(t){return this.BT?t+1:t-1}NextLower(t){return this.BT?t-1:t+1}UpperOf(t,e){return this.BT?Math.max(t,e):Math.min(t,e)}LowerOf(t,e){return this.BT?Math.min(t,e):Math.max(t,e)}IsBelow(t,e){return this.BT?t<e:e<t}LeftMost(t,e){return this.LR?Math.min(t,e):Math.max(t,e)}RightMost(t,e){return this.LR?Math.max(t,e):Math.min(t,e)}IsNotRightFrom(t,e){return this.LR?t<=e:e<=t}IsLeftFrom(t,e){return this.LR?t<e:e<t}NextRight(t){return this.LR?t+1:t-1}NextLeft(t){return this.LR?t-1:t+1}ConflictsWithAtLeastOneInnerEdgeForALayer(t){if(t>=0&&t<this.la.Layers.length){const e=this.la.Layers[t];let i=null,n=this.LeftMost(0,e.length-1);const r=this.RightMost(0,e.length-1);for(;this.IsNotRightFrom(n,r)&&null==i;n=this.NextRight(n))i=this.InnerEdgeByTarget(e[n]);if(null!=i){const t=this.Pos(this.Source(i));for(let i=this.LeftMost(0,e.length-1);this.IsLeftFrom(i,n);i=this.NextRight(i))for(const n of this.InEdges(e[i]))this.IsLeftFrom(t,this.Pos(this.Source(n)))&&this.MarkEdge(n);let s=this.Pos(this.Source(i));for(;this.IsNotRightFrom(n,r);){const r=this.AlignmentToTheRightOfInner(e,n,t);if(n=this.NextRight(n),null!=r){const t=this.Pos(this.Source(r));this.MarkEdgesBetweenInnerAndNewInnerEdges(e,i,r,s,t),i=r,s=t}}for(let t=this.NextRight(this.Pos(this.Target(i)));this.IsNotRightFrom(t,r);t=this.NextRight(t))for(const n of this.InEdges(e[t]))this.IsLeftFrom(this.Pos(this.Source(n)),this.Pos(this.Source(i)))&&this.MarkEdge(n)}}}InEdgeOfVirtualNode(t){return this.BT?this.graph.InEdgeOfVirtualNode(t):this.graph.OutEdgeOfVirtualNode(t)}InEdges(t){return this.BT?this.graph.InEdges(t):this.graph.OutEdges(t)}MarkEdgesBetweenInnerAndNewInnerEdges(t,e,i,n,r){let s=this.NextRight(this.Pos(this.Target(e)));for(;this.IsLeftFrom(s,this.Pos(this.Target(i)));s=this.NextRight(s))for(const e of this.InEdges(t[s])){const t=this.Pos(this.Source(e));(this.IsLeftFrom(t,n)||this.IsLeftFrom(r,t))&&this.MarkEdge(e)}}AlignmentToTheRightOfInner(t,e,i){if(1==this.NumberOfInEdges(t[e])){let n=null;for(const i of this.InEdges(t[e]))n=i;return this.IsInnerEdge(n)&&this.IsLeftFrom(i,this.Pos(n.Source))?n:null}return null}NumberOfInEdges(t){return this.BT?this.graph.InEdgesCount(t):this.graph.OutEdgesCount(t)}Pos(t){return this.la.x[t]}InnerEdgeByTarget(t){if(this.IsVirtual(t)){const e=this.InEdgeOfVirtualNode(t);if(this.IsVirtual(this.Source(e)))return e}return null}IsInnerEdge(t){return this.IsVirtual(t.Source)&&this.IsVirtual(t.Target)}RemoveMarksFromEdges(){this.markedEdges.clear()}Align(){this.CreateBlocks(),this.AssignCoordinatesByLongestPath()}AssignCoordinatesByLongestPath(){this.x=this.xCoords[this.CurrentEnumRightUp]=new Array(this.nOfVertices);const t=new Array;for(let e=0;e<this.nOfVertices;e++)if(e==this.root[e]){let i=e;do{const n={neighbor:0};this.TryToGetRightNeighbor(i,n)&&t.push(new Bt(e,this.root[n.neighbor],null)),i=this.align[i]}while(i!=e)}const e=St(t,this.nOfVertices),i=_e.getOrderOnGraph(e);for(const t of i)if(t==this.root[t]){let e=0,i=!0,n=t;do{const t={neighbor:0};this.TryToGetLeftNeighbor(n,t)&&(i?(e=this.x[this.root[t.neighbor]]+this.DeltaBetweenVertices(t.neighbor,n),i=!1):e=this.RightMost(e,this.x[this.root[t.neighbor]]+this.DeltaBetweenVertices(t.neighbor,n))),n=this.align[n]}while(n!=t);this.x[t]=e}for(const t of i)if(t==this.root[t]&&0==e.inEdges[t].length){let e=t,i=this.RightMost(-ke.infinity,ke.infinity);const n=i;do{const t={neighbor:0};this.TryToGetRightNeighbor(e,t)&&(i=this.LeftMost(i,this.x[this.root[t.neighbor]]-this.DeltaBetweenVertices(e,t.neighbor))),e=this.align[e]}while(e!=t);n!=i&&(this.x[t]=i)}for(let t=0;t<this.nOfVertices;t++)t!=this.root[t]&&(this.x[t]=this.x[this.root[t]])}TryToGetRightNeighbor(t,e){const i=this.NextRight(this.Pos(t)),n=this.la.Layers[this.la.y[t]];return i>=0&&i<n.length&&(e.neighbor=n[i],!0)}TryToGetLeftNeighbor(t,e){const i=this.NextLeft(this.Pos(t)),n=this.la.Layers[this.la.y[t]];return i>=0&&i<n.length&&(e.neighbor=n[i],!0)}CreateBlocks(){for(let t=0;t<this.nOfVertices;t++)this.root[t]=this.align[t]=t;const t=this.LowerOf(0,this.h-1);for(let e=this.NextLower(this.UpperOf(0,this.h-1));!this.IsBelow(e,t);e=this.NextLower(e)){const t=this.la.Layers[e];let i=this.LeftMost(-1,this.la.Layers[this.NextUpper(e)].length);const n=this.RightMost(0,t.length-1);for(let e=this.LeftMost(0,t.length-1);this.IsNotRightFrom(e,n);e=this.NextRight(e)){const n=t[e];for(const t of this.UpperEdgeMedians(n))if(!this.IsMarked(n,t)&&this.IsLeftFrom(i,this.Pos(t))){this.align[t]=n,this.root[n]=this.root[t],this.align[n]=this.root[t],i=this.Pos(t);break}}}}IsMarked(t,e){return this.BT?this.markedEdges.hasxy(e,t):this.markedEdges.hasxy(t,e)}MarkEdge(t){this.markedEdges.addNN(t.Source,t.Target)}DeltaBetweenVertices(t,e){let i;if(this.Pos(t)>this.Pos(e)){const n=t;t=e,e=n,i=-1}else i=1;return(this.anchors[t].rightAnchor+this.anchors[e].leftAnchor+this.nodeSep)*i}}ke.infinity=1e7;class Ve extends Ct{constructor(t,e,i,n,r){super(),this.weightMultiplierOfOriginalOriginal=1,this.weightMultOfOneVirtual=3,this.weightMultiplierOfTwoVirtual=8,this.SetEdges(n,r),this.virtualVerticesStart=t.nodeCount,this.virtualVerticesEnd=e.NodeCount-1,this.layeredGraph=e,this.layerArrays=i}EdgeWeightMultiplier(t){const e=t.source,i=t.target;if(e<this.layeredGraph.NodeCount&&this.layerArrays.y[e]==this.layerArrays.y[i]&&this.layerArrays.x[e]==this.layerArrays.x[i]+1)return 0;let n=0,r=-1,s=-1;for(const t of this.outEdges[e])-1==s?s=t.target:r=t.target;s>=this.virtualVerticesStart&&s<=this.virtualVerticesEnd&&n++,r>=this.virtualVerticesStart&&r<=this.virtualVerticesEnd&&n++;return 0==n?this.weightMultiplierOfOriginalOriginal:1==n?this.weightMultOfOneVirtual:this.weightMultiplierOfTwoVirtual}SetEdgeWeights(){for(const t of this.edges)t.weight=t.weight*this.EdgeWeightMultiplier(t)}}var Ge,ze,je,Ue,We,He;!function(t){t[t.Top=0]="Top",t[t.Internal=1]="Internal",t[t.Bottom=2]="Bottom"}(Ge||(Ge={}));class qe{constructor(t,e){this.groupSplitThreshold=2,this.initialNodes=t,this.groupSplitThreshold=e}static Calculate(t,e=0){return new qe(t,e).Calculate()}Calculate(){return this.Calc(this.initialNodes)}Calc(t){if(0==t.length)return null;if(1==t.length)return t[0];const e=t[0].parallelogram;let i,n=1,r=A.parallelogramOfTwo(e,t[n].parallelogram).area;for(let i=2;i<t.length;i++){const s=A.parallelogramOfTwo(e,t[i].parallelogram).area;s>r&&(n=i,r=s)}for(let e=0;e<t.length;e++)if(e!=n){i=e;break}r=A.parallelogramOfTwo(t[n].parallelogram,t[i].parallelogram).area;for(let e=0;e<t.length;e++){if(e==n)continue;const s=A.parallelogramOfTwo(t[n].parallelogram,t[e].parallelogram).area;s>r&&(i=e,r=s)}const s=new Array,o=new Array;s.push(t[n]),o.push(t[i]);let a=t[n].parallelogram,l=t[i].parallelogram;for(let e=0;e<t.length;e++){if(e==n||e==i)continue;const r=A.parallelogramOfTwo(a,t[e].parallelogram),h=r.area-a.area,u=A.parallelogramOfTwo(l,t[e].parallelogram),c=u.area-l.area;s.length*this.groupSplitThreshold<o.length?(s.push(t[e]),a=r):o.length*this.groupSplitThreshold<s.length?(o.push(t[e]),l=u):h<c?(s.push(t[e]),a=r):(o.push(t[e]),l=u)}return{parallelogram:A.parallelogramOfTwo(a,l),node:{children:[this.Calc(s),this.Calc(o)]},seg:void 0,leafBoxesOffset:void 0}}}class Xe{static mkDebugCurveTWCILD(t,e,i,n,r,s,o=!1){const a=new Xe;return a.transparency=t,a.width=e,a.color=i,a.icurve=n,a.label=r,a.dashArray=s,a.drawPN=o,a}static mkDebugCurveTWCI(t,e,i,n){return Xe.mkDebugCurveTWCILD(t,e,i,n,null,null)}static mkDebugCurveWCI(t,e,i){return Xe.mkDebugCurveTWCI(255,t,e,i)}static mkDebugCurveCI(t,e){return Xe.mkDebugCurveWCI(1,t,e)}static mkDebugCurveI(t){return Xe.mkDebugCurveCI("Black",t)}}Xe.colors=["DeepSkyBlue","IndianRed","Orange","Gold","DarkRed","Plum","Red","Violet","Indigo","Yellow","OrangeRed","Tomato","Purple","SaddleBrown","Green","Navy","Aqua","Pink","Bisque","Black","BlanchedAlmond","Blue","BlueViolet","Brown","Lime","BurlyWood","Chocolate","Coral","CornflowerBlue","Cornsilk","Crimson","Cyan","CadetBlue","Chartreuse","DarkBlue","DarkCyan","DarkGoldenrod","DarkGray","DarkGreen","DarkKhaki","DarkMagenta","DarkOliveGreen","DarkOrange","DarkOrchid","DarkSalmon","DarkSeaGreen","DarkSlateBlue","DarkSlateGray","DarkTurquoise","DarkViolet","DeepPink","DimGray","DodgerBlue","Firebrick","FloralWhite","ForestGreen","Fuchsia","CodeAnalysis","Gainsboro","GhostWhite","Goldenrod","Gray","GreenYellow","Honeydew","HotPink","Ivory","Lavender","LavenderBlush","LawnGreen","LemonChiffon","LightBlue","LightCoral","LightCyan","LightGoldenrodYellow","LightGray","LightGreen","LightPink","LightSalmon","LightSeaGreen","LightSkyBlue","LightSlateGray","LightSteelBlue","LightYellow","LimeGreen","Linen","Magenta","Maroon","MediumAquamarine","MediumBlue","MediumOrchid","MediumPurple","MediumSeaGreen","MediumSlateBlue","MediumSpringGreen","MediumTurquoise","MediumVioletRed","MidnightBlue","MintCream","MistyRose","Moccasin","NavajoWhite","OldLace","Olive","OliveDrab","Orchid","PaleGoldenrod","PaleGreen","PaleTurquoise","PaleVioletRed","PapayaWhip","PeachPuff","Peru","PowderBlue","RosyBrown","RoyalBlue","Salmon","SandyBrown","SeaGreen","CodeAnalysis","SeaShell","Sienna","Silver","SkyBlue","SlateBlue","SlateGray","Snow","SpringGreen","SteelBlue","Tan","Teal","Thistle","Transparent","Turquoise","Aquamarine","Azure","Beige","Wheat","White","WhiteSmoke","YellowGreen","Khaki","AntiqueWhite"];class Ye{constructor(t,e,i,n,r,s,o,a){this.topNode=t,this.bottomNode=e,this.topSite=i,this.bottomSite=i.next,this.currentTopSite=i,this.currentBottomSite=i.next,this.layerArrays=n,this.layeredGraph=r,this.originalGraph=s,this.anchors=o,this.layerSeparation=a}static Refine(t,e,i,n,r,s,o,a){new Ye(t,e,i,r,s,o,n,a).Refine()}Refine(){for(this.Init();this.InsertSites(););}FixCorner(t,e,i){if(t.equal(e))return e;const n=E.ClosestPointAtLineSegment(e,t,i);let r=e.sub(n);const s=Math.abs(r.y),o=this.layerSeparation/2;return s>o&&(r=r.mul(o/(2*s))),r.add(e)}InsertSites(){return 0==se(2)?this.CalculateNewTopSite()||this.CalculateNewBottomSite():this.CalculateNewBottomSite()||this.CalculateNewTopSite()}CalculateNewBottomSite(){const t=this.currentBottomSite.point.sub(this.currentTopSite.point);let e,i=Ye.absCotan(t),n=!1;for(const t of this.bottomCorners()){const r=Ye.absCotan(t.sub(this.currentBottomSite.point));r<i&&(i=r,e=t,n=!0)}return!!n&&(!v(i,Ye.absCotan(t))&&(this.currentBottomSite=X.mkSiteSPS(this.currentTopSite,this.FixCorner(this.currentTopSite.point,e,this.currentBottomSite.point),this.currentBottomSite),!0))}static absCotan(t){return Math.abs(t.x/t.y)}CalculateNewTopSite(){const t=this.currentBottomSite.point.sub(this.currentTopSite.point);let e,i=Ye.absCotan(t),n=!1;for(const t of this.topCorners()){const r=Ye.absCotan(t.sub(this.currentTopSite.point));r<i&&(i=r,e=t,n=!0)}return!!n&&(!v(i,Ye.absCotan(t))&&(this.currentTopSite=X.mkSiteSPS(this.currentTopSite,this.FixCorner(this.currentTopSite.point,e,this.currentBottomSite.point),this.currentBottomSite),!0))}Init(){this.IsTopToTheLeftOfBottom()?(this.topCorners=()=>this.CornersToTheRightOfTop(),this.bottomCorners=()=>this.CornersToTheLeftOfBottom()):(this.topCorners=()=>this.CornersToTheLeftOfTop(),this.bottomCorners=()=>this.CornersToTheRightOfBottom())}IsTopToTheLeftOfBottom(){return this.topSite.point.x<this.topSite.next.point.x}*NodeCorners(t){for(const e of this.anchors[t].polygonalBoundary.polylinePoints())yield e.point}*CornersToTheLeftOfBottom(){const t=this.layerArrays.x[this.bottomNode],e=this.currentTopSite.point.x,i=this.currentBottomSite.point.x;for(const n of this.LeftFromTheNode(this.NodeLayer(this.bottomNode),t,Ge.Bottom,e,i))for(const t of this.NodeCorners(n))t.y>this.currentBottomSite.point.y&&Ye.PossibleCorner(e,i,t)&&(yield t)}*CornersToTheLeftOfTop(){const t=this.layerArrays.x[this.topNode],e=this.currentBottomSite.point.x,i=this.currentTopSite.point.x;for(const n of this.LeftFromTheNode(this.NodeLayer(this.topNode),t,Ge.Top,e,i))for(const t of this.NodeCorners(n))t.y<this.currentTopSite.point.y&&Ye.PossibleCorner(e,i,t)&&(yield t)}*CornersToTheRightOfBottom(){const t=this.layerArrays.x[this.bottomNode],e=this.currentBottomSite.point.x,i=this.currentTopSite.point.x;for(const n of this.RightFromTheNode(this.NodeLayer(this.bottomNode),t,Ge.Bottom,e,i))for(const t of this.NodeCorners(n))t.y>this.currentBottomSite.point.y&&Ye.PossibleCorner(e,i,t)&&(yield t)}*CornersToTheRightOfTop(){const t=this.layerArrays.x[this.topNode],e=this.currentTopSite.point.x,i=this.currentBottomSite.point.x;for(const n of this.RightFromTheNode(this.NodeLayer(this.topNode),t,Ge.Top,e,i))for(const t of this.NodeCorners(n))t.y<this.currentTopSite.point.y&&Ye.PossibleCorner(e,i,t)&&(yield t)}static PossibleCorner(t,e,i){return i.x>t&&i.x<e}NodeLayer(t){return this.layerArrays.Layers[this.layerArrays.y[t]]}IsLabel(t){return this.anchors[t].hasLabel}NodeUCanBeCrossedByNodeV(t,e){return!this.IsLabel(t)&&!this.IsLabel(e)&&!!(this.IsVirtualVertex(t)&&this.IsVirtualVertex(e)&&this.AdjacentEdgesIntersect(t,e))}AdjacentEdgesIntersect(t,e){return this.Intersect(this.IncomingEdge(t),this.IncomingEdge(e))||this.Intersect(this.OutcomingEdge(t),this.OutcomingEdge(e))}Intersect(t,e){return(this.layerArrays.x[t.Source]-this.layerArrays.x[e.Source])*(this.layerArrays.x[t.Target]-this.layerArrays.x[e.Target])<0}IncomingEdge(t){for(const e of this.layeredGraph.InEdges(t))return e;throw new Error}OutcomingEdge(t){for(const e of this.layeredGraph.OutEdges(t))return e;throw new Error}IsVirtualVertex(t){return t>=this.originalGraph.shallowNodeCount}*RightFromTheNode(t,e,i,n,r){let s=0,o=0;i==Ge.Bottom&&(s=Number.MAX_VALUE),i==Ge.Top&&(o=Number.MAX_VALUE);const a=t[e];for(let i=e+1;i<t.length;i++){const e=t[i];if(this.NodeUCanBeCrossedByNodeV(e,a))continue;const l=this.anchors[e];if(l.left>=r)break;l.right>n&&(l.topAnchor>o+y.distanceEpsilon?(o=l.topAnchor,yield e):l.bottomAnchor>s+y.distanceEpsilon&&(s=l.bottomAnchor,yield e))}}*LeftFromTheNode(t,e,i,n,r){let s=0,o=0;i==Ge.Bottom&&(s=Number.MAX_VALUE),i==Ge.Top&&(o=Number.MAX_VALUE);const a=t[e];for(let i=e-1;i>-1;i--){const e=t[i];if(this.NodeUCanBeCrossedByNodeV(e,a))continue;const l=this.anchors[e];if(l.right<=n)break;l.left<r&&(l.topAnchor>o+y.distanceEpsilon?(o=l.topAnchor,yield e):l.bottomAnchor>s+y.distanceEpsilon&&(s=l.bottomAnchor,yield e))}}}class Qe{constructor(t,e,i,n,r,s,o){this.thinRightNodes=new Array,this.thinWestNodes=new Array,this.database=o,this.edgePath=t,this.anchors=e,this.layerArrays=r,this.originalGraph=i,this.settings=n,this.layeredGraph=s,this.eastHierarchy=this.BuildEastHierarchy(),this.westHierarchy=this.BuildWestHierarchy()}BuildEastHierarchy(){const t=this.FindEastBoundaryAnchorCurves(),e=new Array;for(const i of t)e.push(i.pNodeOverICurve());return this.thinEastHierarchy=qe.Calculate(this.thinRightNodes),qe.Calculate(e)}BuildWestHierarchy(){const t=this.FindWestBoundaryAnchorCurves(),e=new Array;for(const i of t)e.push(i.pNodeOverICurve());return this.thinWestHierarchy=qe.Calculate(this.thinWestNodes),qe.Calculate(e)}FindEastBoundaryAnchorCurves(){const t=new Array;let e=0;for(const i of this.edgePath){let n=null;for(const r of this.EastBoundaryNodesOfANode(i,io.GetNodeKind(e,this.edgePath))){const e=this.anchors[r];(null==n||n.origin.x>e.origin.x)&&(n=e),t.push(e.polygonalBoundary)}null!=n&&this.thinRightNodes.push(I.mkLinePXY(n.origin,this.originalGraph.right,n.y).pNodeOverICurve()),e++}return t}FindWestBoundaryAnchorCurves(){const t=[];let e=0;for(const i of this.edgePath.nodes()){let n=-1;for(const r of this.LeftBoundaryNodesOfANode(i,io.GetNodeKind(e,this.edgePath)))(-1==n||this.layerArrays.x[r]>this.layerArrays.x[n])&&(n=r),t.push(this.anchors[r].polygonalBoundary);if(-1!=n){const t=this.anchors[n];this.thinWestNodes.push(I.mkLinePXY(t.origin,this.originalGraph.left,t.origin.y).pNodeOverICurve())}e++}return t}*FillRightTopAndBottomVerts(t,e,i){let n=0,r=0;i==Ge.Bottom?n=Number.MAX_VALUE:i==Ge.Top&&(r=Number.MAX_VALUE);const s=t[e];for(let i=e+1;i<t.length;i++){const e=t[i],o=this.anchors[e];o.topAnchor>r?this.NodeUCanBeCrossedByNodeV(e,s)||(r=o.topAnchor,o.bottomAnchor>n&&(n=o.bottomAnchor),yield e):o.bottomAnchor>n&&(this.NodeUCanBeCrossedByNodeV(e,s)||(n=o.bottomAnchor,o.topAnchor>r&&(r=o.topAnchor),yield e))}}*FillLeftTopAndBottomVerts(t,e,i){let n=0,r=0;i==Ge.Top?r=Number.MAX_VALUE:i==Ge.Bottom&&(n=Number.MAX_VALUE);const s=t[e];for(let i=e-1;i>=0;i--){const e=t[i],o=this.anchors[e];o.topAnchor>r+y.distanceEpsilon?this.NodeUCanBeCrossedByNodeV(e,s)||(r=o.topAnchor,n=Math.max(n,o.bottomAnchor),yield e):o.bottomAnchor>n+y.distanceEpsilon&&(this.NodeUCanBeCrossedByNodeV(e,s)||(r=Math.max(r,o.topAnchor),n=o.bottomAnchor,yield e))}}IsVirtualVertex(t){return t>=this.originalGraph.shallowNodeCount}IsLabel(t){return this.anchors[t].hasLabel}NodeUCanBeCrossedByNodeV(t,e){return!this.IsLabel(t)&&(!this.IsLabel(e)&&!!(this.IsVirtualVertex(t)&&this.IsVirtualVertex(e)&&this.EdgesIntersectSomewhere(t,e)))}EdgesIntersectSomewhere(t,e){return!this.UVAreMiddlesOfTheSameMultiEdge(t,e)&&(this.IntersectAbove(t,e)||this.IntersectBelow(t,e))}UVAreMiddlesOfTheSameMultiEdge(t,e){return!(!this.database.MultipleMiddles.has(t)||!this.database.MultipleMiddles.has(e)||this.SourceOfTheOriginalEdgeContainingAVirtualNode(t)!=this.SourceOfTheOriginalEdgeContainingAVirtualNode(e))}SourceOfTheOriginalEdgeContainingAVirtualNode(t){for(;this.IsVirtualVertex(t);)t=this.IncomingEdge(t).Source;return t}IntersectBelow(t,e){do{const i=this.OutcomingEdge(t),n=this.OutcomingEdge(e);if(this.Intersect(i,n))return!0;t=i.Target,e=n.Target}while(this.IsVirtualVertex(t)&&this.IsVirtualVertex(e));return t==e}IntersectAbove(t,e){do{const i=this.IncomingEdge(t),n=this.IncomingEdge(e);if(this.Intersect(i,n))return!0;t=i.Source,e=n.Source}while(this.IsVirtualVertex(t)&&this.IsVirtualVertex(e));return t==e}Intersect(t,e){const i=this.layerArrays.x[t.Source]-this.layerArrays.x[e.Source],n=this.layerArrays.x[t.Target]-this.layerArrays.x[e.Target];return i>0&&n<0||i<0&&n>0}IncomingEdge(t){return this.layeredGraph.InEdgeOfVirtualNode(t)}OutcomingEdge(t){return this.layeredGraph.OutEdgeOfVirtualNode(t)}EastBoundaryNodesOfANode(t,e){return this.FillRightTopAndBottomVerts(this.NodeLayer(t),this.layerArrays.x[t],e)}NodeLayer(t){return this.layerArrays.Layers[this.layerArrays.y[t]]}LeftBoundaryNodesOfANode(t,e){return this.FillLeftTopAndBottomVerts(this.NodeLayer(t),this.layerArrays.x[t],e)}getSpline(t){return this.createRefinedPolyline(t),this.createSmoothedPolyline()}get GetPolyline(){return new Y(this.headSite)}LineSegIntersectBound(t,e){const i=I.mkPP(t,e);return Qe.CurveIntersectsHierarchy(i,this.westHierarchy)||Qe.CurveIntersectsHierarchy(i,this.thinWestHierarchy)||Qe.CurveIntersectsHierarchy(i,this.eastHierarchy)||Qe.CurveIntersectsHierarchy(i,this.thinEastHierarchy)}SegIntersectWestBound(t,e){return Qe.SegIntersectsBound(t,e,this.westHierarchy)||Qe.SegIntersectsBound(t,e,this.thinWestHierarchy)}SegIntersectEastBound(t,e){return Qe.SegIntersectsBound(t,e,this.eastHierarchy)||Qe.SegIntersectsBound(t,e,this.thinEastHierarchy)}TryToRemoveInflectionCorner(t){if(!t.s.next||!t.s.prev||t.s.turn==s.Counterclockwise&&this.SegIntersectEastBound(t.s.prev,t.s.next)||t.s.turn==s.Clockwise&&this.SegIntersectWestBound(t.s.prev,t.s.next))return t.cut=!1,void(t.s=t.s.next);const e=t.s.next;t.s.prev.next=e,e.prev=t.s.prev,t.s=e,t.cut=!0}static SegIntersectsBound(t,e,i){return Qe.CurveIntersectsHierarchy(I.mkPP(t.point,e.point),i)}static CurveIntersectsHierarchy(t,e){if(null==e)return!1;if(!A.intersect(t.pNodeOverICurve().parallelogram,e.parallelogram))return!1;if(e.node.hasOwnProperty("children")){const i=e.node;return Qe.CurveIntersectsHierarchy(t,i.children[0])||Qe.CurveIntersectsHierarchy(t,i.children[1])}return null!=F.intersectionOne(t,e.seg,!1)}static Flat(t){return E.getTriangleOrientation(t.prev.point,t.point,t.next.point)==s.Collinear}Reverse(){const t=new Qe(this.edgePath,this.anchors,this.originalGraph,this.settings,this.layerArrays,this.layeredGraph,this.database);let e=this.headSite,i=null;for(;null!=e;)t.headSite=e.clone(),t.headSite.next=i,null!=i&&(i.prev=t.headSite),i=t.headSite,e=e.next;return t}createRefinedPolyline(t){this.CreateInitialListOfSites();let e,i=this.headSite;for(let t=0;t<this.edgePath.count;t++)e=i.next,this.RefineBeetweenNeighborLayers(i,this.EdgePathNode(t),this.EdgePathNode(t+1)),i=e;this.TryToRemoveInflections(),t&&this.OptimizeShortPath()}RefineBeetweenNeighborLayers(t,e,i){Ye.Refine(e,i,t,this.anchors,this.layerArrays,this.layeredGraph,this.originalGraph,this.settings.LayerSeparation)}CreateInitialListOfSites(){let t=this.headSite=X.mkSiteP(this.EdgePathPoint(0));for(let e=1;e<=this.edgePath.count;e++)t=X.mkSiteSP(t,this.EdgePathPoint(e))}get TailSite(){let t=this.headSite;for(;null!=t.next;)t=t.next;return t}OptimizeForThreeSites(){const t=this.EdgePathNode(0),e=this.EdgePathNode(2),i=this.anchors[t],n=this.anchors[e];if(v(i.x,n.x))return;const r={ax:i.x,bx:n.x,sign:0};if(!this.FindLegalPositions(i,n,r))return;const s=(i.y-n.y)/(i.bottom-n.top),o=.5*(r.ax+r.bx),a=r.sign*(.5*(r.ax-r.bx));r.ax=o+s*(a*r.sign),r.bx=o-s*(a*r.sign),this.headSite.point=new E(r.ax,i.y);const l=this.headSite.next,h=l.point.y;l.point=new E(this.MiddlePos(r.ax,r.bx,i,n,h),h),l.next.point=new E(r.bx,n.y);this.anchors[this.EdgePathNode(1)].x=l.point.x}OptimizeForTwoSites(){const t=this.EdgePathNode(0),e=this.EdgePathNode(1),i=this.anchors[t],n=this.anchors[e];if(v(i.x,n.x))return;const r={ax:i.x,bx:n.x,sign:0};if(!this.FindPositions(i,n,r))return;const s=(i.y-n.y)/(i.bottom-n.top),o=.5*(r.ax+r.bx),a=r.sign*(.5*(r.ax-r.bx));r.ax=o+s*(a*r.sign),r.bx=o-s*(a*r.sign),this.headSite.point=new E(r.ax,i.y),this.headSite.next.point=new E(r.bx,n.y)}FindLegalPositions(t,e,i){return!!this.FindPositions(t,e,i)&&this.PositionsAreLegal(i.ax,i.bx,i.sign,t,e,this.EdgePathNode(1))}FindPositions(t,e,i){let n,r;if(i.ax<i.bx?(i.sign=1,r=Math.max(i.ax,e.left),n=Math.min(t.right,i.bx)):(i.sign=-1,r=Math.max(t.left,i.bx),n=Math.min(e.right,i.ax)),r<=n)i.bx=.5*(r+n),i.ax=.5*(r+n);else{if(this.OriginToOriginSegCrossesAnchorSide(t,e))return!1;1==i.sign?(i.ax=t.right-.1*t.rightAnchor,i.bx=e.left):(i.ax=t.left+.1*t.leftAnchor,i.bx=e.right)}return!0}OriginToOriginSegCrossesAnchorSide(t,e){const i=I.mkPP(t.origin,e.origin);return t.x<e.x&&F.CurvesIntersect(i,I.mkPP(t.rightBottom,t.rightTop))||F.CurvesIntersect(i,I.mkPP(e.leftBottom,t.leftTop))||t.x>e.x&&F.CurvesIntersect(i,I.mkPP(t.leftBottom,t.leftTop))||F.CurvesIntersect(i,I.mkPP(e.rightBottom,t.rightTop))}OptimizeShortPath(){this.edgePath.count>2||(2==this.edgePath.count&&null!=this.headSite.next.next&&null==this.headSite.next.next.next&&null==this.anchors[this.EdgePathNode(1)].node?this.OptimizeForThreeSites():1==this.edgePath.count&&this.OptimizeForTwoSites())}PositionsAreLegal(t,e,i,n,r,s){if(!v(t,e)&&(t-e)*i>0)return!1;const o=this.anchors[s],a=this.MiddlePos(t,e,n,r,o.y);return!!this.MiddleAnchorLegal(a,s,o)&&!this.LineSegIntersectBound(new E(t,n.bottom),new E(e,r.top))}MiddleAnchorLegal(t,e,i){const n=this.NodeLayer(e),r=this.layerArrays.x[e],s=t-i.x;if(r>0){if(this.anchors[n[r-1]].right>s+i.left)return!1}if(r<n.length-1){if(this.anchors[n[r+1]].left<s+i.right)return!1}return!0}MiddlePos(t,e,i,n,r){const s=i.y-r,o=r-n.y;return(t*s+e*o)/(s+o)}TryToRemoveInflections(){if(this.TurningAlwaySameDirection())return;let t=!0;for(;t;){t=!1;for(const e={s:this.headSite,cut:!1};e.s;)this.TryToRemoveInflectionCorner(e),t=e.cut||t}}TurningAlwaySameDirection(){let t=0;for(let e=this.headSite.next;null!=e&&null!=e.next;e=e.next){const i=e.turn;if(0==t)i>0?t=1:i<0&&(t=-1);else if(t*i<0)return!1}return!0}EdgePathPoint(t){return this.anchors[this.EdgePathNode(t)].origin}EdgePathNode(t){return t==this.edgePath.count?this.edgePath.LayerEdges[this.edgePath.count-1].Target:this.edgePath.LayerEdges[t].Source}createSmoothedPolyline(){this.RemoveVerticesWithNoTurns();let t=new F;const e=this.headSite,i=F.findCorner(e);return null!=i?(this.createFilletCurve(t,{a:e,b:i.b,c:i.c}),t=this.ExtendCurveToEndpoints(t)):t.addSegment(I.mkPP(this.headSite.point,this.TailSite.point)),t}curveIsLegal(t){return!0}RemoveVerticesWithNoTurns(){for(;this.RemoveVerticesWithNoTurnsOnePass(););}RemoveVerticesWithNoTurnsOnePass(){let t=!1;for(let e=this.headSite;null!=e.next&&null!=e.next.next;e=e.next)Qe.Flat(e.next)&&(t=!0,e.next=e.next.next,e.next.prev=e);return t}ExtendCurveToEndpoints(t){let e=this.headSite.point;if(!E.closeDistEps(e,t.start)){const i=new F;i.addSegs([I.mkPP(e,t.start),t]),t=i}return e=this.TailSite.point,E.closeDistEps(e,t.end)||t.addSegment(I.mkPP(t.end,e)),t}createFilletCurve(t,e){for(;this.AddSmoothedCorner(e.a,e.b,e.c,t),e.a=e.b,e.b=e.c,null!=e.b.next;)e.c=e.b.next}AddSmoothedCorner(t,e,i,n){let r,s=.5;do{r=F.createBezierSeg(s,s,t,e,i),e.previouisBezierCoefficient=s,s/=2}while(this.BezierSegIntersectsBoundary(r));if(s*=2,s<.5){s=.5*(s+2*s);const n=F.createBezierSeg(s,s,t,e,i);this.BezierSegIntersectsBoundary(n)||(e.nextBezierCoefficient=s,e.previouisBezierCoefficient=s,r=n)}n.segs.length>0&&!E.closeDistEps(n.end,r.start)&&n.addSegment(I.mkPP(n.end,r.start)),n.addSegment(r)}BezierSegIntersectsBoundary(t){return E.signedDoubledTriangleArea(t.B(0),t.B(1),t.B(2))<0?this.BezierSegIntersectsTree(t,this.thinWestHierarchy)||this.BezierSegIntersectsTree(t,this.westHierarchy):this.BezierSegIntersectsTree(t,this.thinEastHierarchy)||this.BezierSegIntersectsTree(t,this.eastHierarchy)}BezierSegIntersectsTree(t,e){if(null==e)return!1;if(A.intersect(t.pNodeOverICurve().parallelogram,e.parallelogram)){if(e.node.hasOwnProperty("children")){const i=e.node;return this.BezierSegIntersectsTree(t,i.children[0])||this.BezierSegIntersectsTree(t,i.children[1])}return Qe.BezierSegIntersectsBoundary(t,e.seg)}return!1}static BezierSegIntersectsBoundary(t,e){for(const i of F.getAllIntersections(t,e,!1)){if(!(e instanceof F))return!0;{const t=e;if(F.realCutWithClosedCurve(i,t,!1))return!0}}return!1}}class Ze{constructor(t=null){this.parents=new Set,this.children=new Set,this.ports=new Set,this.BoundaryCurve=t}get Parents(){return Array.from(this.parents.values())}get Children(){return Array.from(this.children.values())}get BoundaryCurve(){return this.boundaryCurve}set BoundaryCurve(t){this.boundaryCurve=t}get BoundingBox(){return this.BoundaryCurve.boundingBox}get Ports(){return this.ports}static mkShape(){return new Ze(null)}get IsGroup(){return this.children.size>0}*Descendants(){const t=new h.Queue;for(const e of this.Children)t.enqueue(e);for(;t.length>0;){const e=t.dequeue();yield e;for(const i of e.Children)t.enqueue(i)}}*Ancestors(){const t=new h.Queue;for(const e of this.Parents)t.enqueue(e);for(;t.length>0;){const e=t.dequeue();yield e;for(const i of e.Parents)t.enqueue(i)}}AddParent(t){this.parents.add(t),t.children.add(this)}AddChild(t){t.parents.add(this),this.children.add(t)}RemoveChild(t){this.children.delete(t),t.parents.delete(this)}RemoveParent(t){this.parents.delete(t),t.children.delete(this)}ToString(){return this.UserData?this.UserData.toString():"null"}}class Ke{}class $e extends Ke{constructor(t,e){super(),this.curve=this.curve,this.location=e.clone()}get Location(){return this.location}set Location(t){this.location=t}Translate(t){this.location=this.location.add(t)}get Curve(){return this.curve}set Curve(t){this.curve=t}}class Je extends $e{constructor(t,e,i){super(null,e().add(i)),this.LocationOffset=i,this.CurveDelegate=t,this.CenterDelegate=e}static mk(t,e){return new Je(t,e,new E(0,0))}get CenterDelegate(){return this.centerDelegate}set CenterDelegate(t){this.centerDelegate=t}get CurveDelegate(){return this.curveDelegate}set CurveDelegate(t){this.curveDelegate=t}get LocationOffset(){return this.locationOffset}set LocationOffset(t){this.locationOffset=t}get Location(){return this.CenterDelegate().add(this.LocationOffset)}get Curve(){return this.CurveDelegate()}}class ti{constructor(t,e,i,n,r){this.color=t,void 0!==e&&(this.item=e),void 0!==i&&(this.parent=i),void 0!==n&&(this.left=n),void 0!==r&&(this.right=r)}toString(){return this.item.toString()}}!function(t){t[t.Red=0]="Red",t[t.Black=1]="Black"}(ze||(ze={}));class ei{constructor(t){this.comparer=t,this.count=0,this.root=this.nil=new ti(ze.Black)}[Symbol.iterator](){return this.allNodes()}clear(){this.root=this.nil=new ti(ze.Black)}toNull(t){return t!=this.nil?t:null}isEmpty(){return this.root==this.nil}getComparer(){return this.comparer}getRoot(){return this.root}find(t,e=this.root){let i;for(;e!=this.nil&&0!=(i=this.comparer(t,e.item));)e=i<0?e.left:e.right;return this.toNull(e)}findFirst(t,e=this.root){if(e==this.nil)return null;let i=null;for(;e!=this.nil;)e=t(e.item)?(i=e).left:e.right;return i}findLast(t,e=this.root){if(e==this.nil)return null;let i=null;for(;e!=this.nil;)e=t(e.item)?(i=e).right:e.left;return i}treeMinimum(t=this.root){for(;t.left!=this.nil;)t=t.left;return this.toNull(t)}treeMaximum(t=this.root){for(;t.right!=this.nil;)t=t.right;return this.toNull(t)}next(t){if(t.right!=this.nil)return this.treeMinimum(t.right);let e=t.parent;for(;e!=this.nil&&t==e.right;)t=e,e=e.parent;return this.toNull(e)}previous(t){if(t.left!=this.nil)return this.treeMaximum(t.left);let e=t.parent;for(;e!=this.nil&&t==e.left;)t=e,e=e.parent;return this.toNull(e)}leftRotate(t){const e=t.right;t.right=e.left,e.left!=this.nil&&(e.left.parent=t),e.parent=t.parent,t.parent==this.nil?this.root=e:t==t.parent.left?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}rightRotate(t){const e=t.left;t.left=e.right,e.right!=this.nil&&(e.right.parent=t),e.parent=t.parent,t.parent==this.nil?this.root=e:t==t.parent.right?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}deleteFixup(t){for(;t!=this.root&&t.color==ze.Black;)if(t==t.parent.left){let e=t.parent.right;e.color==ze.Red&&(e.color=ze.Black,t.parent.color=ze.Red,this.leftRotate(t.parent),e=t.parent.right),e.left.color==ze.Black&&e.right.color==ze.Black?(e.color=ze.Red,t=t.parent):(e.right.color==ze.Black&&(e.left.color=ze.Black,e.color=ze.Red,this.rightRotate(e),e=t.parent.right),e.color=t.parent.color,t.parent.color=ze.Black,e.right.color=ze.Black,this.leftRotate(t.parent),t=this.root)}else{let e=t.parent.left;e.color==ze.Red&&(e.color=ze.Black,t.parent.color=ze.Red,this.rightRotate(t.parent),e=t.parent.left),e.right.color==ze.Black&&e.left.color==ze.Black?(e.color=ze.Red,t=t.parent):(e.left.color==ze.Black&&(e.right.color=ze.Black,e.color=ze.Red,this.leftRotate(e),e=t.parent.left),e.color=t.parent.color,t.parent.color=ze.Black,e.left.color=ze.Black,this.rightRotate(t.parent),t=this.root)}t.color=ze.Black}deleteSubTree(t){let e;if(t.left==this.nil||t.right==this.nil)e=t;else for(e=t.right;e.left!=this.nil;)e=e.left;const i=e.left!=this.nil?e.left:e.right;return i.parent=e.parent,e.parent==this.nil?this.root=i:e==e.parent.left?e.parent.left=i:e.parent.right=i,e!=t&&(t.item=e.item),e.color==ze.Black&&this.deleteFixup(i),this.toNull(t)}deleteNodeInternal(t){this.count--,this.deleteSubTree(t)}remove(t){const e=this.find(t);return null!=e?(this.count--,this.deleteSubTree(e)):null}insert(t){const e=this.treeInsert(t);return this.insertPrivate(e),this.toNull(e)}treeInsert(t){let e=this.nil,i=this.root,n=0;for(;i!=this.nil;)e=i,n=this.comparer(t,i.item),i=n<0?i.left:i.right;const r=new ti(ze.Black,t,e,this.nil,this.nil);return e==this.nil?this.root=r:n<0?e.left=r:e.right=r,this.toNull(r)}insertPrivate(t){for(this.count++,t.color=ze.Red;t!=this.root&&t.parent.color==ze.Red;)if(t.parent==t.parent.parent.left){const e=t.parent.parent.right;e.color==ze.Red?(t.parent.color=ze.Black,e.color=ze.Black,t.parent.parent.color=ze.Red,t=t.parent.parent):(t==t.parent.right&&(t=t.parent,this.leftRotate(t)),t.parent.color=ze.Black,t.parent.parent.color=ze.Red,this.rightRotate(t.parent.parent))}else{const e=t.parent.parent.left;e.color==ze.Red?(t.parent.color=ze.Black,e.color=ze.Black,t.parent.parent.color=ze.Red,t=t.parent.parent):(t==t.parent.left&&(t=t.parent,this.rightRotate(t)),t.parent.color=ze.Black,t.parent.parent.color=ze.Red,this.leftRotate(t.parent.parent))}this.root.color=ze.Black}*allNodes(){if(this.isEmpty())return;let t=this.treeMinimum();for(;null!=t;)yield t.item,t=this.next(t)}toString(){let t="{",e=0;for(const i of this.allNodes())t+=i.toString(),e!=this.count-1&&(t+="\n"),e++;return t+"}"}}class ii{constructor(t){this.heapSize=0,this.A=[],this.compare=t}Enqueue(t){let e=this.heapSize+1;this.A[e]=t,this.heapSize++;let i,n,r=e>>1;for(;e>1&&this.Less(i=this.A[e],n=this.A[r]);)this.A[r]=i,this.A[e]=n,e=r,r=e>>1}Dequeue(){if(this.heapSize<1)throw new Error;const t=this.A[1],e=this.A[this.heapSize];return this.heapSize--,this.ChangeMinimum(e),t}ChangeMinimum(t){this.A[1]=t;let e=1,i=2,n=!1;for(;i<this.heapSize&&!n;){n=!0;const r=this.A[i],s=this.A[i+1];this.compare(r,s)<0?this.compare(r,t)<0&&(this.A[e]=r,this.A[i]=t,n=!1,e=i,i=e<<1):this.compare(s,t)<0&&(this.A[e]=s,this.A[i+1]=t,n=!1,e=i+1,i=e<<1)}if(i==this.heapSize){const n=this.A[i];this.compare(n,t)<0&&(this.A[e]=n,this.A[i]=t)}}get Count(){return this.heapSize}Less(t,e){return this.compare(t,e)<0}GetMinimum(){return this.A[1]}}class ni{}class ri extends ni{constructor(t){super(),this.Vertex=t}get Site(){return this.Vertex.point}get Polyline(){return this.Vertex.polyline}}class si extends ri{constructor(t){super(t)}}class oi{constructor(t){this.lineSweeper=t}Compare(t,e){switch(E.getTriangleOrientation(e.Start,e.End,this.x)){case s.Collinear:return 0;case s.Clockwise:return 1;default:return-1}}SetOperand(t){this.x=this.IntersectionOfSideAndSweepLine(t)}IntersectionOfSideAndSweepLine(t){const e=t.Direction.dot(this.lineSweeper.SweepDirection),i=(this.lineSweeper.Z-t.Start.dot(this.lineSweeper.SweepDirection))/e;return t.Start.add(t.Direction.mul(i))}}class ai extends ni{constructor(t){super(),this.site=t}get Site(){return this.site}}class li{constructor(t,e){this.PreviousZ=Number.NEGATIVE_INFINITY,this.z=Number.NEGATIVE_INFINITY,this.Obstacles=null!=t?t:[],this.SweepDirection=e,this.DirectionPerp=e.rotate(-Math.PI/2),this.EventQueue=new ii((t,e)=>this.Compare(t,e)),this.ObstacleSideComparer=new oi(this),this.LeftObstacleSideTree=new ei((t,e)=>this.ObstacleSideComparer.Compare(t,e)),this.RightObstacleSideTree=new ei((t,e)=>this.ObstacleSideComparer.Compare(t,e))}get EventQueue(){return this.eventQueue}set EventQueue(t){this.eventQueue=t}get DirectionPerp(){return this.directionPerp}set DirectionPerp(t){this.directionPerp=t}get Z(){return this.z}set Z(t){t>this.z+y.tolerance&&(this.PreviousZ=this.z),this.z=t}GetZS(t){return this.SweepDirection.dot(t.Site)}GetZP(t){return this.SweepDirection.dot(t)}SegmentIsNotHorizontal(t,e){return Math.abs(t.sub(e).dot(this.SweepDirection))>y.distanceEpsilon}RemoveLeftSide(t){this.ObstacleSideComparer.SetOperand(t),this.LeftObstacleSideTree.remove(t)}RemoveRightSide(t){this.ObstacleSideComparer.SetOperand(t),this.RightObstacleSideTree.remove(t)}InsertLeftSide(t){this.ObstacleSideComparer.SetOperand(t),this.LeftObstacleSideTree.insert(t)}InsertRightSide(t){this.ObstacleSideComparer.SetOperand(t),this.RightObstacleSideTree.insert(t)}FindFirstObstacleSideToTheLeftOfPoint(t){const e=this.RightObstacleSideTree.findLast(e=>E.pointToTheRightOfLineOrOnLine(t,e.Start,e.End));return null==e?null:e.item}FindFirstObstacleSideToToTheRightOfPoint(t){const e=this.LeftObstacleSideTree.findFirst(e=>!E.pointToTheRightOfLineOrOnLine(t,e.Start,e.End));return null==e?null:e.item}EnqueueEvent(t){this.eventQueue.Enqueue(t)}InitQueueOfEvents(){for(const t of this.Obstacles)this.EnqueueLowestPointsOnObstacles(t);if(null!=this.Ports)for(const t of this.Ports.values())this.EnqueueEvent(new ai(t))}EnqueueLowestPointsOnObstacles(t){const e=this.GetLowestPoint(t);this.EnqueueEvent(new si(e))}GetLowestPoint(t){let e=t.startPoint,i=t.startPoint.next;for(;null!=i;i=i.next)this.Less(i.point,e.point)&&(e=i);return e}Compare(t,e){const i=t.Site,n=e.Site;return this.ComparePoints(i,n)}Less(t,e){return this.ComparePoints(t,e)<0}ComparePoints(t,e){let i=this.SweepDirection.dot(t),n=this.SweepDirection.dot(e);return i<n?-1:i>n?1:(i=this.directionPerp.dot(t),n=this.directionPerp.dot(e),i<n?-1:i>n?1:0)}}class hi{constructor(t,e,i=1){this.LengthMultiplier=1,(hi.closeuv(t,e)||hi.closeuv(e,t))&&console.log(t),this.Source=t,this.Target=e,this.Weight=i}static closeuv(t,e){return E.closeDistEps(t.point,hi.u,.1)&&E.closeDistEps(e.point,hi.v,.1)}get SourcePoint(){return this.Source.point}get TargetPoint(){return this.Target.point}get Length(){return this.SourcePoint.sub(this.TargetPoint).length*this.LengthMultiplier}toString(){return _t.String.Format("{0}->{1} ({2})",this.Source,this.Target,this.Weight)}ReversedClone(){return new hi(this.Target,this.Source)}Clone(){return new hi(this.Source,this.Target)}}hi.u=new E(545.833,840.458),hi.v=new E(606.1667261889578,786.2917261889578),hi.DefaultWeight=1;class ui extends hi{static constructorVV(t,e){return new ui(t,e,0)}constructor(t,e,i=0){super(t,e,i)}}class ci{constructor(t){this._inEdges=new Array,this._outEdges=new ei((t,e)=>this.Compare(t,e)),this.point=t}get InEdges(){return this._inEdges}get OutEdges(){return this._outEdges}get Degree(){return this._inEdges.length+this.OutEdges.count}InEdgesLength(){return this._inEdges.length}addInEdge(t){this._inEdges.push(t)}get IsTerminal(){return this._isTerminal}set IsTerminal(t){this._isTerminal=t}get IsShortestPathTerminal(){return this._isShortestPathTerminal}set IsShortestPathTerminal(t){this._isShortestPathTerminal=t}toString(){return this.point.toString()}RemoveOutEdge(t){this.OutEdges.remove(t)}RemoveInEdge(t){const e=this._inEdges.indexOf(t);if(-1==e)return;const i=this._inEdges.length-1;e!=i&&(this._inEdges[e]=this._inEdges[i]),this._inEdges.pop()}static FindFirst(t,e){return ci.FindFirst_t(t.root,t,e)}static FindFirst_t(t,e,i){if(t==e.nil)return null;let n=null;for(;t!=e.nil;)t=t.item.TargetPoint.compareTo(i)>=0?(n=t).left:t.right;return n}get(t){let e=ci.FindFirst(this.OutEdges,t.point);return null!=e&&e.item.Target==t?e.item:(e=ci.FindFirst(t.OutEdges,this.point),null!=e&&e.item.Target==this?e.item:null)}Compare(t,e){return t.TargetPoint.compareTo(e.TargetPoint)}ClearEdges(){this._outEdges.clear(),this._inEdges=[]}}class di{constructor(){this._prevEdgesMap=new Map,this.visVertexToId=new Map,this.VertexFactory=t=>new ci(t),this.pointToVertexMap=new Ie}*edges_(){for(const t of this.pointToVertexMap.values())for(const e of t.OutEdges)yield e}get Edges(){return this.edges_()}ClearPrevEdgesTable(){this._prevEdgesMap.clear()}ShrinkLengthOfPrevEdge(t,e){this._prevEdgesMap.get(t).LengthMultiplier=e}PreviosVertex(t){const e=this._prevEdgesMap.get(t);return e?e.Source==t?e.Target:e.Source:null}SetPreviousEdge(t,e){this._prevEdgesMap.set(t,e)}AddHole(t){let e=t.startPoint;for(;e!=t.endPoint;)this.AddEdgePlPl(e,e.next),e=e.next;this.AddEdgePlPl(t.endPoint,t.startPoint)}static*OrientHolesClockwise(t){for(const e of t)for(let t=e.startPoint;;t=t.next){const i=E.getTriangleOrientation(t.point,t.next.point,t.next.next.point);if(i!=s.Collinear){yield i==s.Clockwise?e:e.reverse();break}}}AddVertexP(t){const e=this.pointToVertexMap.get(t);if(e)return e;const i=this.VertexFactory(t);return this.pointToVertexMap.set(t,i),i}AddVertexV(t){this.pointToVertexMap.set(t.point,t)}ContainsVertex(t){return this.pointToVertexMap.has(t)}static AddEdgeVV(t,e){let i;if(i=t.get(e))return i;if(t==e)throw new Error("Self-edges are not allowed");const n=new hi(t,e);return t.OutEdges.insert(n),e.InEdges.push(n),n}AddEdgePlPl(t,e){this.AddEdgePP(t.point,e.point)}static AddEdge(t){t.Source.OutEdges.insert(t),t.Target.addInEdge(t)}AddEdgeF(t,e,i){let n=this.FindVertex(t),r=null;if(null!=n&&(r=this.FindVertex(e),null!=r)){const t=n.get(r);if(t)return t}null==n?(n=this.AddVertexP(t),r=this.AddVertexP(e)):null==r&&(r=this.AddVertexP(e));const s=i(n,r);return n.OutEdges.insert(s),r.addInEdge(s),s}AddEdgePP(t,e){return this.AddEdgeF(t,e,(t,e)=>new hi(t,e))}FindVertex(t){return this.pointToVertexMap.get(t)}Vertices(){return this.pointToVertexMap.values()}RemoveVertex(t){for(const e of t.OutEdges)e.Target.RemoveInEdge(e);for(const e of t.InEdges)e.Source.RemoveOutEdge(e);this.pointToVertexMap.deleteP(t.point)}FindEdgePP(t,e){const i=this.FindVertex(t);if(null==i)return null;const n=this.FindVertex(e);return null==n?null:i.get(n)}static RemoveEdge(t){t.Source.RemoveOutEdge(t),t.Target.RemoveInEdge(t)}ClearEdges(){for(const t of this.Vertices())t.ClearEdges()}}class gi{constructor(){this.Removed=!1}}class fi extends gi{constructor(t,e,i){super(),this.start=t,this.EndVertex=e,this.ConeSide=i}get Start(){return this.start}get End(){return this.EndVertex.point}get Direction(){return this.End.sub(this.Start)}toString(){return"BrokenConeSide: "+this.Start+","+this.End}}class pi{constructor(t,e){this.apex=t,this.coneSweeper=e}get Removed(){return this.removed}set Removed(t){this.removed=t}get Apex(){return this.apex}set Apex(t){this.apex=t}get RightSideDirection(){return this.coneSweeper.ConeRightSideDirection}get LeftSideDirection(){return this.coneSweeper.ConeLeftSideDirection}get RightSide(){return this.rightSide}set RightSide(t){this.rightSide=t,this.rightSide.Cone=this}get LeftSide(){return this.leftSide}set LeftSide(t){this.leftSide=t,this.leftSide.Cone=this}}class mi extends ni{constructor(t,e){super(),this.site=t,this.coneToClose=e}get ConeToClose(){return this.coneToClose}get Site(){return this.site}toString(){return"ConeClosureEvent "+this.site}}class yi extends gi{constructor(t){super(),this.Cone=t}get Start(){return this.Cone.Apex}get Direction(){return this.Cone.LeftSideDirection}toString(){return"ConeLeftSide "+this.Start+" "+this.Direction}}class bi extends gi{constructor(t){super(),this.Cone=t}get Start(){return this.Cone.Apex}get Direction(){return this.Cone.RightSideDirection}toString(){return"ConeRightSide "+this.Start+" "+this.Direction}}class Pi{constructor(t){this.coneSweeper=t}SetOperand(t){this.x=this.IntersectionOfSegmentAndSweepLine(t)}Compare(t,e){const i=e instanceof fi;return t instanceof fi?i?this.CompareBrokenSides(t,e):this.CompareObstacleSideAndConeSide(e):i?this.CompareConeSideAndObstacleSide(t,e):Pi.CompareNotIntersectingSegs(t,e)}static CompareNotIntersectingSegs(t,e){switch(E.getTriangleOrientation(t.Start,e.Start,e.Start.add(e.Direction))){case s.Counterclockwise:return-1;case s.Clockwise:return 1;default:return 0}}CompareObstacleSideAndConeSide(t){const e=E.getTriangleOrientation(this.x,t.Start,t.Start.add(t.Direction));return e==s.Counterclockwise?-1:e==s.Clockwise?1:t instanceof yi?-1:1}CompareConeSideAndObstacleSide(t,e){const i=E.getTriangleOrientation(this.x,e.start,e.End);return i==s.Counterclockwise?-1:i==s.Clockwise||t instanceof yi?1:-1}IntersectionOfSegmentAndSweepLine(t){const e=t.Direction.dot(this.coneSweeper.SweepDirection),i=(this.coneSweeper.Z-t.Start.dot(this.coneSweeper.SweepDirection))/e;return t.Start.add(t.Direction.mul(i))}CompareBrokenSides(t,e){return t.EndVertex==e.EndVertex?Pi.CompareNotIntersectingSegs(t.ConeSide,e.ConeSide):E.getTriangleOrientation(this.x,e.start,e.EndVertex.point)==s.Counterclockwise?-1:1}}class vi extends ni{constructor(t,e,i){super(),this.coneLeftSide=t,this.intersectionPoint=e,this.endVertex=i}get EndVertex(){return this.endVertex}get Site(){return this.intersectionPoint}toString(){return"LeftIntersectionEvent "+this.intersectionPoint}}class Si{get Direction(){return this.End.sub(this.Start)}toString(){return this.Start+" "+this.End}}class Ci extends Si{constructor(t){super(),this.Init(t)}Init(t){this.StartVertex=t}get Polyline(){return this.StartVertex.polyline}get Start(){return this.StartVertex.point}get End(){return this.EndVertex.point}}class wi extends Ci{constructor(t){super(t),this.end=t.nextOnPolyline.point}get End(){return this.end}get EndVertex(){return this.StartVertex.nextOnPolyline}}class Ei extends ri{constructor(t){super(t)}}class xi extends ni{constructor(t,e,i){super(),this.coneRightSide=t,this.intersectionPoint=e,this.endVertex=i}get EndVertex(){return this.endVertex}set EndVertex(t){this.endVertex=t}get Site(){return this.intersectionPoint}toString(){return"RightIntersectionEvent "+this.intersectionPoint}}class Ai extends Ci{constructor(t){super(t),this.end=t.prevOnPolyline.point}get End(){return this.end}get EndVertex(){return this.StartVertex.prevOnPolyline}}class Ti extends ri{constructor(t){super(t)}}class Ii extends li{constructor(t,e,i,n,r,s,o){super(t,e),this.visibilityGraph=r,this.ConeRightSideDirection=i,this.ConeLeftSideDirection=n,this.coneSideComparer=new Pi(this),this.leftConeSides=new ei((t,e)=>this.coneSideComparer.Compare(t,e)),this.rightConeSides=new ei((t,e)=>this.coneSideComparer.Compare(t,e)),this.Ports=s,this.BorderPolyline=o,this.PortEdgesCreator=(t,e)=>new ui(t,e,0)}static Sweep(t,e,i,n,r,s){new Ii(t,e,e.rotate(-i/2),e.rotate(i/2),n,r,s).Calculate()}Calculate(){for(Ii.debCount++,this.InitQueueOfEvents();this.EventQueue.Count>0;)this.ProcessEvent(this.EventQueue.Dequeue());null!=this.BorderPolyline&&this.CloseRemainingCones(),this.CreatePortEdges()}CreatePortEdges(){if(null!=this.portEdgesGraph)for(const t of this.portEdgesGraph.Edges)this.visibilityGraph.AddEdgeF(t.SourcePoint,t.TargetPoint,this.PortEdgesCreator)}CloseRemainingCones(){if(0==this.leftConeSides.count)return;let t=this.BorderPolyline.startPoint,e=this.leftConeSides.count;do{const i=this.leftConeSides.treeMinimum().item.Cone;t=this.FindPolylineSideIntersectingConeRightSide(t,i),t=this.GetPolylinePointInsideOfConeAndRemoveCones(t,i),e--}while(this.leftConeSides.count>0&&e>0)}GetPolylinePointInsideOfConeAndRemoveCones(t,e){const i=t.nextOnPolyline,n=Ii.FindInsidePoint(t.point,i.point,e);return E.closeDistEps(n,t.point)?(this.AddEdgeAndRemoveCone(e,t.point),this.AddEdgesAndRemoveRemainingConesByPoint(t.point)):E.closeDistEps(n,i.point)?(this.AddEdgeAndRemoveCone(e,i.point),this.AddEdgesAndRemoveRemainingConesByPoint(i.point),t=i):(t=Ii.InsertPointIntoPolylineAfter(this.BorderPolyline,t,n),this.AddEdgeAndRemoveCone(e,t.point),this.AddEdgesAndRemoveRemainingConesByPoint(t.point)),t}static FindInsidePoint(t,e,i){return Ii.FindInsidePointBool(t,e,i.Apex,i.Apex.add(i.LeftSideDirection),i.Apex.add(i.RightSideDirection))}static FindInsidePointBool(t,e,i,n,r){if(E.closeDistEps(t,e))return t;if(E.PointIsInsideCone(t,i,n,r))return t;if(E.PointIsInsideCone(e,i,n,r))return e;const s=E.middle(t,e);return E.pointToTheLeftOfLine(s,i,n)?Ii.FindInsidePointBool(s,e,i,n,r):Ii.FindInsidePointBool(t,s,i,n,r)}AddEdgesAndRemoveRemainingConesByPoint(t){const e=new Array;for(const i of this.leftConeSides){if(!E.PointToTheRightOfLineOrOnLine(t,i.Start,i.Start.add(i.Direction)))break;e.push(i.Cone)}for(const i of e)this.AddEdgeAndRemoveCone(i,t)}FindPolylineSideIntersectingConeRightSide(t,e){const i=t,n=e.Apex,r=e.Apex.add(this.ConeRightSideDirection);let s=Ii.GetSign(t,n,r);for(;;){const e=t.nextOnPolyline,o=Ii.GetSign(e,n,r);if(o-s>0)return t;if(s=o,(t=e)==i)throw new Error("cannod decide if the polyline intersects the cone!")}}static GetSign(t,e,i){const n=E.signedDoubledTriangleArea(e,i,t.point);return n<0?1:n>0?-1:0}AddEdgeAndRemoveCone(t,e){null!=this.Ports&&this.Ports.has(t.Apex)?this.CreatePortEdge(t,e):this.visibilityGraph.AddEdgePP(t.Apex,e),this.RemoveCone(t)}CreatePortEdge(t,e){null==this.portEdgesGraph&&(this.portEdgesGraph=new di);const i=this.portEdgesGraph.FindVertex(t.Apex),n=null!=i?Array.from(i.InEdges).concat(Array.from(i.OutEdges.allNodes())):null;if(n)for(const t of n){const n=(t.Target==i?t.Source:t.Target).point;di.RemoveEdge(t),this.portEdgesGraph.AddEdgePP(n,e)}this.portEdgesGraph.AddEdgePP(t.Apex,e)}static InsertPointIntoPolylineAfter(t,e,i){let n;return null!=e.next?(n=x.mkFromPoint(i),n.prev=e,n.next=e.next,e.next.prev=n,e.next=n):(n=x.mkFromPoint(i),n.prev=e,e.next=n,t.endPoint=n),n.polyline=t,t.setInitIsRequired(),n}ProcessEvent(t){5682==Ii.debCount&&(t.Site.sub(new E(616.167,807.958)).length<.1||t.Site.sub(new E(525.8332738110422,807.9582738110422)).length<.1)&&console.log(this);if(t instanceof ri)this.ProcessVertexEvent(t);else{if(t instanceof xi)this.ProcessRightIntersectionEvent(t);else{if(t instanceof vi)this.ProcessLeftIntersectionEvent(t);else{t instanceof mi?t.ConeToClose.Removed||this.RemoveCone(t.ConeToClose):this.ProcessPortObstacleEvent(t),this.Z=this.GetZS(t)}}}}ProcessPortObstacleEvent(t){this.Z=this.GetZS(t),this.GoOverConesSeeingVertexEvent(t),this.CreateConeOnVertex(t)}ProcessLeftIntersectionEvent(t){if(0==t.coneLeftSide.Removed)if(Math.abs(t.EndVertex.point.sub(t.Site).dot(this.SweepDirection))<y.distanceEpsilon)this.RemoveCone(t.coneLeftSide.Cone);else{this.RemoveSegFromLeftTree(t.coneLeftSide),this.Z=this.GetZP(t.Site);const e=new fi(t.Site,t.EndVertex,t.coneLeftSide);this.InsertToTree(this.leftConeSides,e),t.coneLeftSide.Cone.LeftSide=e,this.LookForIntersectionOfObstacleSideAndLeftConeSide(t.Site,t.EndVertex),this.TryCreateConeClosureForLeftSide(e)}else this.Z=this.GetZP(t.Site)}TryCreateConeClosureForLeftSide(t){if(t.Cone.RightSide instanceof bi){const e=t.Cone.RightSide;E.getTriangleOrientation(e.Start,e.Start.add(e.Direction),t.EndVertex.point)==s.Clockwise&&this.CreateConeClosureEvent(t,e)}}CreateConeClosureEvent(t,e){const i=E.RayIntersectsRayInteriors(t.start,t.Direction,e.Start,e.Direction),n=new mi(i,t.Cone);this.EnqueueEvent(n)}ProcessRightIntersectionEvent(t){if(0==t.coneRightSide.Removed){this.RemoveSegFromRightTree(t.coneRightSide),this.Z=this.GetZP(t.Site);const e=new fi(t.Site,t.EndVertex,t.coneRightSide);this.InsertToTree(this.rightConeSides,e),t.coneRightSide.Cone.RightSide=e,this.LookForIntersectionOfObstacleSideAndRightConeSide(t.Site,t.EndVertex),this.TryCreateConeClosureForRightSide(e)}else this.Z=this.GetZP(t.Site)}TryCreateConeClosureForRightSide(t){if(t.Cone.LeftSide instanceof yi){const e=t.Cone.LeftSide;E.getTriangleOrientation(e.Start,e.Start.add(e.Direction),t.EndVertex.point)==s.Counterclockwise&&this.CreateConeClosureEvent(t,e)}}RemoveConesClosedBySegment(t,e){this.CloseConesCoveredBySegment(t,e,this.GetZP(t)>this.GetZP(e)?this.leftConeSides:this.rightConeSides)}CloseConesCoveredBySegment(t,e,i){let n=i.findFirst(e=>E.getTriangleOrientation(e.Start,e.Start.add(e.Direction),t)==s.Counterclockwise);if(null==n)return;if(!E.IntervalIntersectsRay(t,e,n.item.Start,n.item.Direction))return;const r=new Array;do{r.push(n.item.Cone),n=i.next(n)}while(null!=n&&null!=E.IntervalIntersectsRay(t,e,n.item.Start,n.item.Direction));for(const t of r)this.RemoveCone(t)}ProcessVertexEvent(t){this.Z=this.GetZS(t),this.GoOverConesSeeingVertexEvent(t),this.AddConeAndEnqueueEvents(t)}static Diamond(t){return H.CreateDiamond(2,2,t)}AddConeAndEnqueueEvents(t){if(t instanceof Ei){const e=t.Vertex.nextOnPolyline;this.CloseConesAddConeAtLeftVertex(t,e)}else{if(t instanceof Ti){const e=t.Vertex.prevOnPolyline;this.CloseConesAddConeAtRightVertex(t,e)}else this.CloseConesAddConeAtLeftVertex(t,t.Vertex.nextOnPolyline),this.CloseConesAddConeAtRightVertex(t,t.Vertex.prevOnPolyline)}}CloseConesAddConeAtRightVertex(t,e){const i=t.Vertex.nextOnPolyline.point;this.directionPerp.dot(t.Site.sub(i))>y.distanceEpsilon&&this.RemoveConesClosedBySegment(i,t.Vertex.point),this.directionPerp.dot(e.point.sub(t.Site))>y.distanceEpsilon&&this.RemoveConesClosedBySegment(t.Site,e.point);const n=t.Site,r=n.add(this.ConeLeftSideDirection),s=n.add(this.ConeRightSideDirection),o=e.point;this.GetZP(n.sub(i))>y.distanceEpsilon&&this.RemoveRightSide(new Ai(t.Vertex.nextOnPolyline)),this.GetZP(n.sub(e.point))>y.distanceEpsilon&&this.RemoveLeftSide(new wi(e)),this.GetZP(o)+y.distanceEpsilon<this.GetZS(t)&&this.CreateConeOnVertex(t),E.PointToTheRightOfLineOrOnLine(o,n,r)?E.PointToTheLeftOfLineOrOnLine(o,n,s)?this.CaseToTheLeftOfLineOrOnLineConeRp(t,e):(this.GetZP(o.sub(n))>y.distanceEpsilon&&(this.LookForIntersectionOfObstacleSideAndLeftConeSide(t.Site,e),this.InsertRightSide(new Ai(t.Vertex))),this.EnqueueRightVertexEvent(new Ti(e))):(this.CreateConeOnVertex(t),E.PointToTheLeftOfLineOrOnLine(o.add(this.DirectionPerp),o,n)&&this.EnqueueRightVertexEvent(new Ti(e)))}CaseToTheLeftOfLineOrOnLineConeRp(t,e){this.EnqueueRightVertexEvent(new Ti(e));const i=new pi(t.Vertex.point,this),n=new fi(i.Apex,e,new yi(i));i.LeftSide=n,i.RightSide=new bi(i);const r=this.InsertToTree(this.rightConeSides,i.RightSide);this.LookForIntersectionWithConeRightSide(r);const s=this.InsertToTree(this.leftConeSides,i.LeftSide);this.FixConeLeftSideIntersections(n,s),this.GetZP(e.point.sub(t.Site))>y.distanceEpsilon&&this.InsertRightSide(new Ai(t.Vertex))}LookForIntersectionOfObstacleSideAndRightConeSide(t,e){const i=this.GetLastNodeToTheLeftOfPointInRightSegmentTree(t);if(null!=i){if(null!=i.item instanceof bi){const n=E.IntervalIntersectsRay(t,e.point,i.item.Start,this.ConeRightSideDirection);n&&this.SegmentIsNotHorizontal(n,e.point)&&this.EnqueueEvent(this.CreateRightIntersectionEvent(i.item,n,e))}}}CreateRightIntersectionEvent(t,e,i){return new xi(t,e,i)}GetLastNodeToTheLeftOfPointInRightSegmentTree(t){return this.rightConeSides.findLast(e=>Ii.PointIsToTheRightOfSegment(t,e))}LookForIntersectionOfObstacleSideAndLeftConeSide(t,e){const i=this.GetFirstNodeToTheRightOfPoint(t);if(null==i)return;if(!(i.item instanceof yi))return;const n=i.item,r=E.IntervalIntersectsRay(t,e.point,n.Start,this.ConeLeftSideDirection);r&&this.EnqueueEvent(new vi(n,r,e))}GetFirstNodeToTheRightOfPoint(t){return this.leftConeSides.findFirst(e=>Ii.PointIsToTheLeftOfSegment(t,e))}static PointIsToTheLeftOfSegment(t,e){return E.getTriangleOrientation(e.Start,e.Start.add(e.Direction),t)==s.Counterclockwise}static PointIsToTheRightOfSegment(t,e){return E.getTriangleOrientation(e.Start,e.Start.add(e.Direction),t)==s.Clockwise}FixConeLeftSideIntersections(t,e){do{e=this.leftConeSides.next(e)}while(null!=e&&E.PointToTheRightOfLineOrOnLine(t.Start,e.item.Start,e.item.Start.add(e.item.Direction)));if(null!=e&&e.item instanceof yi){const i=e.item,n=E.IntervalIntersectsRay(t.start,t.End,i.Start,i.Direction);n&&this.EnqueueEvent(new vi(i,n,t.EndVertex))}}InsertToTree(t,e){return this.coneSideComparer.SetOperand(e),t.insert(e)}CloseConesAddConeAtLeftVertex(t,e){const i=t.Vertex.prevOnPolyline.point;t.Site.sub(i).dot(this.directionPerp)<-y.distanceEpsilon&&this.RemoveConesClosedBySegment(t.Site,i),e.point.sub(t.Site).dot(this.directionPerp)<-y.distanceEpsilon&&this.RemoveConesClosedBySegment(e.point,t.Site);const n=t.Site,r=n.add(this.ConeLeftSideDirection),s=n.add(this.ConeRightSideDirection),o=e.point;this.GetZP(n.sub(i))>y.distanceEpsilon&&this.RemoveLeftSide(new wi(t.Vertex.prevOnPolyline));const a=this.GetZP(o)-this.Z;a<-y.distanceEpsilon&&this.RemoveRightSide(new Ai(e));const l=o.sub(t.Site);if(a<-y.distanceEpsilon||v(a,0)&&this.GetZP(l)>0&&l.dot(this.directionPerp)>-y.distanceEpsilon)this.CreateConeOnVertex(t);else if(E.PointToTheLeftOfLineOrOnLine(o,n,s))if(E.PointToTheLeftOfLineOrOnLine(o,n,r))this.EnqueueEvent(new Ei(e)),this.GetZP(l)>y.distanceEpsilon&&(this.LookForIntersectionOfObstacleSideAndRightConeSide(t.Site,e),this.InsertLeftSide(new wi(t.Vertex)));else{this.EnqueueEvent(new Ei(e));const i=new pi(t.Vertex.point,this),n=new fi(t.Vertex.point,e,new bi(i));i.RightSide=n,i.LeftSide=new yi(i),this.LookForIntersectionWithConeLeftSide(this.InsertToTree(this.leftConeSides,i.LeftSide));const r=this.InsertToTree(this.rightConeSides,n);this.FixConeRightSideIntersections(n,r),this.GetZP(l)>y.distanceEpsilon&&this.InsertLeftSide(new wi(t.Vertex))}else this.CreateConeOnVertex(t),this.EnqueueEvent(new Ei(e))}RemoveCone(t){t.Removed=!0,this.RemoveSegFromLeftTree(t.LeftSide),this.RemoveSegFromRightTree(t.RightSide)}RemoveSegFromRightTree(t){this.coneSideComparer.SetOperand(t);let e=this.rightConeSides.remove(t);if(t.Removed=!0,null==e){const i=this.Z;this.Z=Math.max(this.GetZP(t.Start),this.Z-.01),this.coneSideComparer.SetOperand(t),e=this.rightConeSides.remove(t),this.Z=i}}RemoveSegFromLeftTree(t){t.Removed=!0,this.coneSideComparer.SetOperand(t);if(null==this.leftConeSides.remove(t)){const e=this.Z;this.Z=Math.max(this.GetZP(t.Start),this.Z-.01),this.coneSideComparer.SetOperand(t),this.leftConeSides.remove(t),this.Z=e}}FixConeRightSideIntersections(t,e){do{e=this.rightConeSides.previous(e)}while(null!=e&&E.PointToTheLeftOfLineOrOnLine(t.start,e.item.Start,e.item.Start.add(e.item.Direction)));if(null!=e){let i;if(e.item instanceof bi){const n=e.item;(i=E.IntervalIntersectsRay(t.start,t.End,n.Start,n.Direction))&&this.EnqueueEvent(this.CreateRightIntersectionEvent(n,i,t.EndVertex))}}}CreateConeOnVertex(t){const e=new pi(t.Site,this);e.LeftSide=new yi(e),e.RightSide=new bi(e);const i=this.InsertToTree(this.leftConeSides,e.LeftSide),n=this.InsertToTree(this.rightConeSides,e.RightSide);this.LookForIntersectionWithConeRightSide(n),this.LookForIntersectionWithConeLeftSide(i)}LookForIntersectionWithConeLeftSide(t){if(t.item instanceof yi){const e=t.item,i=this.FindFirstObstacleSideToTheLeftOfPoint(e.Start);null!=i&&this.TryIntersectionOfConeLeftSideAndObstacleSide(e,i)}else{const e=t.item;null!=(t=this.leftConeSides.next(t))&&t.item instanceof yi&&this.TryIntersectionOfConeLeftSideAndObstacleConeSide(t.item,e)}}LookForIntersectionWithConeRightSide(t){if(t.item instanceof bi){const e=t.item,i=this.FindFirstObstacleSideToToTheRightOfPoint(e.Start);null!=i&&this.TryIntersectionOfConeRightSideAndObstacleSide(e,i)}else{const e=t.item;null!=(t=this.rightConeSides.previous(t))&&t.item instanceof bi&&this.TryIntersectionOfConeRightSideAndObstacleConeSide(t.item,e)}}TryIntersectionOfConeRightSideAndObstacleConeSide(t,e){const i=E.IntervalIntersectsRay(e.start,e.End,t.Start,t.Direction);i&&this.EnqueueEvent(this.CreateRightIntersectionEvent(t,i,e.EndVertex))}TryIntersectionOfConeRightSideAndObstacleSide(t,e){const i=E.IntervalIntersectsRay(e.Start,e.End,t.Start,t.Direction);i&&this.EnqueueEvent(this.CreateRightIntersectionEvent(t,i,e.EndVertex))}TryIntersectionOfConeLeftSideAndObstacleConeSide(t,e){const i=E.IntervalIntersectsRay(e.start,e.End,t.Start,t.Direction);i&&this.EnqueueEvent(new vi(t,i,e.EndVertex))}TryIntersectionOfConeLeftSideAndObstacleSide(t,e){const i=E.IntervalIntersectsRay(e.Start,e.End,t.Start,t.Direction);i&&this.EnqueueEvent(new vi(t,i,e.EndVertex))}Show(t,e){let i=Array.from(this.Obstacles).map(t=>Xe.mkDebugCurveTWCI(100,.1,"Blue",t));for(const t of this.rightConeSides)i.push(Xe.mkDebugCurveWCI(.5,"Brown",this.ExtendSegmentToZ(t))),t instanceof fi&&i.push(Xe.mkDebugCurveCI("brown",Ii.Diamond(t.start))),i.push(Xe.mkDebugCurveWCI(.5,"green",this.ExtendSegmentToZ(t.Cone.LeftSide))),t.Cone.LeftSide instanceof fi&&i.push(Xe.mkDebugCurveCI("green",Ii.Diamond(t.Cone.LeftSide.start)));i=i.concat(t.map(t=>Xe.mkDebugCurveCI("red",t)))}ExtendSegmentToZ(t){const e=t.Direction.dot(this.SweepDirection),i=(this.Z+40-t.Start.dot(this.SweepDirection))/e;return I.mkPP(t.Start,t.Start.add(t.Direction.mul(i)))}GoOverConesSeeingVertexEvent(t){let e=this.FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(t);if(null==e)return;const i=e.item.Cone,n=i.LeftSide;if(Ii.VertexIsToTheLeftOfSegment(t,n))return;const r=[i];if(this.coneSideComparer.SetOperand(n),e=this.leftConeSides.find(n),null==e){const t=this.Z;this.Z=Math.max(this.GetZP(n.Start),this.PreviousZ),this.coneSideComparer.SetOperand(n),e=this.leftConeSides.find(n),this.Z=t}if(null!=e||(e=this.GetRbNodeEmergency(e,n),null!=e)){for(e=this.leftConeSides.next(e);null!=e&&!Ii.VertexIsToTheLeftOfSegment(t,e.item);)r.push(e.item.Cone),e=this.leftConeSides.next(e);for(const e of r)this.AddEdgeAndRemoveCone(e,t.Site)}}GetRbNodeEmergency(t,e){for(let i=this.leftConeSides.treeMinimum();null!=i;i=this.leftConeSides.next(i))if(i.item==e){t=i;break}return t}static VertexIsToTheLeftOfSegment(t,e){return E.getTriangleOrientation(e.Start,e.Start.add(e.Direction),t.Site)==s.Counterclockwise}static VertexIsToTheRightOfSegment(t,e){return E.getTriangleOrientation(e.Start,e.Start.add(e.Direction),t.Site)==s.Clockwise}FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(t){return this.rightConeSides.findFirst(e=>!Ii.VertexIsToTheRightOfSegment(t,e))}EnqueueRightVertexEvent(t){this.GetZP(t.Site.sub(t.Vertex.prevOnPolyline.point))>y.tolerance||this.EnqueueEvent(t)}invariant(){for(const t of this.leftConeSides)if(t.Removed)return!1;for(const t of this.rightConeSides)if(t.Removed)return!1;return!0}}Ii.debCount=0;class Oi extends K{constructor(t,e){super(null),this.coneAngle=Math.PI/6,this.ports=new ce,this._obstacles=Array.from(di.OrientHolesClockwise(t)),this._visibilityGraph=e}static mk(t,e,i,n,r){const s=new Oi(t,e);return s.Ports=n,s.BorderPolyline=r,s.ConeAngle=i,s}get ConeAngle(){return this.coneAngle}set ConeAngle(t){this.coneAngle=t}get Ports(){return this.ports}set Ports(t){this.ports=t}get BorderPolyline(){return this.borderPolyline}set BorderPolyline(t){this.borderPolyline=t}get Bidirectional(){return this._bidirectional}set Bidirectional(t){this._bidirectional=t}static GetTotalSteps(t){return Math.floor((2*Math.PI-t/2)/t)+1}run(){const t=2*Math.PI-this.coneAngle/2;if(this.Bidirectional)this.HandleBideractionalCase();else{let e;for(let i=0;(e=this.coneAngle*i)<=t;i++)super.ProgressStep(),this.AddDirection(new E(Math.cos(e),Math.sin(e)),this.BorderPolyline,this._visibilityGraph)}}HandleBideractionalCase(){const t=Math.PI/this.coneAngle;for(let e=0;e<t;e++){const t=e*this.coneAngle,i=new di;this.AddDirection(new E(Math.cos(t),Math.sin(t)),this.BorderPolyline,i);const n=new di;this.AddDirection(new E(-1*Math.cos(t),-1*Math.sin(t)),this.BorderPolyline,n),this.AddIntersectionOfBothDirectionSweepsToTheResult(i,n)}}AddIntersectionOfBothDirectionSweepsToTheResult(t,e){for(const i of t.Edges)null!=e.FindEdgePP(i.SourcePoint,i.TargetPoint)&&this._visibilityGraph.AddEdgePP(i.SourcePoint,i.TargetPoint)}AddDirection(t,e,i){Ii.Sweep(this._obstacles,t,this.coneAngle,i,this.Ports,e)}}class _i extends Ke{constructor(t){super(),this.adjustmentAngle=Math.PI/10,this.hookSize=9,this.curve=t,this.location=this.curve().start}mk(t,e){const i=new _i(t);return i.HookSize=e,i}get Location(){return this.location}get Curve(){return this.curve()}SetLocation(t){this.location=t}get AdjustmentAngle(){return this.adjustmentAngle}set AdjustmentAngle(t){this.adjustmentAngle=t}get HookSize(){return this.hookSize}set HookSize(t){this.hookSize=t}}class Li extends Je{constructor(t,e,i=new E(0,0)){super(t,e,i)}get LoosePolyline(){return this.loosePolyline}set LoosePolyline(t){this.loosePolyline=t}static mk(t,e){return new Li(t,e)}}class Ri extends Ke{get Location(){return this.curve.value(this.parameter)}set Location(t){throw new Error("Method should not be called.")}static mk(t,e){const i=new Ri;return i.curve=t,i.parameter=e,i}get Parameter(){return this.parameter}set Parameter(t){this.parameter=t}get Curve(){return this.curve}set Curve(t){this.curve=t}}class Bi extends Ze{constructor(t){super(null),this.curveDelegate=t}get BoundaryCurve(){return this.curveDelegate()}set BoundaryCurve(t){if(t)throw new Error("Cannot set BoundaryCurve directly for RelativeShape")}}class Mi{static GetShapes(t,e){const i=new Map;for(const e of t)Mi.ProcessAncestorDescendantCouple(e.target,e.source,i),Mi.InsertEdgePortsToShapes(i,e);for(const t of e)Mi.ProcessAncestorDescendantCouple(t.source,t.target,i),Mi.InsertEdgePortsToShapes(i,t);return Mi.BindShapes(i),Array.from(i.values())}static InsertEdgePortsToShapes(t,e){t.get(e.target).Ports.add(e.targetPort),t.get(e.source).Ports.add(e.sourcePort)}static BindShapes(t){for(const[e,i]of t){if(!(e instanceof yt))continue;const n=e;for(const e of Di(n)){const n=t.get(e);n&&i.AddChild(n)}}}static ProcessAncestorDescendantCouple(t,e,i){let n=Fi(e);for(;;){for(const t of Di(n))Mi.CreateShapeIfNeeeded(t,i);if(n==t)break;n=Fi(n)}Mi.CreateShapeIfNeeeded(n,i)}static CreateShapeIfNeeeded(t,e){e.has(t)||e.set(t,new Bi(()=>t.boundaryCurve))}static NumberOfActiveNodesIsUnderThreshold(t,e,i){const n=new Set;for(const e of t)if(Mi.SetOfActiveNodesIsLargerThanThreshold(e.target,e.source,n,i))return!1;for(const t of e)if(Mi.SetOfActiveNodesIsLargerThanThreshold(t.source,t.target,n,i))return!1;return!0}static SetOfActiveNodesIsLargerThanThreshold(t,e,i,n){let r=Fi(e);for(;;){for(const t of Di(r))if(i.add(t),i.size>n)return!0;if(r==t)break;r=Fi(r)}return i.add(r),i.size>n}}function Fi(t){const e=t.node.parent;return z.getGeom(e)}function*Di(t){for(const e of t.graph.shallowNodes)yield z.getGeom(e)}class Ni{constructor(t){this.stamp=0,this.SetPivotAndAllocateHullPointsArray(t)}SetPivotAndAllocateHullPointsArray(t){this.pivot=new E(0,Number.MAX_SAFE_INTEGER);let e=-1,i=0;for(const n of t)(n.y<this.pivot.y||n.y==this.pivot.y&&n.x>this.pivot.x)&&(this.pivot=n,e=i),i++;if(i>=1){this.hullPoints=new Array(i-1),i=0;for(const n of t)i!=e?this.hullPoints[i++]={point:n,deleted:!1,stamp:this.stamp++}:e=-1}}get StackTopPoint(){return this.stack.point}get StackSecondPoint(){return this.stack.next.point}static*CalculateConvexHull(t){const e=new Ni(t);for(const t of e.Calculate())yield t}*Calculate(){if(this.pivot.y!=Number.MAX_SAFE_INTEGER)if(0!=this.hullPoints.length){this.SortAllPointsWithoutPivot(),this.Scan();for(const t of this.EnumerateStack())yield t}else yield this.pivot}*EnumerateStack(){let t=this.stack;for(;null!=t;)yield t.point,t=t.next}Scan(){let t=0;for(;this.hullPoints[t].deleted;)t++;for(this.stack={point:this.pivot,next:null},this.Push(t++),t<this.hullPoints.length&&(this.hullPoints[t].deleted?t++:this.Push(t++));t<this.hullPoints.length;)this.hullPoints[t].deleted?t++:this.LeftTurn(t)?this.Push(t++):this.Pop();for(;this.StackHasMoreThanTwoPoints()&&!this.LeftTurnToPivot();)this.Pop()}LeftTurnToPivot(){return E.getTriangleOrientation(this.StackSecondPoint,this.StackTopPoint,this.pivot)==s.Counterclockwise}StackHasMoreThanTwoPoints(){return null!=this.stack.next&&null!=this.stack.next.next}Pop(){this.stack=this.stack.next}LeftTurn(t){if(null==this.stack.next)return!0;const e=E.getTriangleOrientationWithIntersectionEpsilon(this.StackSecondPoint,this.StackTopPoint,this.hullPoints[t].point);return e==s.Counterclockwise||e!=s.Clockwise&&this.BackSwitchOverPivot(this.hullPoints[t].point)}BackSwitchOverPivot(t){return null==this.stack.next.next&&(this.StackTopPoint.x>this.pivot.x+y.distanceEpsilon&&t.x<this.pivot.x-y.distanceEpsilon)}Push(t){this.stack={point:this.hullPoints[t].point,next:this.stack}}SortAllPointsWithoutPivot(){var t;this.hullPoints.sort((t=this.pivot,(e,i)=>{if(e==i)return 0;if(null==e)return-1;if(null==i)return 1;switch(E.getTriangleOrientationWithIntersectionEpsilon(t,e.point,i.point)){case s.Counterclockwise:return-1;case s.Clockwise:return 1;case s.Collinear:const n=e.point.x-t.x,r=i.point.x-t.x;if(n>y.distanceEpsilon&&r<-1*y.distanceEpsilon)return-1;if(n<-1*y.distanceEpsilon&&r>y.distanceEpsilon)return 1;const o=e.point.sub(t),a=i.point.sub(t),l=o.l1-a.l1;return l<0?(e.deleted=!0,-1):l>0?(i.deleted=!0,1):(e.stamp>i.stamp?e.deleted=!0:i.deleted=!0,0)}throw new Error}))}static createConvexHullAsClosedPolyline(t){return k.mkClosedFromPoints(Array.from(Ni.CalculateConvexHull(t)))}}function ki(t,e,i){t.irect.intersects_rect(e.irect)&&(null==t.Left?null==e.Left?i(t.UserData,e.UserData):(ki(t,e.Left,i),ki(t,e.Right,i)):null!=e.Left?(ki(t.Left,e.Left,i),ki(t.Left,e.Right,i),ki(t.Right,e.Left,i),ki(t.Right,e.Right,i)):(ki(t.Left,e,i),ki(t.Right,e,i)))}function Vi(t,e,i){t.irect.intersects_rect(e.irect)&&(t==e?function(t,e){if(null==t.Left)return;Vi(t.Left,t.Left,e),Vi(t.Left,t.Right,e),Vi(t.Right,t.Right,e)}(t,i):null==t.Left?null==e.Left?i(t.UserData,e.UserData):(Vi(t,e.Left,i),Vi(t,e.Right,i)):null!=e.Left?(Vi(t.Left,e.Left,i),Vi(t.Left,e.Right,i),Vi(t.Right,e.Left,i),Vi(t.Right,e.Right,i)):(Vi(t.Left,e,i),Vi(t.Right,e,i)))}function Gi(t,e,i){if(!t.irect.intersects_rect(e.irect))return!1;if(t==e)return function(t,e){return null!=t.Left&&(Gi(t.Left,t.Left,e)||Gi(t.Left,t.Right,e)||Gi(t.Right,t.Right,e))}(t,i);if(null==t.Left){if(null==e.Left)return i(t.UserData,e.UserData);if(Gi(t,e.Left,i))return!0;if(Gi(t,e.Right,i))return!0}else if(null!=e.Left){if(Gi(t.Left,e.Left,i))return!0;if(Gi(t.Left,e.Right,i))return!0;if(Gi(t.Right,e.Left,i))return!0;if(Gi(t.Right,e.Right,i))return!0}else{if(Gi(t.Left,e,i))return!0;if(Gi(t.Right,e,i))return!0}return!1}!function(t){t[t.Increasing=0]="Increasing",t[t.Decreasing=1]="Decreasing",t[t.Extremum=2]="Extremum"}(je||(je={}));class zi{constructor(t,e){this.f=t,this.length=e}get Sequence(){return this.f}set Sequence(t){this.f=t}get Length(){return this.length}set Length(t){this.length=t}FindMinimum(){let t=0,e=this.length-1,i=t+Math.floor((e-t)/2);const n=this.f(i);if(n>=this.f(0)&&n>=this.f(this.length-1))return this.f(0)<this.f(this.length-1)?0:this.length-1;for(;e-t>1;)switch(i=t+Math.floor((e-t)/2),this.BehaviourAtIndex(i)){case je.Decreasing:t=i;break;case je.Increasing:e=i;break;case je.Extremum:return i}return t==e||this.f(t)<=this.f(e)?t:e}BehaviourAtIndex(t){const e=this.f(t);if(0==t){const t=this.f(1);return t==e?je.Extremum:t>e?je.Increasing:je.Decreasing}if(t==this.length-1){const t=this.f(this.length-2);return t==e?je.Extremum:t>e?je.Decreasing:je.Increasing}const i=e-this.f(t-1);return i*(this.f(t+1)-e)<=0?je.Extremum:i>0?je.Increasing:je.Decreasing}FindMaximum(){let t=0,e=this.length-1,i=t+Math.floor((e-t)/2);const n=this.f(i);if(n<=this.f(0)&&n<=this.f(this.length-1))return this.f(0)>this.f(this.length-1)?0:this.length-1;for(;e-t>1;)switch(i=t+Math.floor((e-t)/2),this.BehaviourAtIndex(i)){case je.Decreasing:e=i;break;case je.Increasing:t=i;break;case je.Extremum:return i}return t==e||this.f(t)>this.f(e)?t:e}}class ji{constructor(t,e){this.f=t,this.length=e}toArray(){const t=[];for(let e=0;e<this.length;e++)t.push(this.f(e));return t}GetAdjustedSequenceForMinimum(){const t=this.f(0),e=(this.f(this.length-1)-t)/(this.length-1);return i=>Math.min(this.f(i),t+e*i)}GetAdjustedSequenceForMaximum(){const t=this.f(0),e=(this.f(this.length-1)-t)/(this.length-1);return i=>Math.max(this.f(i),t+e*i)}FindMinimum(){return this.f(0)==this.f(this.length-1)?new zi(this.f,this.length).FindMinimum():new zi(this.GetAdjustedSequenceForMinimum(),this.length).FindMinimum()}FindMaximum(){return this.f(0)==this.f(this.length-1)?new zi(this.f,this.length).FindMaximum():new zi(this.GetAdjustedSequenceForMaximum(),this.length).FindMaximum()}}class Ui{constructor(t,e){this.P=t,this.Q=e}LeftFromLineOnP(t,e,i){const n=this.P.pnt(t);return this.upperBranchOnP?E.pointToTheLeftOfLineOrOnLine(i,n,e):E.pointToTheRightOfLineOrOnLine(i,n,e)}LeftFromLineOnQ(t,e,i){const n=this.Q.pnt(t);return this.lowerBranchOnQ?E.pointToTheLeftOfLineOrOnLine(i,n,e):E.pointToTheRightOfLineOrOnLine(i,n,e)}PrevOnP(t){return this.upperBranchOnP?this.P.Prev(t):this.P.Next(t)}PrevOnQ(t){return this.lowerBranchOnQ?this.Q.Prev(t):this.Q.Next(t)}NextOnP(t){return this.upperBranchOnP?this.P.Next(t):this.P.Prev(t)}NextOnQ(t){return this.lowerBranchOnQ?this.Q.Next(t):this.Q.Prev(t)}MedianOnP(t,e){return this.upperBranchOnP?this.P.Median(t,e):this.P.Median(e,t)}MedianOnQ(t,e){return this.lowerBranchOnQ?this.Q.Median(t,e):this.Q.Median(e,t)}ModuleP(t,e){return this.upperBranchOnP?this.P.Module(e-t):this.P.Module(t-e)}ModuleQ(t,e){return this.lowerBranchOnQ?this.Q.Module(e-t):this.Q.Module(t-e)}TangentBetweenBranches(t,e,i,n){for(;e!=t||n!=i;){const r=e!=t?this.MedianOnP(t,e):t,s=n!=i?this.MedianOnQ(i,n):i,o=this.P.pnt(r),a=this.Q.pnt(s);let l=!0;this.ModuleP(t,e)>1?this.LeftFromLineOnP(this.NextOnP(r),o,a)?t=r:this.LeftFromLineOnP(this.PrevOnP(r),o,a)?e=r:l=!1:e!=t?this.LeftFromLineOnP(e,this.P.pnt(t),a)?t=e:this.LeftFromLineOnP(t,this.P.pnt(e),a)?e=t:l=!1:l=!1;let h=!0;this.ModuleQ(i,n)>1?this.LeftFromLineOnQ(this.NextOnQ(s),a,o)?i=s:this.LeftFromLineOnQ(this.PrevOnQ(s),a,o)?n=s:h=!1:n!=i?this.LeftFromLineOnQ(n,this.Q.pnt(i),o)?i=n:this.LeftFromLineOnQ(i,this.Q.pnt(n),o)?n=i:h=!1:h=!1,l||h||(t=r,e=r,i=s,n=s)}return[t,n]}FindDividingBisector(t){const e={pClosest:void 0,qClosest:void 0,p1:void 0,p2:void 0,q1:void 0,q2:void 0};this.FindClosestFeatures(e),t.bisectorPivot=E.middle(e.pClosest,e.qClosest),t.bisectorRay=e.pClosest.add(e.qClosest).rotate(Math.PI/2)}FindClosestPoints(){const t={q2:void 0,p1:void 0,p2:void 0,q1:void 0,pClosest:void 0,qClosest:void 0};return this.FindClosestFeatures(t),{pClosest:t.pClosest,qClosest:t.qClosest}}FindClosestFeatures(t){const e={leftTangentPoint:void 0,rightTangentPoint:void 0};this.P.GetTangentPoints(e,this.Q.pp(0).point),t.p2=e.leftTangentPoint,t.p1=e.rightTangentPoint,t.p2==t.p1&&(t.p2+=this.P.count),this.Q.GetTangentPoints(e,this.P.pp(0).point),t.q1=e.leftTangentPoint,t.q2=e.rightTangentPoint,t.q2==t.q1&&(t.q2+=this.Q.count),this.FindClosestPoints_(t)}FindClosestPoints_(t){for(;this.ChunksAreLong(t.p2,t.p1,t.q2,t.q1);)this.ShrinkChunks(t);t.p1==t.p2?(t.pClosest=this.P.pp(t.p2).point,t.q1==t.q2?t.qClosest=this.Q.pp(t.q1).point:(t.qClosest=E.ClosestPointAtLineSegment(t.pClosest,this.Q.pp(t.q1).point,this.Q.pp(t.q2).point),E.closeDistEps(t.qClosest,this.Q.pnt(t.q1))?t.q2=t.q1:E.closeDistEps(t.qClosest,this.Q.pnt(t.q2))&&(t.q1=t.q2))):(t.qClosest=this.Q.pp(t.q1).point,t.pClosest=E.ClosestPointAtLineSegment(t.qClosest,this.P.pp(t.p1).point,this.P.pp(t.p2).point),E.closeDistEps(t.pClosest,this.P.pnt(t.p1))?t.p2=t.p1:E.closeDistEps(t.qClosest,this.P.pnt(t.p2))&&(t.p1=t.p2))}ChunksAreLong(t,e,i,n){const r=this.P.Module(t-e)+1;if(r>2)return!0;const s=this.Q.Module(n-i)+1;return s>2||2==r&&2==s}ShrinkChunks(t){const e=t.p1==t.p2?t.p1:this.P.Median(t.p1,t.p2),i=t.q1==t.q2?t.q1:this.Q.Median(t.q2,t.q1),n=this.P.pp(e).point,r=this.Q.pp(i).point,s={a1:void 0,a2:void 0,b1:void 0,b2:void 0};if(this.GetAnglesAtTheMedian(e,i,n,r,s),!this.InternalCut(t,e,i,s.a1,s.a2,s.b1,s.b2)&&!Ui.OneOfChunksContainsOnlyOneVertex(t,e,i,s.a1,s.b1)&&!this.OnlyOneChunkContainsExactlyTwoVertices(t,{mp:e,mq:i},s))if(t.p2!=this.P.Next(t.p1)||t.q1!=this.Q.Next(t.q2))s.a1<=Math.PI&&s.a2<=Math.PI&&s.b1<=Math.PI&&s.b2<=Math.PI?s.a1+s.b1>Math.PI?s.a1>=Math.PI/2?t.p1=e:t.q1=i:s.a2>=Math.PI/2?t.p2=e:t.q2=i:s.a1>Math.PI?t.p1=e:s.a2>Math.PI?t.p2=e:s.b1>Math.PI?t.q1=i:t.q2=i;else{const e=I.minDistBetweenLineSegments(this.P.pnt(t.p1),this.P.pnt(t.p2),this.Q.pnt(t.q1),this.Q.pnt(t.q2));0==e.parab?t.p2=t.p1:1==e.parab?t.p1=t.p2:0==e.parcd?t.q2=t.q1:1==e.parcd&&(t.q1=t.q2)}}InternalCut(t,e,i,n,r,s,o){let a=!1;if(n>=Math.PI&&r>=Math.PI){const n=this.P.pp(e).point,r=this.Q.pp(i).point,s=this.P.pp(this.P.Next(e)).point;E.getTriangleOrientation(n,r,this.Q.pp(0).point)==E.getTriangleOrientation(n,r,s)?t.p1=this.P.Next(e):t.p2=this.P.Prev(e),a=!0}if(s>=Math.PI&&o>=Math.PI){const n=this.P.pp(e).point,r=this.Q.pp(i).point,s=this.Q.pp(this.Q.Next(i)).point;E.getTriangleOrientation(n,r,this.P.pp(0).point)==E.getTriangleOrientation(n,r,s)?t.q2=this.Q.Next(i):t.q1=this.Q.Prev(i),a=!0}return a}GetAnglesAtTheMedian(t,e,i,n,r){r.a1=E.anglePCP(n,i,this.P.pnt(this.P.Prev(t))),r.a2=E.anglePCP(this.P.pnt(this.P.Next(t)),i,n),r.b1=E.anglePCP(this.Q.pnt(this.Q.Next(e)),n,i),r.b2=E.anglePCP(i,n,this.Q.pnt(this.Q.Prev(e)))}OnlyOneChunkContainsExactlyTwoVertices(t,e,i){const n=t.p2==this.P.Next(t.p1),r=t.q1==this.Q.Next(t.q2);return n&&!r?(this.ProcessShortSide(t,e.mp,e.mq,i.a1,i.b1,i.a2,i.b2),!0):!(!r||n)&&(this.SwapEverything(t,e,i),this.ProcessShortSide(t,e.mp,e.mq,i.a1,i.b1,i.a2,i.b2),this.SwapEverything(t,e,i),!0)}SwapEverything(t,e,i){this.SwapPq();let n=t.p2;t.p2=t.q1,t.q1=n,n=t.q2,t.q2=t.p1,t.p1=n,n=e.mq,e.mq=e.mp,e.mp=n,n=i.a2,i.a2=i.b1,i.b1=n,n=i.b2,i.b2=i.a1,i.a1=n}ProcessShortSide(t,e,i,n,r,s,o){e==t.p2?this.ProcessSide(t,i,n,r,o):s<=Math.PI?s+o>=Math.PI?s>=Math.PI/2?t.p2=t.p1:t.q2=i:r>=Math.PI/2?t.q1=i:s<o&&(E.canProject(this.Q.pnt(i),this.P.pp(t.p1).point,this.P.pp(t.p2).point)?t.q1=i:t.p1=t.p2):n+r<=Math.PI?t.p1=t.p2:t.p2=t.p1}SwapPq(){const t=this.P;this.P=this.Q,this.Q=t}ProcessSide(t,e,i,n,r){const s=this.Q.pnt(e);i<=Math.PI?i+n>=Math.PI?i>=Math.PI/2?t.p1=t.p2:t.q1=e:r>=Math.PI/2?t.q2=e:i<r&&(E.canProject(s,this.P.pp(t.p1).point,this.P.pp(t.p2).point)?t.q2=e:t.p2=t.p1):(t.p2=t.p1,n>=Math.PI?t.q1=e:r>=Math.PI&&(t.q2=e))}static OneOfChunksContainsOnlyOneVertex(t,e,i,n,r){return t.p1==t.p2?(r>=Math.PI/2?t.q1=i:t.q2=i,!0):t.q1==t.q2&&(n>=Math.PI/2?t.p1=e:t.p2=e,!0)}CalculateLeftTangents(){let t;this.FindDividingBisector(t);const e=this.P.FindTheFurthestVertexFromBisector(t.p1,t.p2,t.bisectorPivot,t.bisectorRay),i=this.Q.FindTheFurthestVertexFromBisector(t.q2,t.q1,t.bisectorPivot,t.bisectorRay);this.upperBranchOnP=!1,this.lowerBranchOnQ=!0,this.leftPLeftQ=this.TangentBetweenBranches(e,t.p1,i,t.q1),this.lowerBranchOnQ=!1,this.leftPRightQ=this.TangentBetweenBranches(e,t.p1,i,t.q2)}CalculateRightTangents(){let t;this.FindDividingBisector(t);const e=this.P.FindTheFurthestVertexFromBisector(t.p1,t.p2,t.bisectorPivot,t.bisectorRay),i=this.Q.FindTheFurthestVertexFromBisector(t.q2,t.q1,t.bisectorPivot,t.bisectorRay);this.upperBranchOnP=!0,this.lowerBranchOnQ=!0,this.rightPLeftQ=this.TangentBetweenBranches(e,t.p2,i,t.q1),this.lowerBranchOnQ=!1,this.rightPRightQ=this.TangentBetweenBranches(e,t.p2,i,t.q2)}}class Wi{constructor(t){this.polyline=t,this.points=new Array;for(let t=this.polyline.startPoint;t;t=t.next)this.points.push(t)}static mkFromPoints(t){return new Wi(k.mkClosedFromPoints(t))}get Polyline(){return this.polyline}Next(t){return this.Module(t+1)}Prev(t){return this.Module(t-1)}get count(){return this.Polyline.count}Module(t){return t<0?t+this.count:t<this.count?t:t-this.count}pp(t){return this.points[this.Module(t)]}pnt(t){return this.pp(t).point}toString(){return this.polyline.toString()}Median(t,e){return e>t?Math.floor((e+t)/2):this.Module(e+Math.floor((this.count+t)/2))}FindTheFurthestVertexFromBisector(t,e,i,n){let r=n.rotate(Math.PI/2);this.polyline.startPoint.point.sub(i).dot(r)<0&&(r=r.mul(-1)),t==e&&(e=this.Next(t));do{const i=this.Median(e,t),n=this.pnt(i);this.pnt(this.Next(i)).sub(n).dot(r)>=0?e=this.Next(i):this.pnt(this.Prev(i)).sub(n).dot(r)>=0?t=this.Prev(i):e=i,t=i}while(t!=e);return t}static TestPolygonDist(t,e){let i=Number.MAX_SAFE_INTEGER;for(let n=0;n<t.count;n++)for(let r=0;r<e.count;r++){const s=I.minDistBetweenLineSegments(t.pnt(n),t.pnt(n+1),e.pnt(r),e.pnt(r+1));i=Math.min(i,s.dist)}return i}static Distance(t,e){const i=new Ui(t,e).FindClosestPoints();return{p:i.pClosest,q:i.qClosest,dist:i.pClosest.sub(i.qClosest).length}}static DistanceOnly(t,e){return Wi.Distance(t,e).dist}static PolygonIsLegalDebug(t){for(let e=t.Polyline.startPoint;null!=e.next&&null!=e.next.next;e=e.next)if(E.getTriangleOrientation(e.point,e.next.point,e.next.next.point)==s.Collinear)return!1;return!0}static DistancePoint(t,e){let i=Number.MAX_VALUE;for(let n=0;n<t.count;n++){const r=E.distToLineSegment(e,t.points[n].point,t.points[(n+1)%t.count].point).dist;i=Math.min(i,r)}return i}GetTangentPoints(t,e){const i=new ji(this.GetSequenceDelegate(e),this.count);t.leftTangentPoint=i.FindMaximum(),t.rightTangentPoint=i.FindMinimum()}GetSequenceDelegate(t){const e=this.pnt(0);return i=>{const n=E.anglePCP(e,t,this.pnt(i));return n<Math.PI?n:n-2*Math.PI}}}class Hi{constructor(t,e,i,n){this.Obstacles=t,this.TightPadding=e,this.LoosePadding=i,this.IgnoreTightPadding=n}ObstaclesIntersectLine(t,e){return this.ObstaclesIntersectICurve(I.mkPP(t,e))}static PadCorner(t,e,i,n,r){const s=Hi.GetPaddedCorner(e,i,n,r);return-1!=s.numberOfPoints&&(t.addPoint(s.a),2==s.numberOfPoints&&t.addPoint(s.b),!0)}static CurveIsClockwise(t,e){return E.getTriangleOrientation(e,t.start,t.start.add(t.derivative(t.parStart)))==s.Clockwise}static PaddedPolylineBoundaryOfNode(t,e){return Hi.CreatePaddedPolyline(F.polylineAroundClosedCurve(t),e)}static LoosePolylineWithFewCorners(t,e){return e<y.distanceEpsilon?t:Hi.CreateLoosePolylineOnBisectors(t,e)}static CreateLoosePolylineOnBisectors(t,e){return k.mkClosedFromPoints(Ni.CalculateConvexHull(Hi.BisectorPoints(t,e)))}static CreateRectNodeOfPolyline(t){return ut(t,t.boundingBox)}CreateLooseObstacles(){this.tightPolylinesToLooseDistances=new Map,this.LooseObstacles=new Array;for(const t of this.TightObstacles){const e=Hi.FindMaxPaddingForTightPolyline(this.RootOfTightHierarchy,t,this.LoosePadding);this.tightPolylinesToLooseDistances.set(t,e),this.LooseObstacles.push(Hi.LoosePolylineWithFewCorners(t,e))}this.RootOfLooseHierarchy=Hi.CalculateHierarchy(this.LooseObstacles)}CreateTightObstacles(){this.RootOfTightHierarchy=Hi.CreateTightObstacles_(this.Obstacles,this.TightPadding,this.TightObstacles),this.OverlapsDetected=this.TightObstacles.size<this.Obstacles.length}Calculate(){this.ignoreTightPadding?this.CreateTightObstaclesIgnoringTightPadding():this.CreateTightObstacles(),this.IsEmpty()||this.CreateLooseObstacles()}IsEmpty(){return null==this.TightObstacles||0==this.TightObstacles.size}ObstaclesIntersectICurve(t){const e=t.boundingBox;return Hi.CurveIntersectsRectangleNode(t,e,this.RootOfTightHierarchy)}static CurveIntersectsRectangleNode(t,e,i){if(!i.irect.intersects(e))return!1;if(null!=i.UserData){const e=i.UserData;return null!=F.intersectionOne(e,t,!1)||Hi.PointIsInside(e.start,t)}return Hi.CurveIntersectsRectangleNode(t,e,i.Left)||Hi.CurveIntersectsRectangleNode(t,e,i.Right)}static PointIsInside(t,e){return F.PointRelativeToCurveLocation(t,e)==a.Inside}CreateTightObstaclesIgnoringTightPadding(){const t=this.Obstacles.map(t=>F.polylineAroundClosedCurve(t)),e=Hi.CalculateHierarchy(t),i=Hi.GetOverlappedPairSet(e);if(this.TightObstacles=new Set,0==i.size){for(const i of t){const t=Hi.FindMaxPaddingForTightPolyline(e,i,this.TightPadding);this.TightObstacles.add(Hi.LoosePolylineWithFewCorners(i,t))}this.RootOfTightHierarchy=Hi.CalculateHierarchy(Array.from(this.TightObstacles))}else{for(const e of t)this.TightObstacles.add(Hi.CreatePaddedPolyline(e,this.TightPadding));if(!this.IsEmpty())for(this.RootOfTightHierarchy=Hi.CalculateHierarchy(Array.from(this.TightObstacles)),this.OverlapsDetected=!1;Hi.GetOverlappedPairSet(this.RootOfTightHierarchy).size>0;)this.RootOfTightHierarchy=Hi.ReplaceTightObstaclesWithConvexHulls(this.TightObstacles,Array.from(i)),this.OverlapsDetected=!0}}static CreateTightObstacles_(t,e,i){if(0==t.length)return null;for(const n of t)Hi.CalculateTightPolyline(i,e,n);return Hi.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(i)}static CalculateTightPolyline(t,e,i){const n=Hi.PaddedPolylineBoundaryOfNode(i,e);t.add(n)}static CalculateHierarchy(t){return ot(t.map(t=>Hi.CreateRectNodeOfPolyline(t)))}static RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(t){let e,i=Hi.CalculateHierarchy(Array.from(t));for(;(e=Hi.GetOverlappedPairSet(i)).size>0;)i=Hi.ReplaceTightObstaclesWithConvexHulls(t,Array.from(e));return i}static MapToInt(t){const e=new Map;for(let i=0;i<t.length;i++)e.set(t[i],i);return e}static ReplaceTightObstaclesWithConvexHulls(t,e){const i=new Set;for(const t of e)i.add(t[0]),i.add(t[1]);const n=Array.from(i),r=Hi.MapToInt(n),s=Ft(vt(Array.from(e).map(t=>new wt(r.get(t[0]),r.get(t[1])))));for(const e of s){const i=e.map(t=>n[t]),r=be(i,t=>Array.from(t)),s=Ni.createConvexHullAsClosedPolyline(r);for(const e of i)t.delete(e);t.add(s)}return Hi.CalculateHierarchy(Array.from(t))}static OneCurveLiesInsideOfOther(t,e){return F.PointRelativeToCurveLocation(t.start,e)!=a.Outside||F.PointRelativeToCurveLocation(e.start,t)!=a.Outside}static PolylinesIntersect(t,e){return F.CurvesIntersect(t,e)||Hi.OneCurveLiesInsideOfOther(t,e)}static GetOverlappedPairSet(t){const e=new Set;return Vi(t,t,(t,i)=>{Hi.PolylinesIntersect(t,i)&&e.add([t,i])}),e}static BisectorPoints(t,e){const i=new Array;for(let n=t.startPoint;null!=n;n=n.next){const t={skip:!1},r=Hi.GetStickingVertexOnBisector(n,e,t);t.skip||i.push(r)}return i}static GetStickingVertexOnBisector(t,e,i){const n=t.polyline.prev(t).point,r=t.point,s=t.polyline.next(t).point;let o=r.sub(n).normalize().add(r.sub(s).normalize());const a=o.length;return a<y.tolerance?i.skip=!0:(i.skip=!1,o=o.div(a)),o.mul(e).add(r)}static FindMaxPaddingForTightPolyline(t,e,i){let n=i;const r=new Wi(e),s=e.boundingBox.clone();s.pad(2*i);for(const i of Array.from(t.GetNodeItemsIntersectingRectangle(s)).filter(t=>t!=e)){const t=Wi.Distance(r,new Wi(i)).dist;n=Math.min(n,t/Hi.LooseDistCoefficient)}return n}static GetPaddedCorner(t,e,i,n){const r=t.point,o=e.point,a=i.point;if(E.getTriangleOrientation(r,o,a)==s.Counterclockwise)return{a:void 0,b:void 0,numberOfPoints:-1};let l=o.sub(r).rotate(Math.PI/2).normalize();if(Hi.CornerIsNotTooSharp(r,o,a)){l=l.mul(n);const t=a.sub(o).normalize().mul(n).rotate(Math.PI/2),e=E.lineLineIntersection(r.add(l),o.add(l),o.add(t),a.add(t));return{a:e,b:e,numberOfPoints:1}}const h=o.sub(r).normalize().add(o.sub(a).normalize());if(h.length<y.intersectionEpsilon){const t=o.add(l.mul(n));return{a:t,b:t,numberOfPoints:1}}const u=h.normalize().mul(n),c=u.rotate(Math.PI/2),d=(n-u.dot(l))/c.dot(l),g=c.mul(d);return{a:u.add(g).add(o),b:u.sub(g).add(o),numberOfPoints:2}}static CornerIsNotTooSharp(t,e,i){const n=t.sub(e).rotate(Math.PI/4).add(e);return E.getTriangleOrientation(e,n,i)==s.Counterclockwise}static CreatePaddedPolyline(t,e){const i=new k;if(!Hi.PadCorner(i,t.endPoint.prev,t.endPoint,t.startPoint,e))return Hi.CreatePaddedPolyline(k.mkClosedFromPoints(Array.from(Ni.CalculateConvexHull(t))),e);if(!Hi.PadCorner(i,t.endPoint,t.startPoint,t.startPoint.next,e))return Hi.CreatePaddedPolyline(k.mkClosedFromPoints(Array.from(Ni.CalculateConvexHull(t))),e);for(let n=t.startPoint;null!=n.next.next;n=n.next)if(!Hi.PadCorner(i,n,n.next,n.next.next,e))return Hi.CreatePaddedPolyline(k.mkClosedFromPoints(Array.from(Ni.CalculateConvexHull(t))),e);return i.closed=!0,i}}Hi.LooseDistCoefficient=2.1;class qi{get TightPolyline(){return this.tightPoly}set TightPolyline(t){this.tightPoly=t}static mk(t,e,i){const n=new qi;return n.TightPolyline=t,n.LooseShape=e,n.Distance=i,n}toString(){return(null==this.TightPolyline?"null":this.TightPolyline.toString().substring(0,5))+","+(null==this.LooseShape?"null":this.LooseShape.toString().substring(0,5))}}class Xi{constructor(t,e,i,n){this.MainShape=t,this.TightPadding=e,this.LoosePadding=i,this.ShapesToTightLooseCouples=n}Calculate(){0!=this.MainShape.Children.length&&(this.CreateTightObstacles(),this.CreateTigthLooseCouples(),this.FillTheMapOfShapeToTightLooseCouples())}FillTheMapOfShapeToTightLooseCouples(){ki(ot(this.MainShape.Children.map(t=>ut(t,t.BoundingBox))),this.coupleHierarchy,this.TryMapShapeToTightLooseCouple.bind(this))}TryMapShapeToTightLooseCouple(t,e){Xi.ShapeIsInsideOfPoly(t,e.TightPolyline)&&this.ShapesToTightLooseCouples.set(t,e)}static ShapeIsInsideOfPoly(t,e){return F.PointRelativeToCurveLocation(t.BoundaryCurve.start,e)==a.Inside}CreateTigthLooseCouples(){const t=new Array;for(const e of this.tightHierarchy.GetAllLeaves()){const i=Hi.FindMaxPaddingForTightPolyline(this.tightHierarchy,e,this.LoosePadding),n=Hi.LoosePolylineWithFewCorners(e,i);t.push(qi.mk(e,new Ze(n),i))}this.coupleHierarchy=ot(t.map(t=>ut(t,t.TightPolyline.boundingBox)))}CreateTightObstacles(){const t=new Set(this.MainShape.Children.map(this.InitialTightPolyline.bind(this))),e=t.size;this.tightHierarchy=Hi.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(t),this.OverlapsDetected=e>t.size}InitialTightPolyline(t){const e=Hi.PaddedPolylineBoundaryOfNode(t.BoundaryCurve,this.TightPadding),i=be(this.LoosePolylinesUnderShape(t),t=>Array.from(t)).filter(t=>F.PointRelativeToCurveLocation(t,e)==a.Outside);if(i.length<=0)return e;const n=Array.from(e).concat(i);return k.mkClosedFromPoints(Ni.CalculateConvexHull(n))}LoosePolylinesUnderShape(t){return t.Children.map(t=>this.ShapesToTightLooseCouples.get(t).LooseShape.BoundaryCurve)}}class Yi{constructor(t,e,i){this.indexToA=t,this.priority=e,this.v=i}}class Qi{constructor(t=b){this.heapSize=0,this.compare=t,this.cache=new Map,this.A=[]}get count(){return this.heapSize}ContainsElement(t){return this.cache.has(t)}SwapWithParent(t){const e=this.A[t>>1];this.PutAtI(t>>1,this.A[t]),this.PutAtI(t,e)}Enqueue(t,e){let i=++this.heapSize;const n=new Yi(i,e,t);for(this.cache.set(t,n),this.A[i]=n;i>1&&this.compare(this.A[i>>1].priority,e)>0;)this.SwapWithParent(i),i>>=1}IsEmpty(){return 0==this.heapSize}PutAtI(t,e){this.A[t]=e,e.indexToA=t}Dequeue(){if(0==this.heapSize)throw new Error("dequeue on an empty queue");const t=this.A[1].v;return this.MoveQueueOneStepForward(t),t}DequeueAndGetPriority(t){if(0==this.heapSize)throw new Error("dequeue on an empty queue");const e=this.A[1].v;return t.priority=this.A[1].priority,this.MoveQueueOneStepForward(e),e}MoveQueueOneStepForward(t){this.cache.delete(t),this.PutAtI(1,this.A[this.heapSize]);let e=1;for(;;){let t=e;const i=e<<1;i<=this.heapSize&&this.compare(this.A[i].priority,this.A[e].priority)<0&&(t=i);const n=i+1;if(n<=this.heapSize&&this.compare(this.A[n].priority,this.A[t].priority)<0&&(t=n),t==e)break;this.SwapWithParent(t),e=t}this.heapSize--}DecreasePriority(t,e){const i=this.cache.get(t);if(!i)return;i.priority=e;let n=i.indexToA;for(;n>1&&this.compare(this.A[n].priority,this.A[n>>1].priority)<0;)this.SwapWithParent(n),n>>=1}*GetEnumerator(){for(let t=1;t<=this.heapSize;t++)yield this.A[t].v}Peek(t){if(0!=this.count)return t.priority=this.A[1].priority,this.A[1].v;t.priority=0}toString(){const t=new _t.StringBuilder;for(const e of this.A)t.Append(e+",");return t.ToString()}}class Zi{constructor(t,e,i){this.upperBound=Number.POSITIVE_INFINITY,this._visGraph=i,this._visGraph.ClearPrevEdgesTable();for(const t of i.Vertices())t.Distance=Number.POSITIVE_INFINITY;this.source=t,this.targets=new Set(e),this.source.Distance=0}GetPath(){const t=new Qi(b);for(this.source.Distance=0,t.Enqueue(this.source,0);!t.IsEmpty()&&(this.current=t.Dequeue(),!this.targets.has(this.current));){for(const e of this.current.OutEdges)this.PassableOutEdge(e)&&this.ProcessNeighbor(t,e,e.Target);for(const e of this.current.InEdges)this.PassableInEdge(e)&&this.ProcessNeighbor(t,e,e.Source)}return null==this._visGraph.PreviosVertex(this.current)?null:this.CalculatePath()}PassableOutEdge(t){return t.Source==this.source||this.targets.has(t.Target)||!Zi.IsForbidden(t)}PassableInEdge(t){return this.targets.has(t.Source)||t.Target==this.source||!Zi.IsForbidden(t)}static IsForbidden(t){return null!=t.IsPassable&&!t.IsPassable()||t instanceof ui}ProcessNeighbor(t,e,i){const n=e.Length,r=this.current.Distance+n;r>=this.upperBound||(this.targets.has(i)&&(this.upperBound=r,this.closestTarget=i),i!=this.source&&null==this._visGraph.PreviosVertex(i)?(i.Distance=r,this._visGraph.SetPreviousEdge(i,e),t.Enqueue(i,r)):r<i.Distance&&(i.Distance=r,this._visGraph.SetPreviousEdge(i,e),t.DecreasePriority(i,r)))}CalculatePath(){if(null==this.closestTarget)return null;const t=new Array;let e=this.closestTarget;do{t.push(e),e=this._visGraph.PreviosVertex(e)}while(e!=this.source);return t.push(this.source),t.reverse()}}class Ki{constructor(t,e,i){this._lengthMultiplier=1,this._lengthMultiplierForAStar=1,this._visGraph=t,this._source=e,this._target=i,this._source.Distance=0}get LengthMultiplier(){return this._lengthMultiplier}set LengthMultiplier(t){this._lengthMultiplier=t}get LengthMultiplierForAStar(){return this._lengthMultiplierForAStar}set LengthMultiplierForAStar(t){this._lengthMultiplierForAStar=t}GetPath(t){const e=new Qi(b);for(this._source.Distance=0,this._target.Distance=Number.POSITIVE_INFINITY,e.Enqueue(this._source,this.H(this._source));!e.IsEmpty();){const t={priority:0},i=e.DequeueAndGetPriority(t);if(t.priority>=this._target.Distance)break;for(const t of i.OutEdges)if(this.PassableOutEdge(t)){const n=t.Target;this.ProcessNeighbor(e,i,t,n)}for(const t of i.InEdges)if(this.PassableInEdge(t)){const n=t.Source;this.ProcessNeighbor(e,i,t,n)}}return null==this._visGraph.PreviosVertex(this._target)?null:this.CalculatePath(t)}PassableOutEdge(t){return t.Source==this._source||t.Target==this._target||!Ki.IsForbidden(t)}PassableInEdge(t){return t.Source==this._target||t.Target==this._source||!Ki.IsForbidden(t)}static IsForbidden(t){return null!=t.IsPassable&&!t.IsPassable()||t instanceof ui}ProcessNeighborN(t,e,i,n,r){const s=i.Length+r,o=e.Distance+s;n!=this._source&&null==this._visGraph.PreviosVertex(n)?(n.Distance=o,this._visGraph.SetPreviousEdge(n,i),n!=this._target&&t.Enqueue(n,this.H(n))):n!=this._source&&o<n.Distance&&(n.Distance=o,this._visGraph.SetPreviousEdge(n,i),n!=this._target&&t.DecreasePriority(n,this.H(n)))}ProcessNeighbor(t,e,i,n){const r=i.Length,s=e.Distance+r;n!=this._source&&null==this._visGraph.PreviosVertex(n)?(n.Distance=s,this._visGraph.SetPreviousEdge(n,i),n!=this._target&&t.Enqueue(n,this.H(n))):n!=this._source&&s<n.Distance&&(n.Distance=s,this._visGraph.SetPreviousEdge(n,i),n!=this._target&&t.DecreasePriority(n,this.H(n)))}H(t){return t.Distance+t.point.sub(this._target.point).length*this.LengthMultiplierForAStar}CalculatePath(t){const e=new Array;let i=this._target;do{e.push(i),t&&this._visGraph.ShrinkLengthOfPrevEdge(i,this.LengthMultiplier),i=this._visGraph.PreviosVertex(i)}while(i!=this._source);return e.push(this._source),e.reverse()}}!function(t){t[t.Regular=0]="Regular",t[t.Tangent=1]="Tangent"}(Ue||(Ue={}));class $i{constructor(t,e){this.LeftTangent=t,this.RightTangent=e}toString(){return _t.String.Format("{0},{1}",this.Start,this.End)}get Start(){return this.leftTangent.End.point}get End(){return this.rightTangent.End.point}get LeftTangent(){return this.leftTangent}set LeftTangent(t){this.leftTangent=t}get RightTangent(){return this.rightTangent}set RightTangent(t){this.rightTangent=t}get RbNode(){return this.rbNode}set RbNode(t){this.rbNode=t}}class Ji{constructor(t,e){this.start=t,this.End=e}get Comp(){return this.comp}set Comp(t){this.comp=t}get IsHigh(){return!this.IsLow}get IsLow(){return this.lowTangent}set IsLow(t){this.lowTangent=t}get SeparatingPolygons(){return this.separatingPolygons}set SeparatingPolygons(t){this.separatingPolygons=t}get Diagonal(){return this.diagonal}set Diagonal(t){this.diagonal=t}get Start(){return this.start}set Start(t){this.start=t}get End(){return this.end}set End(t){this.end=t}toString(){return _t.String.Format("{0},{1}",this.Start,this.End)}}class tn{get PointOnTangentAndInsertedDiagonal(){return this.pointOnTheRay}set PointOnTangentAndInsertedDiagonal(t){this.pointOnTheRay=t}Compare(t,e){if(t.Start.equal(e.Start))return 0;switch(E.getTriangleOrientation(this.PointOnTangentAndInsertedDiagonal,e.Start,e.End)){case s.Counterclockwise:return-1;default:return 1}}static BelongsToTheDiagonal(t,e,i){return E.closeDistEps(t,E.ClosestPointAtLineSegment(t,e,i))}static IntersectDiagonalWithRay(t,e,i){const n=e.sub(t),r=i.Start,s=i.End,o=m.solve(s.x-r.x,-1*n.x,t.x-r.x,s.y-r.y,-1*n.y,t.y-r.y);return t.add(n.mul(o.y))}}class en{constructor(t){this.pivot=t}IComparer(t,e){if(t==e)return 0;if(null==t)return-1;if(null==e)return 1;const i=t.Start.point.sub(this.pivot),n=e.Start.point.sub(this.pivot);return en.CompareVectorsByAngleToXAxis(i,n)}static CompareVectorsByAngleToXAxis(t,e){return t.y>=0?e.y<0?-1:en.CompareVectorsPointingToTheSameYHalfPlane(t,e):e.y>=0?1:en.CompareVectorsPointingToTheSameYHalfPlane(t,e)}static CompareVectorsPointingToTheSameYHalfPlane(t,e){const i=t.x*e.y-t.y*e.x;if(i>y.tolerance)return-1;if(i<-y.tolerance)return 1;if(t.x>=0){if(e.x<0)return-1}else if(e.x>=0)return 1;let n=Math.abs(t.x)-Math.abs(e.x);return n<0?-1:n>0?1:(n=Math.abs(t.y)-Math.abs(e.y),n<0?-1:n>0?1:0)}}class nn extends K{constructor(t,e,i){super(null),this.activeDiagonalComparer=new tn,this.polygons=t,this.visibilityGraph=i,this.addedPolygons=e}run(){this.useLeftPTangents=!0,this.CalculateAndAddEdges(),this.useLeftPTangents=!1,this.CalculateAndAddEdges()}CalculateAndAddEdges(){for(const t of this.addedPolygons)this.CalculateVisibleTangentsFromPolygon(t);this.ProgressStep()}CalculateVisibleTangentsFromPolygon(t){this.currentPolygon=t,this.AllocateDataStructures(),this.OrganizeTangents(),this.InitActiveDiagonals(),this.Sweep()}AllocateDataStructures(){this.tangents=new Array,this.diagonals=new Array,this.activeDiagonalTree=new ei(this.activeDiagonalComparer.Compare.bind(this.activeDiagonalComparer))}Sweep(){if(!(this.tangents.length<2))for(let t=1;t<this.tangents.length;t++){const e=this.tangents[t];null!=e.Diagonal?(e.Diagonal.RbNode==this.activeDiagonalTree.treeMinimum()&&this.AddVisibleEdge(e),e.IsHigh&&this.RemoveDiagonalFromActiveNodes(e.Diagonal)):e.IsLow&&(this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal=e.End.point,this.InsertActiveDiagonal(new $i(e,e.Comp)),e.Diagonal.RbNode==this.activeDiagonalTree.treeMinimum()&&this.AddVisibleEdge(e))}}AddVisibleEdge(t){di.AddEdgeVV(rn(this.visibilityGraph,t.start),rn(this.visibilityGraph,t.End))}InitActiveDiagonals(){if(0==this.tangents.length)return;const t=this.tangents[0],e=t.start.point,i=t.End.point;for(const n of this.diagonals)if(nn.RayIntersectDiagonal(e,i,n)&&(this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal=tn.IntersectDiagonalWithRay(e,i,n),this.InsertActiveDiagonal(n)),t.Diagonal.RbNode==this.activeDiagonalTree.treeMinimum()&&this.AddVisibleEdge(t),0==t.IsLow){const e=t.Diagonal;this.RemoveDiagonalFromActiveNodes(e)}}RemoveDiagonalFromActiveNodes(t){const e=this.activeDiagonalTree.deleteSubTree(t.RbNode);null!=e&&null!=e.item&&(e.item.RbNode=e),t.LeftTangent.Diagonal=null,t.RightTangent.Diagonal=null}InsertActiveDiagonal(t){t.RbNode=this.activeDiagonalTree.insert(t),nn.MarkDiagonalAsActiveInTangents(t)}static MarkDiagonalAsActiveInTangents(t){t.LeftTangent.Diagonal=t,t.RightTangent.Diagonal=t}static RayIntersectDiagonal(t,e,i){const n=i.Start,r=i.End;return E.getTriangleOrientation(t,n,r)==s.Counterclockwise&&E.getTriangleOrientation(t,e,n)!=s.Counterclockwise&&E.getTriangleOrientation(t,e,r)!=s.Clockwise}static TangentComparison(t,e){return en.CompareVectorsByAngleToXAxis(t.End.point.sub(t.start.point),e.End.point.sub(e.start.point))}*AllObstacles(){for(const t of this.addedPolygons)yield t;for(const t of this.polygons)yield t}OrganizeTangents(){for(const t of this.AllObstacles())t!=this.currentPolygon&&this.ProcessPolygonQ(t);this.tangents.sort(nn.TangentComparison)}ProcessPolygonQ(t){const e=new Ui(this.currentPolygon,t);this.useLeftPTangents?e.CalculateLeftTangents():e.CalculateRightTangents();let i=this.useLeftPTangents?e.leftPLeftQ:e.rightPLeftQ;const n=new Ji(this.currentPolygon.pp(i[0]),t.pp(i[1]));n.IsLow=!0,n.SeparatingPolygons=!this.useLeftPTangents,i=this.useLeftPTangents?e.leftPRightQ:e.rightPRightQ;const r=new Ji(this.currentPolygon.pp(i[0]),t.pp(i[1]));r.IsLow=!1,r.SeparatingPolygons=this.useLeftPTangents,n.Comp=r,r.Comp=n,this.tangents.push(n),this.tangents.push(r),this.diagonals.push(new $i(n,r))}}function rn(t,e){return t.FindVertex(e.point)}class sn{get Pivot(){return this.pivot}set Pivot(t){this.pivot=t}get IntersectionOfTheRayAndInsertedEdge(){return this.pointOnTheRay}set IntersectionOfTheRayAndInsertedEdge(t){this.pointOnTheRay=t}Compare(t,e){switch(E.getTriangleOrientation(this.IntersectionOfTheRayAndInsertedEdge,e.point,e.nextOnPolyline.point)){case s.Counterclockwise:return-1;default:return 1}}IntersectionPointBelongsToTheInsertedEdge(t){const e=t.point.sub(this.IntersectionOfTheRayAndInsertedEdge),i=t.nextOnPolyline.point.sub(this.IntersectionOfTheRayAndInsertedEdge);return Math.abs(e.x*i.y-i.x*e.y)<y.distanceEpsilon}IntersectEdgeWithRayPPP(t,e,i){const n=m.solve(e.x-t.x,-i.x,this.Pivot.x-t.x,e.y-t.y,-i.y,this.Pivot.y-t.y);if(!(-y.tolerance<=n.x&&n.x<=1+y.tolerance))throw new Error;if(!n)throw new Error;return this.Pivot.add(i.mul(n.y))}IntersectEdgeWithRay(t,e){return this.IntersectEdgeWithRayPPP(t.point,t.nextOnPolyline.point,e)}static constructorPP(t,e){const i=new sn;return i.pivot=t,i.pointOnTheRay=e,i}}class on{constructor(t,e){this.start=t,this.end=e}get Start(){return this.start}set Start(t){this.start=t}get End(){return this.end}set End(t){this.end=t}*Sides(){let t=this.start;for(;t!=this.end;){const e=t;yield e,t=e.nextOnPolyline}}MoveStartClockwise(){return this.Start!=this.End&&(this.Start=this.Start.nextOnPolyline,!0)}toString(){return _t.String.Format("Stem({0},{1})",this.Start,this.End)}}class an{constructor(t,e,i,n){this.sideNodes=new Map,this.visibleBoundaries=new Map,this.sortedListOfPolypoints=new Array,this.holes=Array.from(t),this.visibilityGraph=e,this.q=i,this.qPolylinePoint=x.mkFromPoint(this.q),this.QVertex=this.visibilityGraph.AddVertexP(this.qPolylinePoint.point),this.visibilityKind=n;const r=new en(this.q);this.heapForSorting=new ii(r.IComparer.bind(r))}get QVertex(){return this.qV}set QVertex(t){this.qV=t}static CalculatePointVisibilityGraph(t,e,i,n){const r=e.FindVertex(i);if(null!=r)return r;const s=new an(t,e,i,n);return s.FillGraph(),s.QVertex}FillGraph(){this.ComputeHoleBoundariesPossiblyVisibleFromQ(),this.visibleBoundaries.size>0&&(this.SortSAndInitActiveSides(),this.Sweep())}SortSAndInitActiveSides(){this.InitHeapAndInsertActiveSides();for(let t=this.heapForSorting.GetMinimum();this.sortedListOfPolypoints.push(t.Start),t.MoveStartClockwise()?this.heapForSorting.ChangeMinimum(t):this.heapForSorting.Dequeue(),0!=this.heapForSorting.Count;t=this.heapForSorting.GetMinimum());}InitHeapAndInsertActiveSides(){for(const t of this.GetInitialVisibleBoundaryStemsAndInsertActiveSides())this.heapForSorting.Enqueue(t)}*GetInitialVisibleBoundaryStemsAndInsertActiveSides(){for(const[t,e]of this.visibleBoundaries){let i=!1;for(const n of e.Sides()){const r=n;if(r.point.y<this.q.y){if(n.nextOnPolyline.point.y>=this.q.y){const t=E.getTriangleOrientation(this.q,r.point,n.nextOnPolyline.point);if(t==s.Counterclockwise||t==s.Collinear){i=!0,yield new on(e.Start,n),yield new on(n.nextOnPolyline,e.End),this.RegisterActiveSide(n);break}}}else{if(r.point.y>this.q.y)break;if(n.point.x>=this.q.x){i=!0,yield new on(n,e.End),n!=e.Start&&(yield new on(e.Start,t.prev(r))),this.RegisterActiveSide(n);break}}}i||(yield e)}}RegisterActiveSide(t){this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge=this.activeEdgeComparer.IntersectEdgeWithRay(t,new E(1,0)),this.sideNodes.set(t,this.activeSidesTree.insert(t))}Sweep(){for(const t of this.sortedListOfPolypoints)this.SweepPolylinePoint(t)}SweepPolylinePoint(t){const e=an.GetIncomingSide(t),i=this.GetOutgoingSide(t);let n;if(this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge=t.point,n=this.sideNodes.get(e)){if(n==this.activeSidesTree.treeMinimum()&&this.AddEdge(t),null!=i)n.item=i,this.sideNodes.set(i,n);else{const t=this.activeSidesTree.deleteSubTree(n);null!=t&&null!=t.item&&this.sideNodes.set(t.item,t)}this.sideNodes.delete(e)}else{if(null==i)throw new Error;{let e;(e=this.sideNodes.get(i))||(e=this.activeSidesTree.insert(i),this.sideNodes.set(i,e),e==this.activeSidesTree.treeMinimum()&&this.AddEdge(t))}}}AddEdge(t){(this.visibilityKind==Ue.Regular||this.visibilityKind==Ue.Tangent&&an.LineTouchesPolygon(this.QVertex.point,t))&&this.visibilityGraph.AddEdgeF(this.QVertex.point,t.point,(t,e)=>new ui(t,e))}static LineTouchesPolygon(t,e){const i=e.polyline.prev(e).point,n=e.polyline.next(e).point,r=e.point;return E.signedDoubledTriangleArea(t,r,i)*E.signedDoubledTriangleArea(t,r,n)>=0}GetOutgoingSide(t){return t==this.visibleBoundaries.get(t.polyline).End?null:t}static GetIncomingSide(t){return t.prevOnPolyline}ComputeHoleBoundariesPossiblyVisibleFromQ(){this.InitActiveEdgesAndActiveEdgesComparer();for(const t of this.holes)this.ComputeVisiblePartOfTheHole(t)}InitActiveEdgesAndActiveEdgesComparer(){this.activeEdgeComparer=new sn,this.activeEdgeComparer.pivot=this.q,this.activeSidesTree=new ei(this.activeEdgeComparer.Compare.bind(this.activeEdgeComparer))}ComputeVisiblePartOfTheHole(t){let e,i=!0;for(e=t.startPoint;!this.HoleSideIsVisibleFromQ(t,e);e=t.next(e))i=!1;let n=t.next(e);if(i)for(;this.HoleSideIsVisibleFromQ(t,t.prev(e));)e=t.prev(e);for(;this.HoleSideIsVisibleFromQ(t,n);n=t.next(n));this.visibleBoundaries.set(t,new on(e,n))}HoleSideIsVisibleFromQ(t,e){return E.signedDoubledTriangleArea(this.q,e.point,t.next(e).point)>=-y.squareOfDistanceEpsilon}}class ln{constructor(t,e){this.next=null,this.prev=null,this.PolylinePoint=t,this.OriginalPosition=e}get PolylinePoint(){return this.polylinePoint}set PolylinePoint(t){this.polylinePoint=t}get OriginalPosition(){return this.originalPosition}set OriginalPosition(t){this.originalPosition=t}get Next(){return this.next}set Next(t){this.next=t}get Prev(){return this.prev}set Prev(t){this.prev=t}}class hn extends K{constructor(){super(...arguments),this.IgnoreTightPadding=!1,this.activeRectangle=G.mkEmpty(),this.activePolygons=new Array,this.alreadyAddedOrExcludedPolylines=new Set,this.UseEdgeLengthMultiplier=!1,this.UseInnerPolylingShortcutting=!0,this.UsePolylineEndShortcutting=!0,this.AllowedShootingStraightLines=!0,this.LookForRoundedVertices=!1}get Obstacles(){return this.obstacles_}set Obstacles(t){this.obstacles_=t}get EnteringAngleBound(){return this.enteringAngleBound_}set EnteringAngleBound(t){this.enteringAngleBound_=t}get SourceTightPolyline(){return this._sourceTightPolyline}set SourceTightPolyline(t){this._sourceTightPolyline=t}get TargetTightPolyline(){return this.targetTightPolyline}set TargetTightPolyline(t){this.targetTightPolyline=t}get TargetLoosePolyline(){return this.targetLoosePolyline}set TargetLoosePolyline(t){this.targetLoosePolyline=t}get VisibilityGraph(){return this.visibilityGraph}set VisibilityGraph(t){this.visibilityGraph=t}get SourcePort(){return this.sourcePort}set SourcePort(t){if(this.sourcePort=t,null!=this.sourcePort)if(this.SourceTightPolyline=hn.GetFirstHitPolyline(this.sourcePort.Location,this.ObstacleCalculator.RootOfTightHierarchy),this.sourcePort instanceof $e)this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline),this.StartPointOfEdgeRouting=this.SourcePort.Location;else{const t=this.sourcePort;this.StartPointOfEdgeRouting=this.TakeBoundaryPortOutsideOfItsLoosePolyline(t.Curve,t.Parameter,this.SourceLoosePolyline)}}get TargetPort(){return this.targetPort}set TargetPort(t){this.targetPort=t}get LoosePadding(){return this.loosePadding}set LoosePadding(t){this.loosePadding=t,null!=this.ObstacleCalculator&&(this.ObstacleCalculator.LoosePadding=t)}get StartPointOfEdgeRouting(){return this.startPointOfRouting_}set StartPointOfEdgeRouting(t){this.startPointOfRouting_=t}ExtendVisibilityGraphToLocation(t){null==this.VisibilityGraph&&(this.VisibilityGraph=new di);let e=null;if(!this.activeRectangle.contains(t)){this.activeRectangle.isEmpty?this.activeRectangle=G.mkPP(this.SourcePort.Location,t):this.activeRectangle.add(t),e=this.GetAddedPolygonesAndMaybeExtendActiveRectangle();for(const t of e)this.VisibilityGraph.AddHole(t.Polyline)}if(null==e||0==e.length)null!=this.targetVV&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.CalculateEdgeTargetVisibilityGraph(t);else{this.RemovePointVisibilityGraphs();new nn(e,this.activePolygons,this.VisibilityGraph).run(),fe(this.activePolygons,e),this.CalculateEdgeTargetVisibilityGraph(t),this.CalculateSourcePortVisibilityGraph()}}RemovePointVisibilityGraphs(){null!=this.targetVV&&this.VisibilityGraph.RemoveVertex(this.targetVV),null!=this.sourceVV&&this.VisibilityGraph.RemoveVertex(this.sourceVV)}CalculateEdgeTargetVisibilityGraph(t){this.targetVV=an.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()),this.VisibilityGraph,t,Ue.Tangent)}CalculateSourcePortVisibilityGraph(){this.sourceVV=an.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()),this.VisibilityGraph,this.StartPointOfEdgeRouting,Ue.Tangent)}TakeBoundaryPortOutsideOfItsLoosePolyline(t,e,i){const n=t.value(e);let r=t.leftDerivative(e).normalize().add(t.rightDerivative(e).normalize()).normalize();E.getTriangleOrientation(hn.PointInsideOfConvexCurve(t),n,n.add(r))==s.Counterclockwise&&(r=r.mul(-1)),r=r.rotate(Math.PI/2);const o=i.boundingBox.diagonal;let a=I.mkPP(n,n.add(r.mul(o)));const l=F.intersectionOne(a,i,!1).x;let h=r.mul(l.sub(n).length/2);for(;;){a=I.mkPP(n,l.add(h));let t=!1;for(const e of hn.IntersectionsOfLineAndRectangleNodeOverPolylineLR(a,this.ObstacleCalculator.RootOfLooseHierarchy))if(e.seg1!=i){h=h.div(1.5),t=!0;break}if(!t)break}return a.end}static PointInsideOfConvexCurve(t){return t.value(0).add(t.value(1.5)).div(2)}*GetActivePolylines(){for(const t of this.activePolygons)yield t.Polyline}GetAddedPolygonesAndMaybeExtendActiveRectangle(){const t=this.activeRectangle,e=new Array;let i;do{i=!1;for(const n of this.ObstacleCalculator.RootOfLooseHierarchy.GetNodeItemsIntersectingRectangle(this.activeRectangle))this.alreadyAddedOrExcludedPolylines.has(n)||(t.addRec(n.boundingBox),e.push(new Wi(n)),this.alreadyAddedOrExcludedPolylines.add(n),i=!0);i&&(this.activeRectangle=t)}while(i);return e}RelaxPolyline(){let t=hn.CreateRelaxedPolylinePoints(this._polyline);for(t=t.Next;null!=t.Next;t=t.Next)this.RelaxPolylinePoint(t)}static CreateRelaxedPolylinePoints(t){let e=t.startPoint;const i=new ln(e,e.point);let n=i;for(;null!=e.next;){e=e.next;const t=new ln(e,e.point);t.Prev=n,n.Next=t,n=t}return i}RelaxPolylinePoint(t){if(!(null==t.PolylinePoint.prev.prev&&this.SourcePort instanceof Ri&&t.PolylinePoint.polyline!=this.SourceLoosePolyline||null==t.PolylinePoint.next.next&&this.TargetPort instanceof Ri&&t.PolylinePoint.polyline!=this.TargetLoosePolyline))for(let e=this.OffsetForPolylineRelaxing;e>y.distanceEpsilon&&!this.RelaxWithGivenOffset(e,t);)e/=2}RelaxWithGivenOffset(t,e){return hn.SetRelaxedPointLocation(t,e),!!this.StickingSegmentDoesNotIntersectTightObstacles(e)||(hn.PullCloserRelaxedPoint(e.Prev),!1)}static PullCloserRelaxedPoint(t){t.PolylinePoint.point=t.OriginalPosition.mul(.2).add(t.PolylinePoint.point.mul(.8))}StickingSegmentDoesNotIntersectTightObstacles(t){return!(this.PolylineSegmentIntersectsTightHierarchy(t.PolylinePoint.point,t.Prev.PolylinePoint.point)||null!=t.Next&&this.PolylineSegmentIntersectsTightHierarchy(t.PolylinePoint.point,t.Next.PolylinePoint.point))}PolylineSegmentIntersectsTightHierarchy(t,e){return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(t,e,this.ObstacleCalculator.RootOfTightHierarchy)}PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(t,e,i){return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(I.mkPP(t,e),i)}PolylineIntersectsPolyRectangleNodeOfTightHierarchy(t,e){if(!t.boundingBox.intersects(e.irect))return!1;if(null!=e.UserData){for(const i of F.getAllIntersections(t,e.UserData,!1)){if(i.seg1!=this.SourceTightPolyline&&i.seg1!=this.TargetTightPolyline)return!0;if((i.seg1==this.SourceTightPolyline&&this.SourcePort)instanceof Ri)return!0;if((i.seg1==this.TargetTightPolyline&&this.TargetPort)instanceof Ri)return!0}return!1}return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(t,e.Left)||this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(t,e.Right)}static IntersectionsOfLineAndRectangleNodeOverPolylineLR(t,e){const i=new Array;return hn.IntersectionsOfLineAndRectangleNodeOverPolyline(t,e,i),i}static IntersectionsOfLineAndRectangleNodeOverPolyline(t,e,i){null!=e&&t.boundingBox.intersects(e.irect)&&(null==e.UserData?(hn.IntersectionsOfLineAndRectangleNodeOverPolyline(t,e.Left,i),hn.IntersectionsOfLineAndRectangleNodeOverPolyline(t,e.Right,i)):fe(i,F.getAllIntersections(t,e.UserData,!0)))}LineCanBeAcceptedForRouting(t){const e=this.SourcePort instanceof $e,i=this.TargetPort instanceof $e;if(!e&&!this.targetIsInsideOfSourceTightPolyline&&!this.InsideOfTheAllowedConeOfBoundaryPort(t.end,this.SourcePort))return!1;if(!i&&null!=this.TargetPort&&!this.sourceIsInsideOfTargetTightPolyline&&!this.InsideOfTheAllowedConeOfBoundaryPort(t.start,this.TargetPort))return!1;const n=hn.IntersectionsOfLineAndRectangleNodeOverPolylineLR(t,this.ObstacleCalculator.RootOfTightHierarchy);for(const t of n)if(t.seg1!=this.SourceTightPolyline&&t.seg1!=this.targetTightPolyline)return!1;return!0}InsideOfTheAllowedConeOfBoundaryPort(t,e){const i=e.Curve,n=Hi.CurveIsClockwise(i,hn.PointInsideOfConvexCurve(i)),r=e.Location,o=this.GetPointOnTheRightBoundaryPortConeSide(r,i,n,e.Parameter),a=this.GetPointOnTheLeftBoundaryPortConeSide(r,i,n,e.Parameter);return E.getTriangleOrientation(r,o,t)!=s.Clockwise&&E.getTriangleOrientation(r,t,a)!=s.Clockwise}GetPointOnTheRightBoundaryPortConeSide(t,e,i,n){const r=i?e.rightDerivative(n):e.leftDerivative(n).neg();return t.add(r.rotate(this.EnteringAngleBound))}GetPointOnTheLeftBoundaryPortConeSide(t,e,i,n){const r=i?e.leftDerivative(n).neg():e.rightDerivative(n);return t.add(r.rotate(-this.EnteringAngleBound))}static SetRelaxedPointLocation(t,e){const i=E.getTriangleOrientation(e.Next.OriginalPosition,e.OriginalPosition,e.Prev.OriginalPosition)==s.Counterclockwise;let n=e.Next.OriginalPosition.sub(e.Prev.OriginalPosition).normalize().mul(t).rotate(Math.PI/2);i||(n=n.neg()),e.PolylinePoint.point=e.OriginalPosition.add(n)}SmoothCorners(t){let e=t.headSite,i={b:null,c:null};for(;i=F.findCorner(e);)e=this.SmoothOneCorner(e,i.c,i.b)}SmoothOneCorner(t,e,i){let n,r,s,o=.5;null==t.prev?(s=2,r=1):null==e.next?(s=1,r=2):r=1,s=1;do{n=F.createBezierSeg(o*s,o*r,t,i,e),i.previouisBezierCoefficient=o*s,i.nextBezierCoefficient=o*r,o/=1.5}while(this.ObstacleCalculator.ObstaclesIntersectICurve(n)&&o>.01);return o*=1.5,o<.5&&o>.01&&(o=.5*(o+1.5*o),n=F.createBezierSeg(o*s,o*r,t,i,e),this.ObstacleCalculator.ObstaclesIntersectICurve(n)||(i.previouisBezierCoefficient=o*s,i.nextBezierCoefficient=o*r)),i}TryToRemoveInflectionsAndCollinearSegments(t){let e=!0;const i={s:null};for(;e;)for(e=!1,i.s=t.headSite;null!=i.s&&null!=i.s.next;i.s=i.s.next)i.s.turn*i.s.next.turn<0&&(e=this.TryToRemoveInflectionEdge(i)||e)}TryToRemoveInflectionEdge(t){if(!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.prev.point,t.s.next.point)){const e=t.s.prev,i=t.s.next;return e.next=i,i.prev=e,t.s=e,!0}if(!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.prev.point,t.s.next.next.point)){const e=t.s.prev,i=t.s.next.next;return e.next=i,i.prev=e,t.s=e,!0}if(!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.point,t.s.next.next.point)){const e=t.s.next.next;return t.s.next=e,e.prev=t.s,!0}return!1}GetShortestPolyline(t,e){this.CleanTheGraphForShortestPath();const i=new Ki(this.visibilityGraph,t,e).GetPath(this.UseEdgeLengthMultiplier);if(null==i)return null;const n=new k;for(const t of i)n.addPoint(t.point);return hn.RemoveCollinearVertices(n)}CleanTheGraphForShortestPath(){this.visibilityGraph.ClearPrevEdgesTable()}static RemoveCollinearVertices(t){for(let e=t.startPoint.next;null!=e.next;e=e.next)E.getTriangleOrientation(e.prev.point,e.point,e.next.point)==s.Collinear&&(e.prev.next=e.next,e.next.prev=e.prev);return t}get OverlapsDetected(){return this.ObstacleCalculator.OverlapsDetected}get TightHierarchy(){return this.ObstacleCalculator.RootOfTightHierarchy}set TightHierarchy(t){this.ObstacleCalculator.RootOfTightHierarchy=t}get LooseHierarchy(){return this.ObstacleCalculator.RootOfLooseHierarchy}set LooseHierarchy(t){this.ObstacleCalculator.RootOfLooseHierarchy=t}CalculateObstacles(){this.ObstacleCalculator=new Hi(this.Obstacles,this.TightPadding,this.LoosePadding,this.IgnoreTightPadding),this.ObstacleCalculator.Calculate()}RouteEdgeToLocation(t){this.TargetPort=new $e(null,t),this.TargetTightPolyline=null,this.TargetLoosePolyline=null;const e=new Z(null);let i=I.mkPP(this.SourcePort.Location,t);return this.LineCanBeAcceptedForRouting(i)?(this._polyline=new k,this._polyline.addPoint(i.start),this._polyline.addPoint(i.end),e.smoothedPolyline=Y.mkFromPoints(this._polyline),e.curve=e.smoothedPolyline.createCurve(),e):this.SourcePort instanceof Ri&&(i=I.mkPP(this.StartPointOfEdgeRouting,t),0==hn.IntersectionsOfLineAndRectangleNodeOverPolylineLR(i,this.ObstacleCalculator.RootOfTightHierarchy).length)?(this._polyline=new k,this._polyline.addPoint(this.SourcePort.Location),this._polyline.addPoint(i.start),this._polyline.addPoint(i.end),e.smoothedPolyline=Y.mkFromPoints(this._polyline),e.curve=e.smoothedPolyline.createCurve(),e):(this.ExtendVisibilityGraphToLocation(t),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV),this.RelaxPolyline(),this.SourcePort instanceof Ri&&this._polyline.PrependPoint(this.SourcePort.Location),e.smoothedPolyline=Y.mkFromPoints(this._polyline),e.curve=e.smoothedPolyline.createCurve(),e)}RouteEdgeToPort(t,e,i,n){return this.ObstacleCalculator.IsEmpty()?null!=this.sourcePort&&null!=this.targetPort?(n.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(this.sourcePort.Location,this.targetPort.Location),I.mkPP(this.sourcePort.Location,this.targetPort.Location)):null:(this.TargetPort=t,this.TargetTightPolyline=hn.GetFirstHitPolyline(t.Location,this.ObstacleCalculator.RootOfTightHierarchy),t instanceof Ri?this.RouteEdgeToBoundaryPort(e,i,n):this.RouteEdgeToFloatingPortOfNode(e,i,n))}SmoothedPolylineFromTwoPoints(t,e){return this._polyline=new k,this._polyline.addPoint(t),this._polyline.addPoint(e),Y.mkFromPoints(this._polyline)}RouteEdgeToFloatingPortOfNode(t,e,i){return this.sourcePort instanceof $e?this.RouteFromFloatingPortToFloatingPort(t,e,i):this.RouteFromBoundaryPortToFloatingPort(t,e,i)}RouteFromBoundaryPortToFloatingPort(t,e,i){const n=this.SourcePort.Location,r=this.targetPort.Location;let s=I.mkPP(n,r);if(this.LineCanBeAcceptedForRouting(s))return i.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(s.start,s.end),s;if(!this.targetIsInsideOfSourceTightPolyline){const e=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve,this.SourcePort.Parameter,this.SourceLoosePolyline);if(s=I.mkPP(e,r),this.LineAvoidsTightHierarchyLP(s,t))return i.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(s.start,s.end),s}this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(t),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV);const o=this.SourceTightPolyline;return this.targetIsInsideOfSourceTightPolyline||(this.SourceTightPolyline=null),this.TryShortcutPolyline(),this.SourceTightPolyline=o,this.RelaxPolyline(),this._polyline.PrependPoint(n),this.SmoothCornersAndReturnCurve(e,i)}SmoothCornersAndReturnCurve(t,e){return e.smoothedPolyline=Y.mkFromPoints(this._polyline),t&&this.SmoothCorners(e.smoothedPolyline),e.smoothedPolyline.createCurve()}RouteFromFloatingPortToFloatingPort(t,e,i){const n=this.TargetPort.Location,r=I.mkPP(this.StartPointOfEdgeRouting,n);return this.AllowedShootingStraightLines&&this.LineAvoidsTightHierarchyLPP(r,this.SourceTightPolyline,this.targetTightPolyline)?(i.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(r.start,r.end),r):(this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(t),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV),null==this._polyline?null:(this.UseSpanner&&this.TryShortcutPolyline(),this.RelaxPolyline(),i.smoothedPolyline=Y.mkFromPoints(this._polyline),this.SmoothCornersAndReturnCurve(e,i)))}TryShortcutPolyline(){if(this.UseInnerPolylingShortcutting)for(;this.ShortcutPolylineOneTime(););this.UsePolylineEndShortcutting&&this.TryShortCutThePolylineEnds()}TryShortCutThePolylineEnds(){this.TryShortcutPolylineStart(),this.TryShortcutPolylineEnd()}TryShortcutPolylineEnd(){const t=this._polyline.endPoint,e=t.prev;if(null==e)return;const i=e.prev;if(null==i)return;const n=E.middle(e.point,i.point);if(this.LineAvoidsTightHierarchyPPPP(t.point,n,this._sourceTightPolyline,this.targetTightPolyline)){const e=x.mkFromPoint(n);e.next=t,e.prev=i,t.prev=e,i.next=e}}TryShortcutPolylineStart(){const t=this._polyline.startPoint,e=t.next;if(null==e)return;const i=e.next;if(null==i)return;const n=E.middle(e.point,i.point);if(this.LineAvoidsTightHierarchyPPPP(t.point,n,this._sourceTightPolyline,this.targetTightPolyline)){const e=x.mkFromPoint(n);e.prev=t,e.next=i,t.next=e,i.prev=e}}ShortcutPolylineOneTime(){let t=!1;for(let e=this._polyline.startPoint;null!=e.next&&null!=e.next.next;e=e.next)t=t||this.TryShortcutPolyPoint(e);return t}TryShortcutPolyPoint(t){return!!this.LineAvoidsTightHierarchyLPP(I.mkPP(t.point,t.next.next.point),this.SourceTightPolyline,this.targetTightPolyline)&&(t.next=t.next.next,t.next.prev=t,!0)}ExtendVisibilityGraphToLocationOfTargetFloatingPort(t){null==this.VisibilityGraph&&(this.VisibilityGraph=new di);let e=null;const i=this.targetPort.Location;if(!this.activeRectangle.contains(i)){this.activeRectangle.isEmpty?this.activeRectangle=G.mkPP(this.SourcePort.Location,i):this.activeRectangle.add(i),e=this.GetAddedPolygonesAndMaybeExtendActiveRectangle();for(const t of e)this.VisibilityGraph.AddHole(t.Polyline)}if(null==e)null!=this.targetVV&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.CalculateEdgeTargetVisibilityGraphForFloatingPort(i,t),null==this.sourceVV&&this.CalculateSourcePortVisibilityGraph();else{this.RemovePointVisibilityGraphs();new nn(e,this.activePolygons,this.VisibilityGraph).run(),fe(this.activePolygons,e),this.CalculateEdgeTargetVisibilityGraphForFloatingPort(i,t),this.CalculateSourcePortVisibilityGraph()}}CalculateEdgeTargetVisibilityGraphForFloatingPort(t,e){this.UseSpanner?this.targetVV=this.AddTransientVisibilityEdgesForPort(t,e):this.targetVV=an.CalculatePointVisibilityGraph(this.GetActivePolylinesWithException(e),this.VisibilityGraph,t,Ue.Tangent)}AddTransientVisibilityEdgesForPort(t,e){let i=this.GetVertex(t);if(null!=i)return i;if(i=this.visibilityGraph.AddVertexP(t),null!=e)for(const i of e)this.visibilityGraph.AddEdgeF(t,i,(t,e)=>new ui(t,e));else i=an.CalculatePointVisibilityGraph(this.GetActivePolylines(),this.VisibilityGraph,t,Ue.Tangent);return i}GetVertex(t){let e=this.visibilityGraph.FindVertex(t);return null==e&&this.LookForRoundedVertices&&(e=this.visibilityGraph.FindVertex(y.RoundPoint(t))),e}*GetActivePolylinesWithException(t){for(const e of this.activePolygons)e.Polyline!=t&&(yield e.Polyline)}RouteEdgeToBoundaryPort(t,e,i){return this.TargetLoosePolyline=t,this.sourcePort instanceof $e?this.RouteFromFloatingPortToBoundaryPort(e,i):this.RouteFromBoundaryPortToBoundaryPort(e,i)}RouteFromBoundaryPortToBoundaryPort(t,e){const i=this.SourcePort.Location;let n;const r=this.targetPort.Location;let s=I.mkPP(i,r);if(this.LineCanBeAcceptedForRouting(s))this._polyline=new k,this._polyline.addPoint(s.start),this._polyline.addPoint(s.end),e.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(s.start,s.end),n=Y.mkFromPoints(this._polyline).createCurve();else{const o=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.targetPort.Curve,this.targetPort.Parameter,this.TargetLoosePolyline);if(s=I.mkPP(i,o),this.InsideOfTheAllowedConeOfBoundaryPort(o,this.SourcePort)&&this.LineAvoidsTightHierarchyLP(s,this._sourceTightPolyline))this._polyline=new k,this._polyline.addPoint(s.start),this._polyline.addPoint(s.end),this._polyline.addPoint(r),n=this.SmoothCornersAndReturnCurve(t,e);else if(s=I.mkPP(this.StartPointOfEdgeRouting,r),this.InsideOfTheAllowedConeOfBoundaryPort(this.StartPointOfEdgeRouting,this.TargetPort)&&this.LineAvoidsTightHierarchy(s))this._polyline=new k,this._polyline.addPoint(i),this._polyline.addPoint(s.start),this._polyline.addPoint(s.end),n=this.SmoothCornersAndReturnCurve(t,e);else{let s;if(s=I.IntersectPPPP(i,this.StartPointOfEdgeRouting,r,o))this._polyline=new k,this._polyline.addPoint(i),this._polyline.addPoint(s),this._polyline.addPoint(r),n=this.SmoothCornersAndReturnCurve(t,e);else if(E.closeDistEps(this.StartPointOfEdgeRouting,o))this._polyline=new k,this._polyline.addPoint(i),this._polyline.addPoint(o),this._polyline.addPoint(r),n=this.SmoothCornersAndReturnCurve(t,e);else if(this.LineAvoidsTightHierarchy(I.mkPP(this.StartPointOfEdgeRouting,o)))this._polyline=new k,this._polyline.addPoint(i),this._polyline.addPoint(this.StartPointOfEdgeRouting),this._polyline.addPoint(o),this._polyline.addPoint(r),n=this.SmoothCornersAndReturnCurve(t,e);else{this.ExtendVisibilityGraphToTargetBoundaryPort(o),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV);const s={tmpTargetTight:null},a=this.HideSourceTargetTightsIfNeeded(s);this.TryShortcutPolyline(),this.RecoverSourceTargetTights(a,s.tmpTargetTight),this.RelaxPolyline(),this._polyline.PrependPoint(i),this._polyline.addPoint(r),n=this.SmoothCornersAndReturnCurve(t,e)}}}return n}RecoverSourceTargetTights(t,e){this.SourceTightPolyline=t,this.TargetTightPolyline=e}HideSourceTargetTightsIfNeeded(t){const e=this.SourceTightPolyline;return t.tmpTargetTight=this.TargetTightPolyline,this.TargetTightPolyline=null,this.SourceTightPolyline=null,e}LineAvoidsTightHierarchy(t){return 0==hn.IntersectionsOfLineAndRectangleNodeOverPolylineLR(t,this.ObstacleCalculator.RootOfTightHierarchy).length}RouteFromFloatingPortToBoundaryPort(t,e){const i=this.targetPort.Location;let n;if(this.InsideOfTheAllowedConeOfBoundaryPort(this.sourcePort.Location,this.targetPort)&&(n=I.mkPP(this.SourcePort.Location,i),this.LineCanBeAcceptedForRouting(n)))return e.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(n.start,n.end),n;const r=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.TargetPort.Curve,this.TargetPort.Parameter,this.TargetLoosePolyline);if(n=I.mkPP(this.SourcePort.Location,r),this.LineAvoidsTightHierarchyLP(n,this._sourceTightPolyline))return this._polyline=k.mkFromPoints([n.start,n.end,i]),e.smoothedPolyline=Y.mkFromPoints(this._polyline),e.smoothedPolyline.createCurve();this.ExtendVisibilityGraphToTargetBoundaryPort(r),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV),this.RelaxPolyline(),this._polyline.addPoint(i);return this.SmoothCornersAndReturnCurve(t,{smoothedPolyline:null})}LineAvoidsTightHierarchyLP(t,e){let i=!0;for(const n of hn.IntersectionsOfLineAndRectangleNodeOverPolylineLR(t,this.ObstacleCalculator.RootOfTightHierarchy))if(n.seg1!=e){i=!1;break}return i}LineAvoidsTightHierarchyLPP(t,e,i){let n=!0;for(const r of hn.IntersectionsOfLineAndRectangleNodeOverPolylineLR(t,this.ObstacleCalculator.RootOfTightHierarchy))if(r.seg1!=e&&r.seg1!=i){n=!1;break}return n}LineAvoidsTightHierarchyPPPP(t,e,i,n){return this.LineAvoidsTightHierarchyLPP(I.mkPP(t,e),i,n)}ExtendVisibilityGraphToTargetBoundaryPort(t){let e=null;if(null==this.VisibilityGraph&&(this.VisibilityGraph=new di),!this.activeRectangle.contains(t)||!this.activeRectangle.containsRect(this.TargetLoosePolyline.boundingBox)){this.activeRectangle.isEmpty?(this.activeRectangle=this.TargetLoosePolyline.boundingBox.clone(),this.activeRectangle.add(this.SourcePort.Location),this.activeRectangle.add(this.StartPointOfEdgeRouting),this.activeRectangle.add(t)):(this.activeRectangle.add(t),this.activeRectangle.addRec(this.TargetLoosePolyline.boundingBox)),e=this.GetAddedPolygonesAndMaybeExtendActiveRectangle();for(const t of e)this.VisibilityGraph.AddHole(t.Polyline)}if(null==e)null!=this.targetVV&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.CalculateEdgeTargetVisibilityGraph(t);else{this.RemovePointVisibilityGraphs();new nn(e,this.activePolygons,this.VisibilityGraph).run(),fe(this.activePolygons,e),this.CalculateEdgeTargetVisibilityGraph(t),this.CalculateSourcePortVisibilityGraph()}}GetHitLoosePolyline(t){return this.ObstacleCalculator.IsEmpty()||null==this.ObstacleCalculator.RootOfLooseHierarchy?null:hn.GetFirstHitPolyline(t,this.ObstacleCalculator.RootOfLooseHierarchy)}static GetFirstHitPolyline(t,e){const i=hn.GetFirstHitRectangleNode(t,e);return i?i.UserData:null}static GetFirstHitRectangleNode(t,e){return null==e?null:e.FirstHitNodePF(t,(t,e)=>F.PointRelativeToCurveLocation(t,e)!=a.Outside?tt.Stop:tt.Continue)}Clean(){this.TargetPort=null,this.SourcePort=null,this.SourceTightPolyline=null,this.SourceLoosePolyline=null,this.TargetLoosePolyline=null,this.targetTightPolyline=null,this.VisibilityGraph=null,this.targetVV=null,this.sourceVV=null,this.activePolygons=[],this.alreadyAddedOrExcludedPolylines.clear(),this.activeRectangle.setToEmpty()}SetSourcePortAndSourceLoosePolyline(t,e){this.SourceLoosePolyline=e,this.sourcePort=t,null!=this.sourcePort&&(this.SourceTightPolyline=hn.GetFirstHitPolyline(this.sourcePort.Location,this.ObstacleCalculator.RootOfTightHierarchy),this.sourcePort instanceof $e?(this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline),this.StartPointOfEdgeRouting=this.SourcePort.Location):this.StartPointOfEdgeRouting=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve,this.sourcePort.Parameter,this.SourceLoosePolyline))}run(){this.CalculateWholeTangentVisibilityGraph()}CalculateWholeTangentVisibilityGraph(){this.VisibilityGraph=new di,this.CalculateWholeVisibilityGraphOnExistingGraph()}CalculateWholeVisibilityGraphOnExistingGraph(){this.activePolygons=Array.from(this.AllPolygons());for(const t of this.ObstacleCalculator.LooseObstacles)this.VisibilityGraph.AddHole(t);let t;t=this.UseSpanner?new Oi(this.ObstacleCalculator.LooseObstacles,this.VisibilityGraph):new nn(new Array,this.activePolygons,this.visibilityGraph),t.run()}RouteSplineFromPortToPortWhenTheWholeGraphIsReady(t,e,i,n){const r=t instanceof $e&&e instanceof Ri||t instanceof _i;if(r){const i=t;t=e,e=i}this.sourcePort=t,this.targetPort=e,this.FigureOutSourceTargetPolylinesAndActiveRectangle();let s=this.GetEdgeGeomByRouting(i,n);return null==s?null:(this.targetVV=null,this.sourceVV=null,r&&(s=s.reverse()),s)}GetEdgeGeomByRouting(t,e){let i;if(this.sourceIsInsideOfTargetTightPolyline=null==this.TargetTightPolyline||F.PointRelativeToCurveLocation(this.sourcePort.Location,this.TargetTightPolyline)==a.Inside,this.sourcePort instanceof Ri){const e=this.sourcePort;this.StartPointOfEdgeRouting=this.targetIsInsideOfSourceTightPolyline?e.Location:this.TakeBoundaryPortOutsideOfItsLoosePolyline(e.Curve,e.Parameter,this.SourceLoosePolyline),this.CalculateSourcePortVisibilityGraph();const n={smoothedPolyline:null};i=this.targetPort instanceof Ri?this.RouteFromBoundaryPortToBoundaryPort(t,n):this.RouteFromBoundaryPortToFloatingPort(this.targetLoosePolyline,t,n)}else this.targetPort instanceof $e?(this.ExtendVisibilityGraphFromFloatingSourcePort(),i=this.RouteFromFloatingPortToFloatingPort(this.targetLoosePolyline,t,e)):(d.assert(this.targetPort instanceof _i),i=this.RouteFromFloatingPortToAnywherePort(this.targetPort.LoosePolyline,t,e,this.targetPort));return i}RouteFromFloatingPortToAnywherePort(t,e,i,n){return n.Curve.boundingBox.contains(this.sourcePort.Location)?(this.sourceVV=this.GetVertex(this.sourcePort.Location),this._polyline=this.GetShortestPolylineToMulitpleTargets(this.sourceVV,Array.from(this.Targets(t))),null==this._polyline?null:(this.UseSpanner&&this.TryShortcutPolyline(),this.RelaxPolyline(),this.FixLastPolylinePointForAnywherePort(n),n.HookSize>0&&this.BuildHook(n),this.SmoothCornersAndReturnCurve(e,i))):(i.smoothedPolyline=null,null)}BuildHook(t){const e=t.Curve,i=R.mkFullEllipseNNP(t.HookSize,t.HookSize,this._polyline.end),n=F.getAllIntersections(e,i,!0);E.getTriangleOrientation(n[0].x,this._polyline.end,this._polyline.endPoint.prev.point)==s.Counterclockwise&&n.reverse();const r=this._polyline.end.sub(this._polyline.endPoint.prev.point).normalize(),o=e.derivative(n[0].par0).normalize(),a=o.dot(r);if(Math.abs(a)<.2)this.ExtendPolyline(o,n[0],r,t);else{const i=e.derivative(n[1].par0).normalize();i.dot(r)<a?this.ExtendPolyline(i,n[1],r,t):this.ExtendPolyline(o,n[0],r,t)}}ExtendPolyline(t,e,i,n){let r=t.rotate(Math.PI/2);r.dot(i)<0&&(r=r.neg());const s=e.x.add(r.mul(n.HookSize));let o;(o=E.lineLineIntersection(s,s.add(t),this._polyline.end,this._polyline.end.add(i)))&&(this._polyline.addPoint(o),this._polyline.addPoint(s),this._polyline.addPoint(e.x))}FixLastPolylinePointForAnywherePort(t){for(;;){const e=this.GetLastPointInsideOfCurveOnPolyline(t.Curve);e.next.next=null,this._polyline.endPoint=e.next;let i=e.next.point.sub(e.point);i=i.normalize().mul(t.Curve.boundingBox.diagonal);const n=i.rotate(-1*t.AdjustmentAngle),r=i.rotate(t.AdjustmentAngle),s=F.intersectionOne(t.Curve,I.mkPP(e.point,e.point.add(n)),!0),o=F.intersectionOne(t.Curve,I.mkPP(e.point,e.point.add(r)),!0);if(null==s||null==o)return;const a=hn.GetTrimmedCurveForHookingUpAnywhere(t.Curve,e,s,o),l=a.value(a.closestParameter(e.point));if(!this.LineAvoidsTightHierarchyLPP(I.mkPP(e.point,l),this.SourceTightPolyline,null)){const i=F.intersectionOne(t.Curve,I.mkPP(e.point,e.next.point),!1);if(null==i)return;this._polyline.endPoint.point=i.x;break}if(this._polyline.endPoint.point=l,null==e.prev||!this.TryShortcutPolyPoint(e.prev))break}}static GetTrimmedCurveForHookingUpAnywhere(t,e,i,n){const r=E.getTriangleOrientation(n.x,i.x,e.point)==s.Clockwise,o=i.par0,a=n.par0;let l,h,u;return r?o<a?t.trim(o,a):(h=t.trim(o,t.parEnd),l=t.trim(t.parStart,a),u=new F,u.addSegs([h,l])):a<o?t.trim(a,o):(h=t.trim(a,t.parEnd),l=t.trim(t.parStart,o),u=new F,u.addSegs([h,l]))}GetLastPointInsideOfCurveOnPolyline(t){for(let e=this._polyline.endPoint.prev;null!=e;e=e.prev){if(null==e.prev)return e;if(F.PointRelativeToCurveLocation(e.point,t)==a.Inside)return e}throw new Error}GetShortestPolylineToMulitpleTargets(t,e){this.CleanTheGraphForShortestPath();const i=new Zi(t,e,this.VisibilityGraph).GetPath();if(null==i)return null;const n=new k;for(const t of i)n.addPoint(t.point);return hn.RemoveCollinearVertices(n)}Targets(t){return Array.from(t).map(t=>this.visibilityGraph.FindVertex(t))}ExtendVisibilityGraphFromFloatingSourcePort(){const t=this.sourcePort;this.StartPointOfEdgeRouting=t.Location,this.UseSpanner?this.sourceVV=this.AddTransientVisibilityEdgesForPort(this.sourcePort.Location,this.SourceLoosePolyline):this.sourceVV=an.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()).filter(t=>t!=this.SourceLoosePolyline),this.VisibilityGraph,this.StartPointOfEdgeRouting,Ue.Tangent)}FigureOutSourceTargetPolylinesAndActiveRectangle(){let t=this.sourcePort.Curve.value(this.sourcePort.Curve.parStart);this._sourceTightPolyline=hn.GetFirstHitPolyline(t,this.ObstacleCalculator.RootOfTightHierarchy),this.SourceLoosePolyline=hn.GetFirstHitPolyline(t,this.ObstacleCalculator.RootOfLooseHierarchy),t=this.targetPort.Curve.value(this.targetPort.Curve.parStart),this.targetTightPolyline=hn.GetFirstHitPolyline(t,this.ObstacleCalculator.RootOfTightHierarchy),this.targetLoosePolyline=hn.GetFirstHitPolyline(t,this.ObstacleCalculator.RootOfLooseHierarchy),this.activeRectangle=G.mkPP(new E(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),new E(Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY))}*AllPolygons(){for(const t of this.ObstacleCalculator.LooseObstacles)yield new Wi(t)}GetVisibilityGraph(){return this.VisibilityGraph}AddActivePolygons(t){fe(this.activePolygons,t)}ClearActivePolygons(){this.activePolygons=[]}}class un{constructor(){this.size_=0,this.mapOfMaps=new Ie}clear(){this.mapOfMaps.clear(),this.size_=0}get size(){return this.size_}set(t,e){const i=t.first,n=t.second;let r=this.mapOfMaps.get(i);null==r&&this.mapOfMaps.set(i,r=new Ie),r.has(n)||this.size_++,r.set(n,e)}delete(t){const e=t.first,i=t.second,n=this.mapOfMaps.get(e);null!=n&&n.deleteP(i)&&this.size_--}has(t){const e=this.mapOfMaps.get(t.first);return null!=e&&e.has(t.second)}get_(t,e){return this.get(new ue(t,e))}get(t){const e=this.mapOfMaps.get(t.first);if(null!=e)return e.get(t.second)}*keys(){for(const t of this.mapOfMaps)for(const e of t[1])yield new ue(t[0],e[0])}*[Symbol.iterator](){for(const[t,e]of this.mapOfMaps)for(const[i,n]of e)yield[new ue(t,i),n]}*values(){for(const t of this.mapOfMaps)for(const e of t[1])yield e[1]}}class cn{static GetShapes(t,e=Array.from(t.edges())){const i=new Map;!function t(e,i){for(const n of e.shallowNodes())if(n instanceof yt){const e=cn.CreateShapeWithClusterBoundaryPort(n);i.set(n,e);const r=n;if(!r.graph.isCollapsed){t(r,i);for(const t of r.shallowNodes())e.AddChild(i.get(t))}}else i.set(n,cn.CreateShapeWithCenterPort(n))}(t,i);for(const t of e){let e=i.get(t.source);e&&null!=t.sourcePort&&e.Ports.add(t.sourcePort),e=i.get(t.target),e&&null!=t.targetPort&&e.Ports.add(t.targetPort)}return Array.from(i.values())}static CreateShapeWithCenterPort(t){const e=new Bi(()=>t.boundaryCurve),i=Je.mk(()=>t.boundaryCurve,()=>t.center);e.Ports.add(i);for(const e of t.inEdges())cn.FixPortAtTarget(i,e);for(const e of t.outEdges())cn.FixPortAtSource(i,e);for(const e of t.selfEdges())cn.FixPortAtSource(i,e),cn.FixPortAtTarget(i,e);return e}static CreateShapeWithClusterBoundaryPort(t){d.assert(t instanceof yt);const e=new Bi(()=>t.boundaryCurve),i=Li.mk(()=>t.boundaryCurve,()=>t.center);e.Ports.add(i);let n=void 0;for(const e of t.inEdges())e.EdgeToAncestor()==r.ToAncestor?(null==n&&(n=new _i(()=>t.boundaryCurve)),e.targetPort=n):cn.FixPortAtTarget(i,e);for(const e of t.outEdges())e.EdgeToAncestor()==r.FromAncestor?(null==n&&(n=new _i(()=>t.boundaryCurve)),e.sourcePort=n):cn.FixPortAtSource(i,e);for(const e of t.selfEdges())cn.FixPortAtSource(i,e),cn.FixPortAtTarget(i,e);return e}static FixPortAtSource(t,e){null==e.sourcePort&&(e.sourcePort=t)}static FixPortAtTarget(t,e){null==e.targetPort&&(e.targetPort=t)}}class dn{constructor(t){this.Right=t,this.Left=t}SetActiveState(t,e){this.IsActive=t,this.VectorIndex=e,this.IsActive?(this.Left.ActiveConstraintCount++,this.Right.ActiveConstraintCount++):(this.Left.ActiveConstraintCount--,this.Right.ActiveConstraintCount--)}SetVectorIndex(t){this.VectorIndex=t}Reinitialize(){this.IsActive=!1,this.IsUnsatisfiable=!1,this.ClearDfDv()}UpdateGap(t){this.Gap=t}static constructorVVNB(t,e,i,n){const r=new dn(t);return r.Left=t,r.Right=e,r.Gap=i,r.IsEquality=n,r.Lagrangian=0,r.IsActive=!1,r}ToString(){return _t.String.Format("  Cst: [{0}] [{1}] {2} {3:F5} vio {4:F5} Lm {5:F5}/{6:F5} {7}actv",this.Left,this.Right,this.IsEquality?"==":">=",this.Gap,this.Violation,this.Lagrangian,2*this.Lagrangian,this.IsActive?"+":this.IsUnsatisfiable?"!":"-")}get Violation(){return this.Left.ActualPos*this.Left.Scale+(this.Gap-this.Right.ActualPos*this.Right.Scale)}ClearDfDv(){this.Lagrangian=0}CompareTo(t){let e=this.Left.CompareTo(t.Left);return 0==e&&(e=this.Right.CompareTo(t.Right)),0==e&&(e=b(this.Gap,t.Gap)),e}}class gn{constructor(t){this.ConstraintToEval=t,this.Depth=-1}static constructorDCVV(t,e,i,n){const r=new gn(e);return r.Set(t,e,i,n),r}Set(t,e,i,n){return this.Parent=t,this.ConstraintToEval=e,this.VariableToEval=i,this.VariableDoneEval=n,this.Depth=0,this.ChildrenHaveBeenPushed=!1,e.Lagrangian=0,this}get IsLeftToRight(){return this.VariableToEval==this.ConstraintToEval.Right}toString(){return _t.String.Format("{0} {1}{2} - {3}{4} ({5})","",this.IsLeftToRight?"":"*",this.ConstraintToEval.Left.Name,this.IsLeftToRight?"*":"",this.ConstraintToEval.Right.Name,this.Depth)}}class fn{constructor(t,e){this.Constraint=t,this.IsForward=e}}class pn{constructor(t,e){this.Variables=new Array,null!=t&&this.AddVariable(t),this.allConstraints=e}toString(){return _t.String.Format("[Block: nvars = {0} refpos = {1:F5} scale = {2:F5}]",this.Variables.length,this.ReferencePos,this.Scale)}ComputeDfDv(t){this.allConstraints.DfDvStack=new it.Stack;const e=new dn(t);this.dfDvDummyParentNode=new gn(e);const i=this.GetDfDvNode(this.dfDvDummyParentNode,e,t,null);for(this.allConstraints.DfDvStack.push(i);;){const t=this.allConstraints.DfDvStack.top,e=this.allConstraints.DfDvStack.length;if(!t.ChildrenHaveBeenPushed){t.ChildrenHaveBeenPushed=!0;for(const e of t.VariableToEval.LeftConstraints)if(e.IsActive&&e.Right!=t.VariableDoneEval){const i=this.GetDfDvNode(t,e,e.Right,t.VariableToEval);1==e.Right.ActiveConstraintCount?this.ProcessDfDvLeafNodeDirectly(i):this.PushDfDvNode(i)}for(const e of t.VariableToEval.RightConstraints)if(e.IsActive&&e.Left!=t.VariableDoneEval){const i=this.GetDfDvNode(t,e,e.Left,t.VariableToEval);1==e.Left.ActiveConstraintCount?this.ProcessDfDvLeafNodeDirectly(i):this.PushDfDvNode(i)}if(this.allConstraints.DfDvStack.length>e)continue}if(this.allConstraints.DfDvStack.pop(),this.ProcessDfDvLeafNode(t),t==i)break}}ProcessDfDvLeafNode(t){const e=t.VariableToEval.DfDv;t.IsLeftToRight?(t.ConstraintToEval.Lagrangian=t.ConstraintToEval.Lagrangian+e,t.Parent.ConstraintToEval.Lagrangian=t.Parent.ConstraintToEval.Lagrangian+t.ConstraintToEval.Lagrangian):(t.ConstraintToEval.Lagrangian=-1*(t.ConstraintToEval.Lagrangian+e),t.Parent.ConstraintToEval.Lagrangian=t.Parent.ConstraintToEval.Lagrangian-t.ConstraintToEval.Lagrangian),this.CheckForConstraintPathTarget(t),this.Debug_CheckForViolatedActiveConstraint(t.ConstraintToEval),this.allConstraints.RecycleDfDvNode(t)}Debug_CheckForViolatedActiveConstraint(t){t.Violation,this.allConstraints.SolverParameters.GapTolerance}ProcessDfDvLeafNodeDirectly(t){this.ProcessDfDvLeafNode(t)}GetDfDvNode(t,e,i,n){const r=this.allConstraints.DfDvRecycleStack.size>0?this.allConstraints.DfDvRecycleStack.pop().Set(t,e,i,n):gn.constructorDCVV(t,e,i,n);return r.Depth=r.Parent.Depth+1,this.allConstraints.MaxConstraintTreeDepth<r.Depth&&(this.allConstraints.MaxConstraintTreeDepth=r.Depth),r}PushDfDvNode(t){this.PushOnDfDvStack(t)}AddVariableAndPushDfDvNode(t,e){t.push(e.VariableToEval),this.PushOnDfDvStack(e)}PushOnDfDvStack(t){this.allConstraints.DfDvStack.push(t)}CheckForConstraintPathTarget(t){if(this.pathTargetVariable==t.VariableToEval){for(;t.Parent!=this.dfDvDummyParentNode;)this.constraintPath.push(new fn(t.ConstraintToEval,t.IsLeftToRight)),t=t.Parent;this.pathTargetVariable=null}}Expand(t){null==this.constraintPath&&(this.constraintPath=new Array),this.constraintPath=[],this.pathTargetVariable=t.Right,this.ComputeDfDv(t.Left);let e=null;if(this.constraintPath.length>0){for(const t of this.constraintPath)t.IsForward&&(null==e||t.Constraint.Lagrangian<e.Lagrangian)&&(t.Constraint.IsEquality||(e=t.Constraint));null!=e&&this.allConstraints.DeactivateConstraint(e)}if(this.constraintPath=[],this.pathTargetVariable=null,null==e)return t.IsUnsatisfiable=!0,void this.allConstraints.NumberOfUnsatisfiableConstraints++;const i=new Array;this.GetConnectedVariables(i,t.Right,t.Left);const n=t.Violation,r=i.length;for(let t=0;t<r;t++)i[t].OffsetInBlock=i[t].OffsetInBlock+n;this.allConstraints.ActivateConstraint(t),t.ClearDfDv(),this.UpdateReferencePos()}Split(t){if(t&&this.UpdateReferencePos(),this.Variables.length<2)return null;let e=null;this.ComputeDfDv(this.Variables[0]);let i=this.allConstraints.SolverParameters.Advanced.MinSplitLagrangianThreshold;const n=this.Variables.length;for(let t=0;t<n;t++)for(const n of this.Variables[t].LeftConstraints)n.IsActive&&!n.IsEquality&&n.Lagrangian<i&&(e=n,i=n.Lagrangian);return null==e?null:this.SplitOnConstraint(e)}SplitOnConstraint(t){this.allConstraints.DeactivateConstraint(t);let e=new pn(null,this.allConstraints);return this.TransferConnectedVariables(e,t.Right,t.Left),e.Variables.length>0?(this.UpdateReferencePos(),e.UpdateReferencePos()):e=null,e}AddVariable(t){this.Variables.push(t),t.Block=this,1==this.Variables.length?(this.Scale=t.Scale,this.ReferencePos=t.ActualPos,this.sumAd=t.ActualPos*t.Weight,this.sumAb=0,this.sumA2=t.Weight,t.OffsetInBlock=0):this.AddVariableToBlockSums(t)}UpdateReferencePos(){this.Scale=this.Variables[0].Scale,this.sumAd=0,this.sumAb=0,this.sumA2=0;const t=this.Variables.length;for(let e=0;e<t;e++)this.AddVariableToBlockSums(this.Variables[e]);this.UpdateReferencePosFromSums()}AddVariableToBlockSums(t){const e=this.Scale/t.Scale,i=t.OffsetInBlock/t.Scale,n=e*t.Weight;this.sumAd=this.sumAd+n*t.DesiredPos,this.sumAb=this.sumAb+n*i,this.sumA2=this.sumA2+n*e}UpdateReferencePosFromSums(){if(!(Number.isFinite(this.sumAd)&&Number.isFinite(this.sumAb)&&Number.isFinite(this.sumA2)))throw new Error("infinite numbers");this.ReferencePos=(this.sumAd-this.sumAb)/this.sumA2,this.UpdateVariablePositions()}UpdateVariablePositions(){const t=this.Scale*this.ReferencePos,e=this.Variables.length;for(let i=0;i<e;i++){const e=this.Variables[i];e.ActualPos=(t+e.OffsetInBlock)/e.Scale}}GetConnectedVariables(t,e,i){this.RecurseGetConnectedVariables(t,e,i)}RecurseGetConnectedVariables(t,e,i){this.allConstraints.DfDvStack=new it.Stack;const n=new dn(e);for(this.dfDvDummyParentNode=new gn(n),this.allConstraints.DfDvStack.push(this.GetDfDvNode(this.dfDvDummyParentNode,n,e,i)),t.push(e);this.allConstraints.DfDvStack.length>0;){const e=this.allConstraints.DfDvStack.top,i=this.allConstraints.DfDvStack.length;if(!e.ChildrenHaveBeenPushed){e.ChildrenHaveBeenPushed=!0;for(const i of e.VariableToEval.LeftConstraints)i.IsActive&&i.Right!=e.VariableDoneEval&&(1==i.Right.ActiveConstraintCount?t.push(i.Right):this.AddVariableAndPushDfDvNode(t,this.GetDfDvNode(e,i,i.Right,e.VariableToEval)));for(const i of e.VariableToEval.RightConstraints)i.IsActive&&i.Left!=e.VariableDoneEval&&(1==i.Left.ActiveConstraintCount?t.push(i.Left):this.AddVariableAndPushDfDvNode(t,this.GetDfDvNode(e,i,i.Left,e.VariableToEval)))}this.allConstraints.DfDvStack.length>i||this.allConstraints.RecycleDfDvNode(this.allConstraints.DfDvStack.pop())}}TransferConnectedVariables(t,e,i){this.GetConnectedVariables(t.Variables,e,i);const n=t.Variables.length;for(let e=0;e<n;e++)t.Variables[e].Block=t;let r=this.Variables.length-1;for(let e=this.Variables.length-1;e>=0;e--){this.Variables[e].Block==t&&(e<r&&(this.Variables[e]=this.Variables[r]),r--)}if(this.Variables=this.Variables.slice(0,r+1),0==this.Variables.length){for(let e=0;e<n;e++){const i=t.Variables[e];this.Variables.push(i),i.Block=this}t.Variables=[]}}}class mn{constructor(){this.Vector=new Array}get Count(){return this.Vector.length}item(t){return this.Vector[t]}Add(t){t.VectorIndex=this.Vector.length,this.Vector.push(t)}Remove(t){const e=this.Vector[this.Vector.length-1];this.Vector[t.VectorIndex]=e,e.VectorIndex=t.VectorIndex,this.Vector.pop()}toString(){return this.Vector.toString()}}class yn{constructor(){this.nextConstraintIndex=0,this.DfDvStack=new it.Stack,this.DfDvRecycleStack=new it.Stack}get IsEmpty(){return null==this.Vector}Create(t){this.Vector=new Array(t),this.firstActiveConstraintIndex=t}Add(t){t.SetVectorIndex(this.nextConstraintIndex),this.Vector[this.nextConstraintIndex++]=t}ActivateConstraint(t){this.firstActiveConstraintIndex--,this.SwapConstraint(t)}DeactivateConstraint(t){this.SwapConstraint(t),this.firstActiveConstraintIndex++}SwapConstraint(t){const e=this.Vector[this.firstActiveConstraintIndex];e.SetVectorIndex(t.VectorIndex),this.Vector[t.VectorIndex]=e,this.Vector[this.firstActiveConstraintIndex]=t,t.SetActiveState(!t.IsActive,this.firstActiveConstraintIndex)}Reinitialize(){if(null!=this.Vector){for(const t of this.Vector)t.Reinitialize();this.firstActiveConstraintIndex=this.Vector.length}}RecycleDfDvNode(t){this.DfDvRecycleStack.length<1024&&this.DfDvRecycleStack.push(t)}toString(){return this.Vector.toString()}}class bn{constructor(){this.GapTolerance=1e-4,this.QpscConvergenceEpsilon=1e-5,this.QpscConvergenceQuotient=1e-6,this.OuterProjectIterationsLimit=-1,this.InnerProjectIterationsLimit=-1,this.TimeLimit=-1,this.Advanced=new Pn}Clone(){const t=this.MemberwiseClone();return t.Advanced=this.Advanced.Clone(),t}MemberwiseClone(){const t=new bn;return t.GapTolerance=this.GapTolerance,t.QpscConvergenceEpsilon=this.QpscConvergenceEpsilon,t.QpscConvergenceQuotient=this.QpscConvergenceQuotient,t.OuterProjectIterationsLimit=this.OuterProjectIterationsLimit,t.InnerProjectIterationsLimit=this.InnerProjectIterationsLimit,t.TimeLimit=this.TimeLimit,t}}class Pn{constructor(){this.ForceQpsc=!1,this.ScaleInQpsc=!0,this.MinSplitLagrangianThreshold=-1e-7,this.UseViolationCache=!0,this.ViolationCacheMinBlocksDivisor=10,this.ViolationCacheMinBlocksCount=100}Clone(){const t=new Pn;return t.ForceQpsc=this.ForceQpsc,t.ScaleInQpsc=this.ScaleInQpsc,t.MinSplitLagrangianThreshold=this.MinSplitLagrangianThreshold,t.UseViolationCache=this.UseViolationCache,t.ViolationCacheMinBlocksDivisor=this.ViolationCacheMinBlocksDivisor,t.ViolationCacheMinBlocksCount=this.ViolationCacheMinBlocksCount,t}}class vn{constructor(t){this.Variable=t,this.OrigWeight=t.Weight,this.OrigScale=t.Scale,this.OrigDesiredPos=this.Variable.DesiredPos}}class Sn{constructor(t,e){this.Value=t,this.Column=e}}class Cn{constructor(t,e){this.newMatrixRow=new Array,this.previousFunctionValue=Number.MAX_VALUE,this.solverParameters=this.solverParameters,this.matrixQ=new Array(e),this.vectorWiDi=new Array(e),this.vectorQpscVars=new Array(e),this.gradientVector=new Array(e),this.vectorQg=new Array(e),this.vectorPrevY=new Array(e),this.vectorCurY=new Array(e)}AddVariable(t){if(this.isFirstProjectCall=!0,this.vectorWiDi[t.Ordinal]=t.Weight*t.DesiredPos*2*-1,this.vectorPrevY[t.Ordinal]=t.Weight,null!=t.Neighbors)for(const e of t.Neighbors)this.vectorPrevY[t.Ordinal]=this.vectorPrevY[t.Ordinal]+e.Weight,this.vectorPrevY[e.Neighbor.Ordinal]=this.vectorPrevY[e.Neighbor.Ordinal]-e.Weight;for(let t=0;t<this.vectorPrevY.length;t++)0!=this.vectorPrevY[t]&&(this.newMatrixRow.push(new Sn(2*this.vectorPrevY[t],t)),this.vectorPrevY[t]=0);this.matrixQ[t.Ordinal]=Array.from(this.newMatrixRow),this.newMatrixRow=[],this.vectorQpscVars[t.Ordinal]=new vn(t),t.Weight=1}VariablesComplete(){for(const t of this.vectorQpscVars){const e=t.Variable;for(const t of this.matrixQ[e.Ordinal])t.Column==e.Ordinal&&(this.solverParameters.Advanced.ScaleInQpsc&&(e.Scale=1/Math.sqrt(Math.abs(t.Value)),Number.isFinite(e.Scale)||(e.Scale=1),e.Scale,this.vectorWiDi[e.Ordinal]=this.vectorWiDi[e.Ordinal]*e.Scale),this.vectorCurY[e.Ordinal]=e.ActualPos,e.DesiredPos=e.ActualPos)}if(this.solverParameters.Advanced.ScaleInQpsc)for(let t=0;t<this.matrixQ.length;t++){const e=this.matrixQ[t];for(let i=0;i<e.length;i++)e[i].Column==t?e[i].Value=1:e[i].Value=e[i].Value*(this.vectorQpscVars[t].Variable.Scale*this.vectorQpscVars[e[i].Column].Variable.Scale)}}PreProject(){if(this.isFirstProjectCall)for(const t of this.vectorQpscVars)this.vectorCurY[t.Variable.Ordinal]=t.Variable.ActualPos;if(this.MatrixVectorMultiply(this.vectorCurY,this.gradientVector),this.HasConverged())return!1;Cn.VectorVectorAdd(this.gradientVector,this.vectorWiDi,this.gradientVector);const t=Cn.VectorVectorMultiply(this.gradientVector,this.gradientVector);let e=0;if(0!=t&&(this.MatrixVectorMultiply(this.gradientVector,this.vectorQg),e=Cn.VectorVectorMultiply(this.vectorQg,this.gradientVector)),0==e)return!1;const i=t/e;Cn.VectorCopy(this.vectorPrevY,this.vectorCurY),Cn.VectorScaledVectorSubtract(this.vectorPrevY,i,this.gradientVector,this.vectorCurY);for(let t=0;t<this.vectorCurY.length;t++)this.vectorQpscVars[t].Variable.DesiredPos=this.vectorCurY[t];return!0}PostProject(){for(const t of this.vectorQpscVars)this.vectorCurY[t.Variable.Ordinal]=t.Variable.ActualPos;Cn.VectorVectorSubtract(this.vectorPrevY,this.vectorCurY,this.vectorCurY);const t=Cn.VectorVectorMultiply(this.gradientVector,this.vectorCurY);let e=0;if(0!=t){this.MatrixVectorMultiply(this.vectorCurY,this.vectorQg);const i=Cn.VectorVectorMultiply(this.vectorQg,this.vectorCurY);e=0==i?1:t/i,e>1?e=1:e<0&&(e=0)}return Cn.VectorScaledVectorSubtract(this.vectorPrevY,e,this.vectorCurY,this.vectorCurY),this.isFirstProjectCall=!1,e>0}QpscComplete(){for(const t of this.vectorQpscVars)t.Variable.Weight=t.OrigWeight,t.Variable.DesiredPos=t.OrigDesiredPos,this.solverParameters.Advanced.ScaleInQpsc&&(t.Variable.ActualPos=t.Variable.ActualPos*t.Variable.Scale,t.Variable.Scale=t.OrigScale);return this.previousFunctionValue}HasConverged(){const t=this.GetFunctionValue(this.vectorCurY);let e=!1;if(!this.isFirstProjectCall){const i=this.previousFunctionValue-t;let n=0;if(0!=i){const e=0!=this.previousFunctionValue?this.previousFunctionValue:t;n=Math.abs(i/e)}(Math.abs(i)<this.solverParameters.QpscConvergenceEpsilon||Math.abs(n)<this.solverParameters.QpscConvergenceQuotient)&&(e=!0)}return this.previousFunctionValue=t,e}GetFunctionValue(t){return Cn.VectorVectorMultiply(this.gradientVector,t)/2+Cn.VectorVectorMultiply(this.vectorWiDi,t)}static VectorVectorMultiply(t,e){let i=0;for(let n=0;n<t.length;n++)i+=t[n]*e[n];return i}MatrixVectorMultiply(t,e){let i=0;for(const n of this.matrixQ){let r=0;for(const e of n)r+=e.Value*t[e.Column];e[i++]=r}}static VectorVectorAdd(t,e,i){for(let n=0;n<t.length;n++)i[n]=t[n]+e[n]}static VectorVectorSubtract(t,e,i){for(let n=0;n<t.length;n++)i[n]=t[n]-e[n]}static VectorScaledVectorSubtract(t,e,i,n){for(let r=0;r<t.length;r++)n[r]=t[r]-e*i[r]}static VectorCopy(t,e){for(let i=0;i<e.length;i++)t[i]=e[i]}}class wn{get ExecutionLimitExceeded(){return this.TimeLimitExceeded||this.OuterProjectIterationsLimitExceeded||this.InnerProjectIterationsLimitExceeded}Clone(){const t=new wn;return t.GoalFunctionValue=this.GoalFunctionValue,t.InnerProjectIterationsLimitExceeded=this.InnerProjectIterationsLimitExceeded,t.InnerProjectIterationsTotal=this.InnerProjectIterationsTotal,t.MaxConstraintTreeDepth=this.MaxConstraintTreeDepth,t.OuterProjectIterations=this.OuterProjectIterations,t.OuterProjectIterationsLimitExceeded=this.OuterProjectIterationsLimitExceeded,t.AlgorithmUsed=this.AlgorithmUsed,t.NumberOfUnsatisfiableConstraints=this.NumberOfUnsatisfiableConstraints,t.MaxInnerProjectIterations=this.MaxInnerProjectIterations,t}}!function(t){t[t.ProjectOnly=0]="ProjectOnly",t[t.QpscWithScaling=1]="QpscWithScaling",t[t.QpscWithoutScaling=2]="QpscWithoutScaling"}(We||(We={}));class En{constructor(t,e){this.Neighbor=t,this.Weight=e}}class xn{constructor(t,e,i,n,r){if(this.ActiveConstraintCount=0,n<=0)throw new Error("weight");if(r<=0)throw new Error("scale");let s=i*n;if(!Number.isFinite(s)||Number.isNaN(s))throw new Error("desiredPos");if(s=i*r,!Number.isFinite(s)||Number.isNaN(s))throw new Error("desiredPos");this.Ordinal=t,this.UserData=e,this.DesiredPos=i,this.Weight=n,this.Scale=r,this.OffsetInBlock=0,this.ActualPos=this.DesiredPos}get DfDv(){return this.Weight*(this.ActualPos-this.DesiredPos)*2/this.Scale}Reinitialize(){this.ActiveConstraintCount=0,this.OffsetInBlock=0,this.ActualPos=this.DesiredPos}AddNeighbor(t,e){null==this.Neighbors&&(this.Neighbors=new Array),this.Neighbors.push(new En(t,e))}toString(){return _t.String.Format("{0} {1:F5} ({2:F5}) {3:F5} {4:F5}",this.Name,this.ActualPos,this.DesiredPos,this.Weight,this.Scale)}get Name(){return null==this.UserData?"-0-":this.UserData.toString()}SetConstraints(t,e){this.LeftConstraints=t,this.RightConstraints=e}CompareTo(t){return b(this.Ordinal,t.Ordinal)}}class An{get IsFull(){return this.numConstraints==An.MaxConstraints}Clear(){this.LowViolation=0,this.numConstraints=0,this.constraints||(this.constraints=new Array(An.MaxConstraints))}FilterBlock(t){this.LowViolation=Number.MAX_VALUE;const e=this.numConstraints>0;for(let e=this.numConstraints-1;e>=0;e--){const i=this.constraints[e];if(i.Left.Block==t||i.Right.Block==t||i.IsActive||i.IsUnsatisfiable)e<this.numConstraints-1&&(this.constraints[e]=this.constraints[this.numConstraints-1]),this.numConstraints--;else{const t=i.Left.ActualPos*i.Left.Scale+(i.Gap-i.Right.ActualPos*i.Right.Scale);t<this.LowViolation&&(this.LowViolation=t)}}return 0==this.numConstraints&&(this.LowViolation=0),e}FindIfGreater(t){let e=null;for(let i=0;i<this.numConstraints;i++){const n=this.constraints[i],r=n.Left.ActualPos*n.Left.Scale+(n.Gap-n.Right.ActualPos*n.Right.Scale);r>t&&(t=r,e=n)}return e}Insert(t,e){let i=0,n=e,r=e;for(let t=0;t<this.numConstraints;t++){const e=this.constraints[t],s=e.Left.ActualPos*e.Left.Scale+(e.Gap-e.Right.ActualPos*e.Right.Scale);s<n?(r=n,i=t,n=s):s<r&&(r=s)}this.IsFull?(this.constraints[i]=t,this.LowViolation=r):(this.constraints[this.numConstraints++]=t,this.IsFull&&(this.LowViolation=n))}}An.MaxConstraints=20;class Tn{constructor(t,e){this.NumberOfLeftConstraints=0,this.Constraints=t,this.NumberOfLeftConstraints=e}}class In{constructor(){this.allBlocks=new mn,this.allConstraints=new yn,this.numberOfConstraints=0,this.numberOfVariables=0,this.equalityConstraints=new Array,this.loadedVariablesAndConstraintLists=new Map,this.emptyConstraintList=new Array(0),this.updatedConstraints=new Array,this.violationCache=new An,this.violationCacheMinBlockCutoff=0,this.nextVariableOrdinal=0,this.solverParams=new bn,this.solverSolution=new wn}get IsQpsc(){return this.hasNeighbourPairs||this.solverParams.Advanced.ForceQpsc}AddVariableAN(t,e){return this.AddVariableANNN(t,e,1,1)}AddVariableANN(t,e,i){return this.AddVariableANNN(t,e,i,1)}AddVariableANNN(t,e,i,n){if(!this.allConstraints.IsEmpty)throw new Error("Cannot add Variables or Constraints once Solve() has been called");const r=new xn(this.nextVariableOrdinal++,t,e,i,n),s=new pn(r,this.allConstraints);return r.Block=s,this.allBlocks.Add(s),this.numberOfVariables++,this.loadedVariablesAndConstraintLists.set(r,new Tn(new Array,0)),r}UpdateVariables(){for(const t of this.allBlocks.Vector)t.UpdateReferencePos()}get Variables(){return be(this.allBlocks.Vector,t=>t.Variables)}get VariableCount(){return this.numberOfVariables}*Constraints(){if(this.allConstraints.IsEmpty)for(const t of this.loadedVariablesAndConstraintLists.keys()){const e=this.loadedVariablesAndConstraintLists.get(t);if(null!=e.Constraints){const i=e.Constraints.length;for(let n=0;n<i;n++){const i=e.Constraints[n];if(t==i.Left)return yield,i}}}else for(const t of this.allConstraints.Vector)yield t}get ConstraintCount(){return this.numberOfConstraints}AddEqualityConstraint(t,e,i){return this.AddConstraintVVNB(t,e,i,!0)}AddConstraintVVNB(t,e,i,n){if(!this.allConstraints.IsEmpty)throw new Error("Cannot add Variables or Constraints once Solve() has been called");if(t==e)throw new Error("Cannot add a constraint between a variable and itself");const r=this.loadedVariablesAndConstraintLists.get(t),s=this.loadedVariablesAndConstraintLists.get(e),o=dn.constructorVVNB(t,e,i,n);return this.loadedVariablesAndConstraintLists.set(t,new Tn(r.Constraints,r.NumberOfLeftConstraints+1)),r.Constraints.push(o),s.Constraints.push(o),this.numberOfConstraints++,n&&this.equalityConstraints.push(o),o}AddConstraint(t,e,i){return this.AddConstraintVVNB(t,e,i,!1)}SetConstraintUpdate(t,e){e!=t.Gap&&this.updatedConstraints.push([t,e])}AddNeighborPair(t,e,i){if(i<=0||Number.isNaN(i)||!Number.isFinite(i))throw new Error("relationshipWeight");if(t==e)throw new Error;t.AddNeighbor(e,i),e.AddNeighbor(t,i),this.hasNeighbourPairs=!0}Solve(){return this.SolvePar(null)}SolvePar(t){t&&(this.solverParams=t.Clone()),this.solverParams.OuterProjectIterationsLimit<0&&(this.solverParams.OuterProjectIterationsLimit=100*(Math.log2(this.numberOfVariables)+1)),this.solverParams.InnerProjectIterationsLimit<0&&(this.solverParams.InnerProjectIterationsLimit=2*this.numberOfConstraints+100*(Math.log2(this.numberOfConstraints)+1));const e=!this.allConstraints.IsEmpty;if(this.CheckForUpdatedConstraints(),this.solverSolution=new wn,this.solverSolution.MinInnerProjectIterations=Number.MAX_VALUE,this.allConstraints.MaxConstraintTreeDepth=0,this.allConstraints.SolverParameters=this.solverParams,0==this.numberOfConstraints){if(!this.IsQpsc)return this.solverSolution.Clone()}else e||this.SetupConstraints();return this.allConstraints.NumberOfUnsatisfiableConstraints=0,this.MergeEqualityConstraints(),this.IsQpsc?this.SolveQpsc():(this.SolveByStandaloneProject(),this.CalculateStandaloneProjectGoalFunctionValue()),this.solverSolution.MinInnerProjectIterations>this.solverSolution.MaxInnerProjectIterations&&(this.solverSolution.MinInnerProjectIterations=this.solverSolution.MaxInnerProjectIterations),this.solverSolution.NumberOfUnsatisfiableConstraints=this.allConstraints.NumberOfUnsatisfiableConstraints,this.solverSolution.MaxConstraintTreeDepth=this.allConstraints.MaxConstraintTreeDepth,this.solverSolution.Clone()}CheckForUpdatedConstraints(){if(0==this.updatedConstraints.length)return;let t=this.IsQpsc;for(const[e,i]of this.updatedConstraints){const n=e;n.UpdateGap(i),t||n.IsEquality?t=!0:this.SplitOnConstraintIfActive(n)}this.updatedConstraints=[],t&&this.ReinitializeBlocks()}SplitOnConstraintIfActive(t){if(t.IsActive){const e=t.Left.Block.SplitOnConstraint(t);null!=e&&this.allBlocks.Add(e)}}SetupConstraints(){this.allConstraints.Create(this.numberOfConstraints);for(const t of this.loadedVariablesAndConstraintLists.keys()){const e=this.loadedVariablesAndConstraintLists.get(t),i=e.Constraints;let n=0,r=0,s=0;null!=i&&(n=i.length,r=e.NumberOfLeftConstraints,s=n-r);let o=this.emptyConstraintList;0!=r&&(o=new Array(r));let a=this.emptyConstraintList;0!=s&&(a=new Array(s)),t.SetConstraints(o,a);let l=0,h=0;for(let e=0;e<n;e++){const n=i[e];t==n.Left?o[l++]=n:a[h++]=n}for(const e of t.LeftConstraints)this.allConstraints.Add(e)}this.loadedVariablesAndConstraintLists.clear(),this.violationCacheMinBlockCutoff=Number.MAX_VALUE,this.solverParams.Advanced.UseViolationCache&&this.solverParams.Advanced.ViolationCacheMinBlocksDivisor>0&&(this.violationCacheMinBlockCutoff=Math.min(this.allBlocks.Count/this.solverParams.Advanced.ViolationCacheMinBlocksDivisor,this.solverParams.Advanced.ViolationCacheMinBlocksCount))}SolveByStandaloneProject(){for(;;){let t;if(!this.RunProject(t))return;if(!this.SplitBlocks())break}}RunProject(t){return this.solverSolution.OuterProjectIterations++,this.Project(),!this.CheckForLimitsExceeded()}CheckForLimitsExceeded(){return this.solverParams.OuterProjectIterationsLimit>0&&this.solverSolution.OuterProjectIterations>=this.solverParams.OuterProjectIterationsLimit?(this.solverSolution.OuterProjectIterationsLimitExceeded=!0,!0):!!this.solverSolution.InnerProjectIterationsLimitExceeded}CalculateStandaloneProjectGoalFunctionValue(){this.solverSolution.GoalFunctionValue=0;const t=this.allBlocks.Count;for(let e=0;e<t;e++){const t=this.allBlocks.item(e),i=t.Variables.length;for(let e=0;e<i;e++){const i=t.Variables[e];this.solverSolution.GoalFunctionValue=this.solverSolution.GoalFunctionValue+i.Weight*(i.ActualPos*i.ActualPos),this.solverSolution.GoalFunctionValue=this.solverSolution.GoalFunctionValue-i.Weight*(i.DesiredPos*i.ActualPos)*2}}}SolveQpsc(){if(this.solverSolution.AlgorithmUsed=this.solverParams.Advanced.ScaleInQpsc?We.QpscWithScaling:We.QpscWithoutScaling,!this.QpscMakeFeasible())return;const t=new Cn(this.solverParams,this.numberOfVariables);for(const e of this.allBlocks.Vector)for(const i of e.Variables)t.AddVariable(i);t.VariablesComplete(),this.ReinitializeBlocks(),this.MergeEqualityConstraints();let e=!1;for(;(t.PreProject()||e)&&(e=this.SplitBlocks(),this.RunProject(!1))&&(t.PostProject()||e););this.solverSolution.GoalFunctionValue=t.QpscComplete()}QpscMakeFeasible(){return this.RunProject(void 0)}ReinitializeBlocks(){const t=Array.from(this.allBlocks.Vector);this.allBlocks.Vector=[];for(const e of t)for(const t of e.Variables){t.Reinitialize();const e=new pn(t,this.allConstraints);this.allBlocks.Add(e)}this.allConstraints.Reinitialize(),this.violationCache.Clear()}MergeEqualityConstraints(){for(const t of this.equalityConstraints)t.Left.Block!=t.Right.Block?this.MergeBlocks(t):Math.abs(t.Violation)>this.solverParams.GapTolerance&&(t.IsUnsatisfiable=!0,this.allConstraints.NumberOfUnsatisfiableConstraints++)}Project(){if(0==this.numberOfConstraints)return!1;this.violationCache.Clear(),this.lastModifiedBlock=null;let t=this.allBlocks.Count>this.violationCacheMinBlockCutoff,e=1;let i=this.GetMaxViolatedConstraint({maxViolation:0},t);if(!i)return!1;for(;i;){if(i.Left.Block==i.Right.Block?(i.Left.Block.Expand(i),i.IsUnsatisfiable&&this.violationCache.Clear(),this.lastModifiedBlock=i.Left.Block):this.lastModifiedBlock=this.MergeBlocks(i),this.solverParams.InnerProjectIterationsLimit>0&&e>=this.solverParams.InnerProjectIterationsLimit){this.solverSolution.InnerProjectIterationsLimitExceeded=!0;break}t=this.allBlocks.Count>this.violationCacheMinBlockCutoff,t||this.violationCache.Clear(),e++;const n={maxViolation:0};i=this.GetMaxViolatedConstraint(n,t)}return this.solverSolution.InnerProjectIterationsTotal=this.solverSolution.InnerProjectIterationsTotal+e,this.solverSolution.MaxInnerProjectIterations<e&&(this.solverSolution.MaxInnerProjectIterations=e),this.solverSolution.MinInnerProjectIterations>e&&(this.solverSolution.MinInnerProjectIterations=e),!0}MergeBlocks(t){let e=t.Left.Block,i=t.Right.Block,n=t.Left.OffsetInBlock+(t.Gap-t.Right.OffsetInBlock);i.Variables.length>e.Variables.length&&(e=t.Right.Block,i=t.Left.Block,n*=-1);const r=i.Variables.length;for(let t=0;t<r;t++){const r=i.Variables[t];r.OffsetInBlock=r.OffsetInBlock+n,e.AddVariable(r)}return e.UpdateReferencePosFromSums(),this.allConstraints.ActivateConstraint(t),this.allBlocks.Remove(i),e}SplitBlocks(){const t=new Array,e=this.allBlocks.Count;for(let i=0;i<e;i++){const e=this.allBlocks.item(i).Split(this.IsQpsc);null!=e&&t.push(e)}const i=t.length;for(let e=0;e<i;e++){const i=t[e];this.allBlocks.Add(i)}return 0!=t.length}GetMaxViolatedConstraint(t,e){t.maxViolation=this.solverParams.GapTolerance;const i=this.SearchViolationCache(t.maxViolation);return null!=i?i:this.SearchAllConstraints(t.maxViolation,e)}SearchViolationCache(t){let e=null;if(null==this.lastModifiedBlock)return;this.lastModifiedBlock.Variables.length<this.numberOfVariables+1&&this.violationCache.FilterBlock(this.lastModifiedBlock);const i=this.lastModifiedBlock.Variables.length;for(let n=0;n<i;n++){const i=this.lastModifiedBlock.Variables[n];for(const n of i.LeftConstraints)if(!n.IsActive&&!n.IsUnsatisfiable){S(n.Left.ActualPos*n.Left.Scale+(n.Gap-n.Right.ActualPos*n.Right.Scale),t)&&(null!=e&&t>this.violationCache.LowViolation&&this.violationCache.Insert(e,t),t=n.Violation,e=n)}for(const n of i.RightConstraints)if(!n.IsActive&&!n.IsUnsatisfiable&&n.Left.Block!=this.lastModifiedBlock){const i=n.Left.ActualPos*n.Left.Scale+(n.Gap-n.Right.ActualPos*n.Right.Scale);S(i,t)&&(null!=e&&t>this.violationCache.LowViolation&&this.violationCache.Insert(e,t),t=i,e=n)}}const n=this.violationCache.FindIfGreater(t);return null!=n&&(null!=e&&t>this.violationCache.LowViolation&&this.violationCache.Insert(e,t),e=n),e}SearchAllConstraints(t,e){let i=null;this.violationCache.Clear();for(const n of this.allConstraints.Vector){if(n.IsActive)break;if(n.IsUnsatisfiable)continue;const r=n.Left.ActualPos*n.Left.Scale+(n.Gap-n.Right.ActualPos*n.Right.Scale);let s=null,o=0;S(r,t)&&(t>this.violationCache.LowViolation&&(s=i,o=t),t=r,i=n),e&&(null==s&&n!=i&&(!this.violationCache.IsFull||r>this.violationCache.LowViolation)&&(s=n,o=r),null!=s&&o>this.violationCache.LowViolation&&this.violationCache.Insert(s,o))}return i}}class On{constructor(){this.variables=new Map,this.fixedVars=new Map,this.FailToAdjustEpsilon=.001,this.InitSolver()}AddVariableWithIdealPositionNNN(t,e,i){this.variables.set(t,this.solver.AddVariableANN(t,e,i))}AddVariableWithIdealPositionNN(t,e){this.AddVariableWithIdealPositionNNN(t,e,1)}AddLeftRightSeparationConstraintNNNB(t,e,i,n){const r=this.GetVariable(t);if(null==r)return;const s=this.GetVariable(e);null!=s&&this.solver.AddConstraintVVNB(r,s,i,n)}AddLeftRightSeparationConstraintNNN(t,e,i){this.AddLeftRightSeparationConstraintNNNB(t,e,i,!1)}AddGoalTwoVariablesAreCloseNNN(t,e,i){const n=this.GetVariable(t);if(null==n)return;const r=this.GetVariable(e);null!=r&&this.solver.AddNeighborPair(n,r,i)}AddGoalTwoVariablesAreClose(t,e){this.AddGoalTwoVariablesAreCloseNNN(t,e,1)}GetVariable(t){return this.variables.get(t)}Solve(){this.SolveP(null)}SolveP(t){this.SolvePNS(t,{executionLimitExceeded:!1})}SolvePNS(t,e){let i;do{this.solution=null;let n=null;if(null!=t&&(n=t,null==n))throw new Error("parameters");this.solution=this.solver.SolvePar(n),e.executionLimitExceeded=this.solution.ExecutionLimitExceeded,i=this.AdjustConstraintsForMovedFixedVars()}while(i&&0==this.solution.ExecutionLimitExceeded);return 0==this.solution.ExecutionLimitExceeded}AdjustConstraintsForMovedFixedVars(){const t=new Set;for(const[e,i]of this.fixedVars.entries())On.Close(i,this.GetVariableResolvedPosition(e))||t.add(e);return 0!=t.size&&this.AdjustConstraintsForMovedFixedVarSet(t)}static Close(t,e){return Math.abs(t-e)<5e-4}AdjustConstraintsForMovedFixedVarSet(t){for(;t.size>0;){let e;for(const i of t){e=i;break}if(!this.AdjustSubtreeOfFixedVar(e,t))return!1}return!0}AdjustSubtreeOfFixedVar(t,e){const i={successInAdjusting:!1},n=this.AdjustConstraintsOfNeighborsOfFixedVariable(t,i);if(!i.successInAdjusting)return!1;if(0==n.length)return!1;for(const t of n)e.delete(t);return!0}AdjustConstraintsOfNeighborsOfFixedVariable(t,e){const i=this.variables.get(t).Block.Variables,n=new Wt,r=new Wt;let s=1;for(const t of i)this.fixedVars.has(t.UserData)&&(n.AddValue(t.ActualPos),r.AddValue(t.DesiredPos),r.length>0&&(s=Math.max(s,n.length/r.length)));return 1==s&&(s=2),e.successInAdjusting=this.FixActiveConstraints(i,s),i.map(t=>t.UserData)}FixActiveConstraints(t,e){let i=!1;for(const n of t)for(const t of n.LeftConstraints)t.IsActive&&(t.Gap>this.FailToAdjustEpsilon&&(i=!0),this.solver.SetConstraintUpdate(t,t.Gap/e));return i}GetVariableResolvedPosition(t){const e=this.GetVariable(t);return null==e?0:e.ActualPos}InitSolver(){this.solver=new In,this.variables.clear()}AddFixedVariable(t,e){this.AddVariableWithIdealPositionNNN(t,e,On.FixedVarWeight),this.fixedVars.set(t,e)}ContainsVariable(t){return this.variables.has(t)}GetVariableIdealPosition(t){return this.variables.get(t).DesiredPos}get Solution(){return this.solution}}On.FixedVarWeight=1e9;class _n{constructor(){this.lowBound=Number.NEGATIVE_INFINITY,this.upperBound=Number.POSITIVE_INFINITY}get Position(){return this.position}set Position(t){t<this.lowBound?this.position=this.lowBound:t>this.upperBound?this.position=this.upperBound:this.position=t}get LowBound(){return this.lowBound}set LowBound(t){this.lowBound=t}get UpperBound(){return this.upperBound}set UpperBound(t){this.upperBound=t}toString(){return this.lowBound+" "+this.Position+" "+this.upperBound}}class Ln{constructor(t){this.idealPositions=new Map,this.varList=new Array,this.constraints=new Set,this.solverShell=new On,this.boundsToInt=new Map,this.varSepartion=t}SetLowBound(t,e){const i=this.Var(e);i.LowBound=Math.max(t,i.LowBound)}Var(t){return this.varList[t]}SetUpperBound(t,e){const i=this.Var(t);i.UpperBound=Math.min(e,i.UpperBound)}Solve(){this.SolveByRegularSolver()}SolveByRegularSolver(){this.CreateVariablesForBounds();for(let t=0;t<this.varList.length;t++){const e=this.varList[t];e.IsFixed?this.solverShell.AddFixedVariable(t,e.Position):(this.solverShell.AddVariableWithIdealPositionNN(t,this.idealPositions.get(t)),e.LowBound!=Number.NEGATIVE_INFINITY&&this.constraints.add(new wt(this.GetBoundId(e.LowBound),t)),e.UpperBound!=Number.POSITIVE_INFINITY&&this.constraints.add(new wt(t,this.GetBoundId(e.UpperBound))))}this.CreateGraphAndRemoveCycles();for(const t of this.graph.edges){let e=0;t.x<this.varList.length&&(e+=this.varList[t.x].Width),t.y<this.varList.length&&(e+=this.varList[t.y].Width),e/=2,this.solverShell.AddLeftRightSeparationConstraintNNN(t.x,t.y,this.varSepartion+e)}this.solverShell.Solve();for(let t=0;t<this.varList.length;t++)this.varList[t].Position=this.solverShell.GetVariableResolvedPosition(t)}GetBoundId(t){return this.boundsToInt.get(t)}CreateVariablesForBounds(){for(const t of this.varList)t.IsFixed||(t.LowBound!=Number.NEGATIVE_INFINITY&&this.RegisterBoundVar(t.LowBound),t.UpperBound!=Number.POSITIVE_INFINITY&&this.RegisterBoundVar(t.UpperBound))}RegisterBoundVar(t){if(!this.boundsToInt.has(t)){const e=this.varList.length+this.boundsToInt.size;this.boundsToInt.set(t,e),this.solverShell.AddFixedVariable(e,t)}}CreateGraphAndRemoveCycles(){this.graph=St(Array.from(this.constraints),this.varList.length+this.boundsToInt.size);const t=At.getFeedbackSet(this.graph);if(null!=t)for(const e of t)this.graph.removeEdge(e)}GetVariablePosition(t){return this.varList[t].Position}AddConstraint(t,e){this.constraints.add(new wt(t,e))}AddVariableNNNN(t,e,i,n){this.idealPositions.set(t,i),this.AddVariableNNBN(t,e,!1,n)}AddFixedVariable(t,e){this.AddVariableNNBN(t,e,!0,0)}AddVariableNNBN(t,e,i,n){const r=new _n;r.Position=e,r.IsFixed=i,r.Width=n,this.varList.push(r)}}class Rn extends hi{constructor(t,e){super(t,e),this.RightNeighbors=new Set,this.setOfLongestSegs=new Set,this.RightBound=Number.POSITIVE_INFINITY,this.LeftBound=Number.NEGATIVE_INFINITY,this.Direction=W.DirectionFromPointToPoint(t.point,e.point)}AddRightNeighbor(t){this.RightNeighbors.add(t)}get LongestNudgedSegments(){return this.setOfLongestSegs}AddLongestNudgedSegment(t){this.setOfLongestSegs.add(t)}BoundFromRight(t){t=Math.max(t,this.LeftBound),this.RightBound=Math.min(t,this.RightBound)}BoundFromLeft(t){t=Math.min(t,this.RightBound),this.LeftBound=Math.max(t,this.LeftBound)}}class Bn{constructor(t){this.Point=t}*GetEnumerator(){let t;for(t=this;null!=t;t=t.Next)yield t.Point}get X(){return this.Point.x}get Y(){return this.Point.y}InsertVerts(t,e,i){for(e--;t<e;e--)this.SetNewNext(i[e])}InsertVertsInReverse(t,e,i){for(t++;t<e;t++)this.SetNewNext(i[t])}SetNewNext(t){const e=new Bn(t),i=this.Next;this.Next=e,e.Next=i}}class Mn{constructor(t,e){this.IsFixed=!1,this.Reversed=!1,this.index=-1,this.AxisEdge=t,this.Width=e}toString(){return this.Source+" "+this.Target}get LongestNudgedSegment(){return this.longestNudgedSegment}set LongestNudgedSegment(t){this.longestNudgedSegment=t,null!=this.longestNudgedSegment&&(this.longestNudgedSegment.AddEdge(this),this.AxisEdge.AddLongestNudgedSegment(this.longestNudgedSegment))}get Source(){return this.Reversed?this.AxisEdge.TargetPoint:this.AxisEdge.SourcePoint}get Target(){return this.Reversed?this.AxisEdge.SourcePoint:this.AxisEdge.TargetPoint}static VectorsAreParallel(t,e){return v(t.x*e.y-t.y*e.x,0)}static EdgesAreParallel(t,e){return Mn.VectorsAreParallel(t.AxisEdge.TargetPoint.sub(t.AxisEdge.SourcePoint),e.AxisEdge.TargetPoint.sub(e.AxisEdge.SourcePoint))}get Direction(){return this.Reversed?W.OppositeDir(this.AxisEdge.Direction):this.AxisEdge.Direction}get Index(){return this.index}set Index(t){this.index=t}}class Fn{constructor(t){this.pathVisibilityGraph=new di,this.axisEdgesToPathOrders=new Map,this.OriginalPaths=t}get PathVisibilityGraph(){return this.pathVisibilityGraph}GetOrder(){return this.FillTheVisibilityGraphByWalkingThePaths(),this.InitPathOrder(),this.OrderPaths(),this.axisEdgesToPathOrders}FillTheVisibilityGraphByWalkingThePaths(){for(const t of this.OriginalPaths)this.FillTheVisibilityGraphByWalkingPath(t)}FillTheVisibilityGraphByWalkingPath(t){const e=this.CreatePathEdgesFromPoints(function*(){if(t.PathPoints instanceof Bn)for(let e=t.PathPoints;null!=e;e=e.Next)yield e.Point;else for(const e of t.PathPoints)yield e}(),t.Width);let i=e.next();for(i.done||t.SetFirstEdge(i.value);0==(i=e.next()).done;)t.AddEdge(i.value)}*CreatePathEdgesFromPoints(t,e){let i=t.next(),n=i.value;for(;!(i=t.next()).done;)yield this.CreatePathEdge(n,i.value,e),n=i.value}CreatePathEdge(t,e,i){switch(W.DirectionFromPointToPoint(t,e)){case l.East:case l.North:return new Mn(this.GetAxisEdge(t,e),i);case l.South:case l.West:{const n=new Mn(this.GetAxisEdge(e,t),i);return n.Reversed=!0,n}default:throw new Error("Not a rectilinear path")}}GetAxisEdge(t,e){return this.PathVisibilityGraph.AddEdgeF(t,e,(t,e)=>new Rn(t,e))}InitPathOrder(){for(const t of this.PathVisibilityGraph.Edges)this.axisEdgesToPathOrders.set(t,new Array);for(const t of this.OriginalPaths)for(const e of t.PathEdges())this.axisEdgesToPathOrders.get(e.AxisEdge).push(e)}OrderPaths(){for(const t of Fn.WalkGraphEdgesInTopologicalOrderIfPossible(this.PathVisibilityGraph))this.OrderPathEdgesSharingEdge(t)}OrderPathEdgesSharingEdge(t){const e=this.PathOrderOfVisEdge(t);e.sort(Fn.CompareTwoPathEdges);let i=0;for(const t of e)t.Index=i++}static CompareTwoPathEdges(t,e){if(t==e)return 0;const i=Fn.CompareInDirectionStartingFromAxisEdge(t,e,t.AxisEdge,t.AxisEdge.Direction);return 0!=i?i:-Fn.CompareInDirectionStartingFromAxisEdge(t,e,t.AxisEdge,W.OppositeDir(t.AxisEdge.Direction))}static CompareInDirectionStartingFromAxisEdge(t,e,i,n){for(;;){if(null==(t=Fn.GetNextPathEdgeInDirection(t,i,n)))return 0;if(null==(e=Fn.GetNextPathEdgeInDirection(e,i,n)))return 0;if(t.AxisEdge==e.AxisEdge){n=Fn.FindContinuedDirection(i,n,t.AxisEdge),i=t.AxisEdge;const r=Fn.GetExistingOrder(t,e);if(r==Fn.NotOrdered)continue;return n==i.Direction?r:-r}const r=n==i.Direction?i.Target:i.Source,s=Fn.OtherVertex(t.AxisEdge,r),o=Fn.OtherVertex(e.AxisEdge,r),a=Fn.ProjectionForCompare(i,n!=i.Direction);return b(a(s.point),a(o.point))}}static FindContinuedDirection(t,e,i){return t.Direction==e?i.Source==t.Target?i.Direction:W.OppositeDir(i.Direction):i.Source==t.Source?i.Direction:W.OppositeDir(i.Direction)}static OtherVertex(t,e){return t.Source==e?t.Target:t.Source}static ProjectionForCompare(t,e){return t.Direction==l.North?e?t=>-t.x:t=>t.x:e?t=>t.y:t=>-t.y}static GetNextPathEdgeInDirection(t,e,i){return e.Direction==i?t.Reversed?t.Prev:t.Next:t.Reversed?t.Next:t.Prev}static GetExistingOrder(t,e){const i=t.Index;if(-1==i)return Fn.NotOrdered;return b(i,e.Index)}PathOrderOfVisEdge(t){return this.axisEdgesToPathOrders.get(t)}static InitQueueOfSources(t,e,i){for(const n of i.Vertices()){const i=n.InEdgesLength();e.set(n,i),0==i&&t.enqueue(n)}}static*WalkGraphEdgesInTopologicalOrderIfPossible(t){const e=new h.Queue,i=new Map;for(Fn.InitQueueOfSources(e,i,t);e.length>0;){const t=e.dequeue();for(const n of t.OutEdges){const t=i.get(n.Target);i.set(n.Target,t-1),1==t&&e.enqueue(n.Target),yield n}}}}Fn.NotOrdered=Number.MAX_VALUE;class Dn extends ni{constructor(t,e){super(),this.site=e,this.AxisEdge=t}get Site(){return this.site}}class Nn extends ni{constructor(t,e){super(),this.site=e,this.AxisEdge=t}get Site(){return this.site}}class kn{constructor(t){this.edges=new Set,this.Source=t}get Edges(){return this.edges}AddEdge(t){this.UpPoint=t.TargetPoint,this.edges.add(t)}RemoveAxis(t){this.edges.delete(t)}IsEmpty(){return 0==this.edges.size}}class Vn extends li{constructor(t,e,i,n,r){super(e,new W(t).ToPoint()),this.DirectionPerp=new W(t).Right.ToPoint(),this.PathOrders=n,this.xProjection=t==l.North?t=>t.x:t=>-t.y,this.edgeContainersTree=new ei((t,e)=>this.CompareAA(t,e)),this.SweepPole=W.VectorDirection(this.SweepDirection),this.AxisEdges=r,this.AxisEdgesToObstaclesTheyOriginatedFrom=i}FindFreeSpace(){this.InitTheQueueOfEvents(),this.ProcessEvents()}ProcessEvents(){for(;this.EventQueue.Count>0;)this.ProcessEvent(this.EventQueue.Dequeue())}ProcessEvent(t){t instanceof ri?this.ProcessVertexEvent(t):(this.Z=this.GetZP(t.Site),t instanceof Nn?this.ProcessLowEdgeEvent(t):this.ProcessHighEdgeEvent(t))}ProcessHighEdgeEvent(t){const e=t.AxisEdge;this.RemoveEdge(e),this.ConstraintEdgeWithObstaclesAtZ(e,e.Target.point)}ProcessLowEdgeEvent(t){const e=t.AxisEdge,i=this.GetOrCreateAxisEdgesContainer(e);i.item.AddEdge(e);const n=this.edgeContainersTree.previous(i);if(null!=n)for(const t of n.item.edges)for(const e of i.item.edges)this.TryToAddRightNeighbor(t,e);const r=this.edgeContainersTree.next(i);if(null!=r)for(const t of i.item.Edges)for(const e of r.item.edges)this.TryToAddRightNeighbor(t,e);this.ConstraintEdgeWithObstaclesAtZ(e,e.Source.point)}TryToAddRightNeighbor(t,e){this.ProjectionsOfEdgesOverlap(t,e)&&t.AddRightNeighbor(e)}ProjectionsOfEdgesOverlap(t,e){return this.SweepPole==l.North?!(t.TargetPoint.y<e.SourcePoint.y-y.distanceEpsilon||e.TargetPoint.y<t.SourcePoint.y-y.distanceEpsilon):!(t.TargetPoint.x<e.SourcePoint.x-y.distanceEpsilon||e.TargetPoint.x<t.SourcePoint.x-y.distanceEpsilon)}GetObstacleBoundaries(t){return this.Obstacles.map(e=>Xe.mkDebugCurveWCI(1,t,e))}ConstraintEdgeWithObstaclesAtZ(t,e){this.ConstraintEdgeWithObstaclesAtZFromLeft(t,e),this.ConstraintEdgeWithObstaclesAtZFromRight(t,e)}ConstraintEdgeWithObstaclesAtZFromRight(t,e){const i=this.GetActiveSideFromRight(e);if(null==i)return;if(this.NotRestricting(t,i.item.Polyline))return;const n=this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(i.item);t.BoundFromRight(n.dot(this.DirectionPerp))}GetActiveSideFromRight(t){return this.LeftObstacleSideTree.findFirst(e=>Vn.PointToTheLeftOfLineOrOnLineLocal(t,e.Start,e.End))}ConstraintEdgeWithObstaclesAtZFromLeft(t,e){const i=this.GetActiveSideFromLeft(e);if(null==i)return;if(this.NotRestricting(t,i.item.Polyline))return;const n=this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(i.item);t.BoundFromLeft(n.dot(this.DirectionPerp))}static PointToTheLeftOfLineOrOnLineLocal(t,e,i){return E.signedDoubledTriangleArea(t,e,i)>-Vn.AreaComparisonEpsilon}static PointToTheRightOfLineOrOnLineLocal(t,e,i){return E.signedDoubledTriangleArea(e,i,t)<Vn.AreaComparisonEpsilon}GetActiveSideFromLeft(t){return this.RightObstacleSideTree.findLast(e=>Vn.PointToTheRightOfLineOrOnLineLocal(t,e.Start,e.End))}static EdgeMidPoint(t){return E.middle(t.SourcePoint,t.TargetPoint)}GetOrCreateAxisEdgesContainer(t){const e=t.Source.point,i=this.GetAxisEdgesContainerNode(e);return null!=i?i:this.edgeContainersTree.insert(new kn(e))}GetAxisEdgesContainerNode(t){const e=this.xProjection(t),i=this.edgeContainersTree.findFirst(t=>this.xProjection(t.Source)>=e-y.distanceEpsilon/2);return null!=i&&this.xProjection(i.item.Source)<=e+y.distanceEpsilon/2?i:null}ProcessVertexEvent(t){this.Z=this.GetZS(t),t instanceof Ei?this.ProcessLeftVertex(t,t.Vertex.nextOnPolyline):(t instanceof Ti||this.ProcessLeftVertex(t,t.Vertex.nextOnPolyline),this.ProcessRightVertex(t,t.Vertex.prevOnPolyline))}ProcessRightVertex(t,e){const i=t.Site;this.ProcessPrevSegmentForRightVertex(t,i);const n=e.point.sub(t.Site),r=n.dot(this.DirectionPerp),s=n.dot(this.SweepDirection);s<=y.distanceEpsilon?r>0&&s>=0?this.EnqueueEvent(new Ti(e)):this.RestrictEdgeContainerToTheRightOfEvent(t.Vertex):(this.InsertRightSide(new Ai(t.Vertex)),this.EnqueueEvent(new Ti(e)),this.RestrictEdgeContainerToTheRightOfEvent(t.Vertex))}RestrictEdgeContainerToTheRightOfEvent(t){const e=t.point,i=this.xProjection(e),n=this.edgeContainersTree.findFirst(t=>i<=this.xProjection(t.Source));if(null!=n)for(const i of n.item.Edges)this.NotRestricting(i,t.polyline)||i.BoundFromLeft(this.DirectionPerp.dot(e))}NotRestricting(t,e){return this.AxisEdgesToObstaclesTheyOriginatedFrom.get(t)==e}ProcessPrevSegmentForRightVertex(t,e){const i=t.Vertex.nextOnPolyline.point;e.sub(i).dot(this.SweepDirection)>y.distanceEpsilon&&this.RemoveRightSide(new Ai(t.Vertex.nextOnPolyline))}RemoveEdge(t){const e=this.GetAxisEdgesContainerNode(t.Source.point);e.item.RemoveAxis(t),e.item.IsEmpty()&&this.edgeContainersTree.deleteNodeInternal(e)}ProcessLeftVertex(t,e){const i=t.Site;this.ProcessPrevSegmentForLeftVertex(t,i);const n=e.point.sub(t.Site),r=n.dot(this.DirectionPerp),s=n.dot(this.SweepDirection);s<=y.distanceEpsilon?r<0&&s>=0&&this.EnqueueEvent(new Ei(e)):(this.InsertLeftSide(new wi(t.Vertex)),this.EnqueueEvent(new Ei(e))),this.RestrictEdgeFromTheLeftOfEvent(t.Vertex)}RestrictEdgeFromTheLeftOfEvent(t){const e=t.point,i=this.GetContainerNodeToTheLeftOfEvent(e);if(null!=i)for(const n of i.item.Edges)this.NotRestricting(n,t.polyline)||n.BoundFromRight(e.dot(this.DirectionPerp))}GetContainerNodeToTheLeftOfEvent(t){const e=this.xProjection(t);return this.edgeContainersTree.findLast(t=>this.xProjection(t.Source)<=e)}ProcessPrevSegmentForLeftVertex(t,e){const i=t.Vertex.prevOnPolyline.point;e.sub(i).dot(this.SweepDirection)>y.distanceEpsilon&&this.RemoveLeftSide(new wi(t.Vertex.prevOnPolyline))}InitTheQueueOfEvents(){this.InitQueueOfEvents();for(const t of this.AxisEdges)this.EnqueueEventsForEdge(t)}EnqueueEventsForEdge(t){this.EdgeIsParallelToSweepDir(t)&&(this.EnqueueEvent(Vn.EdgeLowPointEvent(t,t.Source.point)),this.EnqueueEvent(Vn.EdgeHighPointEvent(t,t.Target.point)))}EdgeIsParallelToSweepDir(t){return t.Direction==this.SweepPole||t.Direction==W.OppositeDir(this.SweepPole)}static EdgeHighPointEvent(t,e){return new Dn(t,e)}static EdgeLowPointEvent(t,e){return new Nn(t,e)}CompareAA(t,e){return b(t.Source.dot(this.DirectionPerp),e.Source.dot(this.DirectionPerp))}}Vn.AreaComparisonEpsilon=y.intersectionEpsilon;class Gn extends Si{constructor(t){super(),this.CompassDirection=l.None,this.edges=new Array,this._isFixed=!1,this.Id=-1,this.IdealPosition=0,this.Id=t}get Start(){return this.start}get End(){return this.end}get Edges(){return this.edges}AddEdge(t){if(0==this.Edges.length){let e=W.VectorDirectionPP(t.Source,t.Target);switch(e){case l.South:e=l.North;break;case l.West:e=l.East}this.CompassDirection=e,this.start=t.Source,this.end=t.Source}switch(this.CompassDirection){case l.North:this.TryPointForStartAndEndNorth(t.Source),this.TryPointForStartAndEndNorth(t.Target);break;case l.East:this.TryPointForStartAndEndEast(t.Source),this.TryPointForStartAndEndEast(t.Target)}this.Edges.push(t)}TryPointForStartAndEndNorth(t){t.y<this.start.y?this.start=t:t.y>this.end.y&&(this.end=t)}TryPointForStartAndEndEast(t){t.x<this.start.x?this.start=t:t.x>this.end.x&&(this.end=t)}get IsFixed(){return this._isFixed}set IsFixed(t){this._isFixed=t}get Width(){let t=0;for(const e of this.edges)t=Math.max(t,e.Width);return t}GetLeftBound(){if(!this.IsFixed){let t=Number.NEGATIVE_INFINITY;for(const e of this.edges)t=Math.max(t,e.AxisEdge.LeftBound);return t}return this.CompassDirection==l.North?this.Edges[0].Source.x:-this.Edges[0].Source.y}GetRightBound(){if(!this.IsFixed){let t=Number.POSITIVE_INFINITY;for(const e of this.edges)t=Math.min(t,e.AxisEdge.RightBound);return t}return this.Position()}Position(){return this.CompassDirection==l.North?this.Edges[0].Source.x:-this.Edges[0].Source.y}}class zn{constructor(t,e){this.tree=new ei((t,e)=>b(t.Point.x,e.Point.x)),this.VerticalPoints=e,this.HorizontalPoints=t}SplitPoints(){0!=this.VerticalPoints.length&&0!=this.HorizontalPoints.length&&(this.InitEventQueue(),this.ProcessEvents())}ProcessEvents(){for(;!this.Queue.IsEmpty();){const t={priority:0},e=this.Queue.DequeueAndGetPriority(t);this.ProcessEvent(e,t.priority)}}ProcessEvent(t,e){v(t.Next.Point.x,t.Point.x)?e==zn.Low(t)?this.ProcessLowLinkedPointEvent(t):this.ProcessHighLinkedPointEvent(t):this.IntersectWithTree(t)}IntersectWithTree(t){let e,i,n;const r=t.Y;if(t.Point.x<t.Next.Point.x?(i=t.Point.x,e=t.Next.Point.x,n=!0):(e=t.Point.x,i=t.Next.Point.x,n=!1),n)for(let n=this.tree.findFirst(t=>i<=t.Point.x);null!=n&&n.item.Point.x<=e;n=this.tree.next(n)){const e=new E(n.item.Point.x,r);t=zn.TrySplitHorizontalPoint(t,e,!0),zn.TrySplitVerticalPoint(n.item,e)}else for(let n=this.tree.findLast(t=>t.Point.x<=e);null!=n&&n.item.Point.x>=i;n=this.tree.previous(n)){const e=new E(n.item.Point.x,r);t=zn.TrySplitHorizontalPoint(t,e,!1),zn.TrySplitVerticalPoint(n.item,e)}}static TrySplitVerticalPoint(t,e){zn.Low(t)+y.distanceEpsilon<e.y&&e.y+y.distanceEpsilon<zn.High(t)&&t.SetNewNext(e)}static TrySplitHorizontalPoint(t,e,i){return i&&t.X+y.distanceEpsilon<e.x&&e.x+y.distanceEpsilon<t.Next.X||!i&&t.Next.X+y.distanceEpsilon<e.x&&e.x+y.distanceEpsilon<t.X?(t.SetNewNext(e),t.Next):t}ProcessHighLinkedPointEvent(t){this.tree.remove(t)}ProcessLowLinkedPointEvent(t){this.tree.insert(t)}InitEventQueue(){this.Queue=new Qi(b);for(const t of this.VerticalPoints)this.Queue.Enqueue(t,zn.Low(t));for(const t of this.HorizontalPoints)this.Queue.Enqueue(t,t.Point.y)}static Low(t){return Math.min(t.Point.y,t.Next.Point.y)}static High(t){return Math.max(t.Point.y,t.Next.Point.y)}}class jn{constructor(t){this.verticesToPathOffsets=new Ie,this.Paths=t}MergePaths(){this.InitVerticesToPathOffsetsAndRemoveSelfCycles();for(const t of this.Paths)this.ProcessPath(t)}ProcessPath(t){const e=new Map;let i=null;for(let n=t.PathPoints;null!=n;n=n.Next){const r=this.verticesToPathOffsets.get(n.Point);if(null!=i){if(e.size>0)for(const[i,s]of r){const r=e.get(i);r&&(this.CollapseLoopingPath(i,r,s,t,n),e.delete(i))}for(const[t,n]of i)r.has(t)||e.set(t,n)}i=r}}CollapseLoopingPath(t,e,i,n,r){const s=jn.FindLinkedPointInPath(n,e.Point),o=Array.from(jn.GetPointsInBetween(s,r));jn.Before(e,i)?(this.CleanDisappearedPiece(e,i,t),this.ReplacePiece(e,i,o,t)):(this.CleanDisappearedPiece(i,e,t),this.ReplacePiece(i,e,o.reverse(),t))}static*GetPointsInBetween(t,e){for(let i=t.Next;i!=e;i=i.Next)yield i.Point}ReplacePiece(t,e,i,n){let r=t;for(const t of i){const e=new Bn(t);r.Next=e,r=e;this.verticesToPathOffsets.get(t).set(n,r)}r.Next=e}CleanDisappearedPiece(t,e,i){for(const n of jn.GetPointsInBetween(t,e)){this.verticesToPathOffsets.get(n).delete(i)}}static Before(t,e){for(t=t.Next;null!=t;t=t.Next)if(t==e)return!0;return!1}static FindLinkedPointInPath(t,e){for(let i=t.PathPoints;;i=i.Next)if(i.Point.equal(e))return i}InitVerticesToPathOffsetsAndRemoveSelfCycles(){for(const t of this.Paths)for(let e=t.PathPoints;null!=e;e=e.Next){let i=this.verticesToPathOffsets.get(e.Point);i||this.verticesToPathOffsets.set(e.Point,i=new Map);const n=i.get(t);n?(this.CleanDisappearedPiece(n,e,t),n.Next=e.Next):i.set(t,e)}}}class Un{constructor(t){this.projection=t}compare(t,e){return b(this.projection(t),this.projection(e))}}class Wn{static RefinePaths(t,e){Wn.AdjustPaths(t);const i=Wn.CreatePathsToFirstLinkedVerticesMap(t);Wn.Refine(Array.from(i.values())),Wn.CrossVerticalAndHorizontalSegs(i.values()),Wn.ReconstructPathsFromLinkedVertices(i),e&&new jn(t).MergePaths()}static AdjustPaths(t){for(const e of t)e.PathPoints=Wn.AdjustPathPoints(e.PathPoints)}static AdjustPathPoints(t){if(!t||0==t.length)return;const e=[];let i=y.RoundPoint(t[0]);e.push(i);for(let n=1;n<t.length;n++){const r=y.RoundPoint(t[n]);i.equal(r)||(i=r,e.push(i))}return e}static CrossVerticalAndHorizontalSegs(t){const e=new Array,i=new Array;for(const n of t)for(let t=n;null!=t.Next;t=t.Next)v(t.Point.x,t.Next.Point.x)?i.push(t):e.push(t);new zn(e,i).SplitPoints()}static ReconstructPathsFromLinkedVertices(t){for(const[e,i]of t)e.PathPoints=i}static Refine(t){Wn.RefineInDirection(l.North,t),Wn.RefineInDirection(l.East,t)}static*groupByProj(t,e){const i=new Map;for(const n of e){const e=t(n.Point);let r=i.get(e);r||(r=new Array,i.set(e,r)),r.push(n)}for(const t of i.values())yield t}static RefineInDirection(t,e){const i={projectionToPerp:void 0,projectionToDirection:void 0};Wn.GetProjectionsDelegates(t,i);const n=Array.from(Wn.GetAllLinkedVertsInDirection(i.projectionToPerp,e)),r=Wn.groupByProj(i.projectionToPerp,n);for(const t of r)Wn.RefineCollinearBucket(t,i.projectionToDirection)}static GetProjectionsDelegates(t,e){t==l.East?(e.projectionToDirection=t=>t.x,e.projectionToPerp=t=>t.y):(e.projectionToPerp=t=>t.x,e.projectionToDirection=t=>t.y)}static*GetAllLinkedVertsInDirection(t,e){for(const i of e)for(let e=i;null!=e.Next;e=e.Next)v(t(e.Point),t(e.Next.Point))&&(yield e)}static RefineCollinearBucket(t,e){const i=new Kt.SortedMap(new Un(e));for(const e of t)i.has(e.Point)||i.set(e.Point,0),i.has(e.Next.Point)||i.set(e.Next.Point,0);const n=new Array(i.size);let r=0;for(const t of i.keys())n[r++]=t;for(r=0;r<n.length;r++)i.set(n[r],r);for(const e of t){r=i.get(e.Point);const t=i.get(e.Next.Point);Math.abs(t-r)>1&&Wn.InsertPoints(e,n,r,t)}}static InsertPoints(t,e,i,n){i<n?t.InsertVerts(i,n,e):t.InsertVertsInReverse(n,i,e)}static CreatePathsToFirstLinkedVerticesMap(t){const e=new Map;for(const i of t)e.set(i,Wn.CreateLinkedVertexOfEdgePath(i));return e}static CreateLinkedVertexOfEdgePath(t){const e=t.PathPoints;let i=new Bn(e[0]);const n=i;for(let t=1;t<e.length;t++)i.Next=new Bn(e[t]),i=i.Next;return n}}class Hn{constructor(t,e){this.Points=t,this.I=e}static equal(t,e){return t.I==e.I&&t.Points==e.Points}get Start(){return this.Points[this.I]}get End(){return this.Points[this.I+1]}}class qn{constructor(t,e){this.segTree=new pt(null),this.crossedOutPaths=new Set,this.HierarchyOfObstacles=new pt(e),this.Paths=t}static RemoveStaircases(t,e){new qn(t,e).Calculate()}Calculate(){let t;this.InitHierarchies();do{t=!1;for(const e of this.Paths.filter(t=>!this.crossedOutPaths.has(t)))this.ProcessPath(e)&&(t=!0)}while(t)}ProcessPath(t){const e={pts:t.PathPoints,canHaveStaircase:!1};return this.ProcessPoints(e)?(t.PathPoints=e.pts,!0):(e.canHaveStaircase||this.crossedOutPaths.add(t),!1)}ProcessPoints(t){const e=this.FindStaircaseStart(t);return!(e<0)&&(t.pts=this.RemoveStaircasePN(t.pts,e),!0)}FindStaircaseStart(t){if(t.canHaveStaircase=!1,t.pts.length<5)return-1;const e=[new Hn(t.pts,0),new Hn(t.pts,1),new Hn(t.pts,2),new Hn(t.pts,3)];let i=0;for(let n=0;;){const r={canHaveStaircaseAtI:!1};if(this.IsStaircase(t.pts,n,e,r))return t.canHaveStaircase=!0,n;if(t.canHaveStaircase=t.canHaveStaircase||r.canHaveStaircaseAtI,n++,t.pts.length<n+5)return-1;e[i]=new Hn(t.pts,n+3),i++,i%=4}}static GetFlippedPoint(t,e){return v(t[e].y,t[e+1].y)?new E(t[e+4].x,t[e].y):new E(t[e].x,t[e+4].y)}Crossing(t,e,i){return qn.IsCrossing(I.mkPP(t,e),this.segTree,i)}static IsCrossing(t,e,i){for(const n of e.GetAllIntersecting(t.boundingBox))if(-1==i.findIndex(t=>t==n))return!0;return!1}IntersectObstacleHierarchyPPP(t,e,i){return this.IntersectObstacleHierarchyL(I.mkPP(t,e))||this.IntersectObstacleHierarchyL(I.mkPP(e,i))}IntersectObstacleHierarchyL(t){return this.HierarchyOfObstacles.GetAllIntersecting(t.boundingBox).some(e=>null!=F.intersectionOne(t,e,!1))}IsStaircase(t,e,i,n){const r=t[e],s=t[e+1];let o=t[e+2];const a=t[e+3],l=t[e+4];return n.canHaveStaircaseAtI=!1,W.DirectionFromPointToPoint(r,s)==W.DirectionFromPointToPoint(o,a)&&W.DirectionFromPointToPoint(s,o)==W.DirectionFromPointToPoint(a,l)&&(o=qn.GetFlippedPoint(t,e),!this.IntersectObstacleHierarchyPPP(s,o,a)&&(n.canHaveStaircaseAtI=!0,!this.Crossing(s,o,i)))}RemoveStaircasePN(t,e){const i=t[e],n=t[e+1],r=Math.abs(i.y-n.y)<y.distanceEpsilon/2;return this.RemoveStaircasePNB(t,e,r)}RemoveStaircasePNB(t,e,i){this.RemoveSegs(t);const n=new Array(t.length-2);!function(t,e,i){let n=0;for(;i-- >0;)e[n++]=t[n++]}(t,n,e+1);const r=t[e+1],s=t[e+3];return n[e+1]=i?new E(s.x,r.y):new E(r.x,s.y),function(t,e,i,n,r){for(;r-- >0;)i[n++]=t[e++]}(t,e+4,n,e+2,n.length-e-2),this.InsertNewSegs(n,e),n}RemoveSegs(t){for(let e=0;e<t.length-1;e++)this.RemoveSeg(new Hn(t,e))}RemoveSeg(t){this.segTree.Remove(qn.Rect(t),t)}InsertNewSegs(t,e){this.InsSeg(t,e),this.InsSeg(t,e+1)}InitHierarchies(){for(const t of this.Paths)this.InsertPathSegs(t)}InsertPathSegs(t){this.InsertSegs(t.PathPoints)}InsertSegs(t){for(let e=0;e<t.length-1;e++)this.InsSeg(t,e)}InsSeg(t,e){const i=new Hn(t,e);this.segTree.Add(qn.Rect(i),i)}static Rect(t){return G.mkPP(t.Start,t.End)}}class Xn{constructor(t,e,i,n){this.AncestorsSets=n,this.HierarchyOfGroups=ot(Array.from(n.keys()).filter(t=>t.IsGroup).map(t=>ut(t,t.BoundingBox))),this.Obstacles=i,this.EdgeSeparation=2*e,this.Paths=t,this.HierarchyOfObstacles=ot(i.map(t=>ut(t,t.boundingBox))),this.MapPathsToTheirObstacles()}get HasGroups(){return null!=this.HierarchyOfGroups&&this.HierarchyOfGroups.Count>0}MapPathsToTheirObstacles(){this.PathToObstacles=new Map;for(const t of this.Paths)this.MapPathToItsObstacles(t)}MapPathToItsObstacles(t){if(!t.PathPoints||0==t.PathPoints.length)return;const e=t.PathPoints,i=this.HierarchyOfObstacles.FirstHitNodeWithPredicate(e[0],Xn.ObstacleTest),n=this.HierarchyOfObstacles.FirstHitNodeWithPredicate(e[e.length-1],Xn.ObstacleTest);null!=i&&null!=n&&this.PathToObstacles.set(t,[i.UserData,n.UserData])}static ObstacleTest(t,e){return F.PointRelativeToCurveLocation(t,e)!=a.Outside?tt.Stop:tt.Continue}Calculate(t,e){this.NudgingDirection=t,Wn.RefinePaths(this.Paths,e),this.GetPathOrdersAndPathGraph(),this.MapAxisEdgesToTheirObstacles(),this.DrawPaths()}MapAxisEdgesToTheirObstacles(){this.axisEdgesToObstaclesTheyOriginatedFrom=new Map;for(const t of this.Paths)this.MapPathEndAxisEdgesToTheirObstacles(t);for(const t of this.Paths)this.UmmapPathInteriourFromStrangerObstacles(t)}UmmapPathInteriourFromStrangerObstacles(t){const e=this.FindFirstUnmappedEdge(t);if(null==e)return;const i=this.FindLastUnmappedEdge(t);for(let t=e;null!=t&&t!=i;t=t.Next)this.axisEdgesToObstaclesTheyOriginatedFrom.delete(t.AxisEdge)}FindLastUnmappedEdge(t){for(let e=t.LastEdge;null!=e;e=e.Prev)if(e.AxisEdge.Direction!=this.NudgingDirection)return e;return null}FindFirstUnmappedEdge(t){for(let e=t.FirstEdge;null!=e;e=e.Next)if(e.AxisEdge.Direction!=this.NudgingDirection)return e;return null}MapPathEndAxisEdgesToTheirObstacles(t){const e=this.PathToObstacles.get(t);e&&(this.ProcessThePathStartToMapAxisEdgesToTheirObstacles(t,e[0]),this.ProcessThePathEndToMapAxisEdgesToTheirObstacles(t,e[1]))}ProcessThePathEndToMapAxisEdgesToTheirObstacles(t,e){for(let i=t.LastEdge;null!=i&&W.DirectionsAreParallel(i.Direction,this.NudgingDirection);i=i.Prev)this.axisEdgesToObstaclesTheyOriginatedFrom.set(i.AxisEdge,e)}ProcessThePathStartToMapAxisEdgesToTheirObstacles(t,e){for(let i=t.FirstEdge;null!=i&&W.DirectionsAreParallel(i.Direction,this.NudgingDirection);i=i.Next)this.axisEdgesToObstaclesTheyOriginatedFrom.set(i.AxisEdge,e)}GetPathOrdersAndPathGraph(){const t=new Fn(this.Paths);this.PathOrders=t.GetOrder(),this.PathVisibilityGraph=t.PathVisibilityGraph}static GetCurvesForShow(t,e){const i=new Array;for(const e of t){const t=new k;for(const i of e.PathPoints)t.addPoint(i);i.push(t)}return i.concat(Array.from(e))}DrawPaths(){this.SetWidthsOfArrowheads(),this.CreateLongestNudgedSegments(),this.FindFreeSpaceInDirection(Array.from(this.PathVisibilityGraph.Edges)),this.MoveLongestSegsIdealPositionsInsideFeasibleIntervals(),this.PositionShiftedEdges()}SetWidthsOfArrowheads(){for(const t of this.Paths)Xn.SetWidthsOfArrowheadsForEdge(t)}static SetWidthsOfArrowheadsForEdge(t){const e=t.GeomEdge;if(null!=e.targetArrowhead){const i=t.LastEdge;i.Width=Math.max(e.targetArrowhead.width,i.Width)}if(null!=e.sourceArrowhead){const i=t.FirstEdge;i.Width=Math.max(e.sourceArrowhead.width,i.Width)}}PositionShiftedEdges(){this.Solver=new Ln(this.EdgeSeparation);for(let t=0;t<this.LongestNudgedSegs.length;t++)this.CreateVariablesOfLongestSegment(this.LongestNudgedSegs[t]);this.CreateConstraintsOfTheOrder(),this.CreateConstraintsBetweenLongestSegments(),this.Solver.SolveByRegularSolver(),this.ShiftPathEdges()}MoveLongestSegsIdealPositionsInsideFeasibleIntervals(){for(let t=0;t<this.LongestNudgedSegs.length;t++){const e=this.LongestNudgedSegs[t];Xn.MoveLongestSegIdealPositionsInsideFeasibleInterval(e)}}static MoveLongestSegIdealPositionsInsideFeasibleInterval(t){if(t.IsFixed)return;const e=t.GetLeftBound(),i=t.GetRightBound();t.IdealPosition<e?t.IdealPosition=e:t.IdealPosition>i&&(t.IdealPosition=i)}ShiftPathEdges(){for(const t of this.Paths)t.PathPoints=this.GetShiftedPoints(t)}GetShiftedPoints(t){return Xn.RemoveSwitchbacksAndMiddlePoints(this.GetShiftedPointsSimple(t))}static Rectilinearise(t,e){if(t.x==e.x||t.y==e.y)return e;return Math.abs(t.x-e.x)<Math.abs(t.y-e.y)?new E(t.x,e.y):new E(e.x,t.y)}GetShiftedPointsSimple(t){const e=[],i=t.FirstEdge;e.push(this.ShiftedPoint(i.Source,i.LongestNudgedSegment));for(const i of t.PathEdges())e.push(this.ShiftedEdgePositionOfTarget(i));return e}ShiftedEdgePositionOfTarget(t){return null!=t.LongestNudgedSegment||null==t.Next?this.ShiftedPoint(t.Target,t.LongestNudgedSegment):this.ShiftedPoint(t.Next.Source,t.Next.LongestNudgedSegment)}ShiftedPoint(t,e){if(null==e)return t;const i=this.Solver.GetVariablePosition(e.Id);return this.NudgingDirection==l.North?new E(i,t.y):new E(t.x,-i)}static LineSegOfLongestSeg(t,e){const i=e==l.East?t=>t.x:t=>t.y,n={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};for(const e of t.Edges)Xn.UpdateMinMaxWithPoint(n,i,e.Source),Xn.UpdateMinMaxWithPoint(n,i,e.Target);return e==l.East?new I(n.min,-t.IdealPosition,n.max,-t.IdealPosition):new I(t.IdealPosition,n.min,t.IdealPosition,n.max)}static UpdateMinMaxWithPoint(t,e,i){const n=e(i);t.min>n&&(t.min=n),t.max<n&&(t.max=n)}CreateConstraintsBetweenLongestSegments(){for(const t of this.LongestNudgedSegs)this.CreateConstraintsBetweenLongestSegmentsForSegment(t)}CreateConstraintsBetweenLongestSegmentsForSegment(t){const e=new Set;for(const i of t.Edges){const t=i.AxisEdge;if(null!=t)for(const i of t.RightNeighbors)for(const t of i.LongestNudgedSegments)e.add(t)}for(const i of e)this.ConstraintTwoLongestSegs(t,i)}CreateConstraintsOfTheOrder(){for(const t of this.PathOrders)Xn.ParallelToDirection(t[0],this.NudgingDirection)&&this.CreateConstraintsOfThePathOrder(t[1])}static ParallelToDirection(t,e){switch(e){case l.North:case l.South:return v(t.SourcePoint.x,t.TargetPoint.x);default:return v(t.SourcePoint.y,t.TargetPoint.y)}}CreateConstraintsOfThePathOrder(t){let e=null;for(const i of t.filter(t=>null!=t.LongestNudgedSegment))null!=e&&this.ConstraintTwoLongestSegs(e.LongestNudgedSegment,i.LongestNudgedSegment),e=i}ConstraintTwoLongestSegs(t,e){t.IsFixed&&e.IsFixed||this.Solver.AddConstraint(t.Id,e.Id)}CreateVariablesOfLongestSegment(t){if(t.IsFixed)this.Solver.AddFixedVariable(t.Id,Xn.SegmentPosition(t,this.NudgingDirection));else{const e=t.GetLeftBound(),i=t.GetRightBound();e>=i?(this.Solver.AddFixedVariable(t.Id,Xn.SegmentPosition(t,this.NudgingDirection)),t.IsFixed=!0):(this.Solver.AddVariableNNNN(t.Id,Xn.SegmentPosition(t,this.NudgingDirection),t.IdealPosition,t.Width),e!=Number.NEGATIVE_INFINITY&&this.Solver.SetLowBound(e,t.Id),i!=Number.POSITIVE_INFINITY&&this.Solver.SetUpperBound(t.Id,i))}}static SegmentPosition(t,e){return e==l.North?t.Start.x:-t.Start.y}FindFreeSpaceInDirection(t){this.BoundAxisEdgesByRectsKnownInAdvance();new Vn(this.NudgingDirection,this.Obstacles,this.axisEdgesToObstaclesTheyOriginatedFrom,this.PathOrders,t).FindFreeSpace()}BoundAxisEdgesByRectsKnownInAdvance(){for(const t of this.Paths)this.HasGroups&&this.BoundPathByMinCommonAncestors(t),this.BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(t)}BoundPathByMinCommonAncestors(t){for(const e of this.GetMinCommonAncestors(t.GeomEdge)){const i=e.BoundingBox;for(const e of t.PathEdges()){const t=e.AxisEdge;t.Direction==this.NudgingDirection&&this.BoundAxisEdgeByRect(i,t)}}}GetMinCommonAncestors(t){null==this.PortToShapes&&(this.PortToShapes=Xn.MapPortsToShapes(this.AncestorsSets.keys()));const e=function(t,e){const i=new Set;if(t.size<e.size)for(const n of t)e.has(n)&&i.add(n);else for(const n of e)t.has(n)&&i.add(n);return i}(this.AncestorsForPort(t.sourcePort),this.AncestorsForPort(t.targetPort));return Array.from(e).filter(t=>!t.Children.some(t=>e.has(t)))}AncestorsForPort(t){const e=this.PortToShapes.get(t);return e?this.AncestorsSets.get(e):new Set(this.HierarchyOfGroups.AllHitItems(G.mkPP(t.Location,t.Location),null))}BoundAxisEdgeAdjacentToObstaclePort(t,e){null==t.Curve?this.BoundAxisByPoint(t.Location,e):t.Curve.boundingBox.contains(t.Location)&&this.BoundAxisEdgeByRect(t.Curve.boundingBox,e)}BoundAxisByPoint(t,e){null!=e&&e.Direction==this.NudgingDirection&&(this.NudgingDirection==l.North?(e.BoundFromLeft(t.x),e.BoundFromRight(t.x)):(e.BoundFromLeft(-t.y),e.BoundFromRight(-t.y)))}BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(t){this.BoundAxisEdgeAdjacentToObstaclePort(t.GeomEdge.sourcePort,t.FirstEdge.AxisEdge),this.BoundAxisEdgeAdjacentToObstaclePort(t.GeomEdge.targetPort,t.LastEdge.AxisEdge)}BoundAxisEdgeByRect(t,e){null!=e&&e.Direction==this.NudgingDirection&&(this.NudgingDirection==l.North?(e.BoundFromLeft(t.left),e.BoundFromRight(t.right)):(e.BoundFromLeft(-1*t.top),e.BoundFromRight(-1*t.bottom)))}CreateLongestNudgedSegments(){const t=this.NudgingDirection==l.East?t=>-t.y:t=>t.x;this.LongestNudgedSegs=new Array;for(let e=0;e<this.Paths.length;e++)this.CreateLongestNudgedSegmentsForPath(this.Paths[e],t)}CreateLongestNudgedSegmentsForPath(t,e){this.GoOverPathAndCreateLongSegs(t),Xn.CalculateIdealPositionsForLongestSegs(t,e)}static CalculateIdealPositionsForLongestSegs(t,e){let i=null,n=null,r=e(t.Start);for(const s of t.PathEdges())if(null!=s.LongestNudgedSegment){if(i=s.LongestNudgedSegment,null!=n){let t;Xn.SetIdealPositionForSeg(n,t=e(n.start),r,e(i.Start)),r=t,n=null}}else null!=i&&(n=i,i=null);null!=n?Xn.SetIdealPositionForSeg(n,e(n.Start),r,e(t.End)):null!=i&&(i.IdealPosition=e(i.Start))}static SetIdealPositionForSeg(t,e,i,n){const r=Math.max(i,n),s=Math.min(i,n);s+y.distanceEpsilon<e?t.IdealPosition=e<r?.5*(r+s):r:t.IdealPosition=s}GoOverPathAndCreateLongSegs(t){let e=null;const i=W.OppositeDir(this.NudgingDirection);for(const n of t.PathEdges()){const t=n.Direction;t==this.NudgingDirection||t==i?(null==e?(n.LongestNudgedSegment=e=new Gn(this.LongestNudgedSegs.length),this.LongestNudgedSegs.push(e)):n.LongestNudgedSegment=e,n.IsFixed&&(e.IsFixed=!0)):(n.LongestNudgedSegment=null,e=null)}}static BuildPolylineForPath(t){const e={points:t.PathPoints.map(t=>t.clone())};return Xn.ExtendPolylineToPorts(e,t),e.points}static ExtendPolylineToPorts(t,e){Xn.ExtendPolylineToSourcePort(t,e.GeomEdge.sourcePort.Location),Xn.ExtendPolylineToTargetPort(t,e.GeomEdge.targetPort.Location),t.points.length<2&&(t.points=new Array(2),t.points[0]=e.GeomEdge.sourcePort.Location,t.points[1]=e.GeomEdge.targetPort.Location)}static ExtendPolylineToTargetPort(t,e){const i=t.points.length-1,n=W.VectorDirectionPP(t.points[i-1],t.points[i]);if(Xn.ProjectionsAreClose(t.points[i-1],n,e))return void(t.points=t.points.slice(0,i));const r=t.points[i];n==l.East||n==l.West?t.points[i]=new E(e.x,r.y):t.points[i]=new E(r.x,e.y)}static ProjectionsAreClose(t,e,i){return e==l.East||e==l.West?v(t.x,i.x):v(t.y,i.y)}static ExtendPolylineToSourcePort(t,e){const i=W.VectorDirectionPP(t.points[0],t.points[1]);if(Xn.ProjectionsAreClose(t.points[1],i,e))return void(t.points=t.points.slice(1));const n=t.points[0];i==l.East||i==l.West?t.points[0]=new E(e.x,n.y):t.points[0]=new E(n.x,e.y)}static RemoveSwitchbacksAndMiddlePoints(t){const e=[];let i=t[0];e.push(i);let n=t[1],r=W.VectorDirectionPP(i,n),s=1;for(;++s<t.length;){const o=W.VectorDirectionPP(n,t[s]);o!=r&&W.OppositeDir(o)!=r&&o!=l.None&&(E.closeDistEps(i,n)||e.push(i=Xn.Rectilinearise(i,n)),r=o),n=t[s]}return E.closeDistEps(i,n)||e.push(Xn.Rectilinearise(i,n)),e}static NudgePaths(t,e,i,n,r){if(0==t.length)return;const s=new Xn(t,e,i,n);s.Calculate(l.North,!0),s.Calculate(l.East,!1),s.Calculate(l.North,!1),r&&s.RemoveStaircases();for(const e of t)e.GeomEdge.curve=k.mkFromPoints(Xn.BuildPolylineForPath(e))}RemoveStaircases(){qn.RemoveStaircases(this.Paths,this.HierarchyOfObstacles)}static MapPortsToShapes(t){const e=new Map;for(const i of t)for(const t of i.Ports)e.set(t,i);return e}static*GetEdgePathFromPathEdgesAsDebugCurves(t,e,i,n){const r=n.ArrayOfPathPoints(),s=r.length,o=s>1?(e-t)/(s-1):1;for(let e=0;e<r.length-1;e++)yield Xe.mkDebugCurveTWCI(200,t+o*e,i,I.mkPP(r[e],r[e+1]))}}class Yn{constructor(t,e){this.Crossings=[],this.Location=t,this.Crossings=e}}class Qn{constructor(){this.ListOfPointsAndCrossings=[],this.index=0,this.ListOfPointsAndCrossings=new Array}Count(){return this.ListOfPointsAndCrossings.length}Add(t,e){this.ListOfPointsAndCrossings.push(new Yn(t,e))}Pop(){return this.ListOfPointsAndCrossings[this.index++]}CurrentIsBeforeOrAt(t){return!(this.index>=this.ListOfPointsAndCrossings.length)&&U.ComparePP(this.ListOfPointsAndCrossings[this.index].Location,t)<=0}get First(){return this.ListOfPointsAndCrossings[0]}get Last(){return this.ListOfPointsAndCrossings[this.ListOfPointsAndCrossings.length-1]}Reset(){this.index=0}MergeFrom(t){if(this.Reset(),null==t)return;const e=this.ListOfPointsAndCrossings.length;let i=0;const n=t.ListOfPointsAndCrossings.length;let r=0;const s=new Array(this.ListOfPointsAndCrossings.length);for(;i<e||r<n;){if(i>=e){s.push(t.ListOfPointsAndCrossings[r++]);continue}if(r>=n){s.push(this.ListOfPointsAndCrossings[i++]);continue}const o=this.ListOfPointsAndCrossings[i],a=t.ListOfPointsAndCrossings[r],l=U.ComparePP(o.Location,a.Location);0==l?(s.push(o),++i,++r):-1==l?(s.push(o),++i):(s.push(a),++r)}this.ListOfPointsAndCrossings=s}Trim(t,e){this.Reset(),null!=this.ListOfPointsAndCrossings&&0!=this.ListOfPointsAndCrossings.length&&(this.ListOfPointsAndCrossings=this.ListOfPointsAndCrossings.filter(i=>U.ComparePP(i.Location,t)>=0&&U.ComparePP(i.Location,e)<=0))}static ToCrossingArray(t,e){let i=0;const n=t.length;for(let r=0;r<n;r++)t[r].DirectionToInside==e&&i++;if(0==i)return null;const r=new Array(i);let s=0;for(let i=0;i<n;i++)t[i].DirectionToInside==e&&(r[s++]=t[i]);return r}ToString(){return _t.String.Format("{0} [{1}]",this.ListOfPointsAndCrossings.length,this.index)}}class Zn{static EdgeDirectionVE(t){return Zn.EdgeDirectionVV(t.Source,t.Target)}static EdgeDirectionVV(t,e){return U.GetDirections(t.point,e.point)}static GetEdgeEnd(t,e){return e==Zn.EdgeDirectionVE(t)?t.Target:t.Source}static FindAdjacentVertex(t,e){for(const i of t.InEdges)if(U.GetDirections(t.point,i.SourcePoint)==e)return i.Source;for(const i of t.OutEdges)if(U.GetDirections(t.point,i.TargetPoint)==e)return i.Target;return null}static FindAdjacentEdge(t,e){for(const i of t.InEdges)if(U.GetDirections(i.SourcePoint,t.point)==e)return i;for(const i of t.OutEdges)if(U.GetDirections(t.point,i.TargetPoint)==e)return i;return null}static FindBendPointBetween(t,e,i){return Zn.IsVerticalD(i)?new E(e.x,t.y):new E(t.x,e.y)}static SegmentIntersectionPPP(t,e,i){const n=U.GetDirections(t,e);return Zn.IsVerticalD(n)?new E(t.x,i.y):new E(i.x,t.y)}static SegmentIntersectionSP(t,e){return Zn.SegmentIntersectionPPP(t.Start,t.End,e)}static SegmentsIntersection(t,e){return Zn.IntervalsIntersect(t.Start,t.End,e.Start,e.End)}static SegmentsIntersectLL(t,e){return Zn.IntervalsIntersect(t.start,t.end,e.start,e.end)}static IntervalsOverlapSS(t,e){return Zn.IntervalsOverlapPPPP(t.Start,t.End,e.Start,e.End)}static IntervalsOverlapPPPP(t,e,i,n){return Zn.IntervalsAreCollinear(t,e,i,n)&&U.ComparePP(t,n)!=U.ComparePP(e,i)}static IntervalsAreCollinear(t,e,i,n){const r=Zn.IsVerticalPP(t,e);return Zn.IsVerticalPP(i,n)==r&&(r?U.Equal(t.x,i.x):U.Equal(t.y,i.y))}static IntervalsAreSame(t,e,i,n){return U.EqualPP(t,i)&&U.EqualPP(e,n)}static IntervalsIntersect(t,e,i,n){const r=Zn.SegmentIntersectionPPP(t,e,i);return Zn.PointIsOnSegmentPPP(t,e,r)&&Zn.PointIsOnSegmentPPP(i,n,r)?r:void 0}static SegmentIntersectionEP(t,e){return Zn.SegmentIntersectionPPP(t.SourcePoint,t.TargetPoint,e)}static PointIsOnSegmentPPP(t,e,i){return U.EqualPP(t,i)||U.EqualPP(e,i)||U.GetDirections(t,i)==U.GetDirections(i,e)}static PointIsOnSegmentSP(t,e){return Zn.PointIsOnSegmentPPP(t.Start,t.End,e)}static IsVerticalD(t){return 0!=(t&(l.North|l.South))}static IsVerticalE(t){return Zn.IsVerticalD(U.GetDirections(t.SourcePoint,t.TargetPoint))}static IsVerticalPP(t,e){return Zn.IsVerticalD(U.GetDirections(t,e))}static IsVertical(t){return Zn.IsVerticalD(U.GetDirections(t.start,t.end))}static IsAscending(t){return 0!=(t&(l.North|l.East))}static Slope(t,e,i){const n=e.sub(t);return n.dot(i.PerpDirectionAsPoint)/n.dot(i.DirectionAsPoint)}static SortAscending(t,e){const i=U.GetDirections(t,e);return l.None==i||Zn.IsAscending(i)?[t,e]:[e,t]}static RectangleBorderIntersect(t,e,i){switch(i){case l.North:case l.South:return new E(e.x,Zn.GetRectangleBound(t,i));case l.East:case l.West:return new E(Zn.GetRectangleBound(t,i),e.y);default:throw new Error}}static GetRectangleBound(t,e){switch(e){case l.North:return t.top;case l.South:return t.bottom;case l.East:return t.right;case l.West:return t.left;default:throw new Error}}static RectangleInteriorsIntersect(t,e){return U.Compare(t.bottom,e.top)<0&&U.Compare(e.bottom,t.top)<0&&U.Compare(t.left,e.right)<0&&U.Compare(e.left,t.right)<0}static PointIsInRectangleInterior(t,e){return U.Compare(t.y,e.top)<0&&U.Compare(e.bottom,t.y)<0&&U.Compare(t.x,e.right)<0&&U.Compare(e.left,t.x)<0}}class Kn{constructor(t){this.Dir=t,this.DirectionAsPoint=W.toPoint(this.Dir),this.PerpDirection=l.North==t?l.East:l.North,this.PerpDirectionAsPoint=W.toPoint(this.PerpDirection),this.OppositeDirection=W.OppositeDir(t)}get Dir(){return this.dir}set Dir(t){this.dir=t}get IsHorizontal(){return l.East==this.Dir}get IsVertical(){return l.North==this.Dir}Compare(t,e){const i=this.ComparePerpCoord(t,e);return 0!=i?i:this.CompareScanCoord(t,e)}CompareScanCoord(t,e){return U.Compare(t.sub(e).dot(this.DirectionAsPoint),0)}ComparePerpCoord(t,e){return U.Compare(t.sub(e).dot(this.PerpDirectionAsPoint),0)}IsFlatS(t){return this.IsFlatPP(t.Start,t.End)}IsFlatPP(t,e){return U.Equal(e.sub(t).dot(this.PerpDirectionAsPoint),0)}IsPerpendicularS(t){return this.IsPerpendicularPP(t.Start,t.End)}IsPerpendicularPP(t,e){return U.Equal(e.sub(t).dot(this.DirectionAsPoint),0)}Coord(t){return t.dot(this.DirectionAsPoint)}Min(t,e){return this.Compare(t,e)<=0?t:e}Max(t,e){return this.Compare(t,e)>=0?t:e}get PerpendicularInstance(){return this.IsHorizontal?Kn.VerticalInstance:Kn.HorizontalInstance}static GetInstance(t){return Zn.IsVerticalD(t)?Kn.VerticalInstance:Kn.HorizontalInstance}ToString(){return this.Dir.toString()}}Kn.HorizontalInstance=new Kn(l.East),Kn.VerticalInstance=new Kn(l.North);class $n extends Si{constructor(t,e,i,n){super(),this.Update(t,e),this.Weight=i,this.GroupBoundaryPointAndCrossingsList=n}static mk(t,e){return new $n(t,e,$n.NormalWeight,null)}get Start(){return this.startPoint}get End(){return this.endPoint}get IsVertical(){return $n.IsVerticalSegment(this.Start,this.End)}get ScanDirection(){return this.IsVertical?Kn.VerticalInstance:Kn.HorizontalInstance}get IsOverlapped(){return $n.OverlappedWeight==this.Weight}get IsReflection(){return $n.ReflectionWeight==this.Weight}static IsVerticalSegment(t,e){return t.x==e.x}MergeGroupBoundaryCrossingList(t){null!=t&&(null==this.GroupBoundaryPointAndCrossingsList&&(this.GroupBoundaryPointAndCrossingsList=new Qn),this.GroupBoundaryPointAndCrossingsList.MergeFrom(t))}TrimGroupBoundaryCrossingList(){null!=this.GroupBoundaryPointAndCrossingsList&&this.GroupBoundaryPointAndCrossingsList.Trim(this.Start,this.End)}Update(t,e){this.startPoint=t,this.endPoint=e}SetInitialVisibilityVertex(t){this.LowestVisibilityVertex=t,this.HighestVisibilityVertex=t}AppendVisibilityVertex(t,e){if(null==this.HighestVisibilityVertex)this.AddGroupCrossingsBeforeHighestVisibilityVertex(t,e)||this.SetInitialVisibilityVertex(e);else{if(U.IsPureLower(e.point,this.HighestVisibilityVertex.point))return;this.AddGroupCrossingsBeforeHighestVisibilityVertex(t,e)||this.AppendHighestVisibilityVertex(e)}}AddVisibilityEdge(t,e){const i=new hi(t,e,this.Weight);return di.AddEdge(i),i}AppendHighestVisibilityVertex(t){U.EqualPP(this.HighestVisibilityVertex.point,t.point)||(this.AddVisibilityEdge(this.HighestVisibilityVertex,t),this.HighestVisibilityVertex=t)}LoadStartOverlapVertexIfNeeded(t){if(this.NeedStartOverlapVertex){const e=t.FindVertex(this.Start);this.AppendVisibilityVertex(t,null!=e?e:t.AddVertexP(this.Start))}}LoadEndOverlapVertexIfNeeded(t){if(this.NeedEndOverlapVertex){const e=t.FindVertex(this.End);this.AppendVisibilityVertex(t,null!=e?e:t.AddVertexP(this.End))}}OnSegmentIntersectorBegin(t){this.AppendGroupCrossingsThroughPoint(t,this.Start)||this.LoadStartOverlapVertexIfNeeded(t)}OnSegmentIntersectorEnd(t){this.AppendGroupCrossingsThroughPoint(t,this.End),this.GroupBoundaryPointAndCrossingsList=null,(null==this.HighestVisibilityVertex||U.IsPureLower(this.HighestVisibilityVertex.point,this.End))&&this.LoadEndOverlapVertexIfNeeded(t)}static Subsume(t,e,i,n,r,s,o,a){return a.extendStart=!0,a.extendEnd=!0,null!=t.seg&&(!!Zn.IntervalsOverlapPPPP(t.seg.Start,t.seg.End,e,i)&&(t.seg.Weight!=n?t.seg.Start==e&&t.seg.End==i&&(t.seg.Weight=Math.min(t.seg.Weight,n),!0):(a.extendStart=-1==s.CompareScanCoord(e,t.seg.Start),a.extendEnd=1==s.CompareScanCoord(i,t.seg.End),(a.extendStart||a.extendEnd)&&(o.Remove(t.seg),t.seg.startPoint=s.Min(t.seg.Start,e),t.seg.endPoint=s.Max(t.seg.End,i),t.seg=o.InsertUnique(t.seg).item,t.seg.MergeGroupBoundaryCrossingList(r)),!0)))}IntersectsSegment(t){return null!=Zn.SegmentsIntersection(this,t)}toString(){return"["+this.Start+" -> "+this.End+(this.IsOverlapped?" olap":" free")+"]"}ContainsPoint(t){return U.EqualPP(this.Start,t)||U.EqualPP(this.End,t)||U.GetDirections(this.Start,t)==U.GetDirections(t,this.End)}get HasSparsePerpendicularCoords(){return null!=this.sparsePerpendicularCoords&&this.sparsePerpendicularCoords.size>0}CreatePointFromPerpCoord(t){return this.IsVertical?new E(this.Start.x,t):new E(t,this.Start.y)}AddSparseVertexCoord(t){null==this.sparsePerpendicularCoords&&(this.sparsePerpendicularCoords=new Set),this.sparsePerpendicularCoords.add(t)}AddSparseEndpoint(t){return!this.sparsePerpendicularCoords.has(t)&&(this.sparsePerpendicularCoords.add(t),!0)}CreateSparseVerticesAndEdges(t){var e;if(null!=this.sparsePerpendicularCoords){this.AppendGroupCrossingsThroughPoint(t,this.Start);for(const i of Array.from(this.sparsePerpendicularCoords.values()).sort(b)){const n=this.CreatePointFromPerpCoord(i);this.AppendVisibilityVertex(t,null!==(e=t.FindVertex(n))&&void 0!==e?e:t.AddVertexP(n))}this.AppendGroupCrossingsThroughPoint(t,this.End),this.GroupBoundaryPointAndCrossingsList=null,this.sparsePerpendicularCoords.clear(),this.sparsePerpendicularCoords=null}}HasVisibility(){return null!=this.LowestVisibilityVertex}AddGroupCrossingsBeforeHighestVisibilityVertex(t,e){return!!this.AppendGroupCrossingsThroughPoint(t,e.point)&&(U.IsPureLower(this.HighestVisibilityVertex.point,e.point)&&(this.AddVisibilityEdge(this.HighestVisibilityVertex,e),this.HighestVisibilityVertex=e),!0)}AppendGroupCrossingsThroughPoint(t,e){var i;if(null==this.GroupBoundaryPointAndCrossingsList)return!1;let n=!1;for(;this.GroupBoundaryPointAndCrossingsList.CurrentIsBeforeOrAt(e);){const e=this.GroupBoundaryPointAndCrossingsList.Pop();let r=null,s=null;U.ComparePP(e.Location,this.Start)>0&&(r=Qn.ToCrossingArray(e.Crossings,this.ScanDirection.OppositeDirection)),U.ComparePP(e.Location,this.End)<0&&(s=Qn.ToCrossingArray(e.Crossings,this.ScanDirection.Dir)),n=!0;const o=null!==(i=t.FindVertex(e.Location))&&void 0!==i?i:t.AddVertexP(e.Location);t.AddVertexP(e.Location),null!=r||null!=s?(this.AddLowCrossings(t,o,r),this.AddHighCrossings(t,o,s)):null==this.LowestVisibilityVertex?this.SetInitialVisibilityVertex(o):this.AppendHighestVisibilityVertex(o)}return n}static GetCrossingInteriorVertex(t,e,i){var n;const r=i.GetInteriorVertexPoint(e.point);return null!==(n=t.FindVertex(r))&&void 0!==n?n:t.AddVertexP(r)}AddCrossingEdge(t,e,i,n){let r=null;null!=this.HighestVisibilityVertex&&(U.EqualPP(this.HighestVisibilityVertex.point,i.point)?r=t.FindEdgePP(e.point,i.point):this.AppendHighestVisibilityVertex(e)),null==r&&(r=this.AddVisibilityEdge(e,i));const s=n.map(t=>t.Group.InputShape),o=r.IsPassable;r.IsPassable=null==o?()=>{for(const t of s)if(t.IsTransparent)return!0;return!1}:()=>{for(const t of s)if(t.IsTransparent||o())return!0;return!1},null==this.LowestVisibilityVertex&&this.SetInitialVisibilityVertex(e),this.HighestVisibilityVertex=i}AddLowCrossings(t,e,i){if(null!=i){const n=$n.GetCrossingInteriorVertex(t,e,i[0]);this.AddCrossingEdge(t,n,e,i)}}AddHighCrossings(t,e,i){if(null!=i){const n=$n.GetCrossingInteriorVertex(t,e,i[0]);this.AddCrossingEdge(t,e,n,i)}}}$n.NormalWeight=hi.DefaultWeight,$n.ReflectionWeight=5,$n.OverlappedWeight=500;class Jn{constructor(t,e,i,n,r){this.IsClosed=!1,this.Vertex=t,this.Direction=null!=e?W.DirectionFromPointToPoint(e.Vertex.point,t.point):l.None,this.ResetEntry(e,i,n,r)}ResetEntry(t,e,i,n){this.PreviousEntry=t,this.Length=e,this.NumberOfBends=i,this.Cost=n}get PreviousVertex(){return null==this.PreviousEntry?null:this.PreviousEntry.Vertex}toString(){return this.Vertex.point+" "+this.Direction+" "+this.IsClosed+" "+this.Cost}}class tr{constructor(){this.Clear()}Set(t,e){this.Vertex=t,this.Weight=e}Clear(){this.Vertex=null,this.Weight=Number.NaN}}class er{constructor(){this.nextNeighbors=[new tr,new tr,new tr],this.LengthImportance=1,this.BendsImportance=1}CombinedCost(t,e){return this.LengthImportance*t+this.BendsImportance*e}TotalCostFromSourceToVertex(t,e){return this.CombinedCost(t,e)+this.sourceCostAdjustment}InitPath(t,e,i){if(e==i||!this.InitEntryDirectionsAtTarget(i))return!1;this.Target=i,this.Source=e;const n=this.TotalCostFromSourceToVertex(0,0)+this.HeuristicDistanceFromVertexToTarget(e.point,l.None);return!(n>=this.upperBoundOnCost)&&(this.queue=new Qi(b),this.visitedVertices=[e],null==t?this.EnqueueInitialVerticesFromSource(n):this.EnqueueInitialVerticesFromSourceEntries(t),this.queue.count>0)}InitEntryDirectionsAtTarget(t){this.EntryDirectionsToTarget=l.None;for(const e of t.OutEdges)this.EntryDirectionsToTarget=this.EntryDirectionsToTarget|W.DirectionFromPointToPoint(e.TargetPoint,t.point);for(const e of t.InEdges)this.EntryDirectionsToTarget=this.EntryDirectionsToTarget|W.DirectionFromPointToPoint(e.SourcePoint,t.point);return this.EntryDirectionsToTarget!=l.None}static IsInDirs(t,e){return t==(t&e)}MultistageAdjustedCostBound(t){return Number.isFinite(t)?t+this.BendsImportance:t}HeuristicDistanceFromVertexToTarget(t,e){const i=this.Target.point.sub(t);if(v(i.x,0)&&v(i.y,0))return this.targetCostAdjustment;const n=W.VectorDirection(i);let r;return e==l.None?(e=l.East|l.North|l.West|l.South,r=this.GetNumberOfBends(e,n)):r=this.GetNumberOfBends(e,n),this.CombinedCost(er.ManhattanDistance(t,this.Target.point),r)+this.targetCostAdjustment}GetNumberOfBends(t,e){return W.IsPureDirection(e)?this.GetNumberOfBendsForPureDirection(t,e):er.GetBendsForNotPureDirection(e,t,this.EntryDirectionsToTarget)}GetNumberOfBendsForPureDirection(t,e){return(e&t)==e?er.IsInDirs(e,this.EntryDirectionsToTarget)?0:er.IsInDirs(er.Left(e),this.EntryDirectionsToTarget)||er.IsInDirs(er.Right(e),this.EntryDirectionsToTarget)?2:4:this.GetNumberOfBendsForPureDirection(er.AddOneTurn[t],e)+1}static GetBendsForNotPureDirection(t,e,i){const n=t&e;if(n==l.None)return er.GetBendsForNotPureDirection(t,er.AddOneTurn[e],i)+1;const r=t&i;return r==l.None?er.GetBendsForNotPureDirection(t,e,er.AddOneTurn[i])+1:(n|r)==t?1:2}static Left(t){switch(t){case l.None:return l.None;case l.North:return l.West;case l.East:return l.North;case l.South:return l.East;case l.West:return l.South;default:throw new Error("direction")}}static Right(t){switch(t){case l.None:return l.None;case l.North:return l.East;case l.East:return l.South;case l.South:return l.West;case l.West:return l.North;default:throw new Error("direction")}}static RestorePathV(t){return er.RestorePath(t,null)}static RestorePath(t,e){if(null==t.entry)return[];const i=new Array;let n=!1,r=l.None;for(;;){r==t.entry.Direction?n=!0:(n=!1,i.push(t.entry.Vertex.point),r=t.entry.Direction);const s=t.entry.PreviousEntry;if(null==s||t.entry.Vertex==e)break;t.entry=s}return n&&i.push(t.entry.Vertex.point),i.reverse(),i}QueueReversedEntryToNeighborVertexIfNeeded(t,e,i){const n={numberOfBends:0,length:0},r=e.PreviousVertex,s=er.GetLengthAndNumberOfBendsToNeighborVertex(t,r,i,n);if(this.CombinedCost(n.length,n.numberOfBends)<this.CombinedCost(e.Length,e.NumberOfBends)||1==t.Vertex.Degree){const e=this.TotalCostFromSourceToVertex(n.length,n.numberOfBends)+this.HeuristicDistanceFromVertexToTarget(r.point,s);this.EnqueueEntry(t,r,n.length,n.numberOfBends,e)}}UpdateEntryToNeighborVertexIfNeeded(t,e,i){const n={numberOfBends:0,length:0},r=er.GetLengthAndNumberOfBendsToNeighborVertex(t,e.Vertex,i,n);if(this.CombinedCost(n.length,n.numberOfBends)<this.CombinedCost(e.Length,e.NumberOfBends)){const i=this.TotalCostFromSourceToVertex(n.length,n.numberOfBends)+this.HeuristicDistanceFromVertexToTarget(e.Vertex.point,r);e.ResetEntry(t,n.length,n.numberOfBends,i),this.queue.DecreasePriority(e,i)}}CreateAndEnqueueEntryToNeighborVertex(t,e,i){const n={numberOfBends:0,length:0},r=er.GetLengthAndNumberOfBendsToNeighborVertex(t,e,i,n),s=this.TotalCostFromSourceToVertex(n.length,n.numberOfBends)+this.HeuristicDistanceFromVertexToTarget(e.point,r);s<this.upperBoundOnCost&&(null==e.VertexEntries&&this.visitedVertices.push(e),this.EnqueueEntry(t,e,n.length,n.numberOfBends,s))}EnqueueEntry(t,e,i,n,r){const s=new Jn(e,t,i,n,r);e.SetVertexEntry(s),this.queue.Enqueue(s,s.Cost)}static GetLengthAndNumberOfBendsToNeighborVertex(t,e,i,n){n.length=t.Length+er.ManhattanDistance(t.Vertex.point,e.point)*i;const r=W.DirectionFromPointToPoint(t.Vertex.point,e.point);return n.numberOfBends=t.NumberOfBends,t.Direction!=l.None&&r!=t.Direction&&n.numberOfBends++,r}static ManhattanDistance(t,e){return Math.abs(e.x-t.x)+Math.abs(e.y-t.y)}GetPathWithCost(t,e,i,n,r,s,o){if(this.upperBoundOnCost=o,this.sourceCostAdjustment=i,this.targetCostAdjustment=s,!this.InitPath(t,e,r))return null;for(;this.queue.count>0;){const t=this.queue.Dequeue(),e=t.Vertex;if(e==this.Target){if(null==n)return this.Cleanup(),t;if(t.Direction,this.EntryDirectionsToTarget==l.None){let t=0;for(const e of this.Target.VertexEntries)n[t++]=e;return this.Cleanup(),null}this.upperBoundOnCost=Math.min(this.MultistageAdjustedCostBound(t.Cost),this.upperBoundOnCost);continue}t.IsClosed=!0;for(const t of this.nextNeighbors)t.Clear();const i=er.Right(t.Direction);this.ExtendPathAlongInEdges(t,e.InEdges,i),this.ExtendPathAlongOutEdges(t,e.OutEdges,i);for(const e of this.nextNeighbors)null!=e.Vertex&&this.ExtendPathToNeighborVertex(t,e.Vertex,e.Weight)}if(null!=n&&null!=this.Target.VertexEntries)for(let t=0;t<this.Target.VertexEntries.length;t++)n[t]=this.Target.VertexEntries[t];return this.Cleanup(),null}ExtendPathAlongInEdges(t,e,i){for(const n of e)this.ExtendPathAlongEdge(t,n,!0,i)}ExtendPathAlongOutEdges(t,e,i){let n=e.isEmpty()?null:e.treeMinimum();for(;null!=n;n=e.next(n))this.ExtendPathAlongEdge(t,n.item,!1,i)}ExtendPathAlongEdge(t,e,i,n){if(!er.IsPassable(e))return;const r=i?e.Source:e.Target;if(r==t.PreviousVertex){if(t.Vertex.Degree>1||t.Vertex!=this.Source)return;return void this.ExtendPathToNeighborVertex(t,r,e.Weight)}const s=W.DirectionFromPointToPoint(t.Vertex.point,r.point);let o=this.nextNeighbors[2];s!=t.Direction&&(o=this.nextNeighbors[s==n?1:0]),o.Set(r,e.Weight)}EnqueueInitialVerticesFromSource(t){const e=new Jn(this.Source,null,0,0,t);for(const t of this.Source.OutEdges)er.IsPassable(t)&&this.ExtendPathToNeighborVertex(e,t.Target,t.Weight);for(const t of this.Source.InEdges)er.IsPassable(t)&&this.ExtendPathToNeighborVertex(e,t.Source,t.Weight)}EnqueueInitialVerticesFromSourceEntries(t){for(const e of t)null!=e&&this.queue.Enqueue(e,e.Cost)}ExtendPathToNeighborVertex(t,e,i){const n=W.DirectionFromPointToPoint(t.Vertex.point,e.point),r=null!=e.VertexEntries?e.VertexEntries[W.ToIndex(n)]:null;null==r?this.CreateAndEnqueueReversedEntryToNeighborVertex(t,e,i)||this.CreateAndEnqueueEntryToNeighborVertex(t,e,i):r.IsClosed||this.UpdateEntryToNeighborVertexIfNeeded(t,r,i)}CreateAndEnqueueReversedEntryToNeighborVertex(t,e,i){if(null!=t.Vertex.VertexEntries){const n=W.DirectionFromPointToPoint(e.point,t.Vertex.point),r=t.Vertex.VertexEntries[W.ToIndex(n)];if(null!=r)return this.QueueReversedEntryToNeighborVertexIfNeeded(t,r,i),!0}return!1}static IsPassable(t){return null==t.IsPassable||t.IsPassable()}Cleanup(){for(const t of this.visitedVertices)t.RemoveVertexEntries();this.visitedVertices=[],this.queue=null}}er.DefaultBendPenaltyAsAPercentageOfDistance=4,er.AddOneTurn=[l.None,l.North|l.East|l.West,l.North|l.East|l.South,15,l.East|l.South|l.West,15,15,15,13,15,15,15,15,15,15,15];class ir{constructor(t){this.bendPenaltyAsAPercentageOfDistance=er.DefaultBendPenaltyAsAPercentageOfDistance,this.currentPassTargetEntries=new Array(4),this.bendPenaltyAsAPercentageOfDistance=t}GetPath(t,e){const i={entry:this.GetPathStage(null,t,null,e)};return er.RestorePathV(i)}GetPathStage(t,e,i,n){const r=new er,s={bestEntry:null,bestCost:Number.MAX_VALUE/$n.OverlappedWeight};let o=Number.POSITIVE_INFINITY;const a=ir.Barycenter(e),l=ir.Barycenter(n),h=er.ManhattanDistance(a,l);r.BendsImportance=Math.max(.001,h*(.01*this.bendPenaltyAsAPercentageOfDistance));const u=r.LengthImportance,c=null!=i?this.currentPassTargetEntries:null,d=[];for(const t of e)for(const e of n)d.push([t,e]);d.sort(([t,e],[i,n])=>g(t,e)-g(i,n));for(const[e,n]of d){if(E.closeDistEps(e.point,n.point))continue;const h=f(e,a)*u,d=f(n,l)*u;let p=s.bestCost;if(null!=i){for(let t=0;t<c.length;t++)c[t]=null;p=r.MultistageAdjustedCostBound(s.bestCost)}const m=r.GetPathWithCost(t,e,h,c,n,d,p);if(null!=c){ir.UpdateTargetEntriesForEachDirection(i,c,s);continue}if(null==m)continue;const y=m.Cost/g(e,n);(m.Cost<s.bestCost||v(m.Cost,s.bestCost)&&y<o)&&(s.bestCost=m.Cost,s.bestEntry=m,o=m.Cost/g(e,n))}return s.bestEntry;function g(t,e){return er.ManhattanDistance(t.point,e.point)}function f(t,e){return er.ManhattanDistance(t.point,e)}}static UpdateTargetEntriesForEachDirection(t,e,i){for(let n=0;n<e.length;n++){const r=e[n];null!=r&&((null==t[n]||r.Cost<t[n].Cost)&&(t[n]=r,r.Cost<i.bestCost&&(i.bestCost=r.Cost,i.bestEntry=r)))}}static Barycenter(t){let e=new E(0,0);for(const i of t)e=e.add(i.point);return e.div(t.length)}}class nr{constructor(t){this.GeomEdge=t}get PathPoints(){return this._pathPoints}set PathPoints(t){this._pathPoints=t}get Width(){return this.GeomEdge.lineWidth}get End(){return this.LastEdge.Target}get Start(){return this.FirstEdge.Source}ArrayOfPathPoints(){return this._pathPoints instanceof Bn?Array.from(rr(this._pathPoints)):this._pathPoints}*PathEdges(){for(let t=this.FirstEdge;null!=t;t=t.Next)yield t}AddEdge(t){t.Path=this,this.LastEdge.Next=t,t.Prev=this.LastEdge,this.LastEdge=t}SetFirstEdge(t){this.FirstEdge=t,this.LastEdge=t,t.Path=this}toString(){const t=new _t.StringBuilder;this.PathPoints instanceof Bn&&t.Append("L");for(const e of rr(this.PathPoints))t.Append(e.toString());return t.ToString()}}function*rr(t){if(t instanceof Bn)for(let e=t;null!=e;e=e.Next)yield e.Point;else for(const e of t)yield e}class sr extends Ci{constructor(t,e,i,n){super(e),this.Slope=0,this.SlopeInverse=0,this.Obstacle=t,this.endVertex=n?e.nextOnPolyline:e.prevOnPolyline,i.IsPerpendicularPP(e.point,this.endVertex.point)||(this.Slope=Zn.Slope(e.point,this.endVertex.point,i),this.SlopeInverse=1/this.Slope)}get Obstacle(){return this.obstacle}set Obstacle(t){this.obstacle=t}get EndVertex(){return this.endVertex}}class or extends sr{constructor(t,e,i){super(t,e,i,i.IsHorizontal)}}class ar extends sr{constructor(t,e,i){super(t,e,i,i.IsVertical)}}class lr{constructor(t,e,i){if(null!=t){if(e){const e=t.BoundingBox.clone();e.pad(i),this.PaddedPolyline=F.polyFromBox(e)}else this.PaddedPolyline=Hi.PaddedPolylineBoundaryOfNode(t.BoundaryCurve,i);lr.RoundVerticesAndSimplify(this.PaddedPolyline),this.IsRectangle=this.IsPolylineRectangle(),this.InputShape=t,this.Ports=new Set(this.InputShape.Ports)}}get PaddedPolyline(){return this._PaddedPolyline}set PaddedPolyline(t){this._PaddedPolyline=t}GetPortChanges(t){return t.addedPorts=de(this.InputShape.Ports,this.Ports),t.removedPorts=de(this.Ports,this.InputShape.Ports),(0!=t.addedPorts.size||0!=t.removedPorts.size)&&(this.Ports=new Set(this.InputShape.Ports),!0)}get IsInConvexHull(){return null!=this.ConvexHull}get IsGroup(){return null!=this.InputShape&&this.InputShape.IsGroup}get VisibilityBoundingBox(){return this.VisibilityPolyline.boundingBox}get VisibilityPolyline(){return null!=this.ConvexHull?this.ConvexHull.Polyline:this.PaddedPolyline}static CreateSentinel(t,e,i,n){const r=lr.mk(t,e,n);return r.CreateInitialSides(r.PaddedPolyline.startPoint,i),r}CreateInitialSides(t,e){this.ActiveLowSide=new or(this,t,e),this.ActiveHighSide=new ar(this,t,e),e.IsFlatS(this.ActiveHighSide)&&(this.ActiveHighSide=new ar(this,this.ActiveHighSide.EndVertex,e))}static mk(t,e,i){const n=new lr(null,!1,0);return n.PaddedPolyline=k.mkClosedFromPoints([y.RoundPoint(t),y.RoundPoint(e)]),n.Ordinal=i,n}IsPolylineRectangle(){if(4!=this.PaddedPolyline.count)return!1;let t=this.PaddedPolyline.startPoint,e=t.nextOnPolyline,i=W.VectorDirectionPP(t.point,e.point);if(!W.IsPureDirection(i))return!1;do{t=e,e=t.nextOnPolyline;const n=W.DirectionFromPointToPoint(t.point,e.point);if(n!=W.RotateRight(i))return!1;i=n}while(t!=this.PaddedPolyline.startPoint);return!0}static RoundVerticesAndSimplify(t){let e=t.startPoint;do{e.point=y.RoundPoint(e.point),e=e.nextOnPolyline}while(e!=t.startPoint);lr.RemoveCloseAndCollinearVerticesInPlace(t),t.setInitIsRequired()}get IsPrimaryObstacle(){return null==this.ConvexHull||this==this.ConvexHull.PrimaryObstacle}static RemoveCloseAndCollinearVerticesInPlace(t){const e=10*y.intersectionEpsilon;for(let i=t.startPoint.next;null!=i;i=i.next)E.close(i.prev.point,i.point,e)&&(null==i.next?t.RemoveEndPoint():(i.prev.next=i.next,i.next.prev=i.prev));return E.close(t.start,t.end,e)&&t.RemoveStartPoint(),hn.RemoveCollinearVertices(t),null!=t.endPoint.prev&&t.endPoint.prev!=t.startPoint&&E.getTriangleOrientation(t.endPoint.prev.point,t.end,t.start)==s.Collinear&&t.RemoveEndPoint(),null!=t.startPoint.next&&t.endPoint.prev!=t.startPoint&&E.getTriangleOrientation(t.end,t.start,t.startPoint.next.point)==s.Collinear&&t.RemoveStartPoint(),t.setInitIsRequired(),t}get isOverlapped(){return null!=this.clump&&this.clump.length>0}get IsSentinel(){return null==this.InputShape}IsInSameClump(t){return this.isOverlapped&&this.clump==t.clump}Close(){this.ActiveLowSide=null,this.ActiveHighSide=null}SetConvexHull(t){this.clump=null,this.IsRectangle=!1,this.ConvexHull=t,this.looseVisibilityPolyline=null}static CreateLoosePolyline(t){const e=Hi.CreatePaddedPolyline(t,10*y.intersectionEpsilon);return lr.RoundVerticesAndSimplify(e),e}get IsTransparentAncestor(){return null!=this.InputShape&&this.InputShape.IsTransparent}set IsTransparentAncestor(t){this.InputShape.IsTransparent=t}}lr.FirstSentinelOrdinal=1,lr.FirstNonSentinelOrdinal=10;class hr{constructor(t,e,i,n){this.IsOverlapped=!1,this.unpaddedToPaddedBorderWeight=$n.NormalWeight,this.ObstaclePort=t,this.UnpaddedBorderIntersect=e,this.OutwardDirection=i;const r=I.mkPP(this.UnpaddedBorderIntersect,Zn.RectangleBorderIntersect(t.Obstacle.VisibilityBoundingBox,this.UnpaddedBorderIntersect,i)),s=F.getAllIntersections(r,t.Obstacle.VisibilityPolyline,!0);this.VisibilityBorderIntersect=y.RoundPoint(s[0].x);const o={pacList:null};this.MaxVisibilitySegment=n.CreateMaxVisibilitySegment(this.VisibilityBorderIntersect,this.OutwardDirection,o),this.pointAndCrossingsList=o.pacList,(this.Obstacle.isOverlapped||this.Obstacle.IsGroup&&!this.Obstacle.IsInConvexHull)&&(this.IsOverlapped=n.IntersectionIsInsideAnotherObstacle(null,this.Obstacle,this.VisibilityBorderIntersect,Kn.GetInstance(this.OutwardDirection)),(!this.Obstacle.IsGroup||this.IsOverlapped||this.InteriorEdgeCrossesObstacle(n))&&(this.unpaddedToPaddedBorderWeight=$n.OverlappedWeight)),this.Obstacle.IsInConvexHull&&this.unpaddedToPaddedBorderWeight==$n.NormalWeight&&this.SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(n)}get Obstacle(){return this.ObstaclePort.Obstacle}get InitialWeight(){return this.IsOverlapped?$n.OverlappedWeight:$n.NormalWeight}get IsCollinearWithPort(){return W.IsPureDirection(U.GetDirections(this.VisibilityBorderIntersect,this.ObstaclePort.Location))}get IsVertical(){return Zn.IsVertical(this.MaxVisibilitySegment)}get WantVisibilityIntersection(){return!this.IsOverlapped&&this.CanExtend&&(!this.ObstaclePort.HasCollinearEntrances||this.IsCollinearWithPort)}get CanExtend(){return U.GetDirections(this.MaxVisibilitySegment.start,this.MaxVisibilitySegment.end)!=l.None}SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(t){(this.Obstacle.IsGroup?this.InteriorEdgeCrossesObstacle(t):this.InteriorEdgeCrossesConvexHullSiblings())&&(this.unpaddedToPaddedBorderWeight=$n.OverlappedWeight)}InteriorEdgeCrossesObstacle(t){const e=G.mkPP(this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect);return this.InteriorEdgeCrossesObstacleRFI(e,t=>t.VisibilityPolyline,Array.from(t.Root.GetLeafRectangleNodesIntersectingRectangle(e)).filter(t=>!t.UserData.IsGroup&&t.UserData!=this.Obstacle).map(t=>t.UserData))}InteriorEdgeCrossesConvexHullSiblings(){const t=G.mkPP(this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect);return this.InteriorEdgeCrossesObstacleRFI(t,t=>t.PaddedPolyline,this.Obstacle.ConvexHull.Obstacles.filter(t=>t!=this.Obstacle))}InteriorEdgeCrossesObstacleRFI(t,e,i){let n=null;for(const r of i){const i=e(r);if(!Zn.RectangleInteriorsIntersect(t,i.boundingBox))continue;n=null!=n?n:I.mkPP(this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect);if(null!=F.intersectionOne(n,i,!1))return!0;if(a.Outside!=F.PointRelativeToCurveLocation(this.UnpaddedBorderIntersect,i))return!0}return!1}get HasGroupCrossings(){return null!=this.pointAndCrossingsList&&this.pointAndCrossingsList.Count()>0}HasGroupCrossingBeforePoint(t){if(!this.HasGroupCrossings)return!1;const e=Zn.IsAscending(this.OutwardDirection)?this.pointAndCrossingsList.First:this.pointAndCrossingsList.Last;return U.GetDirections(this.MaxVisibilitySegment.start,e.Location)==U.GetDirections(e.Location,t)}AddToAdjacentVertex(t,e,i,n){let r=t.VisGraph.FindVertex(this.VisibilityBorderIntersect);null==r?(this.OutwardDirection==U.GetDirections(e.point,this.VisibilityBorderIntersect)?(this.VisibilityBorderIntersect=e.point,r=e):(r=t.FindOrAddVertex(this.VisibilityBorderIntersect),t.FindOrAddEdge(r,e,this.InitialWeight)),this.ExtendEdgeChain(t,r,e,i,n)):this.ExtendEdgeChain(t,r,r,i,n)}ExtendEdgeChain(t,e,i,n,r){t.ExtendEdgeChainVRLPB(i,n,this.MaxVisibilitySegment,this.pointAndCrossingsList,this.IsOverlapped);const s=t.FindOrAddVertex(this.UnpaddedBorderIntersect);t.FindOrAddEdge(s,e,this.unpaddedToPaddedBorderWeight),r&&t.ConnectVertexToTargetVertex(this.ObstaclePort.CenterVertex,s,this.OutwardDirection,this.InitialWeight)}toString(){return _t.String.Format("{0} {1}~{2} {3}",this.ObstaclePort.Location,this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect,this.OutwardDirection)}}class ur{constructor(t,e){this.HasCollinearEntrances=!1,this.VisibilityRectangle=G.mkEmpty(),this.Port=t,this.Obstacle=e,this.PortEntrances=new Array,this.Location=y.RoundPoint(this.Port.Location)}CreatePortEntrance(t,e,i){const n=new hr(this,t,e,i);this.PortEntrances.push(n),this.VisibilityRectangle.add(n.MaxVisibilitySegment.end),this.HasCollinearEntrances=this.HasCollinearEntrances||n.IsCollinearWithPort}ClearVisibility(){this.PortEntrances=[]}AddToGraph(t,e){e&&(this.CenterVertex=t.FindOrAddVertex(this.Location))}RemoveFromGraph(){this.CenterVertex=null}get LocationHasChanged(){return!E.closeDistEps(this.Location,y.RoundPoint(this.Port.Location))}get PortCurve(){return this.Port.Curve}get PortLocation(){return this.Port.Location}toString(){return this.Port+this.Obstacle.toString()}}class cr{constructor(t,e){this.maxVisibilitySegmentsAndCrossings=new Array(4),this.OutOfBoundsDirectionFromGraph=l.None,this.GetVertex(t,e)}get Point(){return this.Vertex.point}get InitialWeight(){return this.IsOverlapped?$n.OverlappedWeight:$n.NormalWeight}get IsOutOfBounds(){return l.None!=this.OutOfBoundsDirectionFromGraph}GetVertex(t,e){this.Vertex=t.FindOrAddVertex(e)}AddEdgeToAdjacentEdge(t,e,i,n){const r=Zn.SegmentIntersectionEP(e,this.Point);let s=t.VisGraph.FindVertex(r);return null!=s?this.AddToAdjacentVertex(t,s,i,n):s=t.AddEdgeToTargetEdge(this.Vertex,e,r),this.ExtendEdgeChain(t,s,i,n),s}AddToAdjacentVertex(t,e,i,n){U.EqualPP(this.Point,e.point)||t.FindOrAddEdge(this.Vertex,e,this.InitialWeight),this.ExtendEdgeChain(t,e,i,n)}ExtendEdgeChain(t,e,i,n){let r=this.IsOverlapped;r&&(r=t.ObstacleTree.PointIsInsideAnObstaclePD(e.point,i));const s=this.GetSegmentAndCrossings(this.IsOverlapped?e:this.Vertex,i,t);t.ExtendEdgeChainVRLPB(e,n,s[0],s[1],r)}GetSegmentAndCrossings(t,e,i){const n=W.ToIndex(e);let r=this.maxVisibilitySegmentsAndCrossings[n];if(null==r){const s={pacList:null};r=[i.ObstacleTree.CreateMaxVisibilitySegment(t.point,e,s),s.pacList],this.maxVisibilitySegmentsAndCrossings[n]=r}else U.GetDirections(t.point,r[0].start)==e&&(r[0].start=t.point);return r}MaxVisibilityInDirectionForNonOverlappedFreePoint(t,e){return this.GetSegmentAndCrossings(this.Vertex,t,e)[0].end}AddOobEdgesFromGraphCorner(t,e){const i=U.GetDirections(e,this.Vertex.point),n=t.VisGraph.FindVertex(e);t.ConnectVertexToTargetVertex(n,this.Vertex,i&(l.North|l.South),$n.NormalWeight),t.ConnectVertexToTargetVertex(n,this.Vertex,i&(l.East|l.West),$n.NormalWeight)}RemoveFromGraph(){this.Vertex=null}toString(){return this.Vertex.toString()}}class dr{constructor(t,e){this.BoundaryWidth=y.distanceEpsilon,this.Group=t,this.DirectionToInside=e}GetInteriorVertexPoint(t){return y.RoundPoint(t.add(W.toPoint(this.DirectionToInside).mul(this.BoundaryWidth)))}toString(){return _t.String.Format("{0} {1}",this.DirectionToInside,this.Group)}}dr.BoundaryWidth=y.distanceEpsilon;class gr extends ni{constructor(t){super(),this.site=t}get Site(){return this.site}}class fr extends ri{constructor(t,e){super(e),this.Obstacle=t}}class pr extends fr{constructor(t,e){super(t,e)}}class mr{constructor(t){this.Coord=t}AddPendingPerpendicularCoord(t){null==this.pendingPerpCoords&&(this.pendingPerpCoords=new Array),this.pendingPerpCoords.push(t)}ResetForIntersections(){this.CurrentSegment=this.FirstSegment}get IsHorizontal(){return!this.FirstSegment.IsVertical}TraverseToSegmentContainingPoint(t){if(this.CurrentSegment.ContainsPoint(t))return!0;const e=this.IsHorizontal?t.y:t.x;if(!U.Equal(this.Coord,e)){for(;this.MoveNext(););return!1}for(;;){if((null==this.CurrentSegment.NextSegment||U.GetDirections(this.CurrentSegment.End,t)==U.GetDirections(t,this.CurrentSegment.NextSegment.Start))&&E.closeIntersections(this.CurrentSegment.End,t))return this.CurrentSegment.Update(this.CurrentSegment.Start,t),!0;if(!this.MoveNext())return!1;if(this.CurrentSegment.ContainsPoint(t))return!0;if(U.IsPureLower(t,this.CurrentSegment.Start))return this.CurrentSegment.Update(t,this.CurrentSegment.End),!0}}MoveNext(){return this.CurrentSegment=this.CurrentSegment.NextSegment,this.HasCurrent}get HasCurrent(){return null!=this.CurrentSegment}PointIsCurrentEndAndNextStart(t){return t.equal(this.CurrentSegment.End)&&null!=this.CurrentSegment.NextSegment&&t.equal(this.CurrentSegment.NextSegment.Start)}AddPerpendicularCoord(t){const e=this.IsHorizontal?new E(t,this.Coord):new E(this.Coord,t);this.TraverseToSegmentContainingPoint(e),this.CurrentSegment.AddSparseVertexCoord(t)}toString(){return null==this.FirstSegment?"-0- "+this.Coord:this.IsHorizontal?"(H) Y == "+this.Coord:"(V) X == "}AppendScanSegment(t){null==this.FirstSegment?this.FirstSegment=t:this.CurrentSegment.NextSegment=t,this.CurrentSegment=t}AddPendingPerpendicularCoordsToScanSegments(){if(null!=this.pendingPerpCoords){this.ResetForIntersections();for(const t of this.pendingPerpCoords)this.AddPerpendicularCoord(t)}}}class yr{constructor(t,e){this.CurrentSlotIndex=0,this.vector=[],this.IsHorizontal=e;const i=Array.from(t).sort((t,e)=>t>e?1:t<e?-1:0);for(const t of i)this.vector.push(new mr(t))}get Length(){return this.vector.length}get CurrentSlot(){return this.vector[this.CurrentSlotIndex]}Item(t){return this.vector[t]}CreateScanSegment(t,e,i,n){this.CurrentSlot.AppendScanSegment(new $n(t,e,i,n))}ScanSegmentsCompleteForCurrentSlot(){this.CurrentSlotIndex++}ScanSegmentsComplete(){for(const t of this.vector)t.AddPendingPerpendicularCoordsToScanSegments()}Items(){return this.vector}ResetForIntersections(){for(const t of this.vector)t.ResetForIntersections()}FindNearest(t,e){let i=0,n=this.vector.length-1;if(t<=this.vector[i].Coord)return i;if(t>=this.vector[n].Coord)return n;for(;n-i>2;){const e=i+(n-i>>1),r=this.vector[e];if(t<r.Coord)n=e;else{if(!(t>r.Coord))return e;i=e}}for(i++;i<=n;i++){const n=this.vector[i];if(t<n.Coord)return e>0?i:i-1;if(t==n.Coord)break}return i}CreateSparseVerticesAndEdges(t){for(const e of this.vector){e.ResetForIntersections();for(let i=e.FirstSegment;null!=i;i=i.NextSegment)i.CreateSparseVerticesAndEdges(t)}}GetParallelCoord(t){return this.IsHorizontal?t.y:t.x}GetPerpendicularCoord(t){return this.IsHorizontal?t.x:t.y}ConnectAdjoiningSegmentEndpoints(){for(const t of this.vector){t.ResetForIntersections();let e=t.FirstSegment;for(let t=e.NextSegment;null!=t;t=t.NextSegment){if(t.HasSparsePerpendicularCoords&&e.HasSparsePerpendicularCoords&&t.Start==e.End){const i=this.GetPerpendicularCoord(t.Start);e.AddSparseEndpoint(i),t.AddSparseEndpoint(i)}e=t}}}toString(){return(this.IsHorizontal?"(H) count":"(V) count == ")+this.vector.length}}class br extends ni{constructor(t,e,i){super(),this.InitialObstacle=t,this.ReflectingObstacle=e,this.site=i}static mk(t,e,i){const n=new br(t.ReflectingObstacle,e,i);return n.PreviousSite=t,n}IsStaircaseStep(t){return this.InitialObstacle==t}get Site(){return this.site}}class Pr{constructor(){this.eventTree=new ii((t,e)=>this.Compare(t,e))}Reset(t){this.scanDirection=t}Enqueue(t){this.eventTree.Enqueue(t)}Dequeue(){return this.eventTree.Dequeue()}get Count(){return this.eventTree.Count}Compare(t,e){if(t==e)return 0;if(null==t)return-1;if(null==e)return 1;let i=this.scanDirection.ComparePerpCoord(t.Site,e.Site);if(i)return i;return i=(t instanceof br?0:1)-(e instanceof br?0:1),i||this.scanDirection.CompareScanCoord(t.Site,e.Site)}}class vr{constructor(){this.pointCrossingMap=new Ie,this.pointList=new Array}AddIntersection(t,e,i){let n=this.pointCrossingMap.get(t);n||(n=new Array,this.pointCrossingMap.set(t,n));const r=n.length;for(let t=0;t<r;t++){const i=n[t];if(i.Group==e)return i}const s=new dr(e,i);return n.push(s),s}Clear(){this.pointCrossingMap.clear()}GetOrderedListBetween(t,e){if(0==this.pointCrossingMap.size)return null;if(U.ComparePP(t,e)>0){const i=t;t=e,e=i}this.pointList=[];for(const i of this.pointCrossingMap.keys())U.ComparePP(i,t)>=0&&U.ComparePP(i,e)<=0&&this.pointList.push(i);this.pointList.sort((t,e)=>t.compareTo(e));const i=new Qn,n=this.pointList.length;for(let t=0;t<n;t++){const e=this.pointList[t];i.Add(e,this.pointCrossingMap.get(e))}return i}toString(){return _t.String.Format("{0}",this.pointCrossingMap.size)}}class Sr extends br{constructor(t,e,i){super(t.ReflectingObstacle,e.Obstacle,i),this.Side=e}}class Cr{constructor(t){this.staleSites=new Array,this.scanDirection=t,this.eventTree=new ei((t,e)=>this.CompareBB(t,e)),this.findFirstPred=t=>this.CompareToFindFirstPoint(t.Site)>=0}Add(t){this.eventTree.insert(t)}MarkStaleSite(t){this.staleSites.push(t)}RemoveStaleSites(){const t=this.staleSites.length;if(t>0){for(let e=0;e<t;e++)this.RemoveExact(this.staleSites[e]);this.staleSites=[]}}RemoveSitesForFlatBottom(t,e){for(let i=this.FindFirstInRange(t,e);null!=i;i=this.FindNextInRange(i,e))this.MarkStaleSite(i.item);this.RemoveStaleSites()}Find(t){return this.FindFirstInRange(t,t)}RemoveExact(t){const e=this.eventTree.find(t);return null!=e&&e.item.Site==t.Site&&(this.eventTree.deleteNodeInternal(e),!0)}FindFirstInRange(t,e){this.findFirstPoint=t;const i=this.eventTree.findFirst(this.findFirstPred);return null!=i&&this.Compare(i.item.Site,e)<=0?i:null}CompareToFindFirstPoint(t){return this.Compare(t,this.findFirstPoint)}FindNextInRange(t,e){const i=this.eventTree.next(t);return null!=i&&this.Compare(i.item.Site,e)<=0?i:null}CompareBB(t,e){return this.scanDirection.CompareScanCoord(t.Site,e.Site)}Compare(t,e){return this.scanDirection.CompareScanCoord(t,e)}}class wr extends fr{constructor(t,e){super(t,e)}}class Er extends fr{constructor(t,e){super(t,e)}}class xr extends fr{constructor(t,e){super(t,e)}}class Ar extends br{constructor(t,e,i){super(t.ReflectingObstacle,e.obstacle,i),this.Side=e}}class Tr{get LowNeighborSide(){return null==this.LowNeighbor?null:this.LowNeighbor.item}get HighNeighborSide(){return null==this.HighNeighbor?null:this.HighNeighbor.item}Clear(){this.LowNeighbor=null,this.LowOverlapEnd=null,this.GroupSideInterveningBeforeLowNeighbor=null,this.HighNeighbor=null,this.HighOverlapEnd=null,this.GroupSideInterveningBeforeHighNeighbor=null}SetSides(t,e,i,n){if(Zn.IsAscending(t))return this.HighNeighbor=e,this.HighOverlapEnd=i,void(this.GroupSideInterveningBeforeHighNeighbor=n);this.LowNeighbor=e,this.LowOverlapEnd=i,this.GroupSideInterveningBeforeLowNeighbor=n}}class Ir{constructor(t,e){this.Polyline=t,this.Obstacles=Array.from(e),this.PrimaryObstacle=this.Obstacles[0],lr.RoundVerticesAndSimplify(this.Polyline)}}class Or{static MungeClosestIntersectionInfo(t,e,i){const n=e.seg1.boundingBox,r=y.RoundPoint(e.x).clone();return i?new E(Or.MungeIntersect(t.x,r.x,n.left,n.right),r.y):new E(r.x,Or.MungeIntersect(t.y,r.y,n.bottom,n.top))}static MungeIntersect(t,e,i,n){if(t<e){const t=Math.min(i,n);e<t&&(e=t)}else if(t>e){const t=Math.max(i,n);e>t&&(e=t)}return y.RoundDouble(e)}}class _r{constructor(){this.CurrentGroupBoundaryCrossingMap=new vr,this.overlapPairs=new Mt,this.hasOverlaps=!1,this.lookupIntPair=new wt(-1,-1)}get GraphBox(){return this.Root.irect}Init(t,e,i){this.CreateObstacleListAndOrdinals(t),this.AncestorSets=e,this.CreateRoot(),this.shapeIdToObstacleMap=i}CreateObstacleListAndOrdinals(t){this.allObstacles=Array.from(t);let e=lr.FirstNonSentinelOrdinal;for(const t of this.allObstacles)t.Ordinal=e++}OrdinalToObstacle(t){return this.allObstacles[t-lr.FirstNonSentinelOrdinal]}CreateRoot(){this.Root=_r.CalculateHierarchy(this.GetAllObstacles()),this.OverlapsExist()&&(this.AccreteClumps(),this.AccreteConvexHulls(),this.GrowGroupsToAccommodateOverlaps(),this.Root=_r.CalculateHierarchy(this.GetAllObstacles().filter(t=>t.IsPrimaryObstacle)))}OverlapsExist(){return null!=this.Root&&(Vi(this.Root,this.Root,(t,e)=>this.CheckForInitialOverlaps(t,e)),this.hasOverlaps)}OverlapPairAlreadyFound(t,e){return this.lookupIntPair.x=e.Ordinal,this.lookupIntPair.y=t.Ordinal,this.overlapPairs.has(this.lookupIntPair)}CheckForInitialOverlaps(t,e){if(this.hasOverlaps)return;const i={bIsInsideA:!1,aIsInsideB:!1};_r.ObstaclesIntersect(t,e,i)?this.hasOverlaps=!0:(i.aIsInsideB||i.bIsInsideA)&&(t.IsGroup&&e.IsGroup||t.IsGroup&&i.bIsInsideA||e.IsGroup&&i.aIsInsideB||(this.hasOverlaps=!0))}AccreteClumps(){this.AccumulateObstaclesForClumps(),this.CreateClumps()}AccreteConvexHulls(){for(;;)if(this.AccumulateObstaclesForConvexHulls(),!this.CreateConvexHulls())return}static CalculateHierarchy(t){return ot(Array.from(t).map(t=>ut(t,t.VisibilityBoundingBox)))}AccumulateObstaclesForClumps(){this.overlapPairs.clear();const t=_r.CalculateHierarchy(this.GetAllObstacles().filter(t=>!t.IsGroup&&t.IsRectangle));null!=t&&ki(t,t,(t,e)=>this.EvaluateOverlappedPairForClump(t,e))}EvaluateOverlappedPairForClump(t,e){if(t==e||this.OverlapPairAlreadyFound(t,e))return;const i={bIsInsideA:!1,aIsInsideB:!1};(_r.ObstaclesIntersect(t,e,i)||i.aIsInsideB||i.bIsInsideA)&&this.overlapPairs.add(new wt(t.Ordinal,e.Ordinal))}AccumulateObstaclesForConvexHulls(){this.overlapPairs.clear();const t=_r.CalculateHierarchy(this.GetAllObstacles().filter(t=>t.IsPrimaryObstacle&&!t.IsGroup));null!=t&&ki(t,t,(t,e)=>this.EvaluateOverlappedPairForConvexHull(t,e))}EvaluateOverlappedPairForConvexHull(t,e){if(t==e||this.OverlapPairAlreadyFound(t,e))return;const i={bIsInsideA:!1,aIsInsideB:!1};(_r.ObstaclesIntersect(t,e,i)||i.aIsInsideB||i.bIsInsideA)&&(!t.IsInConvexHull&&!e.IsInConvexHull&&t.IsRectangle&&e.IsRectangle||(this.overlapPairs.add(new wt(t.Ordinal,e.Ordinal)),this.AddClumpToConvexHull(t),this.AddClumpToConvexHull(e),this.AddConvexHullToConvexHull(t),this.AddConvexHullToConvexHull(e)))}GrowGroupsToAccommodateOverlaps(){for(;;)if(this.AccumulateObstaclesForGroupOverlaps(),!this.GrowGroupsToResolveOverlaps())return}AccumulateObstaclesForGroupOverlaps(){const t=_r.CalculateHierarchy(this.GetAllObstacles().filter(t=>t.IsGroup)),e=_r.CalculateHierarchy(this.GetAllObstacles().filter(t=>t.IsPrimaryObstacle));null!=t&&null!=e&&ki(t,e,(t,e)=>this.EvaluateOverlappedPairForGroup(t,e))}EvaluateOverlappedPairForGroup(t,e){if(t==e||this.OverlapPairAlreadyFound(t,e))return;const i={bIsInsideA:!1,aIsInsideB:!1},n=_r.ObstaclesIntersect(t,e,i);(n||i.aIsInsideB||i.bIsInsideA)&&(t.IsRectangle&&e.IsRectangle?e.IsGroup||(i.aIsInsideB||_r.FirstRectangleContainsACornerOfTheOther(e.VisibilityBoundingBox,t.VisibilityBoundingBox))&&(e.OverlapsGroupCorner=!0):(n||!e.IsGroup&&!i.bIsInsideA)&&this.overlapPairs.add(new wt(t.Ordinal,e.Ordinal)))}static FirstRectangleContainsACornerOfTheOther(t,e){return t.contains(e.leftBottom)||t.contains(e.leftTop)||t.contains(e.rightTop)||t.contains(e.rightBottom)}static FirstPolylineStartIsInsideSecondPolyline(t,e){return F.PointRelativeToCurveLocation(t.start,e)!=a.Outside}AddClumpToConvexHull(t){if(t.isOverlapped){for(const e of t.clump.filter(e=>e.Ordinal!=t.Ordinal))this.overlapPairs.add(new wt(t.Ordinal,e.Ordinal));t.clump=[]}}AddConvexHullToConvexHull(t){if(t.IsInConvexHull){for(const e of t.ConvexHull.Obstacles.filter(e=>e.Ordinal!=t.Ordinal))this.overlapPairs.add(new wt(t.Ordinal,e.Ordinal));t.ConvexHull.Obstacles=[]}}CreateClumps(){const t=Ft(Pt(Array.from(this.overlapPairs.values())));for(const e of t){if(1==e.length)continue;const t=e.map(t=>this.OrdinalToObstacle(t));for(const e of t)e.clump=t}}CreateConvexHulls(){let t=!1;const e=Ft(Pt(Array.from(this.overlapPairs.values())));for(const i of e){if(1==i.length)continue;t=!0;const e=i.map(this.OrdinalToObstacle),n=be(e,t=>Array.from(t.VisibilityPolyline)),r=new Ir(Ni.createConvexHullAsClosedPolyline(n),e);for(const t of e)t.SetConvexHull(r)}return t}GrowGroupsToResolveOverlaps(){let t=!1;for(const e of this.overlapPairs.values()){t=!0;const i=this.OrdinalToObstacle(e.x),n=this.OrdinalToObstacle(e.y);_r.ResolveGroupAndGroupOverlap(i,n)||_r.ResolveGroupAndObstacleOverlap(i,n)}return this.overlapPairs.clear(),t}static ResolveGroupAndGroupOverlap(t,e){return!!e.IsGroup&&(t.VisibilityPolyline.boundingBox.area>e.VisibilityPolyline.boundingBox.area?_r.ResolveGroupAndObstacleOverlap(t,e):_r.ResolveGroupAndObstacleOverlap(e,t),!0)}static ResolveGroupAndObstacleOverlap(t,e){let i=e.looseVisibilityPolyline;_r.GrowGroupAroundLoosePolyline(t,i);const n={bIsInsideA:!1,aIsInsideB:!1};for(;_r.ObstaclesIntersect(e,t,n)||!n.aIsInsideB;)i=lr.CreateLoosePolyline(i),_r.GrowGroupAroundLoosePolyline(t,i)}static GrowGroupAroundLoosePolyline(t,e){const i=Array.from(t.VisibilityPolyline).concat(Array.from(e));t.SetConvexHull(new Ir(Ni.createConvexHullAsClosedPolyline(i),[t]))}static ObstaclesIntersect(t,e,i){return F.CurvesIntersect(t.VisibilityPolyline,e.VisibilityPolyline)?(i.aIsInsideB=!1,i.bIsInsideA=!1,!0):(i.aIsInsideB=_r.FirstPolylineStartIsInsideSecondPolyline(t.VisibilityPolyline,e.VisibilityPolyline),i.bIsInsideA=!i.aIsInsideB&&_r.FirstPolylineStartIsInsideSecondPolyline(e.VisibilityPolyline,t.VisibilityPolyline),(!t.IsRectangle||!e.IsRectangle)&&(!!_r.ObstaclesAreCloseEnoughToBeConsideredTouching(t,e,i.aIsInsideB,i.bIsInsideA)&&(i.aIsInsideB=!1,i.bIsInsideA=!1,!0)))}static ObstaclesAreCloseEnoughToBeConsideredTouching(t,e,i,n){if(!i&&!n)return F.CurvesIntersect(t.looseVisibilityPolyline,e.VisibilityPolyline);const r=i?t.looseVisibilityPolyline:e.looseVisibilityPolyline,s=i?e.VisibilityPolyline:t.VisibilityPolyline;for(const t of r)if(F.PointRelativeToCurveLocation(t,s)==a.Outside){const e=F.ClosestPoint(s,t);if(!E.closeIntersections(t,e))return!0}return!1}AdjustSpatialAncestors(){if(this.SpatialAncestorsAdjusted)return!1;for(const t of this.GetAllGroups()){const e=t.VisibilityBoundingBox;for(const i of this.Root.GetNodeItemsIntersectingRectangle(e))if(i!=t&&F.ClosedCurveInteriorsIntersect(i.VisibilityPolyline,t.VisibilityPolyline)){if(i.IsInConvexHull)for(const e of i.ConvexHull.Obstacles)this.AncestorSets.get(e.InputShape).add(t.InputShape);this.AncestorSets.get(i.InputShape).add(t.InputShape)}}let t=new Array;for(const e of this.Root.GetAllLeaves()){const i=e.VisibilityBoundingBox;t=t.concat(Array.from(this.AncestorSets.get(e.InputShape)).filter(t=>!i.intersects(this.shapeIdToObstacleMap.get(t).VisibilityBoundingBox)));for(const i of t)this.AncestorSets.get(e.InputShape).delete(i);t=[]}return this.SpatialAncestorsAdjusted=!0,!0}GetAllGroups(){return this.GetAllObstacles().filter(t=>t.IsGroup)}Clear(){this.Root=null,this.AncestorSets=null}CreateMaxVisibilitySegment(t,e,i){const n=Zn.RectangleBorderIntersect(this.GraphBox,t,e);if(U.GetDirections(t,n)==l.None)return i.pacList=null,I.mkPP(t,t);const r=this.RestrictSegmentWithObstacles(t,n);return i.pacList=this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(r.start,r.end),r}GetAllObstacles(){return this.allObstacles}GetAllPrimaryObstacles(){return this.Root.GetAllLeaves()}IntersectionIsInsideAnotherObstacle(t,e,i,n){this.insideHitTestIgnoreObstacle1=e,this.insideHitTestIgnoreObstacle2=t,this.insideHitTestScanDirection=n;return null!=this.Root.FirstHitNodeWithPredicate(i,this.InsideObstacleHitTest.bind(this))}PointIsInsideAnObstaclePD(t,e){return this.PointIsInsideAnObstacle(t,Kn.GetInstance(e))}PointIsInsideAnObstacle(t,e){this.insideHitTestIgnoreObstacle1=null,this.insideHitTestIgnoreObstacle2=null,this.insideHitTestScanDirection=e;return null!=this.Root.FirstHitNodeWithPredicate(t,this.InsideObstacleHitTest.bind(this))}InsideObstacleHitTest(t,e){if(e==this.insideHitTestIgnoreObstacle1||e==this.insideHitTestIgnoreObstacle2)return tt.Continue;if(e.IsGroup)return tt.Continue;if(!Zn.PointIsInRectangleInterior(t,e.VisibilityBoundingBox))return tt.Continue;const i=Zn.RectangleBorderIntersect(e.VisibilityBoundingBox,t,this.insideHitTestScanDirection.dir).add(this.insideHitTestScanDirection.DirectionAsPoint),n=Zn.RectangleBorderIntersect(e.VisibilityBoundingBox,t,this.insideHitTestScanDirection.OppositeDirection).sub(this.insideHitTestScanDirection.DirectionAsPoint),r=I.mkPP(n,i),s=F.getAllIntersections(r,e.VisibilityPolyline,!0);if(2==s.length){const e=y.RoundPoint(s[0].x),i=y.RoundPoint(s[1].x);if(!U.EqualPP(t,e)&&!U.EqualPP(t,i)&&t.compareTo(e)!=t.compareTo(i)&&!v(Math.floor(s[0].par1),Math.floor(s[1].par1)))return tt.Stop}return tt.Continue}SegmentCrossesAnObstacle(t,e){this.stopAtGroups=!0,this.wantGroupCrossings=!1;const i=this.RestrictSegmentPrivate(t,e);return!U.EqualPP(i.end,e)}SegmentCrossesANonGroupObstacle(t,e){this.stopAtGroups=!1,this.wantGroupCrossings=!1;const i=this.RestrictSegmentPrivate(t,e);return!U.EqualPP(i.end,e)}RestrictSegmentWithObstacles(t,e){return this.stopAtGroups=!1,this.wantGroupCrossings=!0,this.RestrictSegmentPrivate(t,e)}RestrictSegmentPrivate(t,e){return this.GetRestrictedIntersectionTestSegment(t,e),this.currentRestrictedRay=I.mkPP(t,e),this.restrictedRayLengthSquared=t.sub(e).lengthSquared,this.CurrentGroupBoundaryCrossingMap.Clear(),this.RecurseRestrictRayWithObstacles(this.Root),this.currentRestrictedRay}GetRestrictedIntersectionTestSegment(t,e){const i=U.GetDirections(t,e),n=l.West==i?this.GraphBox.right:l.East==i?this.GraphBox.left:t.x,r=l.West==i?this.GraphBox.left:l.East==i?this.GraphBox.right:e.x,s=l.South==i?2*this.GraphBox.top:l.North==i?this.GraphBox.bottom:t.y,o=l.South==i?this.GraphBox.bottom:l.North==i?this.GraphBox.top:t.y;this.restrictedIntersectionTestSegment=I.mkPP(new E(n,s),new E(r,o))}RecurseRestrictRayWithObstacles(t){if(!Zn.RectangleInteriorsIntersect(this.currentRestrictedRay.boundingBox,t.irect))return;const e=t.UserData;if(null!=e){const t=F.getAllIntersections(this.restrictedIntersectionTestSegment,e.VisibilityPolyline,!0);return!e.IsGroup||this.stopAtGroups?void this.LookForCloserNonGroupIntersectionToRestrictRay(t):void(this.wantGroupCrossings&&this.AddGroupIntersectionsToRestrictedRay(e,t))}this.RecurseRestrictRayWithObstacles(t.Left),this.RecurseRestrictRayWithObstacles(t.Right)}LookForCloserNonGroupIntersectionToRestrictRay(t){let e=0,i=null,n=this.restrictedRayLengthSquared;const r=U.GetDirections(this.restrictedIntersectionTestSegment.start,this.restrictedIntersectionTestSegment.end);for(const s of t){const t=y.RoundPoint(s.x),o=U.GetDirections(this.currentRestrictedRay.start,t);if(o==W.OppositeDir(r))continue;if(e++,l.None==o){n=0,i=s;continue}const a=t.sub(this.currentRestrictedRay.start).lengthSquared;if(a<n){if(s.x.sub(this.currentRestrictedRay.start).lengthSquared<y.squareOfDistanceEpsilon)continue;n=a,i=s}}if(null!=i){if(1==e){const t=y.RoundPoint(i.x);if(E.closeIntersections(t,this.currentRestrictedRay.start)||E.closeIntersections(t,this.currentRestrictedRay.end))return}this.restrictedRayLengthSquared=n,this.currentRestrictedRay.end=Or.MungeClosestIntersectionInfo(this.currentRestrictedRay.start,i,!Zn.IsVerticalPP(this.currentRestrictedRay.start,this.currentRestrictedRay.end))}}AddGroupIntersectionsToRestrictedRay(t,e){for(const i of e){const e=y.RoundPoint(i.x);if(e.sub(this.currentRestrictedRay.start).lengthSquared>this.restrictedRayLengthSquared)continue;const n=U.GetDirections(this.currentRestrictedRay.start,this.currentRestrictedRay.end),r=i.seg1;let s=n;0!=(W.VectorDirection(r.derivative(i.par1))&W.RotateRight(n))&&(s=W.OppositeDir(s)),this.CurrentGroupBoundaryCrossingMap.AddIntersection(e,t,s)}}}class Lr{constructor(t,e){this.scanDirection=t,this.SideTree=new ei((t,e)=>this.Compare(t,e)),this.linePositionAtLastInsertOrRemove=e}Insert(t,e){this.linePositionAtLastInsertOrRemove=e;return this.SideTree.insert(t)}get Count(){return this.SideTree.count}Remove(t,e){this.linePositionAtLastInsertOrRemove=e,this.SideTree.remove(t)}Find(t){return-1==this.scanDirection.ComparePerpCoord(this.linePositionAtLastInsertOrRemove,t.Start)?null:this.SideTree.find(t)}NextLowB(t){return this.NextLowR(this.Find(t))}NextLowR(t){return this.SideTree.previous(t)}NextHighB(t){return this.NextHighR(this.Find(t))}NextHighR(t){return this.SideTree.next(t)}Next(t,e){return Zn.IsAscending(t)?this.SideTree.next(e):this.SideTree.previous(e)}Lowest(){return this.SideTree.treeMinimum()}Compare(t,e){if(t.Obstacle==e.Obstacle)return t==e?0:t instanceof or?-1:1;const i=Mr.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove,t,this.scanDirection),n=Mr.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove,e,this.scanDirection);let r=i.compareTo(n);if(0==r){r=function(t,e){return(t?1:0)-(e?1:0)}(t instanceof or,e instanceof or),0==r&&(r=b(t.Obstacle.Ordinal,e.Obstacle.Ordinal))}return r}}class Rr{constructor(t){this.lookupSegment=$n.mk(new E(0,0),new E(0,1)),this.ScanDirection=t,this.segmentTree=new ei((t,e)=>this.Compare(t,e)),this.findIntersectorPred=t=>this.CompareIntersector(t),this.findPointPred=t=>this.CompareToPoint(t)}get Segments(){return this.segmentTree.allNodes()}InsertUnique(t){this.AssertValidSegmentForInsertion(t);const e=this.segmentTree.find(t);return null!=e?e:this.segmentTree.insert(t)}AssertValidSegmentForInsertion(t){}Remove(t){this.segmentTree.remove(t)}Find(t,e){this.lookupSegment.Update(t,e);const i=this.segmentTree.find(this.lookupSegment);return null!=i&&U.EqualPP(i.item.End,e)?i.item:null}FindLowestIntersector(t,e){const i=this.FindLowestIntersectorNode(t,e);return null!=i?i.item:null}FindLowestIntersectorNode(t,e){this.lookupSegment.Update(t,t);let i=this.segmentTree.findLast(this.findIntersectorPred);if(U.EqualPP(t,e))null!=i&&this.ScanDirection.Compare(i.item.End,t)<0&&(i=null);else for(this.lookupSegment.Update(t,e);null!=i&&!i.item.IntersectsSegment(this.lookupSegment);){if(this.ScanDirection.Compare(i.item.Start,e)>0)return null;i=this.segmentTree.next(i)}return i}FindHighestIntersector(t,e){this.lookupSegment.Update(e,e);let i=this.segmentTree.findLast(this.findIntersectorPred);if(U.EqualPP(t,e))null!=i&&this.ScanDirection.Compare(i.item.End,t)<0&&(i=null);else for(this.lookupSegment.Update(t,e);null!=i&&!i.item.IntersectsSegment(this.lookupSegment);){if(this.ScanDirection.Compare(i.item.End,t)<0)return null;i=this.segmentTree.previous(i)}return null!=i?i.item:null}CompareIntersector(t){return this.ScanDirection.Compare(t.Start,this.lookupSegment.Start)<=0}FindSegmentContainingPoint(t,e){return this.FindSegmentOverlappingPoints(t,t,e)}FindSegmentOverlappingPoints(t,e,i){this.lookupSegment.Update(t,e);const n=this.segmentTree.findFirst(this.findPointPred);if(null!=n){const t=n.item;if(this.ScanDirection.Compare(t.Start,e)<=0)return t}return null}CompareToPoint(t){return this.ScanDirection.Compare(t.End,this.lookupSegment.Start)>=0}MergeAndRemoveNextNode(t,e){return-1==this.ScanDirection.Compare(t.End,e.item.End)&&t.Update(t.Start,e.item.End),t.MergeGroupBoundaryCrossingList(e.item.GroupBoundaryPointAndCrossingsList),this.segmentTree.deleteNodeInternal(e),this.segmentTree.find(t)}MergeSegments(){if(this.segmentTree.count<2)return;let t=this.segmentTree.treeMinimum(),e=this.segmentTree.next(t);for(;null!=e;e=this.segmentTree.next(t)){switch(this.ScanDirection.Compare(e.item.Start,t.item.End)){case 1:t=e;break;case 0:e.item.IsOverlapped==t.item.IsOverlapped?t=this.MergeAndRemoveNextNode(t.item,e):(t.item.NeedEndOverlapVertex=!0,e.item.NeedStartOverlapVertex=!0,t=e);break;default:if(t.item.IsOverlapped!=e.item.IsOverlapped){if(t.item.IsOverlapped)t.item.Start==e.item.Start?t=this.MergeAndRemoveNextNode(e.item,t):(t.item.Update(t.item.Start,e.item.Start),t=e);else if(t.item.End==e.item.End)t=this.MergeAndRemoveNextNode(t.item,e);else{const i=e.item,n=t.item;this.segmentTree.deleteNodeInternal(e),i.Update(n.End,i.End),this.segmentTree.insert(i),i.TrimGroupBoundaryCrossingList(),t=this.segmentTree.find(n)}break}t=this.MergeAndRemoveNextNode(t.item,e)}}}Compare(t,e){if(t==e)return 0;if(null==t)return-1;if(null==e)return 1;let i=this.ScanDirection.Compare(t.Start,e.Start);return 0==i&&(i=-1*this.ScanDirection.Compare(t.End,e.End)),i}}class Br extends ci{constructor(t){super(t)}SetVertexEntry(t){null==this.VertexEntries&&(this.VertexEntries=new Array(4)),this.VertexEntries[W.ToIndex(t.Direction)]=t}RemoveVertexEntries(){this.VertexEntries=null}}class Mr{constructor(t){this.ObstacleTree=new _r,this.CurrentGroupBoundaryCrossingMap=new vr,this.LowNeighborSides=new Tr,this.HighNeighborSides=new Tr,this.ScanDirection=Kn.HorizontalInstance,this.eventQueue=new Pr,this.HorizontalScanSegments=new Rr(Kn.HorizontalInstance),this.VerticalScanSegments=new Rr(Kn.VerticalInstance),this.wantReflections=t}get ParallelScanSegments(){return this.ScanDirection.IsHorizontal?this.HorizontalScanSegments:this.VerticalScanSegments}get PerpendicularScanSegments(){return this.ScanDirection.IsHorizontal?this.VerticalScanSegments:this.HorizontalScanSegments}static NewVisibilityGraph(){const t=new di;return t.VertexFactory=t=>new Br(t),t}GenerateVisibilityGraph(){if(null==this.ObstacleTree.Root)return;this.InitializeEventQueue(Kn.HorizontalInstance);let t=lr.FirstSentinelOrdinal,e=new E(this.ObstacleTree.GraphBox.left-Mr.SentinelOffset,this.ObstacleTree.GraphBox.bottom-Mr.SentinelOffset),i=new E(this.ObstacleTree.GraphBox.left-Mr.SentinelOffset,this.ObstacleTree.GraphBox.top+Mr.SentinelOffset),n=lr.CreateSentinel(e,i,this.ScanDirection,t++);this.scanLine.Insert(n.ActiveHighSide,this.ObstacleTree.GraphBox.leftBottom),e=new E(this.ObstacleTree.GraphBox.right+Mr.SentinelOffset,this.ObstacleTree.GraphBox.bottom-Mr.SentinelOffset),i=new E(this.ObstacleTree.GraphBox.right+Mr.SentinelOffset,this.ObstacleTree.GraphBox.top+Mr.SentinelOffset),n=lr.CreateSentinel(e,i,this.ScanDirection,t++),this.scanLine.Insert(n.ActiveLowSide,this.ObstacleTree.GraphBox.leftBottom),this.ProcessEvents(),this.InitializeEventQueue(Kn.VerticalInstance),e=new E(this.ObstacleTree.GraphBox.left-Mr.SentinelOffset,this.ObstacleTree.GraphBox.bottom-Mr.SentinelOffset),i=new E(this.ObstacleTree.GraphBox.right+Mr.SentinelOffset,this.ObstacleTree.GraphBox.bottom-Mr.SentinelOffset),n=lr.CreateSentinel(e,i,this.ScanDirection,t++),this.scanLine.Insert(n.ActiveHighSide,this.ObstacleTree.GraphBox.leftBottom),e=new E(this.ObstacleTree.GraphBox.left-Mr.SentinelOffset,this.ObstacleTree.GraphBox.top+Mr.SentinelOffset),i=new E(this.ObstacleTree.GraphBox.right+Mr.SentinelOffset,this.ObstacleTree.GraphBox.top+Mr.SentinelOffset),n=lr.CreateSentinel(e,i,this.ScanDirection,t),this.scanLine.Insert(n.ActiveLowSide,this.ObstacleTree.GraphBox.leftBottom),this.ProcessEvents()}static ScanLineIntersectSidePBS(t,e,i){const n=e.Direction;let r=e.Start.x,s=e.Start.y;return i.IsHorizontal?(r+=n.x/n.y*(t.y-e.Start.y),r=Or.MungeIntersect(t.x,r,e.Start.x,e.End.x),s=t.y):(r=t.x,s+=n.y/n.x*(t.x-e.Start.x),s=Or.MungeIntersect(t.y,s,e.Start.y,e.End.y)),new E(r,s)}GetOpenVertex(t){let e=t.startPoint,i=this.TraversePolylineForEvents(e),n=this.PointCompare(i.point,e.point);for(;;i=this.TraversePolylineForEvents(i)){const t=this.PointCompare(i.point,e.point);if(t<=0)e=i;else if(t>0&&n<=0)break;n=t}return e}TraversePolylineForEvents(t){return this.ScanDirection.IsHorizontal?t.nextOnPolyline:t.prevOnPolyline}InitializeEventQueue(t){this.ScanDirection=t,this.eventQueue.Reset(this.ScanDirection),this.EnqueueBottomVertexEvents(),this.scanLine=new Lr(this.ScanDirection,this.ObstacleTree.GraphBox.leftBottom),this.lookaheadScan=new Cr(this.ScanDirection)}EnqueueBottomVertexEvents(){for(const t of this.ObstacleTree.GetAllPrimaryObstacles()){const e=this.GetOpenVertex(t.VisibilityPolyline);this.eventQueue.Enqueue(new pr(t,e))}}IsFlat(t){return this.ScanDirection.IsFlatS(t)}IsPerpendicular(t){return this.ScanDirection.IsPerpendicularS(t)}ScanLineIntersectSide(t,e){return Mr.ScanLineIntersectSidePBS(t,e,this.ScanDirection)}SideReflectsUpward(t){return t instanceof or?this.ScanDirection.Coord(t.End)>this.ScanDirection.Coord(t.Start):this.ScanDirection.Coord(t.End)<this.ScanDirection.Coord(t.Start)}SideReflectsDownward(t){return t instanceof or?this.ScanDirection.Coord(t.End)<this.ScanDirection.Coord(t.Start):this.ScanDirection.Coord(t.End)>this.ScanDirection.Coord(t.Start)}StoreLookaheadSite(t,e,i,n){if(this.wantReflections&&!this.IsPerpendicular(e)){if(!n&&!Zn.PointIsInRectangleInterior(i,e.Obstacle.VisibilityBoundingBox))return;this.SideReflectsUpward(e)&&null==this.lookaheadScan.Find(i)&&this.lookaheadScan.Add(new br(t,e.Obstacle,i))}}LoadReflectionEvents(t){this.LoadReflectionEventsBB(t,t)}LoadReflectionEventsBB(t,e){if(null==t||this.SideReflectsUpward(t)||this.IsPerpendicular(t))return;const i=G.mkPP(t.Start,t.End),n=G.mkPP(e.Start,e.End);if(this.ScanDirection.IsHorizontal?!i.intersectsOnX(n):!i.intersectsOnY(n))return;const r=G.intersect(i,n),s=r.leftBottom,o=r.rightTop;let a=this.lookaheadScan.FindFirstInRange(s,o);for(;null!=a;){const e=Mr.ScanLineIntersectSidePBS(a.item.Site,t,this.ScanDirection.PerpendicularInstance);this.ScanDirection.ComparePerpCoord(e,a.item.Site)>0?this.AddReflectionEvent(a.item,t,e):a.item.ReflectingObstacle!=t.Obstacle&&this.lookaheadScan.MarkStaleSite(a.item),a=this.lookaheadScan.FindNextInRange(a,o)}this.lookaheadScan.RemoveStaleSites()}AddPerpendicularReflectionSegment(t,e,i){if(this.lookaheadScan.RemoveExact(t.PreviousSite)){if(null==e)return!1;if(t.PreviousSite.IsStaircaseStep(t.ReflectingObstacle)){if(!Zn.PointIsInRectangleInterior(t.Site,t.ReflectingObstacle.VisibilityBoundingBox))return!1;if(!this.InsertPerpendicularReflectionSegment(t.PreviousSite.Site,t.Site))return!1;if(null!=i&&t.IsStaircaseStep(i.Obstacle))return this.ScanLineCrossesObstacle(t.Site,i.Obstacle)}}return!1}AddParallelReflectionSegment(t,e,i,n){{const r=this.ScanLineIntersectSide(n.Site,null!=e?e:i),s=null!=e?r:n.Site,o=null!=e?n.Site:r;return null==e?e=this.scanLine.NextLowB(i).item:i=this.scanLine.NextHighB(e).item,this.InsertParallelReflectionSegment(s,o,t,e,i,n)}}AddReflectionEvent(t,e,i){const n=e;null!=n?this.eventQueue.Enqueue(new Ar(t,n,i)):this.eventQueue.Enqueue(new Sr(t,e,i))}AddSideToScanLine(t,e){const i=this.scanLine.Insert(t,e);return this.LoadReflectionEvents(t),i}RemoveSideFromScanLine(t,e){this.scanLine.Remove(t.item,e)}PointCompare(t,e){return this.ScanDirection.Compare(t,e)}Clear(){this.ObstacleTree.Clear(),this.eventQueue=new Pr,this.HorizontalScanSegments=new Rr(Kn.HorizontalInstance),this.VerticalScanSegments=new Rr(Kn.VerticalInstance),this.VisibilityGraph=null}ProcessEvents(){for(;this.eventQueue.Count>0;){const t=this.eventQueue.Dequeue();t instanceof pr?this.ProcessEventO(t):t instanceof wr?this.ProcessEventLB(t):t instanceof Er?this.ProcessEventHB(t):t instanceof xr?this.ProcessEventCV(t):t instanceof Ar?this.ProcessEventLR(t):t instanceof Sr?this.ProcessEventHR(t):this.ProcessCustomEvent(t),this.LowNeighborSides.Clear(),this.HighNeighborSides.Clear()}}ProcessCustomEvent(t){}ScanLineCrossesObstacle(t,e){return this.ScanDirection.ComparePerpCoord(t,e.VisibilityBoundingBox.leftBottom)>0&&this.ScanDirection.ComparePerpCoord(t,e.VisibilityBoundingBox.rightTop)<0}FindInitialNeighborSides(t,e){e.lowNborSideNode=this.scanLine.NextLowR(t),e.highNborSideNode=this.scanLine.NextHighR(t)}FindNeighborsBRR(t,e,i){this.LowNeighborSides.Clear(),this.HighNeighborSides.Clear(),this.FindNeighbors(t,e,this.LowNeighborSides),this.FindNeighbors(t,i,this.HighNeighborSides)}FindNeighbors(t,e,i){const n=t instanceof pr?e.item.Start:e.item.End,r={lowNborSideNode:null,highNborSideNode:null};this.FindInitialNeighborSides(e,r),this.SkipToNeighbor(this.ScanDirection.OppositeDirection,e.item,n,r.lowNborSideNode,i),this.SkipToNeighbor(this.ScanDirection.Dir,e.item,n,r.highNborSideNode,i)}SkipToNeighbor(t,e,i,n,r){let s=null,o=null;for(;;n=this.scanLine.Next(t,n))if(n.item.Obstacle!=e.Obstacle)if(n.item.Obstacle.IsGroup)this.ProcessGroupSideEncounteredOnTraversalToNeighbor(n,i,t)&&null==o&&(o=n.item);else{if(n.item instanceof ar!=Zn.IsAscending(t))break;this.ScanLineCrossesObstacle(i,n.item.Obstacle)&&(s=n,o=null)}r.SetSides(t,n,s,o)}ProcessGroupSideEncounteredOnTraversalToNeighbor(t,e,i){if(!this.ScanLineCrossesObstacle(e,t.item.Obstacle))return!1;const n=t.item instanceof or==Zn.IsAscending(i)?i:W.OppositeDir(i),r=this.ScanLineIntersectSide(e,t.item);return this.CurrentGroupBoundaryCrossingMap.AddIntersection(r,t.item.Obstacle,n),!0}FindNeighborsAndProcessVertexEvent(t,e,i){this.CurrentGroupBoundaryCrossingMap.Clear(),this.FindNeighborsBRR(i,t,e),this.ProcessVertexEvent(t,e,i),this.CurrentGroupBoundaryCrossingMap.Clear()}ProcessEventO(t){var e,i;const n=t.Obstacle;n.CreateInitialSides(t.Vertex,this.ScanDirection),this.AddSideToScanLine(n.ActiveLowSide,t.Site);const r=this.AddSideToScanLine(n.ActiveHighSide,t.Site),s=this.scanLine.Find(n.ActiveLowSide);this.FindNeighborsAndProcessVertexEvent(s,r,t);const o=null!==(e=this.LowNeighborSides.GroupSideInterveningBeforeLowNeighbor)&&void 0!==e?e:this.LowNeighborSides.LowNeighborSide;this.SideReflectsUpward(o)&&this.LoadReflectionEvents(n.ActiveLowSide);const a=null!==(i=this.HighNeighborSides.GroupSideInterveningBeforeHighNeighbor)&&void 0!==i?i:this.HighNeighborSides.HighNeighborSide;if(this.SideReflectsUpward(a)&&this.LoadReflectionEvents(n.ActiveHighSide),n.ActiveHighSide.Start!=n.ActiveLowSide.Start){const e=new ar(n,t.Vertex,this.ScanDirection);this.lookaheadScan.RemoveSitesForFlatBottom(e.Start,e.End)}this.EnqueueLowBendVertexEvent(n.ActiveLowSide),this.EnqueueHighBendOrCloseVertexEvent(n.ActiveHighSide)}ProcessEventLB(t){const e=t.Obstacle,i=new or(e,t.Vertex,this.ScanDirection);this.ScanDirection.ComparePerpCoord(i.End,i.Start)>0&&(this.RemoveSideFromScanLine(this.scanLine.Find(e.ActiveLowSide),t.Site),this.AddSideToScanLine(i,t.Site),e.ActiveLowSide=i,this.EnqueueLowBendVertexEvent(i))}EnqueueLowBendVertexEvent(t){this.eventQueue.Enqueue(new wr(t.Obstacle,t.EndVertex))}ProcessEventHB(t){const e=t.Obstacle,i=new ar(e,t.Vertex,this.ScanDirection);this.RemoveSideFromScanLine(this.scanLine.Find(e.ActiveHighSide),t.Site);const n=this.AddSideToScanLine(i,t.Site);if(e.ActiveHighSide=i,this.EnqueueHighBendOrCloseVertexEvent(e.ActiveHighSide),this.wantReflections&&this.ScanDirection.IsHorizontal&&i.Start.x==e.VisibilityBoundingBox.right&&this.SideReflectsUpward(i)){const t=this.scanLine.NextHighR(n);t.item instanceof or&&this.SideReflectsDownward(t.item)&&(e.isOverlapped&&this.ObstacleTree.PointIsInsideAnObstacle(i.Start,this.ScanDirection)||(this.StoreLookaheadSite(t.item.Obstacle,i,i.Start,!0),this.LoadReflectionEvents(t.item)))}}EnqueueHighBendOrCloseVertexEvent(t){const e=t.Obstacle,i=this.ScanDirection.IsHorizontal?t.EndVertex.prevOnPolyline:t.EndVertex.nextOnPolyline;this.ScanDirection.ComparePerpCoord(i.point,t.End)>0?this.eventQueue.Enqueue(new Er(e,t.EndVertex)):this.eventQueue.Enqueue(new xr(e,t.EndVertex))}CreateCloseEventSegmentsAndFindNeighbors(t){const e=t.Obstacle;let i=this.scanLine.Find(e.ActiveLowSide),n=this.scanLine.Find(e.ActiveHighSide);if(1==this.scanLine.Compare(e.ActiveLowSide,e.ActiveHighSide)){const t=i;i=n,n=t}if(this.FindNeighborsAndProcessVertexEvent(i,n,t),this.wantReflections&&e.isOverlapped)for(let t=this.scanLine.NextHighR(i);t.item!=n.item;t=this.scanLine.NextHighR(t))this.LoadReflectionEvents(t.item);this.scanLine.Remove(e.ActiveLowSide,t.Site),this.scanLine.Remove(e.ActiveHighSide,t.Site)}ProcessEventCV(t){this.CreateCloseEventSegmentsAndFindNeighbors(t);const e=this.LowNeighborSides.LowNeighbor.item,i=this.HighNeighborSides.HighNeighbor.item,n=t.Obstacle;this.LoadReflectionEvents(e),this.LoadReflectionEvents(i),n.Close()}ProcessEventLR(t){const e=t.Side.Obstacle,i=this.scanLine.NextLowB(t.Side).item;this.AddPerpendicularReflectionSegment(t,t.Side,i)&&this.AddParallelReflectionSegment(e,i,null,t)&&this.LoadReflectionEvents(e.ActiveLowSide)}ProcessEventHR(t){const e=t.Side.Obstacle,i=this.scanLine.NextHighB(t.Side).item;this.AddPerpendicularReflectionSegment(t,t.Side,i)&&this.AddParallelReflectionSegment(e,null,i,t)&&this.LoadReflectionEvents(e.ActiveHighSide)}MakeInBoundsLocation(t){const e=Math.max(t.x,this.ObstacleTree.GraphBox.left),i=Math.max(t.y,this.ObstacleTree.GraphBox.bottom);return new E(Math.min(e,this.ObstacleTree.GraphBox.right),Math.min(i,this.ObstacleTree.GraphBox.top))}IsInBoundsV(t){return this.IsInBoundsP(t.point)}IsInBoundsP(t){return U.EqualPP(t,this.MakeInBoundsLocation(t))}}Mr.SentinelOffset=1;class Fr extends Mr{constructor(){super(!1),this.horizontalVertexPoints=new ce,this.verticalVertexPoints=new ce,this.boundingBoxSteinerPoints=new ce,this.xCoordAccumulator=new Set,this.yCoordAccumulator=new Set,this.horizontalCoordMap=new Map,this.verticalCoordMap=new Map}Clear(){super.Clear(),this.Cleanup()}Cleanup(){this.horizontalVertexPoints.clear(),this.verticalVertexPoints.clear(),this.boundingBoxSteinerPoints.clear(),this.xCoordAccumulator.clear(),this.yCoordAccumulator.clear(),this.horizontalCoordMap.clear(),this.verticalCoordMap.clear()}GenerateVisibilityGraph(){this.AccumulateVertexCoords(),this.CreateSegmentVectorsAndPopulateCoordinateMaps(),this.RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints(),this.GenerateSparseIntersectionsFromVertexPoints(),this.CreateScanSegmentTrees(),this.Cleanup()}AccumulateVertexCoords(){for(const t of this.ObstacleTree.GetAllObstacles())this.xCoordAccumulator.add(t.VisibilityBoundingBox.left),this.xCoordAccumulator.add(t.VisibilityBoundingBox.right),this.yCoordAccumulator.add(t.VisibilityBoundingBox.top),this.yCoordAccumulator.add(t.VisibilityBoundingBox.bottom)}CreateSegmentVectorsAndPopulateCoordinateMaps(){this.horizontalScanSegmentVector=new yr(this.yCoordAccumulator,!0),this.verticalScanSegmentVector=new yr(this.xCoordAccumulator,!1);for(let t=0;t<this.horizontalScanSegmentVector.Length;t++)this.horizontalCoordMap.set(this.horizontalScanSegmentVector.Item(t).Coord,t);for(let t=0;t<this.verticalScanSegmentVector.Length;t++)this.verticalCoordMap.set(this.verticalScanSegmentVector.Item(t).Coord,t)}RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints(){super.GenerateVisibilityGraph(),this.horizontalScanSegmentVector.ScanSegmentsComplete(),this.verticalScanSegmentVector.ScanSegmentsComplete(),this.xCoordAccumulator.clear(),this.yCoordAccumulator.clear()}InitializeEventQueue(t){super.InitializeEventQueue(t),this.SetVectorsAndCoordMaps(t),this.AddAxisCoordinateEvents(t)}AddAxisCoordinateEvents(t){if(t.IsHorizontal)for(const t of this.yCoordAccumulator)this.eventQueue.Enqueue(new gr(new E(this.ObstacleTree.GraphBox.left-Fr.SentinelOffset,t)));else for(const t of this.xCoordAccumulator)this.eventQueue.Enqueue(new gr(new E(t,this.ObstacleTree.GraphBox.bottom-Fr.SentinelOffset)))}ProcessCustomEvent(t){this.ProcessAxisCoordinate(t)||this.ProcessCustomEvent(t)}ProcessAxisCoordinate(t){return t instanceof gr&&(this.CreateScanSegmentsOnAxisCoordinate(t.Site),!0)}InsertPerpendicularReflectionSegment(t,e){return!1}InsertParallelReflectionSegment(t,e,i,n,r,s){return!1}ProcessVertexEvent(t,e,i){const n=this.ScanDirection.IsHorizontal?this.horizontalVertexPoints:this.verticalVertexPoints;n.add(i.Site);const r=this.LowNeighborSides.LowNeighbor.item,s=this.HighNeighborSides.HighNeighbor.item,o=this.ScanDirection.Dir,a=this.ScanDirection.OppositeDirection,l=this.ScanLineIntersectSide(i.Site,r),h=this.ScanLineIntersectSide(i.Site,s);if(this.ObstacleTree.GraphBox.contains(l)){const t=Zn.RectangleBorderIntersect(r.Obstacle.VisibilityBoundingBox,l,o);U.IsPureLower(t,i.Site)&&this.boundingBoxSteinerPoints.add(t)}if(this.ObstacleTree.GraphBox.contains(h)){const t=Zn.RectangleBorderIntersect(s.Obstacle.VisibilityBoundingBox,h,a);U.IsPureLower(i.Site,t)&&this.boundingBoxSteinerPoints.add(t)}const u={lowCorner:void 0,highCorner:void 0};Fr.GetBoundingCorners(t.item.Obstacle.VisibilityBoundingBox,i instanceof pr,this.ScanDirection.IsHorizontal,u),(U.IsPureLower(l,u.lowCorner)||r.Obstacle.IsInSameClump(i.Obstacle))&&n.add(u.lowCorner),(U.IsPureLower(u.highCorner,h)||s.Obstacle.IsInSameClump(i.Obstacle))&&n.add(u.highCorner)}static GetBoundingCorners(t,e,i,n){if(e)return n.lowCorner=t.leftBottom,void(n.highCorner=i?t.rightBottom:t.leftTop);n.lowCorner=i?t.leftTop:t.rightBottom,n.highCorner=t.rightTop}CreateScanSegmentsOnAxisCoordinate(t){this.CurrentGroupBoundaryCrossingMap.Clear();const e=this.scanLine.Lowest();let i=this.scanLine.NextHighR(e),n=0,r=t,s=!1;for(;null!=i;i=this.scanLine.NextHighR(i)){if(this.SkipSide(r,i.item))continue;if(i.item.Obstacle.IsGroup){(0==n||s)&&this.HandleGroupCrossing(t,i.item);continue}if(i.item instanceof or){if(n>0){n++;continue}r=this.CreateScanSegment(r,i.item,$n.NormalWeight),this.CurrentGroupBoundaryCrossingMap.Clear(),n=1,s=i.item.Obstacle.isOverlapped}else n++,n>0||(r=i.item.Obstacle.isOverlapped||i.item.Obstacle.OverlapsGroupCorner?this.CreateScanSegment(r,i.item,$n.OverlappedWeight):this.ScanLineIntersectSide(r,i.item),this.CurrentGroupBoundaryCrossingMap.Clear(),s=!1)}const o=this.ScanDirection.IsHorizontal?new E(this.ObstacleTree.GraphBox.right+Fr.SentinelOffset,r.y):new E(r.x,this.ObstacleTree.GraphBox.top+Fr.SentinelOffset);this.parallelSegmentVector.CreateScanSegment(r,o,$n.NormalWeight,this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(r,o)),this.parallelSegmentVector.ScanSegmentsCompleteForCurrentSlot()}HandleGroupCrossing(t,e){if(!this.ScanLineCrossesObstacle(t,e.Obstacle))return;const i=e instanceof or?this.ScanDirection.Dir:this.ScanDirection.OppositeDirection,n=this.ScanLineIntersectSide(t,e),r=this.CurrentGroupBoundaryCrossingMap.AddIntersection(n,e.Obstacle,i);this.AddPerpendicularCoordForGroupCrossing(n);const s=r.GetInteriorVertexPoint(n);this.AddPerpendicularCoordForGroupCrossing(s)}AddPerpendicularCoordForGroupCrossing(t){const e=this.FindPerpendicularSlot(t,0);-1!=e&&this.perpendicularSegmentVector.Item(e).AddPendingPerpendicularCoord(this.parallelSegmentVector.CurrentSlot.Coord)}SkipSide(t,e){if(e.Obstacle.IsSentinel)return!0;const i=e.Obstacle.VisibilityBoundingBox;return this.ScanDirection.IsHorizontal?t.y==i.bottom||t.y==i.top:t.x==i.left||t.x==i.right}CreateScanSegment(t,e,i){const n=this.ScanLineIntersectSide(t,e);return t!=n&&this.parallelSegmentVector.CreateScanSegment(t,n,i,this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(t,n)),n}GenerateSparseIntersectionsFromVertexPoints(){this.VisibilityGraph=Fr.NewVisibilityGraph(),this.GenerateSparseIntersectionsAlongHorizontalAxis(),this.GenerateSparseIntersectionsAlongVerticalAxis(),this.ConnectAdjoiningScanSegments(),this.horizontalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph),this.verticalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph)}GenerateSparseIntersectionsAlongHorizontalAxis(){this.currentAxisPointComparer=P;const t=Array.from(this.horizontalVertexPoints.values()).sort(this.currentAxisPointComparer),e=Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);this.ScanDirection=Kn.HorizontalInstance,this.SetVectorsAndCoordMaps(this.ScanDirection),this.GenerateSparseIntersections(t,e)}GenerateSparseIntersectionsAlongVerticalAxis(){this.currentAxisPointComparer=(t,e)=>t.compareTo(e);const t=Array.from(this.verticalVertexPoints.values()).sort(this.currentAxisPointComparer),e=Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);this.ScanDirection=Kn.VerticalInstance,this.SetVectorsAndCoordMaps(this.ScanDirection),this.GenerateSparseIntersections(t,e)}SetVectorsAndCoordMaps(t){t.IsHorizontal?(this.parallelSegmentVector=this.horizontalScanSegmentVector,this.perpendicularSegmentVector=this.verticalScanSegmentVector,this.perpendicularCoordMap=this.verticalCoordMap):(this.parallelSegmentVector=this.verticalScanSegmentVector,this.perpendicularSegmentVector=this.horizontalScanSegmentVector,this.perpendicularCoordMap=this.horizontalCoordMap)}ConnectAdjoiningScanSegments(){this.horizontalScanSegmentVector.ConnectAdjoiningSegmentEndpoints(),this.verticalScanSegmentVector.ConnectAdjoiningSegmentEndpoints()}GenerateSparseIntersections(t,e){this.perpendicularSegmentVector.ResetForIntersections(),this.parallelSegmentVector.ResetForIntersections();let i=1;const n={j:0};for(const r of this.parallelSegmentVector.Items())for(;r.CurrentSegment.ContainsPoint(t[i])||this.AddSteinerPointsToInterveningSegments(t[i],e,n,r)&&r.TraverseToSegmentContainingPoint(t[i]);)if(this.AddPointsToCurrentSegmentIntersections(e,n,r),this.GenerateIntersectionsFromVertexPointForCurrentSegment(t[i],r),r.PointIsCurrentEndAndNextStart(t[i]))r.MoveNext();else if(++i>=t.length)return}AddSteinerPointsToInterveningSegments(t,e,i,n){for(;i.j<e.length&&-1==this.currentAxisPointComparer(e[i.j],t);){if(!n.TraverseToSegmentContainingPoint(e[i.j]))return!1;this.AddPointsToCurrentSegmentIntersections(e,i,n)}return!0}AddPointsToCurrentSegmentIntersections(t,e,i){for(;e.j<t.length&&i.CurrentSegment.ContainsPoint(t[e.j]);e.j++){const n=this.FindPerpendicularSlot(t[e.j],0);this.AddSlotToSegmentIntersections(i,n)}}GenerateIntersectionsFromVertexPointForCurrentSegment(t,e){const i=this.FindPerpendicularSlot(e.CurrentSegment.Start,1),n=this.FindPerpendicularSlot(e.CurrentSegment.End,-1),r=this.FindPerpendicularSlot(t,0);i>=n||(this.AddSlotToSegmentIntersections(e,i),this.AddSlotToSegmentIntersections(e,n),r>i&&r<n&&(this.AddSlotToSegmentIntersections(e,r),this.AddBinaryDivisionSlotsToSegmentIntersections(e,i,r,n)))}FindPerpendicularSlot(t,e){return Fr.FindIntersectingSlot(this.perpendicularSegmentVector,this.perpendicularCoordMap,t,e)}static FindIntersectingSlot(t,e,i,n){const r=t.GetParallelCoord(i),s=e.get(r);return null!=s?s:0==n?-1:t.FindNearest(r,n)}AddSlotToSegmentIntersections(t,e){const i=this.perpendicularSegmentVector.Item(e);t.CurrentSegment.AddSparseVertexCoord(i.Coord),i.AddPerpendicularCoord(t.Coord)}AddBinaryDivisionSlotsToSegmentIntersections(t,e,i,n){let r=0,s=this.perpendicularSegmentVector.Length-1;for(;s-r>1;){const o=r+Math.floor((s-r)/2);i<=o?(s=o,i<s&&s<=n&&this.AddSlotToSegmentIntersections(t,s)):(r=o,i>r&&r>=e&&this.AddSlotToSegmentIntersections(t,r))}}CreateScanSegmentTrees(){Fr.CreateScanSegmentTree(this.horizontalScanSegmentVector,this.HorizontalScanSegments),Fr.CreateScanSegmentTree(this.verticalScanSegmentVector,this.VerticalScanSegments)}static CreateScanSegmentTree(t,e){for(const i of t.Items())for(let t=i.FirstSegment;null!=t;t=t.NextSegment)t.HasVisibility()&&e.InsertUnique(t)}}class Dr{constructor(t){this.AddedVertices=new Array,this.AddedEdges=new Array,this.edgesToRestore=new Array,this.LimitPortVisibilitySpliceToEndpointBoundingBox=!1,this.GraphGenerator=t}get ObstacleTree(){return this.GraphGenerator.ObstacleTree}get VisGraph(){return this.GraphGenerator.VisibilityGraph}get IsSparseVg(){return this.GraphGenerator instanceof Fr}AddVertex(t){const e=this.VisGraph.AddVertexP(t);return this.AddedVertices.push(e),e}FindOrAddVertex(t){const e=this.VisGraph.FindVertex(t);return null!=e?e:this.AddVertex(t)}FindOrAddEdgeVV(t,e){return this.FindOrAddEdge(t,e,$n.NormalWeight)}FindOrAddEdge(t,e,i){const n=U.GetPureDirectionVV(t,e),r={bracketSource:void 0,bracketTarget:void 0,splitVertex:void 0};Dr.GetBrackets(t,e,n,r);let s=this.VisGraph.FindEdgePP(r.bracketSource.point,r.bracketTarget.point);return s=null!=s?this.SplitEdge(s,r.splitVertex):this.CreateEdge(r.bracketSource,r.bracketTarget,i),s}static GetBrackets(t,e,i,n){if(n.splitVertex=e,!Dr.FindBracketingVertices(t,e.point,i,n)){const r={bracketSource:null,bracketTarget:null};Dr.FindBracketingVertices(e,t.point,W.OppositeDir(i),r)&&(n.bracketSource=r.bracketTarget,n.splitVertex=t),n.bracketTarget=r.bracketSource}}static FindBracketingVertices(t,e,i,n){for(n.bracketSource=t;n.bracketTarget=Zn.FindAdjacentVertex(n.bracketSource,i),null!=n.bracketTarget;){if(E.closeDistEps(n.bracketTarget.point,e))return!0;if(i!=U.GetDirections(n.bracketTarget.point,e))break;n.bracketSource=n.bracketTarget}return null!=n.bracketTarget}CreateEdge(t,e,i){let n=t,r=e;U.IsPureLower(n.point,r.point)||(n=e,r=t);const s=new ui(n,r,i);return di.AddEdge(s),this.AddedEdges.push(s),s}RemoveFromGraph(){this.RemoveAddedVertices(),this.RemoveAddedEdges(),this.RestoreRemovedEdges()}RemoveAddedVertices(){for(const t of this.AddedVertices)null!=this.VisGraph.FindVertex(t.point)&&this.VisGraph.RemoveVertex(t);this.AddedVertices=[]}RemoveAddedEdges(){for(const t of this.AddedEdges)null!=this.VisGraph.FindVertex(t.SourcePoint)&&di.RemoveEdge(t);this.AddedEdges=[]}RestoreRemovedEdges(){for(const t of this.edgesToRestore)di.AddEdge(t);this.edgesToRestore=[]}FindNextEdge(t,e){return Zn.FindAdjacentEdge(t,e)}FindPerpendicularOrContainingEdge(t,e,i){for(;;){const n=Zn.FindAdjacentVertex(t,e);if(null==n)break;const r=U.GetDirections(n.point,i);if(0!=(W.OppositeDir(e)&r))return this.VisGraph.FindEdgePP(t.point,n.point);t=n}return null}FindNearestPerpendicularOrContainingEdge(t,e,i){U.GetDirections(t.point,i);let n=t;for(;null!=l.None;){const t=Zn.FindAdjacentVertex(n,void 0);if(null==t)break;if(0!=(W.OppositeDir(void 0)&U.GetDirections(t.point,i)))break;n=t,U.GetDirections(n.point,i)}let r;for(;r=this.FindPerpendicularOrContainingEdge(n,e,i),null==r&&n!=t;)n=Zn.FindAdjacentVertex(n,W.OppositeDir(void 0));return r}ConnectVertexToTargetVertex(t,e,i,n){if(E.closeDistEps(t.point,e.point))return;const r=U.GetDirections(t.point,e.point);if(U.IsPureDirectionD(r))return void this.FindOrAddEdgeVV(t,e);const s=Zn.FindBendPointBetween(t.point,e.point,i),o=this.FindOrAddVertex(s);this.FindOrAddEdge(t,o,n),this.FindOrAddEdge(o,e,n)}AddEdgeToTargetEdge(t,e,i){let n=this.VisGraph.FindVertex(i);return null==n&&(n=this.AddVertex(i),this.SplitEdge(e,n)),this.FindOrAddEdgeVV(t,n),n}SplitEdge(t,e){return null==t?null:E.closeDistEps(t.Source.point,e.point)||E.closeDistEps(t.Target.point,e.point)?t:(t instanceof ui||this.edgesToRestore.push(t),di.RemoveEdge(t),(this.IsSparseVg||t.Weight==$n.OverlappedWeight)&&e.Degree>0?(this.FindOrAddEdge(e,t.Source,t.Weight),this.FindOrAddEdge(e,t.Target,t.Weight)):(this.CreateEdge(e,t.Target,t.Weight),this.CreateEdge(t.Source,e,t.Weight)))}ExtendEdgeChainVRLPB(t,e,i,n,r){const s=U.GetDirections(i.start,i.end);if(s==l.None)return;const o=Zn.GetRectangleBound(e,s),a=Zn.IsVerticalD(s)?y.RoundPoint(new E(t.point.x,o)):y.RoundPoint(new E(o,t.point.y));if(E.closeDistEps(a,t.point))return;if(U.GetDirections(t.point,a)!=s)return;let h=i;U.GetDirections(a,h.end)==s&&(h=I.mkPP(h.start,a)),this.ExtendEdgeChain(t,s,h,i,n,r)}ExtendEdgeChain(t,e,i,n,r,s){if(U.GetDirections(t.point,i.end)!=e)return;let o=W.RotateLeft(e),a=Zn.FindAdjacentVertex(t,o);if(null==a&&(o=W.OppositeDir(o),a=Zn.FindAdjacentVertex(t,o),null==a))return;const l=W.OppositeDir(o),h={spliceTarget:null};this.ExtendSpliceWorker(a,e,l,i,n,s,h)&&this.ExtendSpliceWorker(h.spliceTarget,e,o,i,n,s,h),this.SpliceGroupBoundaryCrossings(r,t,i)}SpliceGroupBoundaryCrossings(t,e,i){if(null==t||0==t.Count())return;t.Reset();let n=i.start,r=i.end,s=U.GetDirections(n,r);Zn.IsAscending(s)||(n=i.end,r=i.start,s=W.OppositeDir(s));for(let i=e=Dr.TraverseToFirstVertexAtOrAbove(e,n,W.OppositeDir(s));null!=i;i=Zn.FindAdjacentVertex(i,s)){const n=U.ComparePP(i.point,r)>=0;for(;t.CurrentIsBeforeOrAt(i.point);){const n=t.Pop();U.ComparePP(n.Location,e.point)>0&&U.ComparePP(n.Location,r)<=0&&this.SpliceGroupBoundaryCrossing(i,n,W.OppositeDir(s)),U.ComparePP(n.Location,e.point)>=0&&U.ComparePP(n.Location,r)<0&&this.SpliceGroupBoundaryCrossing(i,n,s)}if(n)break}}static TraverseToFirstVertexAtOrAbove(t,e,i){let n=t;const r=W.OppositeDir(i);for(;;){const t=Zn.FindAdjacentVertex(n,i);if(null==t||U.GetDirections(t.point,e)==r)break;n=t}return n}SpliceGroupBoundaryCrossing(t,e,i){var n,r;const s=Qn.ToCrossingArray(e.Crossings,i);if(null!=s){const i=null!==(n=this.VisGraph.FindVertex(e.Location))&&void 0!==n?n:this.AddVertex(e.Location);this.AddVertex(e.Location),t.point.equal(i.point)||this.FindOrAddEdgeVV(t,i);const o=s[0].GetInteriorVertexPoint(e.Location),a=null!==(r=this.VisGraph.FindVertex(o))&&void 0!==r?r:this.AddVertex(o);this.AddVertex(o),this.FindOrAddEdgeVV(i,a);const l=this.VisGraph.FindEdgePP(i.point,a.point),h=s.map(t=>t.Group.InputShape);l.IsPassable=()=>h.some(t=>t.IsTransparent)}}ExtendSpliceWorker(t,e,i,n,r,s,o){let a=Zn.FindAdjacentVertex(t,i);o.spliceTarget=Zn.FindAdjacentVertex(a,i);const l={spliceSource:t};for(;Dr.GetNextSpliceSource(l,i,e);){const t=Zn.FindBendPointBetween(a.point,l.spliceSource.point,W.OppositeDir(i));if(Dr.IsPointPastSegmentEnd(r,t))break;if(o.spliceTarget=Dr.GetSpliceTarget(l,i,t),null==o.spliceTarget){if(this.IsSkippableSpliceSourceWithNullSpliceTarget(l.spliceSource,e))continue;if(this.ObstacleTree.SegmentCrossesAnObstacle(l.spliceSource.point,t))return!1}let h=this.VisGraph.FindVertex(t);if(null!=h){if(null==o.spliceTarget||null!=this.VisGraph.FindEdgePP(a.point,t))return null==o.spliceTarget&&this.FindOrAddEdge(a,h,s?$n.OverlappedWeight:$n.NormalWeight),!1}else h=this.AddVertex(t);if(this.FindOrAddEdge(a,h,s?$n.OverlappedWeight:$n.NormalWeight),this.FindOrAddEdge(l.spliceSource,h,s?$n.OverlappedWeight:$n.NormalWeight),s&&(s=this.SeeIfSpliceIsStillOverlapped(e,h)),a=h,0==(e&U.GetDirections(t,n.end))){o.spliceTarget=null;break}}return null!=o.spliceTarget}static GetNextSpliceSource(t,e,i){let n=Zn.FindAdjacentVertex(t.spliceSource,i);if(null==n)for(n=t.spliceSource;;){if(n=Zn.FindAdjacentVertex(n,W.OppositeDir(e)),null==n)return!1;const t=Zn.FindAdjacentVertex(n,i);if(null!=t){n=t;break}}return t.spliceSource=n,!0}static GetSpliceTarget(t,e,i){const n=U.GetDirections(t.spliceSource.point,i);let r=n,s=t.spliceSource;for(;r==n&&(t.spliceSource=s,s=Zn.FindAdjacentVertex(t.spliceSource,e),null!=s);){if(E.closeDistEps(s.point,i)){s=Zn.FindAdjacentVertex(s,e);break}r=U.GetDirections(s.point,i)}return s}SeeIfSpliceIsStillOverlapped(t,e){let i=this.FindNextEdge(e,W.RotateLeft(t)),n=null!=i&&$n.NormalWeight==i.Weight;return n||(i=this.FindNextEdge(e,W.RotateRight(t)),n=null!=i&&$n.NormalWeight==i.Weight),!n||this.ObstacleTree.PointIsInsideAnObstaclePD(e.point,t)}IsSkippableSpliceSourceWithNullSpliceTarget(t,e){if(Dr.IsSkippableSpliceSourceEdgeWithNullTarget(Zn.FindAdjacentEdge(t,e)))return!0;const i=Zn.FindAdjacentEdge(t,W.OppositeDir(e));return Dr.IsSkippableSpliceSourceEdgeWithNullTarget(i)||Dr.IsReflectionEdge(i)}static IsSkippableSpliceSourceEdgeWithNullTarget(t){return null!=t&&null!=t.IsPassable&&v(t.Length,dr.BoundaryWidth)}static IsReflectionEdge(t){return null!=t&&t.Weight==$n.ReflectionWeight}static IsPointPastSegmentEnd(t,e){return U.GetDirections(t.start,t.end)==U.GetDirections(t.end,e)}toString(){return _t.String.Format("{0} {1}",this.AddedVertices.length,this.edgesToRestore.length)}}class Nr{constructor(t){this.obstaclePortMap=new Map,this.freePointMap=new Ie,this.freePointLocationsUsedByRouteEdges=new ce,this.RouteToCenterOfObstacles=!1,this.obstaclePortsInGraph=new Array,this.freePointsInGraph=new Set,this.activeAncestors=new Array,this.TransUtil=new Dr(t),this.graphGenerator=t}get LimitPortVisibilitySpliceToEndpointBoundingBox(){return this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox}set LimitPortVisibilitySpliceToEndpointBoundingBox(t){this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox=t}get VisGraph(){return this.graphGenerator.VisibilityGraph}get HScanSegments(){return this.graphGenerator.HorizontalScanSegments}get VScanSegments(){return this.graphGenerator.VerticalScanSegments}get ObstacleTree(){return this.graphGenerator.ObstacleTree}get AncestorSets(){return this.ObstacleTree.AncestorSets}Clear(){this.TransUtil.RemoveFromGraph(),this.obstaclePortMap.clear()}CreateObstaclePorts(t){for(const e of t.Ports)this.CreateObstaclePort(t,e)}CreateObstaclePort(t,e){if(null==e.Curve)return null;const i=y.RoundPoint(e.Location);if(a.Outside==F.PointRelativeToCurveLocation(i,t.InputShape.BoundaryCurve))return null;if(t.InputShape.BoundaryCurve!=e.Curve&&a.Outside==F.PointRelativeToCurveLocation(i,e.Curve))return null;const n=new ur(e,t);return this.obstaclePortMap.set(e,n),n}FindVertices(t){const e=new Array,i=this.obstaclePortMap.get(t);if(i)if(this.RouteToCenterOfObstacles)e.push(i.CenterVertex);else for(const t of i.PortEntrances){const i=this.VisGraph.FindVertex(t.UnpaddedBorderIntersect);null!=i&&e.push(i)}else e.push(this.VisGraph.FindVertex(y.RoundPoint(t.Location)));return e}RemoveObstaclePorts(t){for(const e of t.Ports)this.RemoveObstaclePort(e)}RemoveObstaclePort(t){this.obstaclePortMap.delete(t)}AddControlPointsToGraph(t,e){this.GetPortSpliceLimitRectangle(t),this.activeAncestors=[];const i={oport:null},n={oport:null},r=this.FindAncestorsAndObstaclePort(t.sourcePort,i),s=this.FindAncestorsAndObstaclePort(t.targetPort,n);if(this.AncestorSets.size>0&&null!=i.oport&&null!=n.oport){const t=de(s,r),i=de(r,s);this.ActivateAncestors(i,t,e)}this.AddPortToGraph(t.sourcePort,i.oport),this.AddPortToGraph(t.targetPort,n.oport)}ConnectOobWaypointToEndpointVisibilityAtGraphBoundary(t,e){if(null==t||!t.IsOutOfBounds)return;const i=this.FindVertices(e);let n=t.OutOfBoundsDirectionFromGraph&(l.North|l.South);this.ConnectToGraphAtPointsCollinearWithVertices(t,n,i),n=t.OutOfBoundsDirectionFromGraph&(l.East|l.West),this.ConnectToGraphAtPointsCollinearWithVertices(t,n,i)}ConnectToGraphAtPointsCollinearWithVertices(t,e,i){if(l.None==e)return;const n=W.OppositeDir(e);for(const r of i){const i=this.InBoundsGraphBoxIntersect(r.point,e),s=this.VisGraph.FindVertex(i);null!=s&&this.TransUtil.ConnectVertexToTargetVertex(t.Vertex,s,n,$n.NormalWeight)}}SetAllAncestorsActive(t,e){if(0==this.AncestorSets.size)return!1;this.ObstacleTree.AdjustSpatialAncestors(),this.ClearActiveAncestors();const i=this.FindAncestorsAndObstaclePort(t.sourcePort,{oport:null}),n=this.FindAncestorsAndObstaclePort(t.targetPort,{oport:null});return this.AncestorSets.size>0&&null!=i&&null!=n&&(this.ActivateAncestors(i,n,e),!0)}SetAllGroupsActive(){this.ClearActiveAncestors();for(const t of this.ObstacleTree.GetAllGroups())t.IsTransparentAncestor=!0,this.activeAncestors.push(t)}FindAncestorsAndObstaclePort(t,e){return e.oport=this.FindObstaclePort(t),0==this.AncestorSets.size?null:null!=e.oport?this.AncestorSets.get(e.oport.Obstacle.InputShape):new Set(Array.from(this.ObstacleTree.Root.AllHitItems(G.mkPP(t.Location,t.Location),t=>t.IsGroup)).map(t=>t.InputShape))}ActivateAncestors(t,e,i){for(const n of ge(t,e)){const t=i.get(n);t.IsTransparentAncestor=!0,this.activeAncestors.push(t)}}ClearActiveAncestors(){for(const t of this.activeAncestors)t.IsTransparentAncestor=!1;this.activeAncestors=[]}RemoveControlPointsFromGraph(){this.ClearActiveAncestors(),this.RemoveObstaclePortsFromGraph(),this.RemoveFreePointsFromGraph(),this.TransUtil.RemoveFromGraph(),this.portSpliceLimitRectangle=G.mkEmpty()}RemoveObstaclePortsFromGraph(){for(const t of this.obstaclePortsInGraph)t.RemoveFromGraph();this.obstaclePortsInGraph=[]}RemoveFreePointsFromGraph(){for(const t of this.freePointsInGraph)t.RemoveFromGraph();this.freePointsInGraph.clear()}RemoveStaleFreePoints(){if(this.freePointMap.size>this.freePointLocationsUsedByRouteEdges.size){const t=Array.from(this.freePointMap).filter(t=>!this.freePointLocationsUsedByRouteEdges.has(t[0]));for(const e of t)this.freePointMap.deleteP(e[0])}}ClearVisibility(){this.freePointMap.clear();for(const t of this.obstaclePortMap.values())t.ClearVisibility()}BeginRouteEdges(){this.RemoveControlPointsFromGraph(),this.freePointLocationsUsedByRouteEdges.clear()}EndRouteEdges(){this.RemoveStaleFreePoints()}FindObstaclePort(t){let e=this.obstaclePortMap.get(t);if(e){const i={removedPorts:null,addedPorts:null};if(e.Obstacle.GetPortChanges(i)){for(const t of i.addedPorts)this.CreateObstaclePort(e.Obstacle,t);for(const t of i.removedPorts)this.RemoveObstaclePort(t);e=this.obstaclePortMap.get(t)}}return e}AddPortToGraph(t,e){null==e?this.AddFreePointToGraph(t.Location):this.AddObstaclePortToGraph(e)}AddObstaclePortToGraph(t){if(!t.LocationHasChanged||(this.RemoveObstaclePort(t.Port),null!=(t=this.CreateObstaclePort(t.Obstacle,t.Port)))){t.AddToGraph(this.TransUtil,this.RouteToCenterOfObstacles),this.obstaclePortsInGraph.push(t),this.CreateObstaclePortEntrancesIfNeeded(t);for(const e of t.PortEntrances)this.AddObstaclePortEntranceToGraph(e)}}CreateObstaclePortEntrancesIfNeeded(t){t.PortEntrances.length>0||this.CreateObstaclePortEntrancesFromPoints(t)}GetPortVisibilityIntersection(t){const e=this.FindObstaclePort(t.sourcePort),i=this.FindObstaclePort(t.targetPort);if(null==e||null==i)return null;if(e.Obstacle.IsInConvexHull||i.Obstacle.IsInConvexHull)return null;if(this.CreateObstaclePortEntrancesIfNeeded(e),this.CreateObstaclePortEntrancesIfNeeded(i),!e.VisibilityRectangle.intersects(i.VisibilityRectangle))return null;for(const t of e.PortEntrances)if(t.WantVisibilityIntersection)for(const e of i.PortEntrances){if(!e.WantVisibilityIntersection)continue;const i=t.IsVertical==e.IsVertical?Nr.GetPathPointsFromOverlappingCollinearVisibility(t,e):Nr.GetPathPointsFromIntersectingVisibility(t,e);if(null!=i)return i}return null}static GetPathPointsFromOverlappingCollinearVisibility(t,e){return Zn.IntervalsAreSame(t.MaxVisibilitySegment.start,t.MaxVisibilitySegment.end,e.MaxVisibilitySegment.end,e.MaxVisibilitySegment.start)?t.HasGroupCrossings||e.HasGroupCrossings||E.closeDistEps(t.UnpaddedBorderIntersect,e.UnpaddedBorderIntersect)?null:[t.UnpaddedBorderIntersect,e.UnpaddedBorderIntersect]:null}static GetPathPointsFromIntersectingVisibility(t,e){const i=Zn.SegmentsIntersectLL(t.MaxVisibilitySegment,e.MaxVisibilitySegment);return i?t.HasGroupCrossingBeforePoint(i)||e.HasGroupCrossingBeforePoint(i)?null:[t.UnpaddedBorderIntersect,i,e.UnpaddedBorderIntersect]:null}CreateObstaclePortEntrancesFromPoints(t){const e=this.graphGenerator.ObstacleTree.GraphBox,i=G.mkPP(y.RoundPoint(t.PortCurve.boundingBox.leftBottom),y.RoundPoint(t.PortCurve.boundingBox.rightTop)),n=y.RoundPoint(t.PortLocation);let r=!1;const s={xx0:null,xx1:null};if(!U.Equal(n.y,i.top)&&!U.Equal(n.y,i.bottom)){r=!0;const o=new I(e.left,n.y,e.right,n.y);this.GetBorderIntersections(n,o,t.PortCurve,s);let a=new E(Math.min(s.xx0.x,s.xx1.x),n.y);a.x<i.left&&(a=new E(i.left,a.y));let l=new E(Math.max(s.xx0.x,s.xx1.x),n.y);l.x>i.right&&(l=new E(i.right,l.y)),this.CreatePortEntrancesAtBorderIntersections(i,t,n,a,l)}if(!U.Equal(n.x,i.left)&&!U.Equal(n.x,i.right)){r=!0;const o=new I(n.x,e.bottom,n.x,e.top);this.GetBorderIntersections(n,o,t.PortCurve,s);let a=new E(n.x,Math.min(s.xx0.y,s.xx1.y));a.y<e.bottom&&(a=new E(a.x,e.bottom));let l=new E(n.x,Math.max(s.xx0.y,s.xx1.y));l.y>e.top&&(l=new E(l.x,e.top)),this.CreatePortEntrancesAtBorderIntersections(i,t,n,a,l)}r||this.CreateEntrancesForCornerPort(i,t,n)}GetBorderIntersections(t,e,i,n){const r=F.getAllIntersections(e,i,!0);n.xx0=y.RoundPoint(r[0].x),n.xx1=y.RoundPoint(r[1].x)}CreatePortEntrancesAtBorderIntersections(t,e,i,n,r){const s=U.GetDirections(n,r);U.EqualPP(n,i)||this.CreatePortEntrance(t,e,r,s),U.EqualPP(r,i)||this.CreatePortEntrance(t,e,n,W.OppositeDir(s))}static GetDerivative(t,e){const i=t.PortCurve.closestParameter(e);let n=t.PortCurve.derivative(i);const r=(t.PortCurve.parStart+t.PortCurve.parEnd)/2;return Hi.CurveIsClockwise(t.PortCurve,t.PortCurve.value(r))||(n=n.mul(-1)),n}CreatePortEntrance(t,e,i,n){e.CreatePortEntrance(i,n,this.ObstacleTree);const r=Kn.GetInstance(n);let s=Zn.GetRectangleBound(t,n)-r.Coord(i);if(s<0&&(s=-s),s>y.intersectionEpsilon){const t=W.VectorDirection(Nr.GetDerivative(e,i));let r;W.OppositeDir(n),l.None!=(n&t)&&(r=W.OppositeDir(r)),e.CreatePortEntrance(i,r,this.ObstacleTree)}}CreateEntrancesForCornerPort(t,e,i){let n=l.North;U.EqualPP(i,t.leftBottom)?n=l.South:U.EqualPP(i,t.leftTop)?n=l.West:U.EqualPP(i,t.rightTop)?n=l.North:U.EqualPP(i,t.rightBottom)&&(n=l.East),e.CreatePortEntrance(i,n,this.ObstacleTree),e.CreatePortEntrance(i,W.RotateRight(n),this.ObstacleTree)}AddObstaclePortEntranceToGraph(t){const e=this.VisGraph.FindVertex(t.VisibilityBorderIntersect);if(e)return void t.ExtendEdgeChain(this.TransUtil,e,e,this.portSpliceLimitRectangle,this.RouteToCenterOfObstacles);const i={targetVertex:null},n=t.IsOverlapped?$n.OverlappedWeight:$n.NormalWeight;null!=this.FindorCreateNearestPerpEdgePPDNT(t.MaxVisibilitySegment.end,t.VisibilityBorderIntersect,t.OutwardDirection,n,i)&&t.AddToAdjacentVertex(this.TransUtil,i.targetVertex,this.portSpliceLimitRectangle,this.RouteToCenterOfObstacles)}InBoundsGraphBoxIntersect(t,e){return Zn.RectangleBorderIntersect(this.graphGenerator.ObstacleTree.GraphBox,t,e)}FindorCreateNearestPerpEdgePPDN(t,e,i,n){return this.FindorCreateNearestPerpEdgePPDNT(t,e,i,n,{targetVertex:null})}FindorCreateNearestPerpEdgePPDNT(t,e,i,n,r){const s=Zn.SortAscending(t,e),o=s[0],a=s[1],l=Zn.IsVerticalD(i)?this.HScanSegments:this.VScanSegments,h=Zn.IsAscending(i)?l.FindLowestIntersector(o,a):l.FindHighestIntersector(o,a);if(null==h)return r.targetVertex=null,null;const u=Zn.SegmentIntersectionSP(h,o);return this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(Zn.IsAscending(i)?o:a,h,u,n,r)}FindOrCreateNearestPerpEdgeFromNearestPerpSegment(t,e,i,n,r){var s;const o={segsegVertex:this.VisGraph.FindVertex(i),targetVertex:null};if(null==o.segsegVertex){const r=this.FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(t,i,e,n,o);if(null!=r)return r}else if(U.EqualPP(t,i))return r.targetVertex=o.segsegVertex,this.TransUtil.FindNextEdge(r.targetVertex,W.OppositeDir(e.ScanDirection.Dir));const a=U.GetDirections(i,t);let l=U.GetDirections(o.segsegVertex.point,t);if(a==l){const e={bracketTarget:null,bracketSource:null};return Dr.FindBracketingVertices(o.segsegVertex,t,a,e),null!==(s=this.TransUtil.FindNextEdge(e.bracketSource,W.RotateLeft(a)))&&void 0!==s?s:this.TransUtil.FindNextEdge(e.bracketSource,W.RotateRight(a))}l&=~a;const h=this.TransUtil.FindNearestPerpendicularOrContainingEdge(o.segsegVertex,l,t);return null==h?(r.targetVertex=this.TransUtil.AddVertex(i),this.TransUtil.FindOrAddEdge(r.targetVertex,e.HighestVisibilityVertex,e.Weight)):(o.segsegVertex=Zn.GetEdgeEnd(h,W.OppositeDir(l)),i=Zn.SegmentIntersectionPPP(t,i,o.segsegVertex.point),U.EqualPP(o.segsegVertex.point,i)?(r.targetVertex=o.segsegVertex,this.TransUtil.FindNextEdge(o.segsegVertex,l)):(r.targetVertex=this.TransUtil.FindOrAddVertex(i),this.TransUtil.FindOrAddEdge(o.segsegVertex,r.targetVertex,n)))}FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(t,e,i,n,r){const s=(i.IsVertical?this.HScanSegments:this.VScanSegments).FindHighestIntersector(i.Start,e);if(null==s)return r.segsegVertex=null,r.targetVertex=this.TransUtil.AddVertex(e),this.TransUtil.FindOrAddEdge(r.targetVertex,i.LowestVisibilityVertex,i.Weight);const o=Zn.SegmentsIntersection(i,s);if(r.segsegVertex=this.VisGraph.FindVertex(o),!r.segsegVertex){r.segsegVertex=this.TransUtil.AddVertex(o);const t=this.AddEdgeToClosestSegmentEnd(i,r.segsegVertex,i.Weight);if(this.AddEdgeToClosestSegmentEnd(s,r.segsegVertex,s.Weight),U.EqualPP(r.segsegVertex.point,e))return r.targetVertex=r.segsegVertex,t}return U.EqualPP(t,e)?(r.targetVertex=this.TransUtil.FindOrAddVertex(e),this.TransUtil.FindOrAddEdge(r.segsegVertex,r.targetVertex,n)):(r.targetVertex=null,null)}AddEdgeToClosestSegmentEnd(t,e,i){return U.IsPureLower(t.HighestVisibilityVertex.point,e.point)?this.TransUtil.FindOrAddEdge(t.HighestVisibilityVertex,e,i):U.IsPureLower(e.point,t.LowestVisibilityVertex.point)?this.TransUtil.FindOrAddEdge(e,t.LowestVisibilityVertex,i):this.TransUtil.FindOrAddEdgeVV(t.LowestVisibilityVertex,e)}GetPortSpliceLimitRectangle(t){this.LimitPortVisibilitySpliceToEndpointBoundingBox?(this.portSpliceLimitRectangle=this.GetPortRectangle(t.sourcePort),this.portSpliceLimitRectangle.addRecSelf(this.GetPortRectangle(t.targetPort))):this.portSpliceLimitRectangle=this.graphGenerator.ObstacleTree.GraphBox}GetPortRectangle(t){const e=this.obstaclePortMap.get(t);return e?e.Obstacle.VisibilityBoundingBox.clone():G.mkOnPoints([y.RoundPoint(t.Location)])}AddToLimitRectangle(t){this.graphGenerator.IsInBoundsP(t)&&this.portSpliceLimitRectangle.add(t)}FindOrCreateFreePoint(t){let e=this.freePointMap.get(t);return e?e.GetVertex(this.TransUtil,t):(e=new cr(this.TransUtil,t),this.freePointMap.set(t,e)),this.freePointsInGraph.add(e),this.freePointLocationsUsedByRouteEdges.add(t),e}AddFreePointToGraph(t){t=y.RoundPoint(t);const e=this.VisGraph.FindVertex(t),i=this.FindOrCreateFreePoint(t);if(null!=e)return i;if(!this.graphGenerator.IsInBoundsP(t))return this.CreateOutOfBoundsFreePoint(i),i;let n=null;i.IsOverlapped=this.ObstacleTree.PointIsInsideAnObstacle(i.Point,this.HScanSegments.ScanDirection),this.VScanSegments.FindSegmentContainingPoint(t,!0);let r=l.South;if(null!=n)r=Zn.EdgeDirectionVE(n),this.ConnectFreePointToLateralEdge(i,W.RotateLeft(r)),this.ConnectFreePointToLateralEdge(i,W.RotateRight(r));else for(let t=0;t<4;t++)this.ConnectFreePointToLateralEdge(i,r),r=W.RotateLeft(r);return i}CreateOutOfBoundsFreePoint(t){const e=t.Point,i=this.graphGenerator.MakeInBoundsLocation(e),n=U.GetDirections(i,e);if(t.OutOfBoundsDirectionFromGraph=n,!U.IsPureDirectionD(n))return void t.AddOobEdgesFromGraphCorner(this.TransUtil,i);let r=this.VisGraph.FindVertex(i);const s=W.OppositeDir(n);if(null!=r)t.AddToAdjacentVertex(this.TransUtil,r,s,this.portSpliceLimitRectangle);else{const o=this.FindorCreateNearestPerpEdgePPDN(e,i,n,$n.NormalWeight);null!=o&&(r=t.AddEdgeToAdjacentEdge(this.TransUtil,o,s,this.portSpliceLimitRectangle))}const o=Zn.FindAdjacentVertex(r,W.RotateLeft(s));null!=o&&this.TransUtil.ConnectVertexToTargetVertex(t.Vertex,o,s,$n.NormalWeight);const a=Zn.FindAdjacentVertex(r,W.RotateRight(s));null!=a&&this.TransUtil.ConnectVertexToTargetVertex(t.Vertex,a,s,$n.NormalWeight)}ConnectFreePointToLateralEdge(t,e){const i=t.IsOverlapped?this.InBoundsGraphBoxIntersect(t.Point,e):t.MaxVisibilityInDirectionForNonOverlappedFreePoint(e,this.TransUtil),n=this.FindorCreateNearestPerpEdgePPDN(i,t.Point,e,t.InitialWeight);null!=n&&t.AddEdgeToAdjacentEdge(this.TransUtil,n,e,this.portSpliceLimitRectangle)}}class kr extends K{constructor(t,e,i,n,r){super(null),this.Padding=0,this.CornerFitRadius=0,this.BendPenaltyAsAPercentageOfDistance=0,this.UseObstacleRectangles=!1,this.ShapeToObstacleMap=new Map,this.EdgesToRoute=new Array,this.removeStaircases=!0,this.selfEdges=new Array,this.Padding=e,this.CornerFitRadius=i,this.BendPenaltyAsAPercentageOfDistance=er.DefaultBendPenaltyAsAPercentageOfDistance,this.GraphGenerator=new Fr,this.UseObstacleRectangles=r,this.PortManager=new Nr(this.GraphGenerator),this.AddShapes(t)}get RouteToCenterOfObstacles(){return this.PortManager.RouteToCenterOfObstacles}set RouteToCenterOfObstacles(t){this.PortManager.RouteToCenterOfObstacles=t}get LimitPortVisibilitySpliceToEndpointBoundingBox(){return this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox}set LimitPortVisibilitySpliceToEndpointBoundingBox(t){this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox=t}AddEdgeGeometryToRoute(t){E.closeDistEps(y.RoundPoint(t.sourcePort.Location),y.RoundPoint(t.targetPort.Location))?this.selfEdges.push(t):this.EdgesToRoute.push(t)}get EdgeGeometriesToRoute(){return this.EdgesToRoute}RemoveAllEdgeGeometriesToRoute(){this.EdgesToRoute=[]}get UseSparseVisibilityGraph(){return this.GraphGenerator instanceof Fr}get Obstacles(){return Array.from(this.ShapeToObstacleMap.values()).map(t=>t.InputShape)}get PaddedObstacles(){return Array.from(this.ShapeToObstacleMap.values()).map(t=>t.PaddedPolyline)}AddObstacles(t){this.AddShapes(t),this.RebuildTreeAndGraph()}AddShapes(t){for(const e of t)this.AddObstacleWithoutRebuild(e)}AddObstacle(t){this.AddObstacleWithoutRebuild(t),this.RebuildTreeAndGraph()}UpdateObstacles(t){for(const e of t)this.UpdateObstacleWithoutRebuild(e);this.RebuildTreeAndGraph()}UpdateObstacle(t){this.UpdateObstacleWithoutRebuild(t),this.RebuildTreeAndGraph()}RemoveObstacles(t){for(const e of t)this.RemoveObstacleWithoutRebuild(e);this.RebuildTreeAndGraph()}RemoveObstacle(t){this.RemoveObstacleWithoutRebuild(t),this.RebuildTreeAndGraph()}AddObstacleWithoutRebuild(t){if(null==t.BoundaryCurve)throw new Error("Shape must have a BoundaryCurve");this.CreatePaddedObstacle(t)}UpdateObstacleWithoutRebuild(t){if(null==t.BoundaryCurve)throw new Error("Shape must have a BoundaryCurve");this.PortManager.RemoveObstaclePorts(this.ShapeToObstacleMap.get(t)),this.CreatePaddedObstacle(t)}CreatePaddedObstacle(t){const e=new lr(t,this.UseObstacleRectangles,this.Padding);this.ShapeToObstacleMap.set(t,e),this.PortManager.CreateObstaclePorts(e)}RemoveObstacleWithoutRebuild(t){const e=this.ShapeToObstacleMap.get(t);this.ShapeToObstacleMap.delete(t),this.PortManager.RemoveObstaclePorts(e)}RemoveAllObstacles(){this.InternalClear(!1)}RebuildTreeAndGraph(){const t=null!=this.ObsTree.Root,e=null!=this.GraphGenerator.VisibilityGraph;this.InternalClear(!0),t&&this.GenerateObstacleTree(),e&&this.GenerateVisibilityGraph()}get VisibilityGraph(){return this.GenerateVisibilityGraph(),this.GraphGenerator.VisibilityGraph}Clear(){this.InternalClear(!1)}static constructorEmpty(){return kr.constructorC(null)}static constructorC(t){return new kr([],kr.DefaultPadding,kr.DefaultCornerFitRadius,!1,!1)}static constructorI(t){return new kr(t,kr.DefaultPadding,kr.DefaultCornerFitRadius,!1,!1)}static constructorINNB(t,e,i,n){return new kr(t,e,i,n,!1)}static constructorGNANB(t,e,i,n,r){return this.constructorGNANBB(t,e,i,n,r,!1)}static constructorGNANBB(t,e,i,n,r,s){const o=new kr(cn.GetShapes(t),i,n,r,s);if(null==e)for(const e of t.edges())o.AddEdgeGeometryToRoute(e);else for(const t of e)o.AddEdgeGeometryToRoute(t);return o}run(){this.GenerateVisibilityGraph(),this.GeneratePaths()}GeneratePaths(){const t=this.EdgesToRoute.map(t=>new nr(t));this.FillEdgePathsWithShortestPaths(t),this.NudgePaths(t),this.RouteSelfEdges(),this.FinaliseEdgeGeometries()}RouteSelfEdges(){for(const t of this.selfEdges){const e={smoothedPolyline:null};t.curve=Z.RouteSelfEdge(t.sourcePort.Curve,Math.max(this.Padding,2*t.GetMaxArrowheadLength()),e)}}FillEdgePathsWithShortestPaths(t){this.PortManager.BeginRouteEdges();const e=new ir(this.BendPenaltyAsAPercentageOfDistance);for(const i of t)this.AddControlPointsAndGeneratePath(e,i);this.PortManager.EndRouteEdges()}AddControlPointsAndGeneratePath(t,e){const i=this.PortManager.GetPortVisibilityIntersection(e.GeomEdge);null==i?this.SpliceVisibilityAndGeneratePath(t,e):this.GeneratePathThroughVisibilityIntersection(e,i)}GeneratePathThroughVisibilityIntersection(t,e){t.PathPoints=e}SpliceVisibilityAndGeneratePath(t,e){this.PortManager.AddControlPointsToGraph(e.GeomEdge,this.ShapeToObstacleMap),this.GeneratePath(t,e,!1)||this.RetryPathsWithAdditionalGroupsEnabled(t,e),this.PortManager.RemoveControlPointsFromGraph()}GeneratePath(t,e,i){const n=this.PortManager.FindVertices(e.GeomEdge.sourcePort),r=this.PortManager.FindVertices(e.GeomEdge.targetPort);return kr.GetSingleStagePath(e,t,n,r,i)}static GetSingleStagePath(t,e,i,n,r){return t.PathPoints=e.GetPath(i,n),r&&kr.EnsureNonNullPath(t),null!=t.PathPoints&&t.PathPoints.length>0}static EnsureNonNullPath(t){null==t.PathPoints&&(U.IsPureDirection(t.GeomEdge.sourcePort.Location,t.GeomEdge.targetPort.Location)?t.PathPoints=[t.GeomEdge.sourcePort.Location,t.GeomEdge.targetPort.Location]:t.PathPoints=[t.GeomEdge.sourcePort.Location,new E(t.GeomEdge.sourcePort.Location.x,t.GeomEdge.targetPort.Location.y),t.GeomEdge.targetPort.Location])}RetryPathsWithAdditionalGroupsEnabled(t,e){this.PortManager.SetAllAncestorsActive(e.GeomEdge,this.ShapeToObstacleMap)&&this.GeneratePath(t,e,!1)||(this.PortManager.SetAllGroupsActive(),this.GeneratePath(t,e,!0))}NudgePaths(t){const e=this.ObsTree.SpatialAncestorsAdjusted?to.GetAncestorSetsMap(this.Obstacles):this.AncestorsSets;Xn.NudgePaths(t,this.CornerFitRadius,this.PaddedObstacles,e,this.RemoveStaircases)}get RemoveStaircases(){return this.removeStaircases}set RemoveStaircases(t){this.removeStaircases=t}FinaliseEdgeGeometries(){for(const t of this.EdgesToRoute.concat(this.selfEdges)){if(null==t.curve)continue;t.curve instanceof k&&(t.curve=kr.FitArcsIntoCorners(this.CornerFitRadius,Array.from(t.curve))),kr.CalculateArrowheads(t)}}CreateVisibilityGraph(){this.GraphGenerator.Clear(),this.InitObstacleTree(),this.GraphGenerator.GenerateVisibilityGraph()}static CalculateArrowheads(t){Q.trimSplineAndCalculateArrowheadsII(t,t.sourcePort.Curve,t.targetPort.Curve,t.curve,!0)}get ObsTree(){return this.GraphGenerator.ObstacleTree}GenerateObstacleTree(){if(null==this.Obstacles||0==this.Obstacles.length)throw new Error("No obstacles have been added");null==this.ObsTree.Root&&this.InitObstacleTree()}InitObstacleTree(){this.AncestorsSets=to.GetAncestorSetsMap(this.Obstacles),this.ObsTree.Init(this.ShapeToObstacleMap.values(),this.AncestorsSets,this.ShapeToObstacleMap)}InternalClear(t){this.GraphGenerator.Clear(),this.ClearShortestPaths(),t?this.PortManager.ClearVisibility():(this.PortManager.Clear(),this.ShapeToObstacleMap.clear(),this.EdgesToRoute=[])}ClearShortestPaths(){for(const t of this.EdgesToRoute)t.curve=null}GenerateVisibilityGraph(){if(null==this.Obstacles||0==this.Obstacles.length)throw new Error("No obstacles have been set");null==this.GraphGenerator.VisibilityGraph&&this.CreateVisibilityGraph()}static FitArcsIntoCorners(t,e){const i=kr.GetFittedArcSegs(t,e),n=new F;let r=null;for(const t of i){const i=kr.EllipseIsAlmostLineSegment(t);null!=r?i?F.continueWithLineSegmentP(n,kr.CornerPoint(t)):(F.continueWithLineSegmentP(n,t.start),n.addSegment(t)):i?F.addLineSegment(n,e[0],kr.CornerPoint(t)):(F.addLineSegment(n,e[0],t.start),n.addSegment(t)),r=t}return n.segs.length>0?F.continueWithLineSegmentP(n,e[e.length-1]):F.addLineSegment(n,e[0],e[e.length-1]),n}static CornerPoint(t){return t.center.add(t.aAxis.add(t.bAxis))}static EllipseIsAlmostLineSegment(t){return t.aAxis.lengthSquared<1e-4||t.aAxis.lengthSquared<1e-4}static*GetFittedArcSegs(t,e){let i=e[1].sub(e[0]),n=i.normalize(),r=Math.min(t,i.length/2);for(let s=1;s<e.length-1;s++){i=e[s+1].sub(e[s]);const o=i.length;if(o<y.intersectionEpsilon){yield new R(0,0,new E(0,0),new E(0,0),e[s]);continue}const a=i.div(o);Math.abs(a.dot(n))>.9&&(yield new R(0,0,new E(0,0),new E(0,0),e[s]));const l=Math.min(t,i.length/2),h=a.mul(-l),u=n.mul(r);yield new R(0,Math.PI/2,h,u,e[s].sub(u.add(h))),n=a,r=l}}}kr.DefaultPadding=1,kr.DefaultCornerFitRadius=3;class Vr extends K{constructor(t,e,i){super(null),this.graph=t,this.source=e,this.length=i}get Result(){return this.result}run(){const t=new Qi((t,e)=>t-e),e=new Map;for(const i of this.graph.shallowNodes()){const n=i==this.source?0:Number.POSITIVE_INFINITY;t.Enqueue(i,n),e.set(i,n)}for(;t.count>0;){const i={priority:0},n=t.DequeueAndGetPriority(i);e.set(n,i.priority);const r=e.get(n);for(const i of n.inEdges()){const n=i.source,s=r+this.length(i);e.get(n)>s&&(e.set(n,s),t.DecreasePriority(n,s))}for(const i of n.outEdges()){const n=i.target,s=r+this.length(i);e.get(n)>s&&(e.set(n,s),t.DecreasePriority(n,s))}}this.result=new Array(this.graph.shallowNodeCount);let i=0;for(const t of this.graph.shallowNodes()){const n=e.get(t);this.result[i++]=null!=n?n:Number.POSITIVE_INFINITY}}}class Gr extends K{constructor(t,e){super(null),this.graph=t,this.length=e}get Result(){return this.result}set Result(t){this.result=t}run(){this.result=new Array(this.graph.shallowNodeCount);let t=0;for(const e of this.graph.shallowNodes()){const i=new Vr(this.graph,e,this.length);i.run(),this.Result[t++]=i.Result}}static Stress(t,e){let i=0;if(0==t.edgeCount)return i;const n=new Gr(t,e);n.run();const r=n.Result;let s=0;for(const i of t.edges())s+=e(i);s/=t.edgeCount;let o=0;for(const e of t.shallowNodes()){let n=0;for(const a of t.shallowNodes()){if(o!=n){const t=e.center.sub(a.center).length,l=s*r[o][n],h=l-t;i+=h*h/(l*l)}n++}o++}return i}}class zr extends K{constructor(t,e,i){super(null),this.graph=t,this.pivotArray=e,this.length=i}get Result(){return this.result}run(){this.result=new Array(this.pivotArray.length);const t=Array.from(this.graph.shallowNodes()),e=new Array(this.graph.shallowNodeCount).fill(Number.POSITIVE_INFINITY);let i=t[0];this.pivotArray[0]=0;for(let n=0;;n++){const r=new Vr(this.graph,i,this.length);if(r.run(),this.Result[n]=r.Result,!(n+1<this.pivotArray.length))break;{let r=0;for(let t=0;t<this.Result[n].length;t++)e[t]=Math.min(e[t],this.Result[n][t]),e[t]>e[r]&&(r=t);i=t[r],this.pivotArray[n+1]=r}}}}class jr{static DoubleCenter(t){const e=new Array(t.length).fill(0),i=new Array(t[0].length).fill(0);let n=0;for(let r=0;r<t.length;r++)for(let s=0;s<t[0].length;s++)e[r]+=t[r][s],i[s]+=t[r][s],n+=t[r][s];for(let i=0;i<t.length;i++)e[i]/=t.length;for(let e=0;e<t[0].length;e++)i[e]/=t[0].length;n/=t.length,n/=t[0].length;for(let r=0;r<t.length;r++)for(let s=0;s<t[0].length;s++)t[r][s]-=e[r]+i[s]-n}static SquareEntries(t){for(let e=0;e<t.length;e++)for(let i=0;i<t[0].length;i++)t[e][i]=Math.pow(t[e][i],2)}static Multiply(t,e){for(let i=0;i<t.length;i++)for(let n=0;n<t[0].length;n++)t[i][n]*=e}static MultiplyX(t,e){if(t[0].length!=e.length)return null;const i=new Array(e.length).fill(0);for(let n=0;n<t.length;n++)for(let r=0;r<t[0].length;r++)i[n]+=t[n][r]*e[r];return i}static Norm(t){let e=0;for(let i=0;i<t.length;i++)e+=Math.pow(t[i],2);return Math.sqrt(e)}static Normalize(t){const e=jr.Norm(t);if(e<=0)return 0;for(let i=0;i<t.length;i++)t[i]/=e;return e}static RandomUnitLengthVector(t){const e=new Array(t);for(let i=0;i<t;i++)e[i]=oe();return jr.Normalize(e),e}static SpectralDecomposition(t,e){jr.SpectralDecompositionIE(t,e,30,1e-6)}static SpectralDecompositionIE(t,e,i,n){const r=t[0].length;e.u1=jr.RandomUnitLengthVector(r),e.lambda1=0,e.u2=jr.RandomUnitLengthVector(r),e.lambda2=0;let s=0;const o=1-n;for(let n=0;n<i&&s<o;n++){const i=jr.MultiplyX(t,e.u1),n=jr.MultiplyX(t,e.u2);e.lambda1=jr.Normalize(i),e.lambda2=jr.Normalize(n),jr.MakeOrthogonal(n,i),jr.Normalize(n),s=Math.min(jr.DotProduct(e.u1,i),jr.DotProduct(e.u2,n)),e.u1=i,e.u2=n}}static DotProduct(t,e){if(t.length!=e.length)return 0;let i=0;for(let n=0;n<t.length;n++)i+=t[n]*e[n];return i}static MakeOrthogonal(t,e){if(t.length!=e.length)return;const i=jr.DotProduct(t,e)/jr.DotProduct(e,e);for(let n=0;n<t.length;n++)t[n]-=i*e[n]}static ClassicalScaling(t,e){const i=new Array(t.length);for(let e=0;e<t.length;e++)i[e]=t[e].slice();jr.SquareEntries(i),jr.DoubleCenter(i),jr.Multiply(i,-.5),jr.SpectralDecomposition(i,e),e.lambda1=Math.sqrt(Math.abs(e.lambda1)),e.lambda2=Math.sqrt(Math.abs(e.lambda2));for(let t=0;t<e.u1.length;t++)e.u1[t]*=e.lambda1,e.u2[t]*=e.lambda2}static DistanceScalingSubset(t,e,i,n,r){const s=e.length,o=t.length,a=new Array(o);for(let e=0;e<o;e++)for(let i=0;i<s;i++)0==t[e][i]&&(a[e]=i);const l=new Array(o).fill(0);for(let t=0;t<o;t++)for(let e=0;e<s;e++)a[t]!=e&&(l[t]+=n[t][e]);for(let h=0;h<r;h++)for(let r=0;r<o;r++){let o=0,h=0;for(let l=0;l<s;l++)if(r!=l){let s=Math.sqrt(Math.pow(e[a[r]]-e[l],2)+Math.pow(i[a[r]]-i[l],2));s>0&&(s=1/s),o+=n[r][l]*(e[l]+t[r][l]*(e[a[r]]-e[l])*s),h+=n[r][l]*(i[l]+t[r][l]*(i[a[r]]-i[l])*s)}e[a[r]]=o/l[r],i[a[r]]=h/l[r]}}static DistanceScaling(t,e,i,n,r){const s=e.length,o=new Array(s).fill(0);for(let t=0;t<s;t++)for(let e=0;e<s;e++)t!=e&&(o[t]+=n[t][e]);for(let a=0;a<r;a++)for(let r=0;r<s;r++){let a=0,l=0;for(let o=0;o<s;o++)if(r!=o){let s=Math.sqrt(Math.pow(e[r]-e[o],2)+Math.pow(i[r]-i[o],2));s>0&&(s=1/s),a+=n[r][o]*(e[o]+t[r][o]*(e[r]-e[o])*s),l+=n[r][o]*(i[o]+t[r][o]*(i[r]-i[o])*s)}e[r]=a/o[r],i[r]=l/o[r]}}static ExponentialWeightMatrix(t,e){const i=new Array(t.length);for(let n=0;n<t.length;n++){i[n]=new Array(t[n].length).fill(0);for(let r=0;r<t[n].length;r++)t[n][r]>0&&(i[n][r]=Math.pow(t[n][r],e))}return i}static EuclideanDistanceMatrix(t,e){const i=new Array(t.length);for(let n=0;n<t.length;n++){i[n]=new Array(t.length);for(let r=0;r<t.length;r++)i[n][r]=Math.sqrt(Math.pow(t[n]-t[r],2)+Math.pow(e[n]-e[r],2))}return i}static LandmarkClassicalScaling(t,e,i){const n=new Array(t.length);for(let e=0;e<t.length;e++){n[e]=new Array(t.length);for(let r=0;r<t.length;r++)n[e][r]=t[e][i[r]]}jr.SquareEntries(n);const r=new Array(t.length).fill(0);for(let e=0;e<t.length;e++){for(let i=0;i<t.length;i++)r[e]+=n[e][i];r[e]/=t.length}jr.DoubleCenter(n),jr.Multiply(n,-.5);const s={u1:new Array,u2:new Array,lambda1:0,lambda2:0};jr.SpectralDecomposition(n,s),s.lambda1=Math.sqrt(Math.abs(s.lambda1)),s.lambda2=Math.sqrt(Math.abs(s.lambda2)),e.x=new Array(t[0].length).fill(0),e.y=new Array(t[0].length).fill(0);for(let i=0;i<e.x.length;i++)for(let o=0;o<n.length;o++){const n=(Math.pow(t[o][i],2)-r[o])/2;e.x[i]-=s.u1[o]*n,e.y[i]-=s.u2[o]*n}}}class Ur{constructor(t,e){this.Constrained=!1,this.Capacity=1e6;1==is.AbovePP(t.point,e.point)?(this.upperSite=t,this.lowerSite=e):(this.lowerSite=t,this.upperSite=e),this.upperSite.AddEdgeToSite(this)}get CcwTriangle(){return this.ccwTriangle}set CcwTriangle(t){this.ccwTriangle=t}get CwTriangle(){return this.cwTriangle}set CwTriangle(t){this.cwTriangle=t}GetOtherTriangle_c(t){return this.cwTriangle.Contains(t)?this.ccwTriangle:this.cwTriangle}IsAdjacent(t){return t==this.upperSite||t==this.lowerSite}GetOtherTriangle_T(t){return this.ccwTriangle==t?this.cwTriangle:this.ccwTriangle}toString(){return _t.String.Format("({0},{1})",this.upperSite,this.lowerSite)}OtherSite(t){return this.upperSite==t?this.lowerSite:this.upperSite}}class Wr{constructor(t){this.Owner=null,this.InEdges=new Array,this.point=t}static mkSO(t,e){const i=new Wr(t);return i.Owner=e,i}AddEdgeToSite(t){null==this.Edges&&(this.Edges=new Array),this.Edges.push(t)}EdgeBetweenUpperSiteAndLowerSite(t){if(null!=this.Edges)for(const e of this.Edges)if(e.lowerSite==t)return e;return null}AddInEdge(t){null==this.InEdges&&(this.InEdges=new Array),this.InEdges.push(t)}*Triangles(){let t;if(null!=this.Edges&&this.Edges.length>0)t=this.Edges[0];else{if(!(null!=this.InEdges&&this.InEdges.length>0))return;t=this.InEdges[0]}let e=t;do{const t=e.upperSite==this?e.CcwTriangle:e.CwTriangle;if(null==t){e=null;break}yield t,e=t.TriEdges.getItem(t.TriEdges.index(e)+2)}while(e!=t);if(e!=t)for(e=t;;){const t=e.upperSite==this?e.CwTriangle:e.CcwTriangle;if(null==t)break;yield t,e=t.TriEdges.getItem(t.TriEdges.index(e)+1)}}toString(){return this.point.toString()}}class Hr{constructor(t,e){this.RightSite=e.upperSite==t?e.lowerSite:e.upperSite,this.LeftSite=t,this.Edge=e}get x(){return this.LeftSite.point.x}toString(){return"("+this.LeftSite.toString()+", "+this.Edge.toString()+","+this.RightSite.toString()+")"}}class qr{has(t){return t==this.item0||t==this.item1||t==this.item2}index(t){return t==this.item0?0:t==this.item1?1:t==this.item2?2:-1}getItem(t){switch(t){case 0:case 3:case-3:return this.item0;case 1:case 4:case-2:return this.item1;case 2:case 5:case-1:return this.item2;default:throw new Error}}setItem(t,e){switch(t){case 0:case 3:case-3:this.item0=e;break;case 1:case 4:case-2:this.item1=e;break;case 2:case 5:case-1:this.item2=e;break;default:throw new Error}}[Symbol.iterator](){return this.GetEnumerator()}*GetEnumerator(){yield this.item0,yield this.item1,yield this.item2}}class Xr{constructor(){this.TriEdges=new qr,this.Sites=new qr}static mkSSSD(t,e,i,n){const r=E.getTriangleOrientation(t.point,e.point,i.point),o=new Xr;switch(r){case s.Counterclockwise:o.FillCcwTriangle(t,e,i,n);break;case s.Clockwise:o.FillCcwTriangle(t,i,e,n);break;default:throw new Error}return o}static mkSED(t,e,i){const n=new Xr;switch(E.getTriangleOrientation(e.upperSite.point,e.lowerSite.point,t.point)){case s.Counterclockwise:e.CcwTriangle=n,n.Sites.setItem(0,e.upperSite),n.Sites.setItem(1,e.lowerSite);break;case s.Clockwise:e.CwTriangle=n,n.Sites.setItem(0,e.lowerSite),n.Sites.setItem(1,e.upperSite);break;default:throw new Error}return n.TriEdges.setItem(0,e),n.Sites.setItem(2,t),n.CreateEdge(1,i),n.CreateEdge(2,i),n}static mkSSSEE(t,e,i,n,r,s){const o=Xr.mkSSSD(t,e,i,s);return o.TriEdges.setItem(0,n),o.TriEdges.setItem(1,r),o.BindEdgeToTriangle(t,n),o.BindEdgeToTriangle(e,r),o.CreateEdge(2,s),o}BindEdgeToTriangle(t,e){t==e.upperSite?e.CcwTriangle=this:e.CwTriangle=this}FillCcwTriangle(t,e,i,n){this.Sites.setItem(0,t),this.Sites.setItem(1,e),this.Sites.setItem(2,i);for(let t=0;t<3;t++)this.CreateEdge(t,n)}CreateEdge(t,e){const i=this.Sites.getItem(t),n=e(i,this.Sites.getItem(t+1));this.TriEdges.setItem(t,n),this.BindEdgeToTriangle(i,n)}Contains(t){return this.Sites.has(t)}OppositeEdge(t){const e=this.Sites.index(t);return this.TriEdges.getItem(e+1)}OppositeSite(t){const e=this.TriEdges.index(t);return this.Sites.getItem(e+2)}BoundingBox(){const t=G.mkPP(this.Sites.getItem(0).point,this.Sites.getItem(1).point);return t.add(this.Sites.getItem(2).point),t}static mkSSSEED(t,e,i,n,r,s){const o=new Xr;return o.Sites.setItem(0,t),o.Sites.setItem(1,e),o.Sites.setItem(2,i),o.TriEdges.setItem(0,n),o.TriEdges.setItem(1,r),o.BindEdgeToTriangle(t,n),o.BindEdgeToTriangle(e,r),o.CreateEdge(2,s),o}toString(){return this.Sites.getItem(0).toString()+","+this.Sites.getItem(1).toString()+","+this.Sites.getItem(2).toString()}}class Yr{constructor(t,e,i,n,r){this.elementsToBeRemovedFromFront=new Array,this.removedTriangles=new Array,this.edge=t,this.triangles=e,this.front=i,this.leftPolygon=n,this.rightPolygon=r,this.a=t.upperSite,this.b=t.lowerSite}Run(){this.Init(),this.Traverse()}Traverse(){for(;!this.BIsReached();)null!=this.piercedToTheLeftFrontElemNode?this.ProcessLeftFrontPiercedElement():null!=this.piercedToTheRightFrontElemNode?this.ProcessRightFrontPiercedElement():this.ProcessPiercedEdge();null!=this.piercedTriangle&&this.removePiercedTriangle(this.piercedTriangle),this.FindMoreRemovedFromFrontElements();for(const t of this.elementsToBeRemovedFromFront)this.front.remove(t)}ProcessLeftFrontPiercedElement(){let t=this.piercedToTheLeftFrontElemNode;do{this.elementsToBeRemovedFromFront.push(t.item),this.AddSiteToLeftPolygon(t.item.LeftSite),t=this.front.previous(t)}while(E.pointToTheLeftOfLine(t.item.LeftSite.point,this.a.point,this.b.point));this.elementsToBeRemovedFromFront.push(t.item),this.AddSiteToRightPolygon(t.item.LeftSite),t.item.LeftSite!=this.b?(this.FindPiercedTriangle(t),this.piercedToTheLeftFrontElemNode=null):this.piercedToTheLeftFrontElemNode=t}FindPiercedTriangle(t){var e;const i=t.item.Edge,n=null!==(e=i.CcwTriangle)&&void 0!==e?e:i.CwTriangle,r=n.TriEdges.index(i);for(let t=1;t<=2;t++){const e=n.TriEdges.getItem(t+r),i=Wt.sign(E.signedDoubledTriangleArea(e.lowerSite.point,this.a.point,this.b.point));if(Wt.sign(E.signedDoubledTriangleArea(e.upperSite.point,this.a.point,this.b.point))*i<=0){this.piercedTriangle=n,this.piercedEdge=e;break}}}FindMoreRemovedFromFrontElements(){for(const t of this.removedTriangles)for(const e of t.TriEdges)if(null==e.CcwTriangle&&null==e.CwTriangle){const t=e.upperSite.point.x<e.lowerSite.point.x?e.upperSite:e.lowerSite,i=Kr.FindNodeInFrontBySite(this.front,t);i.item.Edge==e&&this.elementsToBeRemovedFromFront.push(i.item)}}ProcessPiercedEdge(){this.piercedEdge.CcwTriangle==this.piercedTriangle?(this.AddSiteToLeftPolygon(this.piercedEdge.lowerSite),this.AddSiteToRightPolygon(this.piercedEdge.upperSite)):(this.AddSiteToLeftPolygon(this.piercedEdge.upperSite),this.AddSiteToRightPolygon(this.piercedEdge.lowerSite)),this.removePiercedTriangle(this.piercedTriangle),this.PrepareNextStateAfterPiercedEdge()}PrepareNextStateAfterPiercedEdge(){var t,e;const i=null!==(t=this.piercedEdge.CwTriangle)&&void 0!==t?t:this.piercedEdge.CcwTriangle,n=i.TriEdges.index(this.piercedEdge);for(let t=1;t<=2;t++){const r=i.TriEdges.getItem(t+n),s=Wt.sign(E.signedDoubledTriangleArea(r.lowerSite.point,this.a.point,this.b.point));if(Wt.sign(E.signedDoubledTriangleArea(r.upperSite.point,this.a.point,this.b.point))*s<=0){if(null!=r.CwTriangle&&null!=r.CcwTriangle){this.piercedTriangle=i,this.piercedEdge=r;break}this.piercedTriangle=null,this.piercedEdge=null;const t=r.upperSite.point.x<r.lowerSite.point.x?r.upperSite:r.lowerSite,n=Kr.FindNodeInFrontBySite(this.front,t);t.point.x<this.a.point.x?this.piercedToTheLeftFrontElemNode=n:this.piercedToTheRightFrontElemNode=n,this.removePiercedTriangle(null!==(e=r.CwTriangle)&&void 0!==e?e:r.CcwTriangle);break}}}removePiercedTriangle(t){this.triangles.delete(t);for(const e of t.TriEdges)e.CwTriangle==t?e.CwTriangle=null:e.CcwTriangle=null,this.removedTriangles.push(t)}ProcessRightFrontPiercedElement(){let t=this.piercedToTheRightFrontElemNode;do{this.elementsToBeRemovedFromFront.push(t.item),this.AddSiteToRightPolygon(t.item.RightSite),t=this.front.next(t)}while(E.pointToTheRightOfLine(t.item.RightSite.point,this.a.point,this.b.point));this.elementsToBeRemovedFromFront.push(t.item),this.AddSiteToLeftPolygon(t.item.RightSite),t.item.RightSite!=this.b?(this.FindPiercedTriangle(t),this.piercedToTheRightFrontElemNode=null):this.piercedToTheRightFrontElemNode=t}AddSiteToLeftPolygon(t){this.AddSiteToPolygonWithCheck(t,this.leftPolygon)}AddSiteToPolygonWithCheck(t,e){t!=this.b&&(0!=e.length&&e[e.length-1]==t||e.push(t))}AddSiteToRightPolygon(t){this.AddSiteToPolygonWithCheck(t,this.rightPolygon)}BIsReached(){var t;const e=null!==(t=this.piercedToTheLeftFrontElemNode)&&void 0!==t?t:this.piercedToTheRightFrontElemNode;return null!=e?e.item.Edge.IsAdjacent(this.b):this.piercedEdge.IsAdjacent(this.b)}Init(){const t=Kr.FindNodeInFrontBySite(this.front,this.a),e=this.front.previous(t);if(E.pointToTheLeftOfLine(this.b.point,e.item.LeftSite.point,e.item.RightSite.point))this.piercedToTheLeftFrontElemNode=e;else if(E.pointToTheRightOfLine(this.b.point,t.item.RightSite.point,t.item.LeftSite.point))this.piercedToTheRightFrontElemNode=t;else for(const t of this.a.Edges){const e=t.CcwTriangle;if(null==e)continue;if(E.pointToTheLeftOfLine(this.b.point,t.lowerSite.point,t.upperSite.point))continue;const i=e.TriEdges.index(t),n=e.Sites.getItem(i+2);if(E.pointToTheLeftOfLineOrOnLine(this.b.point,n.point,t.upperSite.point)){this.piercedEdge=e.TriEdges.getItem(i+1),this.piercedTriangle=e;break}}}}class Qr{constructor(t,e,i,n){this.rightPolygon=new Array,this.leftPolygon=new Array,this.addedTriangles=new Array,this.edge=t,this.triangles=e,this.front=i,this.createEdgeDelegate=n}Run(){this.TraceEdgeThroughTriangles(),this.TriangulatePolygon0(this.rightPolygon,this.edge.upperSite,this.edge.lowerSite,!0),this.TriangulatePolygon0(this.leftPolygon,this.edge.upperSite,this.edge.lowerSite,!1),this.UpdateFront()}UpdateFront(){const t=new Set;for(const e of this.addedTriangles)for(const i of e.TriEdges)null!=i.CwTriangle&&null!=i.CcwTriangle||t.add(i);for(const e of t)this.AddEdgeToFront(e)}AddEdgeToFront(t){const e=t.upperSite.point.x<t.lowerSite.point.x?t.upperSite:t.lowerSite;this.front.insert(new Hr(e,t))}TriangulatePolygon0(t,e,i,n){t.length>0&&this.TriangulatePolygon1(0,t.length-1,t,e,i,n)}TriangulatePolygon1(t,e,i,n,r,s){let o=i[t],a=t;for(let l=t+1;l<=e;l++){const t=i[l];Qr.LocalInCircle(t,n,r,o,s)&&(a=l,o=t)}const l=Xr.mkSSSD(n,r,o,this.createEdgeDelegate);this.triangles.add(l),this.addedTriangles.push(l),t<a&&this.TriangulatePolygon1(t,a-1,i,n,o,s),a<e&&this.TriangulatePolygon1(a+1,e,i,o,r,s)}static LocalInCircle(t,e,i,n,r){return r?ts(t,e,n,i):ts(t,e,i,n)}TraceEdgeThroughTriangles(){new Yr(this.edge,this.triangles,this.front,this.leftPolygon,this.rightPolygon).Run()}}class Zr{constructor(t){this.Edge=t}}class Kr extends K{constructor(t,e,i,n){if(super(null),this.front=new ei((t,e)=>t.x-e.x),this.triangles=new Set,this.listOfSites=t,0==this.listOfSites.length)return;this.p_1=e,this.p_2=i,this.createEdgeDelegate=n;const r=Xr.mkSSSD(e,i,this.listOfSites[0],n);this.triangles.add(r),this.front.insert(new Hr(e,r.TriEdges.getItem(2))),this.front.insert(new Hr(this.listOfSites[0],r.TriEdges.getItem(1)))}run(){if(0!=this.listOfSites.length){for(let t=1;t<this.listOfSites.length;t++)this.ProcessSite(this.listOfSites[t]);this.FinalizeTriangulation()}}FinalizeTriangulation(){this.RemoveP1AndP2Triangles(),this.triangles.size>0&&this.MakePerimeterConvex()}MakePerimeterConvex(){let t=this.CreateDoubleLinkedListOfPerimeter();for(;;){const e=this.FindConcaveEdge(t);if(null==e)return;t=this.ShortcutTwoListElements(e)}}FindConcaveEdge(t){let e,i=t;do{if(e=i.Next,E.getTriangleOrientation(i.Start.point,i.End.point,e.End.point)==s.Counterclockwise)return i;i=e}while(e!=t);return null}static FindPivot(t){let e=t,i=t;do{i=i.Next,(i.Start.point.x<e.Start.point.x||i.Start.point.x==e.Start.point.x&&i.Start.point.y<e.Start.point.y)&&(e=i)}while(i!=t);return e}FindFirsePerimeterEdge(){for(const t of this.triangles)for(const e of t.TriEdges)if(null==e.GetOtherTriangle_T(t))return e;return null}CreateDoubleLinkedListOfPerimeter(){const t=this.FindFirsePerimeterEdge();let e,i=t,n=null,r=null;const s=new Array;do{e=Kr.CreatePerimeterElementFromEdge(i),s.push(I.mkPP(e.Start.point,e.End.point)),i=Kr.FindNextEdgeOnPerimeter(i),null!=r?(e.Prev=r,r.Next=e):n=e,r=e}while(i!=t);return n.Prev=e,e.Next=n,n}static FindNextEdgeOnPerimeter(t){var e;let i=null!==(e=t.CwTriangle)&&void 0!==e?e:t.CcwTriangle;for(t=i.TriEdges.getItem(i.TriEdges.index(t)+2);null!=t.CwTriangle&&null!=t.CcwTriangle;)i=t.GetOtherTriangle_T(i),t=i.TriEdges.getItem(i.TriEdges.index(t)+2);return t}static CreatePerimeterElementFromEdge(t){const e=new Zr(t);return null!=t.CwTriangle?(e.Start=t.upperSite,e.End=t.lowerSite):(e.End=t.upperSite,e.Start=t.lowerSite),e}RemoveP1AndP2Triangles(){const t=new Set;for(const e of this.triangles)(e.Sites.has(this.p_1)||e.Sites.has(this.p_2))&&t.add(e);for(const e of t)Kr.RemoveTriangleWithEdges(this.triangles,e)}static RemoveTriangleWithEdges(t,e){t.delete(e);for(const t of e.TriEdges)t.CwTriangle==e?t.CwTriangle=null:t.CcwTriangle=null,null==t.CwTriangle&&null==t.CcwTriangle&&$r(t.upperSite.Edges,t)}static RemoveTriangleButLeaveEdges(t,e){t.delete(e);for(const t of e.TriEdges)t.CwTriangle==e?t.CwTriangle=null:t.CcwTriangle=null}ProcessSite(t){this.PointEvent(t);for(let e=0;e<t.Edges.length;e++){const i=t.Edges[e];i.Constrained&&this.EdgeEvent(i)}}EdgeEvent(t){if(Kr.EdgeIsProcessed(t))return;new Qr(t,this.triangles,this.front,this.createEdgeDelegate).Run()}static EdgeIsProcessed(t){return null!=t.CwTriangle||null!=t.CcwTriangle}ShowFrontWithSite(t,e=null){const i=new Array;if(null!=t.Edges)for(const e of t.Edges)i.push(Xe.mkDebugCurveTWCI(200,.8,e.Constrained?"Pink":"Brown",I.mkPP(e.upperSite.point,e.lowerSite.point)));i.push(Xe.mkDebugCurveTWCI(200,1,"Brown",R.mkFullEllipseNNP(.5,.5,t.point)));for(const t of this.triangles)for(let e=0;e<3;e++){const n=t.TriEdges.getItem(e);i.push(Xe.mkDebugCurveTWCI(n.Constrained?155:100,n.Constrained?.8:.4,n.Constrained?"Pink":"Navy",I.mkPP(n.upperSite.point,n.lowerSite.point)))}if(null!=e)for(const t of e)i.push(Xe.mkDebugCurveTWCI(100,.5,"Red",t));for(const t of this.front)i.push(Xe.mkDebugCurveTWCI(100,5.5,"Green",I.mkPP(t.Edge.upperSite.point,t.Edge.lowerSite.point)))}Show(t){Kr.ShowCdt(Array.from(this.triangles.values()),this.front,null,null,[],t)}static ShowCdt(t,e,i,n,r,s){let o=new Array;if(null!=i)for(const t of i)o.push(Xe.mkDebugCurveTWCI(200,.1,"Red",t));if(null!=n)for(const t of n)o.push(Xe.mkDebugCurveTWCI(200,.1,"Blue",t));if(null!=e)for(const t of e)o.push(Xe.mkDebugCurveTWCI(200,.1,"Green",I.mkPP(t.Edge.upperSite.point,t.Edge.lowerSite.point)));for(const e of t)for(let t=0;t<3;t++){const i=e.TriEdges.getItem(t);o.push(Kr.GetDebugCurveOfCdtEdge(i))}o=o.concat(r)}static GetDebugCurveOfCdtEdge(t){return null==t.CcwTriangle||null==t.CwTriangle?Xe.mkDebugCurveTWCI(255,.5,t.Constrained?"Brown":"Black",I.mkPP(t.upperSite.point,t.lowerSite.point)):Xe.mkDebugCurveTWCI(200,t.Constrained?.8:.2,t.Constrained?"Pink":"Navy",I.mkPP(t.upperSite.point,t.lowerSite.point))}PointEvent(t){const e=this.ProjectToFront(t),i={rightSite:null},n=e.item.x+y.distanceEpsilon<t.point.x?this.MiddleCase(t,e,i):this.LeftCase(t,e,i);let r=this.InsertSiteIntoFront(n,t,i.rightSite);this.TriangulateEmptySpaceToTheRight(r),r=Kr.FindNodeInFrontBySite(this.front,n),this.TriangulateEmptySpaceToTheLeft(r)}LeftCase(t,e,i){const n=e.item;this.InsertAndLegalizeTriangle(t,n);const r=this.front.previous(e),s=r.item.LeftSite;i.rightSite=e.item.RightSite,this.InsertAndLegalizeTriangle(t,r.item),this.front.deleteNodeInternal(r);this.front.remove(n);return s}MiddleCase(t,e,i){const n=e.item.LeftSite;return i.rightSite=e.item.RightSite,this.InsertAndLegalizeTriangle(t,e.item),this.front.deleteNodeInternal(e),n}TriangulateEmptySpaceToTheLeft(t){const e=t.item.RightSite;let i=this.front.previous(t);for(;null!=i;){const n=i.item,r=n.LeftSite,s=n.RightSite;if(!(s.point.sub(e.point).dot(r.point.sub(s.point))<0)){this.TryTriangulateBasinToTheLeft(t);break}t=this.ShortcutTwoFrontElements(i,t),i=this.front.previous(t)}}ShortcutTwoListElements(t){var e;const i=t.Next;let n=Xr.mkSSSEE(t.Start,t.End,i.End,t.Edge,i.Edge,this.createEdgeDelegate);this.triangles.add(n);const r=n.TriEdges.getItem(2);this.LegalizeEdge(t.Start,n.OppositeEdge(t.Start)),n=null!==(e=r.CcwTriangle)&&void 0!==e?e:r.CwTriangle,this.LegalizeEdge(i.End,n.OppositeEdge(i.End));const s=new Zr(r);return s.Start=t.Start,s.End=i.End,t.Prev.Next=s,s.Prev=t.Prev,s.Next=i.Next,i.Next.Prev=s,s}ShortcutTwoFrontElements(t,e){var i;const n=t.item,r=e.item;let s=Xr.mkSSSEED(n.LeftSite,n.RightSite,r.RightSite,n.Edge,r.Edge,this.createEdgeDelegate);this.triangles.add(s),this.front.deleteNodeInternal(t),this.front.remove(r);const o=s.TriEdges.getItem(2);return this.LegalizeEdge(n.LeftSite,s.OppositeEdge(n.LeftSite)),s=null!==(i=o.CcwTriangle)&&void 0!==i?i:o.CwTriangle,this.LegalizeEdge(r.RightSite,s.OppositeEdge(r.RightSite)),this.front.insert(new Hr(n.LeftSite,o))}TryTriangulateBasinToTheLeft(t){if(!Kr.DropsSharpEnoughToTheLeft(t.item))return;const e=new it.Stack;for(e.push(t.item.LeftSite);;){const i=e.pop();t=Kr.FindNodeInFrontBySite(this.front,i);const n=this.front.previous(t);if(null==n)return;if(E.getTriangleOrientation(n.item.LeftSite.point,t.item.LeftSite.point,t.item.RightSite.point)==s.Counterclockwise)e.push(n.item.LeftSite),this.ShortcutTwoFrontElements(n,t);else if(t.item.LeftSite.point.y>t.item.RightSite.point.y)e.push(n.item.LeftSite);else{if(n.item.LeftSite.point.y<=n.item.RightSite.point.y)return;e.push(n.item.LeftSite)}}}static DropsSharpEnoughToTheLeft(t){const e=t.Edge;if(t.RightSite!=e.upperSite)return!1;const i=e.lowerSite.point.sub(e.upperSite.point);return i.x>=.5*i.y}InsertSiteIntoFront(t,e,i){let n=null,r=null;for(const s of e.Edges)if(null==r&&s.lowerSite==t&&(r=s),null==n&&s.lowerSite==i&&(n=s),null!=r&&null!=n)break;return this.front.insert(new Hr(t,r)),this.front.insert(new Hr(e,n))}TriangulateEmptySpaceToTheRight(t){const e=t.item.LeftSite.point;let i=this.front.next(t);for(;null!=i;){const n=i.item,r=n.LeftSite,s=n.RightSite;if(!(r.point.sub(e).dot(s.point.sub(r.point))<0)){this.TryTriangulateBasinToTheRight(t);break}t=this.ShortcutTwoFrontElements(t,i),i=this.front.next(t)}}TryTriangulateBasinToTheRight(t){if(!Kr.DropsSharpEnoughToTheRight(t.item))return;const e=new it.Stack;for(e.push(t.item.LeftSite);;){const i=e.pop();t=Kr.FindNodeInFrontBySite(this.front,i);const n=this.front.next(t);if(null==n)return;if(E.getTriangleOrientation(t.item.LeftSite.point,t.item.RightSite.point,n.item.RightSite.point)==s.Counterclockwise)this.ShortcutTwoFrontElements(t,n),e.push(i);else if(t.item.LeftSite.point.y>t.item.RightSite.point.y)e.push(t.item.RightSite);else{if(n.item.LeftSite.point.y>=n.item.RightSite.point.y)return;e.push(t.item.RightSite)}}}static DropsSharpEnoughToTheRight(t){const e=t.Edge;if(t.LeftSite!=e.upperSite)return!1;const i=e.lowerSite.point.sub(e.upperSite.point);return i.x<=-.5*i.y}static FindNodeInFrontBySite(t,e){return t.findLast(t=>t.LeftSite.point.x<=e.point.x)}InsertAndLegalizeTriangle(t,e){var i;if(E.getTriangleOrientation(t.point,e.LeftSite.point,e.RightSite.point)!=s.Collinear){const i=Xr.mkSED(t,e.Edge,this.createEdgeDelegate);this.triangles.add(i),this.LegalizeEdge(t,i.TriEdges.getItem(0))}else{const n=e.Edge;$r(n.upperSite.Edges,n);let r=null!==(i=n.CcwTriangle)&&void 0!==i?i:n.CwTriangle;const s=r.OppositeSite(n);Kr.RemoveTriangleButLeaveEdges(this.triangles,r),r=Xr.mkSSSD(e.LeftSite,s,t,this.createEdgeDelegate);const o=Xr.mkSSSD(e.RightSite,s,t,this.createEdgeDelegate);this.triangles.add(r),this.triangles.add(o),this.LegalizeEdge(t,r.OppositeEdge(t)),this.LegalizeEdge(t,o.OppositeEdge(t))}}LegalizeEdge(t,e){e.Constrained||null==e.CcwTriangle||null==e.CwTriangle||(e.CcwTriangle.Contains(t)?this.LegalizeEdgeForOtherCwTriangle(t,e):this.LegalizeEdgeForOtherCcwTriangle(t,e))}LegalizeEdgeForOtherCwTriangle(t,e){const i=e.CwTriangle.TriEdges.index(e);if(Jr(t,e.upperSite,e.CwTriangle.Sites.getItem(i+2),e.lowerSite)){const i=es(t,e);this.LegalizeEdge(t,i.CwTriangle.OppositeEdge(t)),this.LegalizeEdge(t,i.CcwTriangle.OppositeEdge(t))}}LegalizeEdgeForOtherCcwTriangle(t,e){const i=e.CcwTriangle.TriEdges.index(e);if(Jr(t,e.lowerSite,e.CcwTriangle.Sites.getItem(i+2),e.upperSite)){const i=es(t,e);this.LegalizeEdge(t,i.CwTriangle.OppositeEdge(t)),this.LegalizeEdge(t,i.CcwTriangle.OppositeEdge(t))}}ProjectToFront(t){return this.front.findLast(e=>e.x<=t.point.x)}}function $r(t,e){if(0==t.length)return;const i=t.findIndex(t=>e==t);i>=0&&(i!=t.length-1&&(t[i]=t[t.length-1]),t.pop())}function Jr(t,e,i,n){return function(t,e,i,n){return E.getTriangleOrientation(e.point,t.point,i.point)==s.Clockwise&&E.getTriangleOrientation(i.point,t.point,n.point)==s.Clockwise}(t,e,i,n)&&ts(t,e,i,n)}function ts(t,e,i,n){const r=e.point.x-t.point.x,s=e.point.y-t.point.y,o=i.point.x-t.point.x,a=i.point.y-t.point.y,l=n.point.x-t.point.x,h=n.point.y-t.point.y,u=r*r+s*s,c=o*o+a*a,d=l*l+h*h;return r*(a*d-h*c)-o*(s*d-h*u)+l*(s*c-a*u)>y.tolerance}function es(t,e){let i,n;e.CcwTriangle.Contains(t)?(i=e.CcwTriangle,n=e.CwTriangle):(i=e.CwTriangle,n=e.CcwTriangle);const r=i.TriEdges.index(e),s=n.TriEdges.index(e),o=n.Sites.getItem(s+2),a=i.TriEdges.getItem(r+1),l=n.TriEdges.getItem(s+1),h=is.GetOrCreateEdge(t,o);return i.Sites.setItem(r+1,o),i.TriEdges.setItem(r,l),i.TriEdges.setItem(r+1,h),n.Sites.setItem(s+1,t),n.TriEdges.setItem(s,a),n.TriEdges.setItem(s+1,h),l.lowerSite==o?l.CcwTriangle=i:l.CwTriangle=i,a.lowerSite==t?a.CcwTriangle=n:a.CwTriangle=n,h.upperSite==t?(h.CcwTriangle=n,h.CwTriangle=i):(h.CcwTriangle=i,h.CwTriangle=n),$r(e.upperSite.Edges,e),h}class is extends K{constructor(t,e,i){super(null),this.isolatedSites=[],this.obstacles=[],this.PointsToSites=new Ie,this.cdtTree=null,this.isolatedSites=t,this.obstacles=e,this.isolatedSegments=i}static constructor_(t){const e=new is(null,null,null);return e.isolatedSitesWithObject=t,e}FillAllInputSites(){if(null!=this.isolatedSitesWithObject)for(const t of this.isolatedSitesWithObject)this.AddSite(t[0],t[1]);if(null!=this.isolatedSites)for(const t of this.isolatedSites)this.AddSite(t,null);if(null!=this.obstacles)for(const t of this.obstacles)this.AddPolylineToAllInputSites(t);if(null!=this.isolatedSegments)for(const t of this.isolatedSegments)this.AddConstrainedEdge(t.A,t.B,null);this.AddP1AndP2(),this.allInputSites=Array.from(this.PointsToSites.values())}AddSite(t,e){let i;return(i=this.PointsToSites.get(t))?i.Owner=e:(i=Wr.mkSO(t,e),this.PointsToSites.set(t,i)),i}AddP1AndP2(){const t=G.mkEmpty();for(const e of this.PointsToSites.keys())t.add(e);const e=Math.max(t.width/3,1),i=Math.max(t.height/3,1);this.P1=new Wr(t.leftBottom.add(new E(-e,-i))),this.P2=new Wr(t.rightBottom.add(new E(e,-i)))}AddPolylineToAllInputSites(t){for(let e=t.startPoint;null!=e.next;e=e.next)this.AddConstrainedEdge(e.point,e.next.point,t);t.closed&&this.AddConstrainedEdge(t.endPoint.point,t.startPoint.point,t)}AddConstrainedEdge(t,e,i){let n,r;is.AbovePP(t,e)>0?(n=this.AddSite(t,i),r=this.AddSite(e,i)):(n=this.AddSite(e,i),r=this.AddSite(t,i));is.CreateEdgeOnOrderedCouple(n,r).Constrained=!0}static GetOrCreateEdge(t,e){if(1==is.AboveCC(t,e)){const i=t.EdgeBetweenUpperSiteAndLowerSite(e);return null!=i?i:is.CreateEdgeOnOrderedCouple(t,e)}{const i=e.EdgeBetweenUpperSiteAndLowerSite(t);return null!=i?i:is.CreateEdgeOnOrderedCouple(e,t)}}static CreateEdgeOnOrderedCouple(t,e){return new Ur(t,e)}GetTriangles(){return this.sweeper.triangles}run(){this.Initialization(),this.SweepAndFinalize()}SweepAndFinalize(){this.sweeper=new Kr(this.allInputSites,this.P1,this.P2,is.GetOrCreateEdge),this.sweeper.run()}Initialization(){this.FillAllInputSites(),this.allInputSites.sort(is.OnComparison)}static OnComparison(t,e){return is.AboveCC(t,e)}static AbovePP(t,e){let i=t.y-e.y;return i>0?1:i<0?-1:(i=t.x-e.x,i>0?-1:i<0?1:0)}static AboveCC(t,e){return is.AbovePP(t.point,e.point)}RestoreEdgeCapacities(){for(const t of this.allInputSites)for(const e of t.Edges)e.Constrained||(e.ResidualCapacity=e.Capacity)}SetInEdges(){for(const t of this.PointsToSites.values())for(const e of t.Edges){e.lowerSite.AddInEdge(e)}}FindSite(t){return this.PointsToSites.get(t)}static PointIsInsideOfTriangle(t,e){for(let i=0;i<3;i++){const n=e.Sites.getItem(i).point,r=e.Sites.getItem(i+1).point;if(E.signedDoubledTriangleArea(t,n,r)<-1*y.distanceEpsilon)return!1}return!0}GetCdtTree(){return null==this.cdtTree&&(this.cdtTree=ot(Array.from(this.GetTriangles().values()).map(t=>ut(t,t.BoundingBox())))),this.cdtTree}EdgeIsCorrect(t){const e=t.upperSite;let i=!1;for(const n of e.Edges)if(n==t){i=!0;break}if(!i)return!1;return this.PointsToSites.get(e.point)==e}}class ns{constructor(t,e){this.start=t,this.end=e}add(t){this.add_d(t)}add_rect(t){const e=t,i=this.clone();return i.add_d(e.start),i.add_d(e.end),i}clone(){return new ns(this.start,this.end)}contains_point(t){return this.contains_d(t)}contains_rect(t){const e=t;return this.contains_d(e.start)&&this.contains_d(e.end)}intersection_rect(t){const e=t;return new ns(Math.max(this.start,e.start),Math.min(this.end,e.end))}intersects_rect(t){const e=t;return this.intersects(e)}contains_point_radius(t,e){return this.contains_d(t-e)&&this.contains_d(t+e)}static mkInterval(t,e){const i=new ns(t.start,t.end);return i.add_d(e.start),i.add_d(e.end),i}add_d(t){this.start>t&&(this.start=t),this.end<t&&(this.end=t)}get Start(){return this.start}set Start(t){this.start=t}get Length(){return this.end-this.start}contains_d(t){return this.start<=t&&t<=this.end}GetInRange(t){return t<this.start?this.start:t>this.end?this.end:t}intersects(t){return!(t.start>this.end+y.distanceEpsilon)&&!(t.end<this.start-y.distanceEpsilon)}}class rs{constructor(t){this.heapSize=0,this._priors=new Array(t),this._heap=new Array(t+1),this._reverse_heap=new Array(t)}get Count(){return this.heapSize}SwapWithParent(t){const e=this._heap[t>>1];this.PutAtI(t>>1,this._heap[t]),this.PutAtI(t,e)}Enqueue(t,e){this.heapSize++;let i=this.heapSize;for(this._priors[t]=e,this.PutAtI(i,t);i>1&&this._priors[this._heap[i>>1]]>e;)this.SwapWithParent(i),i>>=1}PutAtI(t,e){this._heap[t]=e,this._reverse_heap[e]=t}Dequeue(){if(0==this.heapSize)throw new Error;const t=this._heap[1];if(this.heapSize>1){this.PutAtI(1,this._heap[this.heapSize]);let t=1;for(;;){let e=t;const i=t<<1;i<=this.heapSize&&this._priors[this._heap[i]]<this._priors[this._heap[t]]&&(e=i);const n=i+1;if(n<=this.heapSize&&this._priors[this._heap[n]]<this._priors[this._heap[e]]&&(e=n),e==t)break;this.SwapWithParent(e),t=e}}return this.heapSize--,t}IsEmpty(){return 0==this.heapSize}DecreasePriority(t,e){this._priors[t]=e;let i=this._reverse_heap[t];for(;i>1&&this._priors[this._heap[i]]<this._priors[this._heap[i>>1]];)this.SwapWithParent(i),i>>=1}}class ss{constructor(t,e,i,n){this._numberOfOverlaps=0,this._proximityEdges=t,this._nodeSizes=e,this._nodePositions=i,this._forLayers=n,this._q=new rs(2*e.length)}Run(){return this.InitQueue(),this.FindOverlaps(),this._numberOfOverlaps}FindOverlaps(){for(;this._q.Count>0;){let t=this._q.Dequeue();t<this._nodePositions.length?(this.FindOverlapsWithInterval(t),this.AddIntervalToTree(t)):(t-=this._nodePositions.length,this.RemoveIntervalFromTree(t))}}RemoveIntervalFromTree(t){this._intervalTree.Remove(this.GetInterval(t),t)}AddIntervalToTree(t){const e=this.GetInterval(t);null==this._intervalTree&&(this._intervalTree=dt([])),this._intervalTree.Add(e,t)}FindOverlapsWithInterval(t){if(null==this._intervalTree)return;const e=this.GetInterval(t);for(const i of this._intervalTree.GetAllIntersecting(e)){const e=hs.GetIdealEdge(t,i,this._nodePositions[t],this._nodePositions[i],this._nodeSizes);if(e.overlapFactor<=1)return;this._proximityEdges.push(e),this._numberOfOverlaps++}}GetInterval(t){const e=this._nodeSizes[t].width/2,i=this._nodePositions[t].x;return new ns(i-e,i+e)}InitQueue(){for(let t=0;t<this._nodeSizes.length;t++){const e=this._nodeSizes[t].height/2,i=this._nodePositions[t].y;this._q.Enqueue(t,i-e),this._q.Enqueue(this._nodeSizes.length+t,i+e)}}}class os{constructor(t,e,i){this.treeNodes=new Set,this.hedgehog=new Map,this.graph=t,this.weight=e,this.root=i,this.q=new rs(this.graph.nodeCount)}NodeIsInTree(t){return this.treeNodes.has(t)}GetTreeEdges(){const t=new Array;for(this.Init();t.length<this.graph.nodeCount-1&&this.q.Count>0;)this.AddEdgeToTree(t);return t}AddEdgeToTree(t){const e=this.q.Dequeue(),i=this.hedgehog.get(e);this.treeNodes.add(e),t.push(i),this.UpdateOutEdgesOfV(e),this.UpdateInEdgesOfV(e)}UpdateOutEdgesOfV(t){for(const e of this.graph.outEdges[t]){const t=e.target;if(this.NodeIsInTree(t))continue;const i=this.hedgehog.get(t);if(i){const n=this.weight(i),r=this.weight(e);r<n&&(this.q.DecreasePriority(t,r),this.hedgehog.set(t,e))}else this.q.Enqueue(t,this.weight(e)),this.hedgehog.set(t,e)}}UpdateInEdgesOfV(t){for(const e of this.graph.inEdges[t]){const t=e.source;if(this.NodeIsInTree(t))continue;const i=this.hedgehog.get(t);if(i){const n=this.weight(i),r=this.weight(e);r<n&&(this.q.DecreasePriority(t,r),this.hedgehog.set(t,e))}else this.q.Enqueue(t,this.weight(e)),this.hedgehog.set(t,e)}}Init(){this.treeNodes.add(this.root);for(const t of this.graph.outEdges[this.root]){const e=this.weight(t);this.q.Enqueue(t.target,e),this.hedgehog.set(t.target,t)}for(const t of this.graph.inEdges[this.root]){const e=this.weight(t);this.q.Enqueue(t.source,e),this.hedgehog.set(t.source,t)}}}class as{static GetMst(t,e){if(0==t.length)return null;const i=t.map(t=>new wt(t.source,t.target)),n=i.reduce((t,e)=>Math.max(t,Math.max(e.x,e.y)),0),r=new Et(n+1);for(let e=0;e<t.length;e++)r.setPair(i[e],t[e]);const s=St(i,e);return new os(s,t=>r.get(t.source,t.target).weight,i[0].source).GetTreeEdges().map(t=>r.get(t.source,t.target))}static GetMstOnCdt(t,e){const i=Array.from(t.PointsToSites.values()),n=new Map;for(let t=0;t<i.length;t++)n.set(i[t],t);const r=as.GetEdges(i,n),s=vt(Array.from(r.keys()));return new os(s,t=>e(r.get(t.source,t.target)),0).GetTreeEdges().map(t=>r.get(t.source,t.target))}static GetEdges(t,e){const i=new Et(t.length);for(let n=0;n<t.length;n++){const r=t[n],s=e.get(r);for(const t of r.Edges)i.set(s,e.get(t.lowerSite),t)}return i}}class ls{constructor(){this.epsilon=.01,this.iterationsMax=1e3,this.stopOnMaxIterat=!1,this.nodeSeparation=4,this.randomizationSeed=1,this.randomizeAllPointsOnStart=!1}get StopOnMaxIterat(){return this.stopOnMaxIterat}set StopOnMaxIterat(t){this.stopOnMaxIterat=t}get Epsilon(){return this.epsilon}set Epsilon(t){this.epsilon=t}get IterationsMax(){return this.iterationsMax}set IterationsMax(t){this.iterationsMax=t}get NodeSeparation(){return this.nodeSeparation}set NodeSeparation(t){this.nodeSeparation=t}get RandomizationSeed(){return this.randomizationSeed}set RandomizationSeed(t){this.randomizationSeed=t}get RandomizeAllPointsOnStart(){return this.randomizeAllPointsOnStart}set RandomizeAllPointsOnStart(t){this.randomizeAllPointsOnStart=t}Clone(){const t=new ls;return t.Epsilon=this.Epsilon,t.IterationsMax=this.IterationsMax,t.StopOnMaxIterat=this.StopOnMaxIterat,t.NodeSeparation=this.NodeSeparation,t.RandomizationSeed=this.RandomizationSeed,t.RandomizeAllPointsOnStart=this.randomizeAllPointsOnStart,t}}class hs{constructor(t,e){this._settings=t,this._nodes=e}static RemoveOverlaps(t,e){const i=new ls;i.RandomizeAllPointsOnStart=!0,i.NodeSeparation=e;new hs(i,t).RemoveOverlaps()}RemoveOverlaps(){if(this._nodes.length<3)return void this.RemoveOverlapsOnTinyGraph();const t={nodePositions:new Array,nodeSizes:new Array};for(!function(t,e,i){i.nodePositions=e.map(t=>t.center),i.nodeSizes=e.map(e=>{const i=e.boundingBox.size;return i.width+=t.NodeSeparation,i.height+=t.NodeSeparation,i})}(this._settings,this._nodes,t),this.lastRunNumberIterations=0;this.OneIteration(t.nodePositions,t.nodeSizes,!1);)this.lastRunNumberIterations++;for(;this.OneIteration(t.nodePositions,t.nodeSizes,!0);)this.lastRunNumberIterations++;for(let e=0;e<this._nodes.length;e++)this._nodes[e].center=t.nodePositions[e]}RemoveOverlapsOnTinyGraph(){if(1!=this._nodes.length&&2==this._nodes.length){const t=this._nodes[0],e=this._nodes[1];E.closeDistEps(t.center,e.center)&&(e.center=e.center.add(new E(.001,0)));const i=this.GetIdealDistanceBetweenTwoNodes(t,e),n=E.middle(t.center,e.center);let r=t.center.sub(e.center);const s=r.length;r=r.mul(i/s*.5),t.center=n.add(r),e.center=n.sub(r)}}GetIdealDistanceBetweenTwoNodes(t,e){const i=t.center.sub(e.center),n=Math.abs(i.x),r=Math.abs(i.y),s=(t.width+e.width)/2+this._settings.NodeSeparation,o=(t.height+e.height)/2+this._settings.NodeSeparation;let a=Number.POSITIVE_INFINITY,l=Number.POSITIVE_INFINITY;return n>y.tolerance&&(a=s/n),r>y.tolerance&&(l=o/r),Math.min(a,l)*i.length}static AvgEdgeLength(t){let e=0,i=0;for(const n of t)for(const t of n.outEdges())i+=n.center.sub(t.target.center).length,e++;return e>0?i/e:1}OneIteration(t,e,i){const n=new Array;for(let e=0;e<t.length;e++)n.push([t[e],e]);const r=is.constructor_(n);r.run();const s=new Map;for(let e=0;e<t.length;e++)s.set(r.PointsToSites.get(t[e]),e);let o=0;const a=new Array;for(const t of r.PointsToSites.values())for(const i of t.Edges){const t=i.upperSite.point,n=i.lowerSite.point,r=s.get(i.upperSite),l=s.get(i.lowerSite),h=hs.GetIdealEdge(r,l,t,n,e);a.push(h),h.overlapFactor>1&&o++}if(0==o||i){const n=this.FindProximityEdgesWithSweepLine(a,e,t);if(0==o&&0==n)return!1;if(0==o&&!i)return!1}const l=as.GetMst(a,t.length);return hs.MoveNodePositions(l,t,l[0].source),!0}FindProximityEdgesWithSweepLine(t,e,i){return new ss(t,e,i,this._overlapForLayers).Run()}static GetIdealEdge(t,e,i,n,r){const s={overlapFactor:0},o=hs.GetIdealEdgeLength(t,e,i,n,r,s),a=i.sub(n).length,l=G.mkSizeCenter(r[t],i),h=G.mkSizeCenter(r[e],n),u=s.overlapFactor>1?a-o:hs.GetDistanceRects(l,h);return{source:Math.min(t,e),target:Math.max(t,e),overlapFactor:s.overlapFactor,idealDistance:o,weight:u}}static GetIdealEdgeLength(t,e,i,n,r,s){const o=i.sub(n),a=o.length,l=Math.abs(o.x),h=Math.abs(o.y),u=(r[t].width+r[e].width)/2,c=(r[t].height+r[e].height)/2;if(l>=u||h>=c)return s.overlapFactor=1,o.length;let d;if(l>1e-10)d=h>1e-10?Math.min(u/l,c/h):u/l;else{if(!(h>1e-10))return s.overlapFactor=2,Math.sqrt(u*u+c*c)/4;d=c/h}return d=Math.max(d,1.001),s.overlapFactor=d,d*a}static GetDistanceRects(t,e){if(t.intersects(e))return 0;let i=0,n=0;(t.right<e.left||e.right<t.left)&&(n=t.left-e.right),t.top<e.bottom?i=e.bottom-t.top:e.top<t.bottom&&(i=t.bottom-e.top);return Math.sqrt(n*n+i*i)}static MoveNodePositions(t,e,i){const n=e.map(t=>t.clone()),r=new Set;r.add(i);for(let i=0;i<t.length;i++){const s=t[i];r.has(s.source)?hs.MoveNode(s.source,s.target,n,e,r,s.idealDistance):hs.MoveNode(s.target,s.source,n,e,r,s.idealDistance)}}static MoveNode(t,e,i,n,r,s){let o=i[e].sub(i[t]);o=o.mul(s/o.length+.01),n[e]=n[t].add(o),r.add(e)}GetLastRunIterations(){return this.lastRunNumberIterations}}class us extends K{constructor(t,e,i,n){super(i),this.settings=t,this.graph=e,this.length=n}run(){this.LayoutConnectedGraphWithMds(),this.SetGraphBoundingBox()}SetGraphBoundingBox(){this.graph.boundingBox=this.graph.pumpTheBoxToTheGraphWithMargins(this.settings.NodeSeparation/2)}static ScaleToAverageEdgeLength(t,e,i,n){const r=new Map;let s=0;for(const e of t.shallowNodes())r.set(e,s),s++;let o=0,a=0;for(const s of t.edges()){const t=r.get(s.source),l=r.get(s.target);a+=Math.sqrt(Math.pow(e[t]-e[l],2)+Math.pow(i[t]-i[l],2)),o+=n(s)}if(o>0&&(a/=o),a>0)for(let t=0;t<e.length;t++)e[t]/=a,i[t]/=a}static LayoutGraphWithMds(t,e,i,n){if(i.x=new Array(t.shallowNodeCount),i.y=new Array(t.shallowNodeCount),0==i.x.length)return;if(1==i.x.length)return void(i.x[0]=i.y[0]=0);const r=Math.min(e.PivotNumber,t.shallowNodeCount),s=e.GetNumberOfIterationsWithMajorization(t.shallowNodeCount),o=e.Exponent,a=new Array(r),l=new zr(t,a,n);l.run();const h=l.Result;if(jr.LandmarkClassicalScaling(h,i,a),us.ScaleToAverageEdgeLength(t,i.x,i.y,n),s>0){const e=new Gr(t,n);e.run();const r=e.Result,a=jr.ExponentialWeightMatrix(r,o);jr.DistanceScalingSubset(r,i.x,i.y,a,s)}}LayoutConnectedGraphWithMds(){const t={x:[],y:[]};us.LayoutGraphWithMds(this.graph,this.settings,t,this.length),0!=this.settings.RotationAngle&&class{static Rotate(t,e,i){const n=Math.sin(i*(Math.PI/180)),r=Math.cos(i*(Math.PI/180));for(let i=0;i<t.length;i++){const s=r*t[i]+n*e[i];e[i]=r*e[i]-n*t[i],t[i]=s}}}.Rotate(t.x,t.y,this.settings.RotationAngle);let e=0;for(const i of this.graph.shallowNodes())i.boundingBox&&(i.center=new E(t.x[e]*this.settings.ScaleX,t.y[e]*this.settings.ScaleY)),e++;this.settings.RemoveOverlaps&&hs.RemoveOverlaps(Array.from(this.graph.shallowNodes()),this.settings.NodeSeparation),this.graph.pumpTheBoxToTheGraphWithMargins(this.settings.NodeSeparation/2)}ScaleNodes(t,e){for(const i of t)i.center=i.center.mul(e)}static PackGraphs(t,e){if(0==t.length)return G.mkEmpty();if(1==t.length)return t[0].boundingBox;const i=t.map(t=>t.boundingBox),n=new Array;for(const e of t)n.push({g:e,lb:e.boundingBox.leftBottom.clone()});const r=new st(i,e.PackingAspectRatio);r.run();for(const{g:t,lb:e}of n){const i=t.boundingBox.leftBottom.sub(e);t.translate(i)}return new G({left:0,bottom:0,right:r.PackedWidth,top:r.PackedHeight})}}class cs extends jt{constructor(){super(...arguments),this.pivotNumber=50,this.iterationsWithMajorization=30,this.scaleX=200,this.scaleY=200,this.exponent=-2,this.rotationAngle=0,this.removeOverlaps=!0,this._callIterationsWithMajorizationThreshold=3e3,this.adjustScale=!1}get RemoveOverlaps(){return this.removeOverlaps}set RemoveOverlaps(t){this.removeOverlaps=t}get PivotNumber(){return this.pivotNumber}set PivotNumber(t){this.pivotNumber=t}get IterationsWithMajorization(){return this.iterationsWithMajorization}set IterationsWithMajorization(t){this.iterationsWithMajorization=t}get ScaleX(){return this.scaleX}set ScaleX(t){this.scaleX=t}get ScaleY(){return this.scaleY}set ScaleY(t){this.scaleY=t}get Exponent(){return this.exponent}set Exponent(t){this.exponent=t}get RotationAngle(){return this.rotationAngle}set RotationAngle(t){this.rotationAngle=t%360}get IdealEdgeLength(){return this.edgeConstraints}set IdealEdgeLength(t){this.edgeConstraints=t}get AdjustScale(){return this.adjustScale}set AdjustScale(t){this.adjustScale=t}GetNumberOfIterationsWithMajorization(t){return t>this.CallIterationsWithMajorizationThreshold?0:this.IterationsWithMajorization}get CallIterationsWithMajorizationThreshold(){return this._callIterationsWithMajorizationThreshold}set CallIterationsWithMajorizationThreshold(t){this._callIterationsWithMajorizationThreshold=t}}class ds extends K{constructor(t,e,i,n){super(e),this.graph=t,this.length=i,this.settings=n,this.settings.ScaleX=this.settings.ScaleY=200}get scaleX(){return this.settings.ScaleX}set scaleX(t){this.settings.ScaleX=t}get scaleY(){return this.settings.ScaleY}set scaleY(t){this.settings.ScaleY=t}run(){new us(this.settings,this.graph,this.cancelToken,this.length).run()}}function gs(t,e){function i(t){t.layoutSettings||(t.layoutSettings=function(t){return t.shallowNodeCount<200||t.edgeCount<200?new Ut:new cs}(t))}i(t),ms(t,e,(function(t,e){if(i(t),t.layoutSettings instanceof Ut){new no(t,t.layoutSettings,e).run()}else{if(!(t.layoutSettings instanceof cs))throw Error("not implemented");new ds(t,e,()=>1,t.layoutSettings).run()}}),ps,mt)}function fs(t){for(;;){if(t.layoutSettings&&t.layoutSettings.edgeRoutingSettings)return t.layoutSettings.edgeRoutingSettings;const e=t.graph.parent;if(!e)break;t=z.getGeom(e)}const e=new zt;return e.EdgeRoutingMode=It.Spline,e}function ps(t,e,i){const n=fs(t);if(n.EdgeRoutingMode==It.Rectilinear)!function(t,e,i,n=1,r=3){kr.constructorGNANB(t,e,n,r,!0).run()}(t,e);else if(n.EdgeRoutingMode==It.Spline||n.EdgeRoutingMode==It.SplineBundling)!function(t,e,i){const n=t.layoutSettings?t.layoutSettings.edgeRoutingSettings:fs(t);new to(t,e,n.Padding,n.PolylinePadding,n.coneAngle,n.BundlingSettings,i).run()}(t,e,i);else if(n.EdgeRoutingMode==It.StraightLine)!function(t,e,i){if(e)for(const n of e){if(i&&i.canceled)return;eo.RouteEdge(n,t.padding)}else for(const e of t.deepNodes()){if(i&&i.canceled)return;for(const i of e.outEdges())null==i.curve&&eo.RouteEdge(i,t.padding);for(const i of e.selfEdges())null==i.curve&&eo.RouteEdge(i,t.padding)}}(t,e,i);else if(null==t.graph.parent&&n.EdgeRoutingMode!=It.None){const e=Array.from(t.deepEdges()).filter(t=>!t.curve);e.length>0&&new to(t,e).run()}}function ms(t,e,i,n,r,s=!0){if(t.graph.isEmpty())return;if(t.layoutSettings&&t.layoutSettings.runRoutingOnly)return void n(t,Array.from(t.deepEdges()),e);const o=function(){const e=new Set,i=t.graph;if(null==i.parent)return e;for(const t of i.shallowNodes){for(const n of t.outEdges){const r=i.liftNode(n.target);null!=r&&r!=t||e.add(n)}for(const n of t.inEdges){const r=i.liftNode(n.source);null!=r&&r!=t||e.add(n)}}for(const t of e)t.remove();return e}();!function(t){for(const s of t.shallowNodes())if(s instanceof yt){const t=s;if(ms(t,e,i,n,r),!t.graph.isEmpty()){const e=t.boundingBox;e&&!e.isEmpty()&&(s.boundaryCurve=H.mkRectangleWithRoundedCorners(e.width,e.height,Math.min(10,e.width/10),Math.min(10,e.height/10),e.center))}}}(t);const a=function(t){const e=new Array;for(const i of t.deepNodes){const n=t.liftNode(i);if(null!=n)for(const r of i.outEdges.values()){const s=r.target,o=t.liftNode(s);if(null==o||n==i&&o==s||n==o)continue;r.remove();const a=new c(n,o),l=new Z(a);e.push([l,r])}}return e}(t.graph),l=function(t){const e=t.graph,i=function*(t){const e=new Set,i=new h.Queue;for(const s of t.shallowNodes){if(e.has(s))continue;const t=new Array;for(r(s,i,e);i.length>0;){const s=i.dequeue();t.push(s);for(const t of n(s))r(t,i,e)}yield t}function*n(t){for(const e of t.outEdges)yield e.target;for(const e of t.inEdges)yield e.source}function r(t,e,i){i.has(t)||(e.enqueue(t),i.add(t))}}(e),n=[];let r=0;for(const s of i){const i=new p(e.id+r++);i.parent=e;const o=new yt(i);o.layoutSettings=t.layoutSettings;for(const t of s)t.parent=i,i.addNode(t);n.push(o)}return n}(t);!function(){if(0==l.length)return;for(const t of l)i(t,e);r(t,l)}(),a.forEach(t=>{t[0].edge.remove(),t[1].add()}),l.forEach(e=>{for(const i of e.graph.shallowNodes)i.parent=t.graph});const u=function(t){const e=[];for(const i of t.deepNodes()){for(const t of i.outEdges())null==t.curve&&e.push(t);for(const t of i.selfEdges())null==t.curve&&e.push(t)}return e}(t);o.forEach(t=>t.add()),n(t,u,e),null==t.graph.parent&&s&&t.FlipYAndMoveLeftTopToOrigin()}class ys{static constructorStatic(t,e){const i=new ys;i.edges=t,i.nodeBoundaries=e,i.boundingBox=G.mkEmpty();for(const t of i.nodeBoundaries)i.boundingBox=i.boundingBox.addRec(t.boundingBox);return i}AddGraph(t){this.edges=this.edges.concat(t.edges),this.nodeBoundaries=ge(this.nodeBoundaries,t.nodeBoundaries),this.boundingBox.addRec(t.boundingBox)}AddNodeBoundary(t){this.nodeBoundaries.add(t),this.boundingBox.addRec(t.boundingBox)}}!function(t){t[t.Success=0]="Success",t[t.Overlaps=1]="Overlaps",t[t.EdgeSeparationIsTooLarge=2]="EdgeSeparationIsTooLarge"}(He||(He={}));var bs,Ps,vs,Ss,Cs=i(42);class ws{constructor(t,e,i){this.currentTriangle=t,this.start=e,this.end=i}get CurrentPiercedEdge(){return this.currentPiercedEdge}get CurrentTriangle(){return this.currentTriangle}*Triangles(){for(;this.MoveNext();)yield this.CurrentTriangle}FindFirstPiercedEdge(){const t=this.GetHyperplaneSign(this.currentTriangle.Sites.item0),e=this.GetHyperplaneSign(this.currentTriangle.Sites.item1);if(t!=e&&E.getTriangleOrientation(this.end,this.currentTriangle.Sites.item0.point,this.currentTriangle.Sites.item1.point)==s.Clockwise)return this.positiveSign=t,this.negativeSign=e,this.currentTriangle.TriEdges.item0;const i=this.GetHyperplaneSign(this.currentTriangle.Sites.item2);return e!=i&&E.getTriangleOrientation(this.end,this.currentTriangle.Sites.item1.point,this.currentTriangle.Sites.item2.point)==s.Clockwise?(this.positiveSign=e,this.negativeSign=i,this.currentTriangle.TriEdges.item1):(this.positiveSign=i,this.negativeSign=t,this.currentTriangle.TriEdges.item2)}static PointLocationForTriangle(t,e){let i=!1;for(let n=0;n<3;n++){const r=E.signedDoubledTriangleArea(t,e.Sites.getItem(n).point,e.Sites.getItem(n+1).point);if(r<-1*y.distanceEpsilon)return a.Outside;r<y.distanceEpsilon&&(i=!0)}return i?a.Boundary:a.Inside}FindNextPierced(){if(this.currentTriangle=this.currentPiercedEdge.GetOtherTriangle_T(this.currentTriangle),null==this.currentTriangle)return void(this.currentPiercedEdge=null);const t=this.currentTriangle.TriEdges.index(this.currentPiercedEdge);let e;const i=this.currentTriangle.Sites.getItem(t+2),n=this.GetHyperplaneSign(i);0==this.negativeSign?-1==n||0==n?(this.negativeSign=n,e=t+1):e=t+2:0==this.positiveSign?1==n||0==n?(this.positiveSign=n,e=t+2):e=t+1:n!=this.positiveSign?(this.negativeSign=n,e=t+1):(this.positiveSign=n,e=t+2),this.currentPiercedEdge=E.signedDoubledTriangleArea(this.end,this.currentTriangle.Sites.getItem(e).point,this.currentTriangle.Sites.getItem(e+1).point)<-y.distanceEpsilon?this.currentTriangle.TriEdges.getItem(e):null}GetHyperplaneSign(t){const e=E.signedDoubledTriangleArea(this.start,t.point,this.end);return e>y.distanceEpsilon?1:e<-1*y.distanceEpsilon?-1:0}MoveNext(){return null==this.currentPiercedEdge?this.currentPiercedEdge=this.FindFirstPiercedEdge():this.FindNextPierced(),null!=this.currentPiercedEdge}}class Es{constructor(t,e){this.ComputeForcesForBundles=!1,this.metroGraphData=t,this.bundlingSettings=e}EdgeIsLegal_(t,e,i,n){if(is.PointIsInsideOfTriangle(e,i))return!0;const r=new ws(i,t,e);for(;r.MoveNext();){const t=r.CurrentPiercedEdge;if(t.Constrained){const e=t.lowerSite.Owner;if(!n.has(e))return!1}}return!0}BundleAvoidsObstacles(t,e,i,n,r,s){s.closestDist=new Array;const o=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t,e),a=this.FindCloseObstaclesForBundle(e.CdtTriangle,n,i,o,r);if(null==a)return!1;for(const t of a){const e=t[1];s.closestDist.push(e)}return!0}FindCloseObstaclesForBundle(t,e,i,n,r){const s=new Map,o=[];if(!this.ThreadLineSegmentThroughTriangles(t,e,i,n,o))return null;if(!this.ComputeForcesForBundles&&!this.bundlingSettings.HighestQuality)return s;const a=new Cs.HashSet;for(const t of o)for(const o of t.Sites){if(a.has(o))continue;a.add(o);const t=o.Owner;if(n.has(t))continue;const l=Es.FindPolylinePoint(t,o.point),h=I.minDistBetweenLineSegments(l.point,l.nextOnPolyline.point,e,i),u=h.dist,c=h.parab,d=h.parcd,g=I.minDistBetweenLineSegments(l.point,l.prevOnPolyline.point,e,i),f=g.dist,p=g.parab,m=g.parcd;let y,b,P;if(u<f){if(P=u,P>r)continue;y=l.point.add(l.nextOnPolyline.point.sub(l.point).mul(c)),b=e.add(i.sub(e).mul(d))}else{if(P=f,P>r)continue;y=l.point.add(l.prevOnPolyline.point.sub(l.point).mul(p)),b=e.add(i.sub(e).mul(m))}s.get(t)||s.set(t,[y,b])}return s}ThreadLineSegmentThroughTriangles(t,e,i,n,r){if(is.PointIsInsideOfTriangle(i,t))return r.push(t),!0;const s=new ws(t,e,i);for(r.push(t);s.MoveNext();){r.push(s.CurrentTriangle);const t=s.CurrentPiercedEdge;if(t.Constrained){const e=t.lowerSite.Owner;if(!n.has(e))return!1}}return null!=s.CurrentTriangle&&r.push(s.CurrentTriangle),!0}static PointLocationInsideTriangle(t,e){let i=!1;for(let n=0;n<3;n++){const r=E.signedDoubledTriangleArea(t,e.Sites.getItem(n).point,e.Sites.getItem(n+1).point);if(r<-1*y.distanceEpsilon)return a.Outside;r<y.distanceEpsilon&&(i=!0)}return i?a.Boundary:a.Inside}static FindPolylinePoint(t,e){for(const i of t.polylinePoints())if(i.point.equal(e))return i;throw new Error("polyline point "+e+" not found")}EdgeIsLegal(t,e,i,n){const r=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t,e);return this.ThreadLineSegmentThroughTriangles(t.CdtTriangle,i,n,r,[])}static closedeb(t,e){return t.Position.sub(new E(360.561,428.416)).length<.1&&e.Position.sub(new E(414.281,440.732)).length<.1}EdgeIsLegalSSPPS(t,e,i){const n=t.Position,r=t.CdtTriangle,s=e.Position;if(is.PointIsInsideOfTriangle(s,r))return!0;const o=new ws(r,n,s);for(;o.MoveNext();){const t=o.CurrentPiercedEdge;if(t.Constrained){const e=t.lowerSite.Owner;if(!i.has(e))return!1}}return!0}}class xs{constructor(t,e,i,n){this.metroGraphData=t,this.obstaclesToIgnoreLambda=n,this.bundlingSettings=e,this.obstacleTree=i}ObstaclesToIgnoreForBundle(t,e){return null!=t&&null!=e?ge(this.obstaclesToIgnoreLambda(t),this.obstaclesToIgnoreLambda(e)):null==t&&null==e?new Set:null!=t?this.obstaclesToIgnoreLambda(t):this.obstaclesToIgnoreLambda(e)}HubAvoidsObstaclesSPNBA(t,e,i,n){const r={minimalDistance:i};return xs.IntersectCircleWithTree(this.obstacleTree,e,i,this.obstaclesToIgnoreLambda(t),n.touchedObstacles,r)}HubAvoidsObstaclesPNS__(t,e,i){const n={touchedObstacles:Array()};return this.HubAvoidsObstaclesPNSTT(t,e,i,n,{minimalDistance:0})}GetMinimalDistanceToObstacles(t,e,i){const n=new Array,r={minimalDistance:i};return xs.IntersectCircleWithTree(this.obstacleTree,e,i,this.obstaclesToIgnoreLambda(t),n,r)?r.minimalDistance:0}HubAvoidsObstaclesPNSTT(t,e,i,n,r){return n.touchedObstacles=new Array,r.minimalDistance=e,xs.IntersectCircleWithTree(this.obstacleTree,t,e,i,n.touchedObstacles,r)}static IntersectCircleWithTree(t,e,i,n,r,s){if(!t.irect.contains_point_radius(e,i))return!0;if(null==t.UserData){let o=xs.IntersectCircleWithTree(t.Left,e,i,n,r,s);if(!o)return!1;if(o=xs.IntersectCircleWithTree(t.Right,e,i,n,r,s),!o)return!1}else{const o=t.UserData;if(n.has(o))return!0;if(F.PointRelativeToCurveLocation(e,o)!=a.Outside)return xs.containingPoly=o,!1;const l=o.value(o.closestParameter(e)),h=l.sub(e).length;h<=i&&r.push([o,l]),s.minimalDistance=Math.min(h,s.minimalDistance)}return!0}static Create4gon(t,e,i,n){let r=e.sub(t).normalize();return r=new E(r.y,-1*r.x),k.mkFromPoints([t.add(r.mul(i/2)),t.sub(r.mul(i/2)),e.sub(r.mul(n/2)),e.add(r.mul(n/2))])}}class As{constructor(t,e,i,n){this.Width=e,this.Polyline=t,this.sourceAndTargetLoosePolylines=i,this.Index=n}UpdateLengths(){let t=0;for(let e=this.Polyline.startPoint;null!=e.next;e=e.next)t+=e.next.point.sub(e.point).length;this.Length=t,this.IdealLength=this.Polyline.end.sub(this.Polyline.start).length}}class Ts{constructor(t,e,i){this.metroline=t,this.station=e,this.polyPoint=i}get Metroline(){return this.metroline}get PolyPoint(){return this.polyPoint}}class Is{constructor(t,e,i){this.Radius=0,this.BundleBases=new Map,this.MetroNodeInfos=new Array,this._cachedIdealRadius=0,this.SerialNumber=t,this.IsReal=e,this.Position=i}debStop(){return 28==this.SerialNumber&&this.Position.sub(new E(841.2662778763244,303.3817005853006)).length<.001}get Position(){return this._Position}set Position(t){this._Position=t}getELP(){return this.EnterableLoosePolylines}setELP(t){this.EnterableLoosePolylines=t}addEL(t){this.EnterableLoosePolylines.add(t)}static less(t,e){return t.SerialNumber<e.SerialNumber}static greater(t,e){return t.SerialNumber>e.SerialNumber}get cachedIdealRadius(){return this._cachedIdealRadius}set cachedIdealRadius(t){this._cachedIdealRadius=t}AddEnterableLoosePolyline(t){null==this.EnterableLoosePolylines&&(this.EnterableLoosePolylines=new Set),this.EnterableLoosePolylines.add(t)}AddEnterableTightPolyline(t){null==this.EnterableTightPolylines&&(this.EnterableTightPolylines=new Set),this.EnterableTightPolylines.add(t)}}class Os{constructor(){this.Width=0,this.Metrolines=new Array,this.cachedBundleCost=0}get Count(){return this.Metrolines.length}}class _s{constructor(t,e){this.metroGraphData=t,this.bundlingSettings=e}CreateNodeRadii(){for(const t of this.metroGraphData.VirtualStations())t.Radius=0,t.cachedIdealRadius=_s.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,t);this.GrowHubs(!1),this.GrowHubs(!0);for(const t of this.metroGraphData.VirtualStations())t.Radius=Math.max(t.Radius,this.bundlingSettings.MinHubRadius)}GrowHubs(t){const e=new Qi(b);for(const i of this.metroGraphData.VirtualStations())e.Enqueue(i,-this.CalculatePotential(i,t));let i=!1;for(;!e.IsEmpty();){const n={priority:0},r=e.DequeueAndGetPriority(n);if(n.priority>=0)break;this.TryGrowHub(r,t)&&(e.Enqueue(r,-this.CalculatePotential(r,t)),i=!0)}return i}TryGrowHub(t,e){const i=this.CalculateAllowedHubRadius(t);if(t.Radius>=i)return!1;const n=e?_s.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings,t):t.cachedIdealRadius;if(t.Radius>=n)return!1;let r=.05*(n-t.Radius);r<1&&(r=1);const s=Math.min(t.Radius+r,i);return!(s<=t.Radius)&&(t.Radius=s,!0)}CalculatePotential(t,e){const i=e?_s.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings,t):t.cachedIdealRadius;return i<=t.Radius?0:(i-t.Radius)/i}CalculateAllowedHubRadius(t){let e=this.bundlingSettings.MaxHubRadius;for(const i of t.Neighbors){const n=i.Position.sub(t.Position).length;e=Math.min(e,n/1.05-i.Radius)}const i=this.metroGraphData.tightIntersections.GetMinimalDistanceToObstacles(t,t.Position,e);return i<e&&(e=i-.001),Math.max(e,.1)}static CalculateIdealHubRadius(t,e,i){let n=1;for(const r of i.Neighbors){const s=t.GetWidthSSN(r,i,e.EdgeSeparation)/2+e.EdgeSeparation;n=Math.max(n,s)}return n=Math.min(n,2*e.MaxHubRadius),n}static CalculateIdealHubRadiusWithNeighborsMBS(t,e,i){return _s.CalculateIdealHubRadiusWithNeighborsMBNP(t,e,i,i.Position)}static CalculateIdealHubRadiusWithNeighborsMBNP(t,e,i,n){let r=_s.CalculateIdealHubRadius(t,e,i);if(i.Neighbors.length>1){const s=i.Neighbors;for(let o=0;o<s.length;o++){const a=s[o],l=s[(o+1)%s.length];r=Math.max(r,_s.GetMinRadiusForTwoAdjacentBundles(r,i,n,a,l,t,e))}}return r=Math.min(r,2*e.MaxHubRadius),r}static CalculateIdealHubRadiusWithAdjacentEdges(t,e){let i=t.MaxHubRadius;for(const t of e.Neighbors)i=Math.min(i,e.Position.sub(t.Position).length/2);return i}static GetMinRadiusForTwoAdjacentBundles(t,e,i,n,r,s,o){const a=s.GetWidthSSN(e,n,o.EdgeSeparation),l=s.GetWidthSSN(e,r,o.EdgeSeparation);return _s.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(t,i,n.Position,r.Position,a,l,o)}static GetMinRadiusForTwoAdjacentBundlesNPPPNNB(t,e,i,n,r,s,o){if(r<y.distanceEpsilon||s<y.distanceEpsilon)return t;let a=E.anglePCP(i,e,n);if(a=Math.min(a,2*Math.PI-a),a<y.distanceEpsilon)return 2*o.MaxHubRadius;if(a>=Math.PI/2)return 1.05*t;const l=Math.sin(a),h=Math.cos(a),u=r/(4*l),c=s/(4*l);let d=2*Math.sqrt(u*u+(c*c+u*(c*h)*2));return d=Math.min(d,2*o.MaxHubRadius),d=Math.max(d,t),d}}class Ls{constructor(t,e,i,n){this.metroGraphData=t,this.bundlingSettings=e,this.costCalculator=i,this.cdt=n}InitializeCostCache(){for(const t of this.metroGraphData.VirtualStations())t.cachedIdealRadius=_s.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,t),t.cachedRadiusCost=this.costCalculator.RadiusCost(t,t.Position),t.cachedBundleCost=0;for(const t of this.metroGraphData.VirtualEdges()){const e=t[0],i=t[1],n=this.metroGraphData.GetIjInfo(e,i);n.cachedBundleCost=this.costCalculator.BundleCost(e,i,e.Position),e.cachedBundleCost+=n.cachedBundleCost,i.cachedBundleCost+=n.cachedBundleCost}}UpdateCostCache(t){const e=this.cdt.GetCdtTree();t.CdtTriangle=e.FirstHitNodeWithPredicate(t.Position,Ls.testPointInside).UserData,t.cachedIdealRadius=_s.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,t),t.cachedRadiusCost=this.costCalculator.RadiusCost(t,t.Position),t.cachedBundleCost=0;for(const e of t.Neighbors){e.IsReal||(e.cachedIdealRadius=_s.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,e),e.cachedRadiusCost=this.costCalculator.RadiusCost(e,e.Position));const i=this.metroGraphData.GetIjInfo(t,e);e.cachedBundleCost-=i.cachedBundleCost,i.cachedBundleCost=this.costCalculator.BundleCost(t,e,t.Position),t.cachedBundleCost+=i.cachedBundleCost,e.cachedBundleCost+=i.cachedBundleCost}}static testPointInside(t,e){return is.PointIsInsideOfTriangle(t,e)?tt.Stop:tt.Continue}}class Rs{constructor(){this.mainMap=new Map}get isEmpty(){return 0==this.mainMap.size||this.everyMapIsEmpty()}everyMapIsEmpty(){for(const t of this.mainMap.values())if(t.size)return!1;return!0}get(t,e){const i=this.mainMap.get(t);if(i)return i.get(e)}has(t,e){const i=this.mainMap.get(t);return!!i&&i.has(e)}set(t,e,i){let n=this.mainMap.get(t);n||(n=new Map,this.mainMap.set(t,n)),n.set(e,i)}*[Symbol.iterator](){for(const[t,e]of this.mainMap)for(const[i,n]of e)yield[t,i,n]}*keys(){for(const[t,e]of this.mainMap)for(const[i]of e)yield[t,i]}}class Bs{constructor(t,e,i,n,r,s,o,a){this.cachedEnterableLooseForEnd=new Ie,this.regularEdges=t,this.Cdt=null!=r?r:Qs.CreateConstrainedDelaunayTriangulation(e),this.EdgeLooseEnterable=s,this.EdgeTightEnterable=o,this.LoosePolylineOfPort=a,this.looseIntersections=new xs(this,n,e,t=>t.getELP()),this.tightIntersections=new xs(this,n,i,t=>t.EnterableTightPolylines),this.cdtIntersections=new Es(this,n),this.Initialize(!1)}get Ink(){return this.ink}get Edges(){return this.regularEdges}VirtualStations(){return Array.from(this.Stations).filter(t=>!t.IsReal)}get Metrolines(){return this.metrolines}get LooseTree(){return this.looseIntersections.obstacleTree}get TightTree(){return this.tightIntersections.obstacleTree}*VirtualEdges(){for(const t of this.edgeInfoDictionary.keys())yield t}RealEdgeCount(t,e){const i=t.SerialNumber<e.SerialNumber?[t,e]:[e,t],n=this.edgeInfoDictionary.get(i[0],i[1]);return n?n.Count:0}MetroNodeInfosOfNode(t){return t.MetroNodeInfos}GetIjInfo(t,e){const i=t.SerialNumber<e.SerialNumber?[t,e]:[e,t];return this.edgeInfoDictionary.get(i[0],i[1])}MoveNode(t,e){const i=t.Position;this.PointToStations.deleteP(i),this.PointToStations.set(e,t),t.Position=e;for(const i of this.MetroNodeInfosOfNode(t))i.PolyPoint.point=e;for(const n of this.MetroNodeInfosOfNode(t)){const t=n.Metroline,r=n.PolyPoint.prev.point,s=n.PolyPoint.next.point;t.Length+=s.sub(e).length+r.sub(e).length-s.sub(i).length-r.sub(i).length}for(const n of t.Neighbors)this.ink+=e.sub(n.Position).length-i.sub(n.Position).length;this.SortNeighbors(t);for(const e of t.Neighbors)this.SortNeighbors(e)}GetWidthSSN(t,e,i){const n=t.SerialNumber<e.SerialNumber?[t,e]:[e,t],r=this.edgeInfoDictionary.get(n[0],n[1]);return r?r.Width+(r.Count-1)*i:0}GetWidthAN(t,e){let i=0;for(const e of t)i+=e.Width;const n=t.length;return i+=n>0?(n-1)*e:0,i}Initialize(t){this.SimplifyRegularEdges(),this.InitializeStationData(),this.InitializeEdgeData(),this.InitializeVirtualGraph(),this.InitializeEdgeNodeInfo(t),this.InitializeCdtInfo()}SimplifyRegularEdges(){for(const t of this.regularEdges)this.SimplifyRegularEdge(t)}SimplifyRegularEdge(t){const e=t.curve,i=new it.Stack,n=new ce;for(let t=e.endPoint;null!=t;t=t.prev){const e=t.point;if(n.has(t.point)){let r=t.next;for(;;){const t=i.top;if(t.equal(e))break;n.delete(t),i.pop(),r=r.next}r.prev=t.prev,r.prev.next=r}else i.push(e),n.add(e)}}InitializeStationData(){this.Stations=[],this.PointToStations=new Ie;for(const t of this.regularEdges){const e=t.curve;this.ProcessPolylinePoints(e)}}ProcessPolylinePoints(t){let e=t.startPoint;for(this.RegisterStation(e,!0),e=e.next;e!=t.endPoint;e=e.next)this.RegisterStation(e,!1);this.RegisterStation(e,!0)}RegisterStation(t,e){if(!this.PointToStations.has(t.point)){const i=new Is(this.Stations.length,e,t.point);this.PointToStations.set(t.point,i),this.Stations.push(i)}}InitializeEdgeData(){this.metrolines=new Array;for(let t=0;t<this.regularEdges.length;t++){const e=this.regularEdges[t];this.InitEdgeData(e,t)}}InitEdgeData(t,e){const i=new As(t.curve,t.lineWidth,this.EdgeSourceAndTargetFunc(t),e);this.metrolines.push(i),this.PointToStations.get(i.Polyline.start).BoundaryCurve=t.sourcePort.Curve,this.PointToStations.get(i.Polyline.end).BoundaryCurve=t.targetPort.Curve}EdgeSourceAndTargetFunc(t){return()=>[this.LoosePolylineOfPort(t.sourcePort),this.LoosePolylineOfPort(t.targetPort)]}InitializeVirtualGraph(){const t=new Map;for(const e of this.metrolines){let i,n=this.PointToStations.get(e.Polyline.start);for(let r=e.Polyline.startPoint;null!=r.next;r=r.next,n=i)i=this.PointToStations.get(r.next.point),Pe(t,n,i),Pe(t,i,n)}for(const e of this.Stations)e.Neighbors=Array.from(t.get(e))}GetUnorderedIjInfo(t,e){return t.SerialNumber<e.SerialNumber?this.GetCreateOrderedIjInfo(t,e):this.GetCreateOrderedIjInfo(e,t)}static closedeb(t,e){return t.Position.sub(new E(360.561,428.416)).length<.1&&e.Position.sub(new E(414.281,440.732)).length<.1}GetCreateOrderedIjInfo(t,e){let i=this.edgeInfoDictionary.get(t,e);return i||(i=new Os,this.edgeInfoDictionary.set(t,e,i),i)}InitializeEdgeNodeInfo(t){this.edgeInfoDictionary=new Rs,this.InitAllMetroNodeInfos(t),this.SortAllNeighbors(),this.InitEdgeIjInfos(),this.ink=0;for(const t of this.VirtualEdges())this.ink+=t[0].Position.sub(t[1].Position).length}InitAllMetroNodeInfos(t){for(let e=0;e<this.metrolines.length;e++){const i=this.metrolines[e];this.InitMetroNodeInfos(i),this.InitNodeEnterableLoosePolylines(i,this.regularEdges[e]),t&&this.InitNodeEnterableTightPolylines(i,this.regularEdges[e]),i.UpdateLengths()}}InitMetroNodeInfos(t){for(let e=t.Polyline.startPoint;null!=e;e=e.next){const i=this.PointToStations.get(e.point);i.MetroNodeInfos.push(new Ts(t,i,e))}}InitNodeEnterableLoosePolylines(t,e){const i=null!=this.EdgeLooseEnterable?this.EdgeLooseEnterable.get(e):new Set;for(let e=t.Polyline.startPoint.next;null!=e&&null!=e.next;e=e.next){const t=this.PointToStations.get(e.point);null!=t.getELP()?t.setELP(pe(t.getELP(),i)):t.setELP(new Set(i))}this.AddLooseEnterableForMetrolineStartEndPoints(t)}AddLooseEnterableForMetrolineStartEndPoints(t){this.AddLooseEnterableForEnd(t.Polyline.start),this.AddLooseEnterableForEnd(t.Polyline.end)}AddTightEnterableForMetrolineStartEndPoints(t){this.AddTightEnterableForEnd(t.Polyline.start),this.AddTightEnterableForEnd(t.Polyline.end)}AddLooseEnterableForEnd(t){const e=this.PointToStations.get(t);if(this.cachedEnterableLooseForEnd.has(t))e.setELP(this.cachedEnterableLooseForEnd.get(t));else{for(const i of this.LooseTree.AllHitItems_(t))F.PointRelativeToCurveLocation(t,i)==a.Inside&&e.AddEnterableLoosePolyline(i);this.cachedEnterableLooseForEnd.set(t,e.getELP())}}AddTightEnterableForEnd(t){const e=this.PointToStations.get(t);for(const i of this.TightTree.AllHitItems_(t))F.PointRelativeToCurveLocation(t,i)==a.Inside&&e.AddEnterableTightPolyline(i)}InitNodeEnterableTightPolylines(t,e){const i=null!=this.EdgeTightEnterable?this.EdgeTightEnterable.get(e):new Set;for(let e=t.Polyline.startPoint.next;null!=e&&null!=e.next;e=e.next){const t=this.PointToStations.get(e.point),n=t.EnterableTightPolylines;t.EnterableTightPolylines=null!=n?pe(n,i):new Set(i)}this.AddTightEnterableForMetrolineStartEndPoints(t)}SortAllNeighbors(){for(const t of this.Stations)this.SortNeighbors(t)}SortNeighbors(t){if(t.Neighbors.length<=2)return;const e=t.Neighbors[0].Position,i=t.Position;t.Neighbors.sort((t,n)=>Ms(e.sub(i),t.Position.sub(i),n.Position.sub(i)))}InitEdgeIjInfos(){for(const t of this.metrolines){const e=t.Polyline;let i,n=this.PointToStations.get(e.start);for(let e=t.Polyline.startPoint;null!=e.next;e=e.next,n=i){i=this.PointToStations.get(e.next.point);const r=this.GetUnorderedIjInfo(n,i);r.Width+=t.Width,r.Metrolines.push(t)}}}InitializeCdtInfo(){const t=this.Cdt.GetCdtTree();for(const e of this.Stations)e.CdtTriangle=t.FirstHitNodeWithPredicate(e.Position,Ls.testPointInside).UserData}PointIsAcceptableForEdge(t,e){if(null==this.LoosePolylineOfPort)return!0;const i=t.sourceAndTargetLoosePolylines();return F.PointRelativeToCurveLocation(e,i[0])==a.Outside&&F.PointRelativeToCurveLocation(e,i[1])==a.Outside}}function Ms(t,e,i){t=t.mul(1e3),e=e.mul(1e3),i=i.mul(1e3);const n=E.crossProduct(t,i),r=t.dot(i),s=E.crossProduct(t,e),o=t.dot(e);return v(s,0)&&Fs(o,0)?v(n,0)&&Fs(r,0)?0:1:v(n,0)&&Fs(r,0)?-1:v(s,0)||v(n,0)||s*n>0?C(E.crossProduct(i,e),0):-C(Math.sign(s),0)}function Fs(t,e){return C(t,e)>=0}class Ds{constructor(t,e){this.metroGraphData=t,this.bundlingSettings=e}static InkError(t,e,i){return(t-e)*i.InkImportance}static PathLengthsError(t,e,i,n){return(t-e)*(n.PathLengthImportance/i)}static RError(t,e,i){if(t<=e)return 0;return i.HubRepulsionImportance*((1-e/t)*(t-e))}static BundleError(t,e,i){if(t<=e)return 0;return i.BundleRepulsionImportance*((1-e/t)*(t-e))}static Cost(t,e){let i=e.InkImportance*t.Ink;for(const n of t.Metrolines)i+=e.PathLengthImportance*n.Length/n.IdealLength;return i+=this.CostOfForces(t),i}static CostOfForces(t){let e=0;for(const i of t.VirtualStations())e+=i.cachedRadiusCost;for(const i of t.VirtualEdges()){const n=i[0],r=i[1];e+=t.GetIjInfo(n,r).cachedBundleCost}return e}InkGain(t,e){const i=this.metroGraphData.Ink;let n=this.metroGraphData.Ink;for(const i of t.Neighbors){const r=i.Position;n-=r.sub(t.Position).length,n+=r.sub(e).length}return Ds.InkError(i,n,this.bundlingSettings)}PathLengthsGain(t,e){let i=0;for(const n of this.metroGraphData.MetroNodeInfosOfNode(t)){const r=n.Metroline.Length,s=n.PolyPoint.prev.point,o=n.PolyPoint.next.point,a=n.Metroline.Length+o.sub(e).length+s.sub(e).length-o.sub(t.Position).length-s.sub(t.Position).length;i+=Ds.PathLengthsError(r,a,n.Metroline.IdealLength,this.bundlingSettings)}return i}RadiusGain(t,e){let i=0;return i+=t.cachedRadiusCost,i-=this.RadiusCost(t,e),i}RadiusCost(t,e){let i;i=E.closeDistEps(t.Position,e)?t.cachedIdealRadius:_s.CalculateIdealHubRadiusWithNeighborsMBNP(this.metroGraphData,this.bundlingSettings,t,e);const n={touchedObstacles:[]};if(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(t,e,i,n))return Ds.Inf;let r=0;for(const t of n.touchedObstacles){const n=t[1].sub(e).length;r+=Ds.RError(i,n,this.bundlingSettings)}return r}BundleGain(t,e){let i=t.cachedBundleCost;for(const n of t.Neighbors){const r=this.BundleCost(t,n,e);if(Fs(r,Ds.Inf))return-Ds.Inf;i-=r}return i}BundleCost(t,e,i){const n=this.metroGraphData.GetWidthSSN(t,e,this.bundlingSettings.EdgeSeparation),r={closestDist:[]};if(!this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t,e,i,e.Position,n,r))return Ds.Inf;let s=0;for(const t of r.closestDist){const e=t[0].sub(t[1]).length;s+=Ds.BundleError(n/2,e,this.bundlingSettings)}return s}}Ds.Inf=1e9;class Ns{constructor(t){this.polylineToEdgeGeom=new Map,this.pathsThroughPoints=new Ie,this.interestingPoints=new ce,this.metroGraphData=t}get Polylines(){return Array.from(this.polylineToEdgeGeom.keys())}Run(){this.Init(),this.SwitchFlips()}Init(){for(const t of this.metroGraphData.Edges)this.polylineToEdgeGeom.set(t.curve,t);for(const t of this.Polylines)this.RegisterPolylinePointInPathsThrough(t.polylinePoints())}RegisterPolylinePointInPathsThrough(t){for(const e of t)this.RegisterPolylinePointInPathsThroughP(e)}RegisterPolylinePointInPathsThroughP(t){!function(t,e,i){let n=t.get(e);n||(n=new Set,t.set(e,n));n.add(i)}(this.pathsThroughPoints,t.point,t)}UnregisterPolylinePointsInPathsThrough(t){for(const e of t)this.UnregisterPolylinePointInPathsThrough(e)}UnregisterPolylinePointInPathsThrough(t){!function(t,e,i){const n=t.get(e);if(!n)return;n.delete(i),0==n.size&&t.deleteP(e)}(this.pathsThroughPoints,t.point,t)}SwitchFlips(){const t=new Set(this.Polylines),e=new h.Queue;for(const t of this.Polylines)e.enqueue(t);for(;e.length>0;){const i=e.dequeue();t.delete(i);const n=this.ProcessPolyline(i);null!=n&&(t.has(i)||(t.add(i),e.enqueue(i)),t.has(n)||(t.add(n),e.enqueue(n)))}}ProcessPolyline(t){const e=new Map;for(let i=t.startPoint.next;null!=i;i=i.next){this.FillDepartedPolylinePoints(i,e);for(const t of this.pathsThroughPoints.get(i.point)){const n=e.get(t.polyline);if(n){if(this.ProcessFlip(i,n))return t.polyline;e.delete(t.polyline)}}}return null}FillDepartedPolylinePoints(t,e){const i=t.prev.point;for(const n of this.pathsThroughPoints.get(i))this.IsNeighborOnTheSamePolyline(n,t)||e.has(n.polyline)||e.set(n.polyline,n)}ProcessFlip(t,e){const i=t.polyline,n=e.polyline,r=t.point,s=e.point,o=this.polylineToEdgeGeom.get(i),a=this.polylineToEdgeGeom.get(n);if(o.lineWidth!=a.lineWidth||null==this.metroGraphData.EdgeLooseEnterable||!ye(this.metroGraphData.EdgeLooseEnterable.get(o),this.metroGraphData.EdgeLooseEnterable.get(a)))return!1;let l=this.FindPointsOnPolyline(i,r,s);const h=l[0],u=l[1],c=l[2];l=this.FindPointsOnPolyline(n,r,s);const d=l[0],g=l[1],f=l[2],p=this.FindRelationOnFirstPoint(h,d,c,f),m=this.FindRelationOnLastPoint(u,g,c,f);return(2==p||2==m)&&(1!=p&&1!=m&&(this.UnregisterPolylinePointsInPathsThrough(i.polylinePoints()),this.UnregisterPolylinePointsInPathsThrough(n.polylinePoints()),this.Swap(h,d,u,g,c,f),this.RegisterPolylinePointInPathsThrough(i.polylinePoints()),this.RegisterPolylinePointInPathsThrough(n.polylinePoints()),this.RegisterInterestingPoint(h.point),this.RegisterInterestingPoint(u.point),this.numberOfReducedCrossings++,!0))}FindPointsOnPolyline(t,e,i){let n,r;for(let s=t.startPoint;null!=s;s=s.next)if(null==n)if(s.point.equal(e)){if(null!=r)return[s,r,!1];n=s}else null==r&&s.point.equal(i)&&(r=s);else if(s.point.equal(i))return[n,s,!0]}PolylinePointsAreInForwardOrder(t,e){for(let i=t;null!=i;i=i.next)if(i==e)return!0;return!1}Next(t,e){return e?t.next:t.prev}Prev(t,e){return e?t.prev:t.next}FindRelationOnFirstPoint(t,e,i,n){const r=t,s=e;for(;;){const r=this.Prev(t,i),s=this.Prev(e,n);if(null==r||null==s)return 0;if(!r.point.equal(s.point))break;t=r,e=s}return this.PolylinesIntersect(r,s,t,e,i,n)}FindRelationOnLastPoint(t,e,i,n){const r=t,s=e;for(;;){const r=this.Next(t,i),s=this.Next(e,n);if(null==r||null==s)return 0;if(!r.point.equal(s.point))break;t=r,e=s}for(;this.Next(t,i).point.equal(this.Prev(e,n).point);)t=this.Next(t,i),e=this.Prev(e,n);return this.PolylinesIntersect(t,e,r,s,i,n)}PolylinesIntersect(t,e,i,n,r,s){const o=this.Prev(t,r),a=this.Next(t,r),l=this.Next(i,r),h=this.Prev(i,r),u=this.Next(e,s),c=this.Prev(n,s);if(t.point.equal(i.point)){const e=t.point;return Ms(h.point.sub(e),c.point.sub(e),a.point.sub(e))==Ms(h.point.sub(e),u.point.sub(e),a.point.sub(e))?1:2}return Ms(o.point.sub(t.point),a.point.sub(t.point),u.point.sub(t.point))==Ms(l.point.sub(i.point),c.point.sub(i.point),h.point.sub(i.point))?1:2}Swap(t,e,i,n,r,s){const o=this.GetRangeOnPolyline(this.Next(t,r),i,r),a=this.GetRangeOnPolyline(this.Next(e,s),n,s);this.ChangePolylineSegment(t,i,r,a),this.ChangePolylineSegment(e,n,s,o),ks.RemoveSelfCyclesFromPolyline(t.polyline),ks.RemoveSelfCyclesFromPolyline(e.polyline)}ChangePolylineSegment(t,e,i,n){let r=t;for(const t of n){const e=x.mkFromPoint(t.point);e.polyline=r.polyline,i?(e.prev=r,r.next=e):(e.next=r,r.prev=e),r=e}i?(r.next=e,e.prev=r):(r.prev=e,e.next=r)}GetRangeOnPolyline(t,e,i){const n=new Array;for(let r=t;r!=e;r=this.Next(r,i))n.push(r);return n}IsNeighborOnTheSamePolyline(t,e){return null!=t.prev&&t.prev.point.equal(e.point)||null!=t.next&&t.next.point.equal(e.point)}RegisterInterestingPoint(t){this.interestingPoints.has(t)||this.interestingPoints.add(t)}GetChangedHubs(){return this.interestingPoints}NumberOfReducedCrossings(){return this.numberOfReducedCrossings}PolylineIsOK(t){const e=new ce;for(let i=t.startPoint;null!=i;i=i.next){if(i==t.startPoint){if(null!=i.prev)return!1}else if(i.prev.next!=i)return!1;if(i==t.endPoint){if(null!=i.next)return!1}else if(i.next.prev!=i)return!1;if(e.has(i.point))return!1;e.add(i.point)}return null==t.startPoint.prev&&null==t.endPoint.next}}class ks{constructor(t,e){this.foundCrossings=new ce,this.crossingsThatShouldBecomeHubs=new ce,this.metroGraphData=t,this.polylineAcceptsPoint=e}*Vertices(){for(const t of this.Polylines)for(const e of t.polylinePoints())yield e}get Polylines(){return this.metroGraphData.Edges.map(t=>t.curve)}Edges(){const t=new un;for(const e of this.Vertices())e.next&&t.set(new ue(e.point,e.next.point),0);return Array.from(t.keys())}run(){if(0==this.metroGraphData.Edges.length)return!1;const t=new un,e=new pt(null);for(const t of this.Vertices()){const i=G.mkOnPoints([t.point]);i.pad(y.intersectionEpsilon),e.Add(i,t.point)}const i=lt(this.Edges(),t=>G.mkPP(t.First,t.Second));Vi(i,i,(i,n)=>this.IntersectTwoEdges.bind(i,n,t,e)),this.SortInsertedPoints(t);const n=this.InsertPointsIntoPolylines(t),r=this.FixPaths(),s=this.RemoveUnimportantCrossings();return r||n||s}FixPaths(){let t=!1;return this.RemoveSelfCycles()&&(t=!0),this.ReduceEdgeCrossings()&&(t=!0),t}SortInsertedPoints(t){for(const e of t)this.SortInsideSegment(e[0],e[1])}SortInsideSegment(t,e){e.sort((e,i)=>b(w(e,t.First),w(i,t.First)))}InsertPointsIntoPolylines(t){let e=!1;for(const i of this.metroGraphData.Metrolines)return this.InsertPointsIntoPolyline(i,t)&&(e=!0),e}InsertPointsIntoPolyline(t,e){let i=!1;for(let n=t.Polyline.startPoint;null!=n.next;n=n.next)this.InsertPointsOnPolypoint(n,e,t)&&(i=!0);return i}InsertPointsOnPolypoint(t,e,i){const n=new ue(t.point,t.next.point),r=t.point!=n.First,s=e.get(n);if(!s)return!1;const o=t.next,a=t.polyline;if(r)for(let e=s.length-1;e>=0;e--){if(null!=this.polylineAcceptsPoint&&!this.polylineAcceptsPoint(i,s[e]))continue;const n=x.mkFromPoint(s[e]);n.prev=t,n.polyline=a,t.next=n,t=n}else for(let e=0;e<s.length;e++){if(null!=this.polylineAcceptsPoint&&!this.polylineAcceptsPoint(i,s[e]))continue;const n=x.mkFromPoint(s[e]);n.prev=t,n.polyline=a,t.next=n,t=n}return t.next=o,o.prev=t,!0}RemoveSelfCycles(){let t=!1;for(const e of this.Polylines)ks.RemoveSelfCyclesFromPolyline(e)&&(t=!0);return t}static RemoveSelfCyclesFromPolyline(t){let e=!1;const i=new Ie;for(let n=t.startPoint;null!=n;n=n.next){const t=n.point,r=i.get(t);if(r){for(let t=r.next;t!=n.next;t=t.next)i.deleteP(t.point);r.next=n.next,n.next.prev=r,e=!0}else i.set(n.point,n)}return e}ReduceEdgeCrossings(){const t=new Ns(this.metroGraphData);t.Run();for(const e of t.GetChangedHubs())this.crossingsThatShouldBecomeHubs.add(e);return t.NumberOfReducedCrossings()>0}RemoveUnimportantCrossings(){let t=!1;this.pointsToDelete=function(t,e){const i=new ce;for(const n of t)e.has(n)||i.add(n);return i}(this.foundCrossings,this.crossingsThatShouldBecomeHubs);for(const e of this.Polylines)this.RemoveUnimportantCrossingsFromPolyline(e)&&(t=!0);return t}RemoveUnimportantCrossingsFromPolyline(t){let e=!1;for(let i=t.startPoint.next;null!=i&&null!=i.next;i=i.next)if(this.pointsToDelete.has(i.point)&&E.getTriangleOrientation(i.prev.point,i.point,i.next.point)==s.Collinear){const t=i.prev,n=i.next;t.next=n,n.prev=t,i=t,e=!0}return e}IntersectTwoEdges(t,e,i,n){const r=I.IntersectPPPP(t.First,t.Second,e.First,e.Second);if(r){const s=this.FindExistingVertexOrCreateNew(n,r);(this.AddVertexToSplittingList(t,i,s)||this.AddVertexToSplittingList(e,i,s))&&this.foundCrossings.add(s)}}FindExistingVertexOrCreateNew(t,e){const i=t.RootNode.FirstHitNode(e);if(null!=i)return i.UserData;const n=G.mkOnPoints([e]).pad(y.intersectionEpsilon);return t.Add(n,e),e}AddVertexToSplittingList(t,e,i){if(!F.closeIntersectionPoints(i,t.First)&&!F.closeIntersectionPoints(i,t.Second)){let n=e.get(t);if(n||(n=new Array,e.set(t,n)),!n.find(t=>t.equal(i)))return n.push(i),!0}return!1}}class Vs{constructor(t,e,i,n){this.BelongsToRealNode=n,this.Curve=e,this.Position=i,this.points=new Array(t),this.tangents=new Array(t),this.OrientedHubSegments=new Array(t),this.ParameterSpan=this.Curve.parEnd-this.Curve.parStart}get Count(){return this.points.length}get CurveCenter(){return this.Curve.boundingBox.center}get OppositeBase(){return null!=this.OutgoingBundleInfo?this.OutgoingBundleInfo.TargetBase:this.IncomingBundleInfo.SourceBase}get length(){return this.points.length}get Points(){return this.points}get Tangents(){return this.tangents}get InitialMidParameter(){return this.initialMidParameter}set InitialMidParameter(t){this.initialMidParameter=t,this.InitialMidPoint=this.Curve.value(t)}get ParRight(){return this.parRight}set ParRight(t){this.parRight=t,this.RightPoint=this.Curve.value(this.parRight)}get ParLeft(){return this.parLeft}set ParLeft(t){this.parLeft=t,this.LeftPoint=this.Curve.value(this.parLeft)}get ParMid(){return(this.parRight+this.parLeft)/2}get MidPoint(){return E.middle(this.RightPoint,this.LeftPoint)}get Span(){return this.SpanBetweenTwoPoints(this.parRight,this.parLeft)}SpanBetweenTwoPoints(t,e){return t<=e?e-t:e-t+this.ParameterSpan}RotateLeftPoint(t,e){return 0==t?this.LeftPoint:this.RotatePoint(t,this.parLeft,e)}RotateRigthPoint(t,e){return 0==t?this.RightPoint:this.RotatePoint(t,this.parRight,e)}RotatePoint(t,e,i){return e+=t*(this.ParameterSpan*i),e=this.AdjustParam(e),this.Curve.value(e)}AdjustParam(t){return t>this.Curve.parEnd?t=this.Curve.parStart+(t-this.Curve.parEnd):t<this.Curve.parStart&&(t=this.Curve.parEnd-(this.Curve.parStart-t)),t}RotateBy(t,e,i){const n=this.ParameterSpan*i;0!=t&&(this.ParRight=this.AdjustParam(this.ParRight+t*n)),0!=e&&(this.ParLeft=this.AdjustParam(this.ParLeft+e*n))}Intersect(t){return this.IntersectNNNB(this.parRight,this.parLeft,t.parRight,t.parLeft)}IntersectNNNB(t,e,i,n){return t>e?this.IntersectNNNB(t,this.Curve.parEnd,i,n)||this.IntersectNNNB(this.Curve.parStart,e,i,n):i>n?this.IntersectNNNB(t,e,i,this.Curve.parEnd)||this.IntersectNNNB(t,e,this.Curve.parStart,n):!C(e,i)&&!C(n,t)}RelativeOrderOfBasesIsPreserved(t,e,i){const n=this.ParameterSpan*i,r=this.parRight+t*n,s=this.parRight<this.parLeft?this.parLeft+e*n:this.parLeft+this.ParameterSpan+e*n;if(r>s)return!1;if(this.SpanBetweenTwoPoints(r,s)>this.ParameterSpan/2)return!1;if(null==this.Prev)return!0;if(this.SpanBetweenTwoPoints(this.Prev.ParMid,this.ParMid)>n&&this.SpanBetweenTwoPoints(this.ParMid,this.Next.ParMid)>n)return!0;const o=this.RotateLeftPoint(e,i),a=this.RotateRigthPoint(t,i),l=E.middle(o,a),h=this.MidPoint;return E.getTriangleOrientation(this.CurveCenter,this.Prev.MidPoint,h)==E.getTriangleOrientation(this.CurveCenter,this.Prev.MidPoint,l)&&E.getTriangleOrientation(this.CurveCenter,this.Next.MidPoint,h)==E.getTriangleOrientation(this.CurveCenter,this.Next.MidPoint,l)}}class Gs{constructor(t,e,i,n,r){this.SourceBase=t,this.TargetBase=e,this.obstaclesToIgnore=i,this.EdgeSeparation=n,this.HalfWidthArray=r,this.TotalRequiredWidth=this.EdgeSeparation*(this.HalfWidthArray.length-1)+2*this.HalfWidthArray.reduce((t,e)=>t+e,0),this.longEnoughSideLength=t.Curve.boundingBox.addRec(e.Curve.boundingBox).diagonal;const s=Math.max(t.Curve.boundingBox.diagonal,e.Curve.boundingBox.diagonal);if(this.TotalRequiredWidth>s){const t=this.TotalRequiredWidth/s;for(let e=0;e<this.HalfWidthArray.length;e++)this.HalfWidthArray[e]/=t;this.TotalRequiredWidth/=t,this.EdgeSeparation/=t}}SetParamsFeasiblySymmetrically(t){this.CalculateTightObstaclesForBundle(t,this.obstaclesToIgnore),this.SetEndParamsSymmetrically()}CalculateTightObstaclesForBundle(t,e){const i=this.SourceBase.Curve.boundingBox.diagonal/2,n=this.TargetBase.Curve.boundingBox.diagonal/2,r=xs.Create4gon(this.SourceBase.Position,this.TargetBase.Position,2*i,2*n);this.tightObstaclesInTheBoundingBox=Array.from(t.AllHitItems(r.boundingBox,t=>!e.has(t)&&F.ClosedCurveInteriorsIntersect(r,t)))}SetEndParamsSymmetrically(){const t=this.TargetBase.Position,e=this.SourceBase.Position,i=t.sub(e).normalize(),n=i.rotate90Ccw(),r=E.middle(t,e),s=i.mul(this.longEnoughSideLength),o=r.add(s),a=r.sub(s);if(this.SetRLParamsIfWidthIsFeasible(n.mul(this.TotalRequiredWidth/2),o,a))return void this.SetInitialMidParams();let l=this.TotalRequiredWidth,h=0,u=l/2;for(;l-h>Gs.FeasibleWidthEpsilon;)this.SetRLParamsIfWidthIsFeasible(n.mul(u/2),o,a)?h=u:l=u,u=.5*(l+h);u<=Gs.FeasibleWidthEpsilon&&(this.SetRLParamsIfWidthIsFeasible_(n.mul(Gs.FeasibleWidthEpsilon),new E(0,0),o,a)||this.SetRLParamsIfWidthIsFeasible_(new E(0,0),n.mul(-Gs.FeasibleWidthEpsilon),o,a))&&(u=2*Gs.FeasibleWidthEpsilon),this.SourceBase.InitialMidParameter=this.SourceBase.AdjustParam(this.SourceBase.ParRight+this.SourceBase.Span/2),this.TargetBase.InitialMidParameter=this.TargetBase.AdjustParam(this.TargetBase.ParRight+this.TargetBase.Span/2)}mkNameFromLRST(){return"/tmp/leftRight"+this.SourceBase.Position.toString()+"_"+this.TargetBase.Position.toString()+".svg"}SetRLParamsIfWidthIsFeasible(t,e,i){return this.SetRLParamsIfWidthIsFeasible_(t,t.neg(),e,i)}SetRLParamsIfWidthIsFeasible_(t,e,i,n){const r={par:0},s={par:0},o={par:0},a={par:0};let l=this.TrimSegWithBoundaryCurves(I.mkPP(i.add(t),n.add(t)),s,o);if(null==l)return!1;return!this.tightObstaclesInTheBoundingBox.find(t=>null!=F.intersectionOne(l,t,!1))&&(l=this.TrimSegWithBoundaryCurves(I.mkPP(i.add(e),n.add(e)),a,r),null!=l&&(!this.tightObstaclesInTheBoundingBox.find(t=>null!=F.intersectionOne(l,t,!1))&&(this.SourceBase.IsParent?(this.SourceBase.ParRight=s.par,this.SourceBase.ParLeft=a.par):(this.SourceBase.ParRight=a.par,this.SourceBase.ParLeft=s.par),this.TargetBase.IsParent?(this.TargetBase.ParRight=r.par,this.TargetBase.ParLeft=o.par):(this.TargetBase.ParRight=o.par,this.TargetBase.ParLeft=r.par),!0)))}SetInitialMidParams(){const t={par:0},e={par:0};null!=this.TrimSegWithBoundaryCurves(I.mkPP(this.TargetBase.CurveCenter,this.TargetBase.CurveCenter),e,t)?(this.SourceBase.InitialMidParameter=e.par,this.TargetBase.InitialMidParameter=t.par):(this.SourceBase.InitialMidParameter=this.SourceBase.AdjustParam(this.SourceBase.ParRight+this.SourceBase.Span/2),this.TargetBase.InitialMidParameter=this.TargetBase.AdjustParam(this.TargetBase.ParRight+this.TargetBase.Span/2))}mkNameFromST(){return"/tmp/mparam"+this.SourceBase.Position.toString()+"_"+this.TargetBase.Position.toString()+".svg"}TrimSegWithBoundaryCurves(t,e,i){let n,r,s=F.getAllIntersections(t,this.SourceBase.Curve,!0);return 0==s.length?(i.par=0,e.par=0,null):(n=1==s.length?s[0]:this.SourceBase.IsParent?s[0].par0<s[1].par0?s[1]:s[0]:s[0].par0<s[1].par0?s[0]:s[1],s=F.getAllIntersections(t,this.TargetBase.Curve,!0),0==s.length?(i.par=0,e.par=0,null):(r=1==s.length?s[0]:this.TargetBase.IsParent?s[0].par0>s[1].par0?s[1]:s[0]:s[0].par0>s[1].par0?s[0]:s[1],e.par=n.par1,i.par=r.par1,I.mkPP(n.x,r.x)))}RotateBy(t,e,i,n,r){const s=0!=t||0!=e,o=0!=i||0!=n;s&&this.SourceBase.RotateBy(t,e,r),o&&this.TargetBase.RotateBy(i,n,r),this.UpdateSourceAndTargetBases(s,o)}UpdateSourceAndTargetBases(t,e){t&&this.UpdatePointsOnBundleBase(this.SourceBase),e&&this.UpdatePointsOnBundleBase(this.TargetBase),this.UpdateTangentsOnBases()}UpdateTangentsOnBases(){const t=this.TargetBase.length;for(let e=0;e<t;e++){let i=this.TargetBase.Points[e].sub(this.SourceBase.Points[t-1-e]);const n=i.length;n>=y.tolerance&&(i=i.div(n),this.TargetBase.Tangents[e]=i,this.SourceBase.Tangents[t-1-e]=i.neg())}}UpdatePointsOnBundleBase(t){const e=t.length,i=t.Points,n=I.mkPP(t.LeftPoint,t.RightPoint),r=1/this.TotalRequiredWidth;let s=this.HalfWidthArray[0];i[0]=n.value(s*r);for(let t=1;t<e;t++)s+=this.HalfWidthArray[t-1]+this.EdgeSeparation+this.HalfWidthArray[t],i[t]=n.value(s*r)}RotationIsLegal(t,e,i,n,r){if(this.SourceBase.IsParent||this.TargetBase.IsParent){if(0!=e||0!=n){const t=this.SourceBase.RotateLeftPoint(e,r),i=this.TargetBase.RotateLeftPoint(n,r);if(!this.LineIsLegal(t,i))return!1}if(0!=t||0!=i){const e=this.SourceBase.RotateRigthPoint(t,r),n=this.TargetBase.RotateRigthPoint(i,r);if(!this.LineIsLegal(e,n))return!1}}else{if(0!=e||0!=i){const t=this.SourceBase.RotateLeftPoint(e,r),n=this.TargetBase.RotateRigthPoint(i,r);if(!this.LineIsLegal(t,n))return!1}if(0!=t||0!=n){const e=this.SourceBase.RotateRigthPoint(t,r),i=this.TargetBase.RotateLeftPoint(n,r);if(!this.LineIsLegal(e,i))return!1}}return!!(0==t&&0==e||this.SourceBase.RelativeOrderOfBasesIsPreserved(t,e,r))&&!!(0==i&&0==n||this.TargetBase.RelativeOrderOfBasesIsPreserved(i,n,r))}LineIsLegal(t,e){return null==this.tightObstaclesInTheBoundingBox.find(i=>null!=F.intersectionOne(I.mkPP(t,e),i,!1))}}Gs.FeasibleWidthEpsilon=.1;class zs{constructor(t,e,i,n){this.Segment=t,this.Reversed=e,this.Index=i,this.BundleBase=n}get Segment(){return this.segment}set Segment(t){this.segment=t}value(t){return this.Reversed?this.Segment.value(this.Segment.parEnd-t):this.Segment.value(t)}}class js{constructor(t,e,i){this.fixedBundles=new Cs.HashSet,this.stepsWithProgress=0,this.metroOrdering=t,this.metroGraphData=e,this.bundlingSettings=i}Run(){this.AllocateBundleBases(),this.SetBasesRightLeftParamsToTheMiddles(),this.bundlingSettings.KeepOverlaps?(this.UpdateSourceAndTargetBases(),this.CreateOrientedSegs()):(this.SetRightLeftParamsFeasiblySymmetrically(),this.AdjustStartEndParamsToAvoidBaseOverlaps(),this.UpdateSourceAndTargetBases(),this.CreateOrientedSegs(),this.bundlingSettings.RotateBundles&&this.RotateBundlesToDiminishCost(),this.AdjustStartEndParamsToAvoidBaseOverlaps(),this.UpdateSourceAndTargetBases())}AllocateBundleBases(){this.externalBases=new Map,this.internalBases=new Map,this.Bundles=new Array;for(const t of this.metroGraphData.Stations)null==t.BoundaryCurve&&(t.BoundaryCurve=R.mkCircle(t.Radius,t.Position));for(const t of this.metroGraphData.Stations)for(const e of t.Neighbors)if(t.SerialNumber<e.SerialNumber){const i=new Vs(this.metroGraphData.RealEdgeCount(t,e),t.BoundaryCurve,t.Position,t.IsReal);t.BundleBases.set(e,i);const n=new Vs(this.metroGraphData.RealEdgeCount(t,e),e.BoundaryCurve,e.Position,e.IsReal);e.BundleBases.set(t,n),F.PointRelativeToCurveLocation(e.Position,t.BoundaryCurve)!=a.Outside?(i.IsParent=!0,ve(this.internalBases,t.BoundaryCurve,i),ve(this.externalBases,e.BoundaryCurve,n)):F.PointRelativeToCurveLocation(t.Position,e.BoundaryCurve)!=a.Outside?(n.IsParent=!0,ve(this.externalBases,t.BoundaryCurve,i),ve(this.internalBases,e.BoundaryCurve,n)):(ve(this.externalBases,t.BoundaryCurve,i),ve(this.externalBases,e.BoundaryCurve,n));const r=this.metroGraphData.tightIntersections.ObstaclesToIgnoreForBundle(t,e),s=new Gs(i,n,r,this.bundlingSettings.EdgeSeparation,Array.from(this.metroOrdering.GetOrder(t,e)).map(t=>t.Width/2));i.OutgoingBundleInfo=n.IncomingBundleInfo=s,this.Bundles.push(s)}this.SetBundleBaseNeighbors()}SetBundleBaseNeighbors(){for(const t of this.externalBases.keys()){const e=this.externalBases.get(t);this.SortBundlesCounterClockwise(e),this.SetLeftRightBases(e)}for(const t of this.internalBases.keys()){const e=this.internalBases.get(t);this.SortBundlesCounterClockwise(e),this.SetLeftRightBases(e)}}SortBundlesCounterClockwise(t){if(t.length>2){const e=t[0].OppositeBase.Position,i=t[0].CurveCenter;t.sort((t,n)=>Ms(e.sub(i),t.OppositeBase.Position.sub(i),n.OppositeBase.Position.sub(i)))}}SetLeftRightBases(t){const e=t.length;if(!(e<=1))for(let i=0;i<e;i++)t[i].Prev=t[(i-1+e)%e],t[i].Next=t[(i+1)%e]}CreateOrientedSegs(){for(const t of this.metroGraphData.Metrolines)this.CreateOrientedSegsOnLine(t)}CreateOrientedSegsOnLine(t){for(let e=t.Polyline.startPoint.next;null!=e.next;e=e.next)this.CreateOrientedSegsOnLineVertex(t,e)}CreateOrientedSegsOnLineVertex(t,e){const i=this.metroGraphData.PointToStations.get(e.prev.point),n=this.metroGraphData.PointToStations.get(e.point),r=this.metroGraphData.PointToStations.get(e.next.point),s=n.BundleBases.get(i),o=n.BundleBases.get(r),a=this.metroOrdering.GetLineIndexInOrder(i,n,t),l=this.metroOrdering.GetLineIndexInOrder(r,n,t),h=s.OrientedHubSegments[a]=new zs(null,!1,a,s),u=o.OrientedHubSegments[l]=new zs(null,!0,l,o);u.Other=h,h.Other=u}UpdateSourceAndTargetBases(){for(const t of this.Bundles)t.UpdateSourceAndTargetBases(!0,!0)}SetBasesRightLeftParamsToTheMiddles(){for(const t of this.Bundles){const e=t.SourceBase,i=t.TargetBase;e.ParLeft=e.ParRight=this.GetBaseMiddleParamInDirection(e,e.Position,i.Position),i.ParLeft=i.ParRight=this.GetBaseMiddleParamInDirection(i,i.Position,e.Position)}}GetBaseMiddleParamInDirection(t,e,i){const n=t.Curve;if(n instanceof R){const t=n;if(t.isArc())return E.angle(t.aAxis,i.sub(e))}const r=F.getAllIntersections(n,I.mkPP(e,i),!0);for(const t of r){const n=t.x;if(n.sub(e).dot(n.sub(i))<=0)return t.par0}throw new Error}SetRightLeftParamsFeasiblySymmetrically(){for(const t of this.Bundles)t.SetParamsFeasiblySymmetrically(this.metroGraphData.TightTree)}AdjustStartEndParamsToAvoidBaseOverlaps(){for(const t of this.externalBases.keys())this.AdjustCurrentBundleWidthsOnCurve(this.externalBases.get(t));for(const t of this.internalBases.keys())this.AdjustCurrentBundleWidthsOnCurve(this.internalBases.get(t))}AdjustCurrentBundleWidthsOnCurve(t){const e=t.length;if(!(e<=1))for(let i=0;i<e;i++){const e=t[i],n=e.Next;this.ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(e,n)}}ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(t,e){if(!t.Intersect(e))return;let i=t.ParRight,n=t.ParLeft,r=e.ParRight,o=e.ParLeft;const a=e.ParameterSpan;i>n&&(i-=a),r>o&&(r-=a),r>n&&(r-=a,o-=a),i>o&&(i-=a,n-=a);const l=this.RegularCut(i,n,r,o,t.Span,e.Span),h=E.getTriangleOrientation(e.CurveCenter,e.OppositeBase.InitialMidPoint,t.OppositeBase.InitialMidPoint);h==s.Clockwise?(n=l,r=l):h==s.Counterclockwise?(o=l,i=l):o-i>=n-r?(n=l,r=l):(o=l,i=l),e.ParRight=e.AdjustParam(r),e.ParLeft=e.AdjustParam(o),t.ParRight=t.AdjustParam(i),t.ParLeft=t.AdjustParam(n)}RegularCut(t,e,i,n,r,s){let o=(r*n+s*t)/(r+s);const a=Math.min(e,n),l=Math.max(t,i);return o<l&&(o=l),o>a&&(o=a),o}RotateBundlesToDiminishCost(){let t=js.MaxParameterChange;const e={cost:this.Cost()};let i=0;for(;i++<js.MaxIterations;){const i=e.cost;if(this.RotateBundlesToDiminishCostOneIteration(t,e),t=this.UpdateParameterChange(t,i,e.cost),t<js.MinParameterChange)break}}UpdateParameterChange(t,e,i){return i+1<e?(this.stepsWithProgress++,this.stepsWithProgress>=5&&(this.stepsWithProgress=0,this.fixedBundles.clear())):(this.stepsWithProgress=0,t*=.8,this.fixedBundles.clear()),t}RotateBundlesToDiminishCostOneIteration(t,e){let i=!1;for(const n of this.Bundles)this.fixedBundles.has(n)||(this.OptimizeBundle(n,t,e)?i=!0:this.fixedBundles.add(n));return i}OptimizeBundle(t,e,i){const n=this.CostBi(t);if(n<js.CostThreshold)return!1;let r=0,s=-1,o=-1;for(let i=0;i<js.Deltas.length-1;i++){let a=this.DeltaWithChangedAngles(js.Deltas[i][0],js.Deltas[i][1],0,0,t,n,e);a>js.CostDeltaThreshold&&a>r&&(o=i,s=js.Deltas.length-1,r=a),a=this.DeltaWithChangedAngles(0,0,js.Deltas[i][0],js.Deltas[i][1],t,n,e),a>js.CostDeltaThreshold&&a>r&&(o=js.Deltas.length-1,s=i,r=a)}return!(r<js.CostDeltaThreshold)&&(i.cost-=r,t.RotateBy(js.Deltas[o][0],js.Deltas[o][1],js.Deltas[s][0],js.Deltas[s][1],e),!0)}DeltaWithChangedAngles(t,e,i,n,r,s,o){if(!r.RotationIsLegal(t,e,i,n,o))return 0;r.RotateBy(t,e,i,n,o);const a=this.CostBN(r,s);return r.RotateBy(-1*t,-1*e,-1*i,-1*n,o),s-a}CostBi(t){return js.SeparationCoeff*this.SeparationCost(t)+(js.SqueezeCoeff*this.SqueezeCost(t)+(js.AssymetryCoeff*this.AssymetryCost(t)+js.CenterCoeff*this.CenterCostBi(t)))}CostBN(t,e){let i=0;return i+=js.CenterCoeff*this.CenterCostBi(t),i>e?i:(i+=js.SeparationCoeff*this.SeparationCost(t),i>e?i:(i+=js.SqueezeCoeff*this.SqueezeCost(t),i>e||(i+=js.AssymetryCoeff*this.AssymetryCost(t)),i))}SqueezeCost(t){const e=t.TargetBase.MidPoint.sub(t.SourceBase.MidPoint).normalize().rotate90Ccw(),i=Math.abs(t.SourceBase.RightPoint.sub(t.SourceBase.LeftPoint).dot(e)),n=Math.abs(t.TargetBase.RightPoint.sub(t.TargetBase.LeftPoint).dot(e)),r=Math.abs(t.TotalRequiredWidth-i)/t.TotalRequiredWidth,s=Math.abs(t.TotalRequiredWidth-n)/t.TotalRequiredWidth,o=Math.abs(i-n)/t.TotalRequiredWidth;return Math.exp(10*r)-1+(Math.exp(10*s)-1)+o}CenterCostBi(t){return t.SourceBase.BelongsToRealNode||t.TargetBase.BelongsToRealNode?this.CenterCostBb(t.SourceBase)+this.CenterCostBb(t.TargetBase):0}CenterCostBb(t){if(!t.BelongsToRealNode)return 0;const e=t.ParMid,i=Math.min(t.InitialMidParameter,e),n=Math.max(t.InitialMidParameter,e),r=Math.min(n-i,i+(t.ParameterSpan-n));return t.CurveCenter.equal(t.Position)||t.IsParent?r*r*25:r*r*500}AssymetryCost(t){return this.GetAssymetryCostForBase(t.SourceBase)+this.GetAssymetryCostForBase(t.TargetBase)}GetAssymetryCostForBase(t){if(t.BelongsToRealNode)return 0;const e=t.OppositeBase.BelongsToRealNode?200:500;let i=0;for(const n of t.OrientedHubSegments){const r=n.Index,s=n.Other.Index,o=t.Points[r],a=t.Tangents[r],l=n.Other.BundleBase,h=l.Points[s],u=l.Tangents[s],c=t.Count+l.Count;i+=this.GetAssymetryCostOnData(o,a,h,u,e)/c}return i}GetAssymetryCostOnData(t,e,i,n,r){const s=t.sub(i),o=s.length;if(o<y.distanceEpsilon)return 0;const a=e.add(n).dot(s),l=E.crossProduct(s,e),h=E.crossProduct(s,n),u=l-h;return 10*(a*a+u*u)+r*(l*l+h*h)}SeparationCost(t){return this.SeparationCostForBundleBase(t.SourceBase)+this.SeparationCostForBundleBase(t.TargetBase)}SeparationCostForBundleBase(t){return null==t.Prev?0:this.SeparationCostForAdjacentBundleBases(t,t.Prev)+this.SeparationCostForAdjacentBundleBases(t,t.Next)}SeparationCostForAdjacentBundleBases(t,e){const i=t.Curve,n=this.IntervalsOverlapLength(t.ParRight,t.ParLeft,e.ParRight,e.ParLeft,i),r=Math.min(t.Span,e.Span);return Math.exp(n/(10*r))-1}IntervalsOverlapLength(t,e,i,n,r){const s=r.parStart,o=r.parEnd;return t<e?i<n?this.IntersectRegularIntervals(t,e,i,n):this.IntersectRegularIntervals(t,e,i,o)+this.IntersectRegularIntervals(t,e,s,n):i<n?this.IntersectRegularIntervals(t,o,i,n)+this.IntersectRegularIntervals(s,e,i,n):this.IntersectRegularIntervals(t,o,i,o)+this.IntersectRegularIntervals(s,e,s,n)}IntersectRegularIntervals(t,e,i,n){const r=Math.max(t,i),s=Math.min(e,n);return r<s?s-r:0}Cost(){let t=0;for(const e of this.Bundles){t+=(js.SeparationCoeff*this.SeparationCost(e)+js.AssymetryCoeff*this.AssymetryCost(e))/2+js.SqueezeCoeff*this.SqueezeCost(e)+js.CenterCoeff*this.CenterCostBi(e)}return t}}js.Deltas=[[1,-1],[1,-1]],js.SeparationCoeff=1,js.SqueezeCoeff=1,js.CenterCoeff=10,js.AssymetryCoeff=1,js.MaxIterations=200,js.MaxParameterChange=8/360,js.MinParameterChange=.1/360,js.CostThreshold=1e-5,js.CostDeltaThreshold=.01;class Us{constructor(){this.Metrolines=new Array}Add(t){this.Metrolines.push(t)}}class Ws{constructor(t){this.Metrolines=t,this.BuildOrder()}*GetOrder(t,e){const i=new ue(t.Position,e.Position),n=this.bundles.get(i).Metrolines;if(t.Position==i.First)for(let t=0;t<n.length;t++)yield n[t];else for(let t=n.length-1;t>=0;t--)yield n[t]}GetLineIndexInOrder(t,e,i){const n=new ue(t.Position,e.Position),r=t.Position!=n.First,s=this.bundles.get(n).LineIndexInOrder;return r?s.size-1-s.get(i):s.get(i)}BuildOrder(){this.bundles=new un;for(const t of this.Metrolines)for(let e=t.Polyline.startPoint;null!=e.next;e=e.next){const i=new ue(e.point,e.next.point);let n=this.bundles.get(i);n||this.bundles.set(i,n=new Us),n.Add(t)}for(const t of this.bundles)this.BuildOrderPP(t[0],t[1])}BuildOrderPP(t,e){if(!e.orderFixed){e.Metrolines.sort((e,i)=>this.CompareLines(e,i,t.First,t.Second)),e.orderFixed=!0,e.LineIndexInOrder=new Map;for(let t=0;t<e.Metrolines.length;t++)e.LineIndexInOrder.set(e.Metrolines[t],t)}}CompareLines(t,e,i,n){const r={polyPoint:null,next:null,prev:null};this.FindStationOnLine(i,n,t,r);const s=r.polyPoint,o=r.next,a=r.prev;this.FindStationOnLine(i,n,e,r);const l=r.polyPoint,h=r.next,u=r.prev;let c,d,g=s,f=l;for(;null!=(d=a(g))&&null!=(c=u(f))&&d.point.equal(c.point);){const i=new ue(d.point,g.point);if(this.bundles.get(i).orderFixed)return this.CompareOnFixedOrder(i,t,e,!d.point.equal(i.First));g=d,f=c}if(null!=d&&null!=c){const t=g.point;return-Ws.IsLeft(o(g).point.sub(t),d.point.sub(t),c.point.sub(t))}for(g=s,f=l;null!=(d=o(g))&&null!=(c=h(f))&&d.point.equal(c.point);){const i=new ue(d.point,g.point);if(this.bundles.get(i).orderFixed)return this.CompareOnFixedOrder(i,t,e,!g.point.equal(i.First));g=d,f=c}if(null!=d&&null!=c){const t=g.point;return Ws.IsLeft(a(g).point.sub(t),d.point.sub(t),c.point.sub(t))}return b(t.Index,e.Index)}CompareOnFixedOrder(t,e,i,n){const r=this.bundles.get(t).LineIndexInOrder;return(n?-1:1)*b(r.get(e),r.get(i))}FindStationOnLine(t,e,i,n){for(let r=i.Polyline.startPoint;null!=r.next;r=r.next){if(r.point.equal(t)&&r.next.point.equal(e))return n.next=t=>t.next,n.prev=t=>t.prev,void(n.polyPoint=r);if(r.point.equal(e)&&r.next.point.equal(t))return n.next=t=>t.prev,n.prev=t=>t.next,void(n.polyPoint=r.next)}throw new Error}static IsLeft(t,e,i){return Ms(t,e,i)}}class Hs extends K{constructor(t,e){super(null),this.metroGraphData=t,this.bundlingSettings=e}run(){this.CreateMetroOrdering(),this.InitRadii(),this.FinalizePaths()}InitRadii(){new _s(this.metroGraphData,this.bundlingSettings).CreateNodeRadii()}CreateMetroOrdering(){this.metroOrdering=new Ws(this.metroGraphData.Metrolines)}FinalizePaths(){this.CreateBundleBases(),this.CreateSegmentsInsideHubs(),this.CreateCurves()}CreateBundleBases(){new js(this.metroOrdering,this.metroGraphData,this.bundlingSettings).Run()}CreateCurves(){for(let t=0;t<this.metroGraphData.Metrolines.length;t++)this.CreateCurveLine(this.metroGraphData.Metrolines[t],this.metroGraphData.Edges[t])}CreateCurveLine(t,e){const i=new F;let n=Hs.FindCurveStart(this.metroGraphData,this.metroOrdering,t);const r=Hs.HubSegsOfLine(this.metroGraphData,this.metroOrdering,t);for(const t of r)null!=t&&(i.addSegment(I.mkPP(n,t.start)),i.addSegment(t),n=t.end);i.addSegment(I.mkPP(n,Hs.FindCurveEnd(this.metroGraphData,this.metroOrdering,t))),e.curve=i}static FindCurveStart(t,e,i){const n=t.PointToStations.get(i.Polyline.startPoint.point),r=t.PointToStations.get(i.Polyline.startPoint.next.point),s=n.BundleBases.get(r),o=s.IsParent?e.GetLineIndexInOrder(n,r,i):e.GetLineIndexInOrder(r,n,i);return s.Points[o]}static FindCurveEnd(t,e,i){const n=t.PointToStations.get(i.Polyline.endPoint.prev.point),r=t.PointToStations.get(i.Polyline.endPoint.point),s=r.BundleBases.get(n),o=s.IsParent?e.GetLineIndexInOrder(r,n,i):e.GetLineIndexInOrder(n,r,i);return s.Points[o]}static*HubSegsOfLine(t,e,i){for(let n=i.Polyline.startPoint.next;null!=n.next;n=n.next)yield Hs.SegOnLineVertex(t,e,i,n)}static SegOnLineVertex(t,e,i,n){const r=t.PointToStations.get(n.prev.point),s=t.PointToStations.get(n.point),o=s.BundleBases.get(r),a=e.GetLineIndexInOrder(r,s,i);if(null==o.OrientedHubSegments[a]||null==o.OrientedHubSegments[a].Segment){const r=t.PointToStations.get(n.next.point),l=s.BundleBases.get(r),h=e.GetLineIndexInOrder(r,s,i);return I.mkPP(o.Points[a],l.Points[h])}return o.OrientedHubSegments[a].Segment}CreateSegmentsInsideHubs(){for(const t of this.metroGraphData.Metrolines)this.CreateOrientedSegsOnLine(t);this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs&&this.FanBezierSegs()}CreateOrientedSegsOnLine(t){for(let e=t.Polyline.startPoint.next;null!=e.next;e=e.next)this.CreateOrientedSegsOnLineVertex(t,e)}CreateOrientedSegsOnLineVertex(t,e){const i=this.metroGraphData.PointToStations.get(e.prev.point),n=this.metroGraphData.PointToStations.get(e.point),r=this.metroGraphData.PointToStations.get(e.next.point),s=n.BundleBases.get(i),o=n.BundleBases.get(r),a=this.metroOrdering.GetLineIndexInOrder(i,n,t),l=this.metroOrdering.GetLineIndexInOrder(r,n,t),h=this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs?Hs.StandardBezier(s.Points[a],s.Tangents[a],o.Points[l],o.Tangents[l]):Hs.BiArc(s.Points[a],s.Tangents[a],o.Points[l],o.Tangents[l]);s.OrientedHubSegments[a].Segment=h,o.OrientedHubSegments[l].Segment=h}static ShowHubs(t,e,i,n,r=[]){let s=Hs.GetAllDebugCurves(e,t);null!=i&&s.push(Xe.mkDebugCurveTWCI(255,1,"red",H.CreateDiamond(5,25,i.Position))),s=s.concat(r)}static GetAllDebugCurves(t,e){return Hs.GraphNodes(e).concat(Hs.VertexDebugCurves(t,e)).concat(Hs.DebugEdges(e))}static DebugEdges(t){return t.Edges.map(t=>Xe.mkDebugCurveTWCI(40,.1,"gray",t.curve))}static VertexDebugCurves(t,e){return Hs.DebugCircles(e).concat(Hs.DebugHubBases(e)).concat(Hs.DebugSegs(e)).concat(Hs.BetweenHubs(t,e))}static BetweenHubs(t,e){const i=[];for(const n of e.Metrolines){const r=Hs.GetInterestingSegs(e,t,n),s=Hs.GetMonotoneColor(n.Polyline.start,n.Polyline.end,r);for(const t of r)i.push(Xe.mkDebugCurveTWCI(100,n.Width,s,I.mkPP(t[0],t[1])))}return i}static GetInterestingSegs(t,e,i){const n=new Array;if(0==t.Stations.length||null==t.Stations[0].BundleBases||0==t.Stations[0].BundleBases.size)return[];let r=Hs.FindCurveStart(t,e,i);const s=Hs.HubSegsOfLine(t,e,i);for(const t of s)null!=t&&(n.push([r,t.start]),r=t.end);return n.push([r,Hs.FindCurveEnd(t,e,i)]),n}static GetMonotoneColor(t,e,i){return"green"}static DebugHubBases(t){const e=new Array;for(const i of t.Stations)for(const t of i.BundleBases.values())e.push(Xe.mkDebugCurveTWCI(100,1,"red",I.mkPP(t.LeftPoint,t.RightPoint)));return e}static DebugCircles(t){return t.Stations.map(t=>Xe.mkDebugCurveTWCI(100,.1,"blue",H.mkCircle(t.Radius,t.Position)))}static DebugSegs(t){const e=new Array;for(const i of t.VirtualStations())for(const t of i.BundleBases.values())for(const i of t.OrientedHubSegments)if(null!=i)if(null==i.Segment){const n=i.Other.BundleBase,r=i.Index,s=i.Other.Index;e.push(I.mkPP(t.Points[r],n.Points[s]))}else e.push(i.Segment);return e.map(t=>Xe.mkDebugCurveTWCI(100,.01,"green",t))}static GraphNodes(t){return t.Edges.map(t=>t.sourcePort.Curve).concat(t.Edges.map(t=>t.targetPort.Curve)).map(t=>Xe.mkDebugCurveTWCI(40,1,"black",t))}static BiArc(t,e,i,n){const r=t.sub(i);if(r.length<y.distanceEpsilon)return null;const s=r.dot(e.sub(n)),o=2*(-e.dot(n)-1),a=2*s,l=r.dot(r);let h;if(Math.abs(o)<y.distanceEpsilon){if(!(Math.abs(a)>y.distanceEpsilon))return null;h=-l/a}else{let t=a*a-4*o*l;t<0&&(t=0),t=Math.sqrt(t),h=(-a+t)/(2*o),h<0&&(h=(-a-t)/(2*o))}const u=t.add(e.mul(h)),c=i.add(n.mul(h)),d=E.middle(u,c),g=new F;if(g.addSegs([Hs.ArcOn(t,u,d),Hs.ArcOn(d,c,i)]),e.dot(i.sub(t))<=0&&e.dot(n)<=0){return Hs.StandardBezier(t,e,i,n)}return g}static ArcOn(t,e,i){const n={center:null};if(Math.abs(E.signedDoubledTriangleArea(t,e,i))<1e-4||!Hs.FindArcCenter(t,e,i,n))return I.mkPP(t,i);const r=n.center,s=w(t,r);if(w(t,e)/s<1e-4)return I.mkPP(t,i);const o=t.sub(r);let a=Math.atan2(o.y,o.x);const l=i.sub(r);let h=Math.atan2(l.y,l.x),u=h-a;if(u<0&&(u+=2*Math.PI,h+=2*Math.PI),u<=Math.PI){return new R(a,h,new E(s,0),new E(0,s),r)}for(h>2*Math.PI&&(h-=2*Math.PI),a=Math.PI-a,h=Math.PI-h,a<0&&(a+=2*Math.PI);h<a;)h+=2*Math.PI;return u=h-a,new R(a,h,new E(-s,0),new E(0,s),r)}static FindArcCenter(t,e,i,n){const r=e.sub(t).rotate90Cw(),s=e.sub(i).rotate90Cw();return n.center=E.lineLineIntersection(t,t.add(r),i,i.add(s)),null!=n.center}static StandardBezier(t,e,i,n){const r=w(t,i)/4;return M.mkBezier([t,t.add(e.mul(r)),i.add(n.mul(r)),i])}FanBezierSegs(){let t=!0;let e=0;for(;t&&e++<5;){t=!1;for(const e of this.metroGraphData.Stations)for(const i of e.BundleBases.values())t||(t=this.FanEdgesOfHubSegment(i))}}FanEdgesOfHubSegment(t){let e=!1;for(let i=0;i<t.Count-1;i++)e||(e=this.FanCouple(t,i,t.CurveCenter,t.Curve.boundingBox.diagonal/2));return e}FanCouple(t,e,i,n){const r=t.OrientedHubSegments[e],s=t.OrientedHubSegments[e+1];if(null==r)return!1;if(I.IntersectPPPP(r.Segment.start,r.Segment.end,s.Segment.start,s.Segment.end))return!1;if(E.getTriangleOrientation(r.value(0),r.value(.5),r.value(1))!=E.getTriangleOrientation(s.value(0),s.value(.5),s.value(1)))return!1;const o=this.BaseLength(r),a=this.BaseLength(s);return!(Math.abs(o-a)<y.intersectionEpsilon)&&(o>a?this.AdjustLongerSeg(r,s,i,n):this.AdjustLongerSeg(s,r,i,n))}AdjustLongerSeg(t,e,i,n){const r=t.value(0).sub(e.value(0)),s=t.value(1).sub(e.value(1)),o=Math.min(r.length,s.length),a=e.value(.5),l=Math.max(r.length,s.length);return 0!=this.NicelyAligned(t.Segment,r,s,a,o,l)&&this.FitLonger(t,r,s,a,o,l,i,n)}FitLonger(t,e,i,n,r,s,o,a){let l=t.Segment;const h=l.start,u=l.end;let c=0;let d=l.start.mul(1-Hs.SqueezeBound).add(l.B(1).mul(Hs.SqueezeBound)),g=l.end.mul(1-Hs.SqueezeBound).add(l.B(2).mul(Hs.SqueezeBound)),f=l.B(1).mul(2).sub(l.start),p=l.B(2).mul(2).sub(l.end);const m={highP:f};this.PullControlPointToTheCircle(l.start,m,o,a),f=m.highP;let y=this.NicelyAligned(l,e,i,n,r,s);for(;;){if(-1==y){const t=E.middle(l.B(1),d),e=E.middle(l.B(2),g);f=l.B(1),p=l.B(2),l=new M(h,t,e,u)}else{const t=E.middle(l.B(1),f),e=(l.B(2),p);d=l.B(1),g=l.B(2),l=new M(h,t,e,u)}if(0==(y=this.NicelyAligned(l,e,i,n,r,s)))return t.Segment=l,t.Other.Segment=l,!0;if(c++>10)return!1}}PullControlPointToTheCircle(t,e,i,n){const r=E.ProjectionToLine(t,e.highP,i),s=Math.sqrt(n*n-r.sub(i).lengthSquared),o=e.highP.sub(r),a=o.length;a>s&&(e.highP=r.add(o.mul(s/a)))}NicelyAligned(t,e,i,n,r,s){const o=t.value(.5).sub(n),a=o.length;return e.dot(o)<0||i.dot(o)<0||a<r-.001?1:a>s+.001?-1:0}BaseLength(t){return t.value(0).sub(t.value(1)).lengthSquared}}Hs.SqueezeBound=.2;class qs{constructor(t,e){this.stepsWithProgress=0,this.metroGraphData=t,this.bundlingSettings=e,this.costCalculator=new Ds(this.metroGraphData,this.bundlingSettings),this.cache=new Ls(this.metroGraphData,this.bundlingSettings,this.costCalculator,this.metroGraphData.Cdt)}static FixRouting(t,e){return this.FixRoutingMBP(t,e,null)}static FixRoutingMBP(t,e,i){return new qs(t,e).FixRoutingP(i)}FixRoutingP(t){this.stationsForOptimizations=this.GetStationsForOptimizations(t),this.cache.InitializeCostCache();let e=qs.MaxStep,i=Number.POSITIVE_INFINITY,n=this.metroGraphData.VirtualStations().map(t=>t.Position),r=0;for(;r++<qs.MaxIterations;){const t=this.TryMoveStations();if(r<=1&&!t)return!1;if(!t)break;const s=i;i=Ds.Cost(this.metroGraphData,this.bundlingSettings),e=this.UpdateMaxStep(e,s,i);const o=n;if(n=this.metroGraphData.VirtualStations().map(t=>t.Position),e<qs.MinStep||this.Converged(e,o,n))break}return!0}static stationsArePositionedCorrectly(t){for(const e of t.VirtualEdges())if(!this.edgeIsPositionedCorrectly(e,t))return!1;return!0}static edgeIsPositionedCorrectly(t,e){const i=t[0],n=t[1],r=e.looseIntersections.ObstaclesToIgnoreForBundle(i,n),s=I.mkPP(i.Position,n.Position),o=Array.from(e.looseIntersections.obstacleTree.GetNodeItemsIntersectingRectangle(s.boundingBox)).filter(t=>!r.has(t)).filter(t=>F.CurvesIntersect(s,t));return!(o.length>0)||(Hs.ShowHubs(e,null,null,"/tmp/badcross.svg",[Xe.mkDebugCurveTWCI(200,1,"Brown",s),Xe.mkDebugCurveTWCI(200,1,"Red",H.mkCircle(2,i.Position)),Xe.mkDebugCurveTWCI(200,1,"Blue",H.mkCircle(5,n.Position)),Xe.mkDebugCurveTWCI(100,1,"Blue",H.mkCircle(5,n.Position))].concat(o.map(t=>Xe.mkDebugCurveTWCI(100,1,"Pink",t)))),!1)}GetStationsForOptimizations(t){if(null==t)return new Set(this.metroGraphData.VirtualStations());{const e=new Set;for(const i of t){const t=this.metroGraphData.PointToStations.get(i);t&&!t.IsReal&&e.add(t)}return e}}Converged(t,e,i){let n=0,r=0;for(let t=0;t<e.length;t++)r+=e[t].sub(i[t]).lengthSquared,n+=e[t].lengthSquared;return Math.sqrt(r/n)<qs.MinRelativeChange}UpdateMaxStep(t,e,i){return i+1<e?(this.stepsWithProgress++,this.stepsWithProgress>=5&&(this.stepsWithProgress=0,t=Math.min(qs.MaxStep,t/.8))):(this.stepsWithProgress=0,t*=.8),t}TryMoveStations(){let t=!1;const e=new Set;for(const i of this.stationsForOptimizations)if(this.TryMoveStation(i)){t=!0,e.add(i);for(const t of i.Neighbors)t.IsReal||e.add(t)}return this.stationsForOptimizations=e,t}TryMoveStation(t){let e=this.BuildDirection(t);if(0==e.length)return!1;let i=this.BuildStepLength(t,e);if(i<qs.MinStep&&(e=new E(1+2*oe(),1+2*oe()),i=this.BuildStepLength(t,e),i<qs.MinStep))return!1;const n=e.mul(i),r=t.Position.add(n);return!this.metroGraphData.PointToStations.has(r)&&(!!this.moveIsLegalForAdjacentBundles(t,r)&&(this.metroGraphData.MoveNode(t,r),this.cache.UpdateCostCache(t),!0))}moveIsLegalForAdjacentBundles(t,e){for(const i of this.metroGraphData.looseIntersections.obstacleTree.AllHitItems(G.mkOnPoints([e]),t=>F.PointRelativeToCurveLocation(e,t)!=a.Outside))if(0==t.getELP().has(i))return!1;for(const i of t.Neighbors){const n=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(i,t);if(!this.metroGraphData.cdtIntersections.EdgeIsLegal_(i.Position,e,i.CdtTriangle,n))return!1}return!0}BuildDirection(t){const e=this.BuildForceForInk(t),i=this.BuildForceForPathLengths(t),n=this.BuildForceForRadius(t),r=this.BuildForceForBundle(t),s=e.add(i.add(n.add(r)));return s.length<.1?new E(0,0):s.normalize()}BuildStepLength(t,e){let i=qs.MinStep,n=this.CostGain(t,t.Position.add(e.mul(i)));if(n<.01)return 0;for(;2*i<=qs.MaxStep;){const r=this.CostGain(t,t.Position.add(e.mul(2*i)));if(r<=n)break;i*=2,n=r}return i}CostGain(t,e){const i=-12345678,n=this.costCalculator.RadiusGain(t,e);if(n<i)return i;const r=this.costCalculator.BundleGain(t,e);if(r<i)return i;return n+this.costCalculator.InkGain(t,e)+this.costCalculator.PathLengthsGain(t,e)+r}BuildForceForInk(t){let e=new E(0,0);for(const i of t.Neighbors){const n=i.Position.sub(t.Position);e=e.add(n.normalize())}return e.mul(this.bundlingSettings.InkImportance)}BuildForceForPathLengths(t){let e=new E(0,0);for(const i of this.metroGraphData.MetroNodeInfosOfNode(t)){const n=i.Metroline,r=i.PolyPoint.next.point,s=i.PolyPoint.prev.point,o=r.sub(t.Position),a=s.sub(t.Position);e=e.add(o.div(o.length*n.IdealLength)),e=e.add(a.div(a.length*n.IdealLength))}return e.mul(this.bundlingSettings.PathLengthImportance)}BuildForceForRadius(t){let e=new E(0,0);const i=t.cachedIdealRadius,n={touchedObstacles:[]};if(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(t,t.Position,i,n))throw Hs.ShowHubs(this.metroGraphData,null,t,"/tmp/hubs.svg",[Xe.mkDebugCurveTWCI(255,1,"Brown",xs.containingPoly),Xe.mkDebugCurveTWCI(100,1,"Blue",H.mkCircle(i,t.Position))]),new Error;for(const r of n.touchedObstacles){const n=2*(1-r[1].sub(t.Position).length/i),s=t.Position.sub(r[1]).normalize();e=e.add(s.mul(n))}return e.mul(this.bundlingSettings.HubRepulsionImportance)}BuildForceForBundle(t){let e=new E(0,0);for(const i of t.Neighbors){qs.debcount++;const n=this.metroGraphData.GetWidthSSN(t,i,this.bundlingSettings.EdgeSeparation),r={closestDist:[]};this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t,i,t.Position,i.Position,n/2,r)||Hs.ShowHubs(this.metroGraphData,null,t,"/tmp/inside_forbid.svg",[Xe.mkDebugCurveTWCI(100,.2,"Blue",I.mkPP(t.Position,i.Position)),Xe.mkDebugCurveTWCI(100,.2,"Red",H.mkCircle(2,t.Position)),Xe.mkDebugCurveTWCI(100,.2,"Red",H.mkCircle(3,i.Position))]);for(const t of r.closestDist){const i=2*(1-t[0].sub(t[1]).length/(n/2)),r=t[0].sub(t[1]).normalize().neg();e=e.add(r.mul(i))}}return e.mul(this.bundlingSettings.BundleRepulsionImportance)}}qs.MaxIterations=100,qs.MaxStep=50,qs.MinStep=1,qs.MinRelativeChange=5e-4,qs.debcount=0;class Xs{constructor(t,e){this.metroGraphData=t,this.bundlingSettings=e}static FixRouting(t,e){const i=new Xs(t,e);i.GlueConflictingStations(),i.UnglueEdgesFromBundleToSaveInk(!0);let n=0;for(;++n<10;){let t=i.GlueConflictingStations();if(t||(t=i.RelaxConstrainedEdges()),t||(t=n<=3&&i.UnglueEdgesFromBundleToSaveInk(!1)),t||(t=i.GlueCollinearNeighbors(n)),t||(t=3==n&&i.RemoveDoublePathCrossings()),!t)break}for(t.cdtIntersections.ComputeForcesForBundles=!0,i.RemoveDoublePathCrossings(),i.UnglueEdgesFromBundleToSaveInk(!0);i.GlueConflictingStations(););t.Initialize(!0)}GlueConflictingStations(){const t=this.GetCirclesHierarchy();if(null==t)return!1;const e=new Map,i=new Set;if(Vi(t,t,(t,n)=>this.TryToGlueStations(t,n,e,i)),0==e.size)return!1;for(let t=0;t<this.metroGraphData.Edges.length;t++)this.RegenerateEdge(e,t);const n=new ce;for(const t of i){n.add(t.Position);for(const e of t.Neighbors)e.IsReal||n.add(e.Position)}return this.metroGraphData.Initialize(!1),qs.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,n),!0}GetCirclesHierarchy(){for(const t of this.metroGraphData.VirtualStations())t.Radius=this.GetCurrentHubRadius(t);return ot(this.metroGraphData.VirtualStations().map((function(t){const e=t.Position,i=Math.max(t.Radius,5),n=new E(i,i),r=G.mkPP(e.add(n),e.sub(n));return ut(t,r)})))}GetCurrentHubRadius(t){if(t.IsReal)return t.BoundaryCurve.boundingBox.diagonal/2;{const e=t.cachedIdealRadius;let i=this.metroGraphData.looseIntersections.GetMinimalDistanceToObstacles(t,t.Position,e);for(const e of t.Neighbors)i=Math.min(i,t.Position.sub(e.Position).length);return i}}TryToGlueStations(t,e,i,n){if(!ye(t.getELP(),e.getELP()))return!1;t.Position.sub(e.Position).length>=Math.max(t.Radius,5)+Math.max(e.Radius,5)||this.TryGlueOrdered(t,e,n,i)||this.TryGlueOrdered(e,t,n,i)}TryGlueOrdered(t,e,i,n){return!(n.has(t)||i.has(t)||!this.StationGluingIsAllowed(t,e,n))&&(this.Map(t,e,i,n),!0)}Map(t,e,i,n){n.set(t,e),i.add(e)}StationGluingIsAllowed(t,e,i){for(const n of t.Neighbors){const r=Xs.Glued(n,i),s=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(r,t);if(!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(r,e,s))return!1}return!(this.ComputeCostDeltaAfterStationGluing(t,e,i)<0)}ComputeCostDeltaAfterStationGluing(t,e,i){const n=t.Position.sub(e.Position).length;if(t.Radius>=n||e.Radius>=n)return 1;let r=0;const s=this.metroGraphData.Ink;let o=this.metroGraphData.Ink-e.Position.sub(t.Position).length;for(const n of t.Neighbors){const r=Xs.Glued(n,i);o-=r.Position.sub(t.Position).length,o+=0==this.metroGraphData.RealEdgeCount(r,e)?r.Position.sub(e.Position).length:0}r+=Ds.InkError(s,o,this.bundlingSettings);for(const i of this.metroGraphData.MetroNodeInfosOfNode(t)){const n=i.Metroline.Length;let s=i.Metroline.Length;const o=i.PolyPoint,a=o.prev,l=o.next;s-=a.point.sub(t.Position).length+l.point.sub(t.Position).length,s+=a.point.sub(e.Position).length+l.point.sub(e.Position).length,r+=Ds.PathLengthsError(n,s,i.Metroline.IdealLength,this.bundlingSettings)}return r}RegenerateEdge(t,e){const i=this.metroGraphData.Metrolines[e].Polyline;for(const t of i)if(!this.metroGraphData.PointToStations.has(t))return;let n=!1;for(const e of i)if(t.has(this.metroGraphData.PointToStations.get(e))){n=!0;break}if(!n)return;const r=Array.from(i).map(t=>this.metroGraphData.PointToStations.get(t));this.metroGraphData.Edges[e].curve=k.mkFromPoints(Xs.GluedPolyline(r,t))}static GluedPolyline(t,e){let i;Xs.debCount++;const n=new it.Stack;n.push(t[0]);const r=new Set;for(i=1;i<t.length-1;i++){const s=Xs.Glued(t[i],e);if(r.has(s))for(;n.top!=s;)r.delete(n.pop());else E.closeDistEps(s.Position,n.top.Position)||(r.add(s),n.push(s))}return n.push(t[i]),Array.from(n).reverse().map(t=>t.Position)}static Glued(t,e){var i;return null!==(i=e.get(t))&&void 0!==i?i:t}UnglueEdgesFromBundleToSaveInk(t){const e=new un;this.ink=this.metroGraphData.Ink,this.polylineLength=new Map;for(const t of this.metroGraphData.Metrolines){this.polylineLength.set(t,t.Length);for(let i=t.Polyline.startPoint;null!=i.next;i=i.next){Se(e,new ue(i.point,i.next.point),t)}}const i=new ce;let n=!1;for(const t of this.metroGraphData.Metrolines){const r=pe(this.metroGraphData.PointToStations.get(t.Polyline.start).getELP(),this.metroGraphData.PointToStations.get(t.Polyline.end).getELP());this.TrySeparateOnPolyline(t,e,i,r)&&(n=!0)}return n&&this.metroGraphData.Initialize(!1),(t||n)&&qs.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,t?null:i),n}TrySeparateOnPolyline(t,e,i,n){let r=!1,s=!0;for(;s;){s=!1;for(let r=t.Polyline.startPoint;null!=r.next&&null!=r.next.next;r=r.next)this.TryShortcutPolypoint(r,e,i,n)&&(s=!0);s&&(r=!0)}return r}TryShortcutPolypoint(t,e,i,n){return!!this.SeparationShortcutAllowed(t,e,n)&&(i.add(t.point),i.add(t.next.point),i.add(t.next.next.point),this.RemoveShortcuttedPolypoint(t,e),!0)}SeparationShortcutAllowed(t,e,i){const n=t.point,r=t.next.point,s=t.next.next.point,o=this.metroGraphData.PointToStations.get(n),a=this.metroGraphData.PointToStations.get(r),l=this.metroGraphData.PointToStations.get(s),h=ge(o.getELP(),l.getELP()),u=function(t){if(0==t.length)return new Set;let e=t[0];for(let i=1;i<t.length;i++)e=pe(e,t[i]);return e}([i,a.getELP(),h]);if(!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(o,l,u))return!1;return!(this.GetInkgain(t,e,n,r,s)<0)}GetInkgain(t,e,i,n,r){const[s,o,a]=this.FindPolylines(t,e);let l=0;const h=this.ink;let u=this.ink;const c=i.sub(n).length,d=n.sub(r).length,g=i.sub(r).length;s.size==a.size&&(u-=c),o.size==a.size&&(u-=d);const f=e.get(new ue(i,r));f&&0!=f.size||(u+=g),l+=Ds.InkError(h,u,this.bundlingSettings);for(const t of a){const e=this.polylineLength.get(t),i=e-(c+d-g);l+=Ds.PathLengthsError(e,i,t.IdealLength,this.bundlingSettings)}let p=this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(i));const m=this.metroGraphData.GetWidthAN(Array.from(a),this.bundlingSettings.EdgeSeparation),y=this.metroGraphData.GetWidthAN(Array.from(de(s,a)),this.bundlingSettings.EdgeSeparation);let b=_s.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(p,i,r,n,m,y,this.bundlingSettings);b>p&&(l-=Ds.RError(b,p,this.bundlingSettings)),p=this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(r));const P=this.metroGraphData.GetWidthAN(Array.from(de(o,a)),this.bundlingSettings.EdgeSeparation);return b=_s.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(p,r,n,i,P,m,this.bundlingSettings),b>p&&(l-=Ds.RError(b,p,this.bundlingSettings)),l}RemoveShortcuttedPolypoint(t,e){const i=t.point,n=t.next.point,r=t.next.next.point,[s,o,a]=this.FindPolylines(t,e),l=w(i,n),h=w(n,r),u=w(i,r);s.size==a.size&&(this.ink-=l),o.size==a.size&&(this.ink-=h);const c=e.get(new ue(i,r));c&&0!=c.size||(this.ink+=u);for(const t of a){const e=this.polylineLength.get(t);this.polylineLength.set(t,e-(l+h-u))}for(const t of a){const s=Array.from(t.Polyline.polylinePoints()).find(t=>t.point.equal(n));this.RemovePolypoint(s),Ce(e,[i,n],t),Ce(e,[n,r],t),g=t,Se(e,new ue((d=[i,r])[0],d[1]),g)}var d,g}FindPolylines(t,e){const i=t.point,n=t.next.point,r=t.next.next.point,s=e.get_(i,n),o=e.get_(n,r);return[s,o,pe(s,o)]}RemovePolypoint(t){const e=t.prev,i=t.next;e.next=i,i.prev=e}GlueCollinearNeighbors(t){const e=new ce;let i=!1;for(const n of this.metroGraphData.Stations)this.GlueCollinearNeighborsSPN(n,e,t)&&(i=!0);return i&&(this.metroGraphData.Initialize(!1),qs.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,e)),i}GlueCollinearNeighborsSPN(t,e,i){if(t.Neighbors.length<=1)return!1;const n=new Rs,r=t.Neighbors;for(let e=0;e<r.length;e++)this.TryToGlueEdges(t,r[e],r[(e+1)%r.length],n,i);if(n.isEmpty)return!1;for(const t of n)this.GlueEdge(t),e.add(t[0].Position),e.add(t[1].Position),e.add(t[2]);return!0}TryToGlueEdges(t,e,i,n,r){if(E.anglePCP(e.Position,t.Position,i.Position)<this.bundlingSettings.AngleThreshold){const s=w(e.Position,t.Position),o=w(i.Position,t.Position),a=Math.min(s,o)/Math.max(s,o);if(a<.05)return;if(s<o){if(this.EdgeGluingIsAllowedSSS(t,e,i))return void this.AddEdgeToGlue(t,i,e,e.Position,n)}else if(this.EdgeGluingIsAllowedSSS(t,i,e))return void this.AddEdgeToGlue(t,e,i,i.Position,n);if(r<5&&a>.5){const r=this.ConstructGluingPoint(t,e,i);this.EdgeGluingIsAllowedSSSP(t,e,i,r)&&this.AddEdgeToGlue(t,i,e,r,n)}}}ConstructGluingPoint(t,e,i){const n=Math.min(w(e.Position,t.Position),w(i.Position,t.Position)/2),r=e.Position.sub(t.Position).normalize().add(i.Position.sub(t.Position).normalize());return t.Position.add(r.mul(n/2))}EdgeGluingIsAllowedSSS(t,e,i){if(e.IsReal||i.IsReal)return!1;if(!ye(e.getELP(),i.getELP()))return!1;if(!this.metroGraphData.cdtIntersections.EdgeIsLegal(e,i,e.Position,i.Position))return!1;const n=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t,i);if(hn.IntersectionsOfLineAndRectangleNodeOverPolylineLR(I.mkPP(t.Position,e.Position),this.metroGraphData.LooseTree).find(t=>!n.has(t.seg1)))return!1;if(hn.IntersectionsOfLineAndRectangleNodeOverPolylineLR(I.mkPP(e.Position,i.Position),this.metroGraphData.LooseTree).find(t=>!n.has(t.seg1)))return!1;return!(this.ComputeCostDeltaAfterEdgeGluing(t,e,i,e.Position)<0)}EdgeGluingIsAllowedSSSP(t,e,i,n){if(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(n,0,pe(e.getELP(),i.getELP())))return!1;if(!this.metroGraphData.cdtIntersections.EdgeIsLegal(t,null,t.Position,n))return!1;if(!this.metroGraphData.cdtIntersections.EdgeIsLegal(e,null,e.Position,n))return!1;if(!this.metroGraphData.cdtIntersections.EdgeIsLegal(i,null,i.Position,n))return!1;return!(this.ComputeCostDeltaAfterEdgeGluing(t,e,i,n)<0)}ComputeCostDeltaAfterEdgeGluing(t,e,i,n){let r=0;const s=this.metroGraphData.Ink,o=this.metroGraphData.Ink-w(t.Position,i.Position)-w(t.Position,e.Position)+w(t.Position,n)+w(n,e.Position)+w(n,i.Position);r+=Ds.InkError(s,o,this.bundlingSettings);for(const e of this.metroGraphData.GetIjInfo(t,i).Metrolines){const s=e.Length,o=e.Length-w(t.Position,i.Position)+w(t.Position,n)+w(n,i.Position);r+=Ds.PathLengthsError(s,o,e.IdealLength,this.bundlingSettings)}for(const i of this.metroGraphData.GetIjInfo(t,e).Metrolines){const s=i.Length,o=i.Length-w(t.Position,e.Position)+w(t.Position,n)+w(n,e.Position);r+=Ds.PathLengthsError(s,o,i.IdealLength,this.bundlingSettings)}const a=t.cachedIdealRadius,l=this.GetCurrentHubRadius(t),h=_s.GetMinRadiusForTwoAdjacentBundles(l,t,t.Position,e,i,this.metroGraphData,this.bundlingSettings);return h>l&&(r+=Ds.RError(h,l,this.bundlingSettings)),a>w(t.Position,n)&&!t.IsReal&&(r-=Ds.RError(a,w(t.Position,n),this.bundlingSettings)),r}AddEdgeToGlue(t,e,i,n,r){r.has(i,t)||r.has(e,t)||r.has(t,i)||r.has(t,e)||(r.set(t,i,n),r.set(t,e,n))}GlueEdge(t){const e=t[0],i=t[1],n=t[2];for(const t of e.MetroNodeInfos.map(t=>t.PolyPoint))null!=t.next&&t.next.point.equal(i.Position)?this.SplitPolylinePoint(t,n):null!=t.prev&&t.prev.point.equal(i.Position)&&this.SplitPolylinePoint(t.prev,n)}SplitPolylinePoint(t,e){if(t.point==e||t.next.point==e)return;const i=x.mkFromPoint(e);i.polyline=t.polyline,i.next=t.next,i.prev=t,i.next.prev=i,i.prev.next=i}RelaxConstrainedEdges(){const t=new ce;let e=!1;for(const i of this.metroGraphData.VirtualEdges())this.RelaxConstrainedEdge(i[0],i[1],t)&&(e=!0);return e&&(this.metroGraphData.Initialize(!1),qs.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,t)),e}RelaxConstrainedEdge(t,e,i){const n=this.metroGraphData.GetWidthSSN(t,e,this.bundlingSettings.EdgeSeparation),r={closestDist:new Array};this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t,e,t.Position,e.Position,.99*n/2,r);const s=r.closestDist;if(s.length>0){let n,r=-1;for(const i of s){if(Math.min(w(t.Position,i[1]),w(e.Position,i[1]))/w(t.Position,e.Position)<.1)continue;const s=w(i[0],i[1]);(-1==r||s<r)&&(r=s,n=i[1])}if(-1==r)return!1;if(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(n,0,pe(t.getELP(),e.getELP())))return!1;i.add(n),i.add(t.Position),i.add(e.Position);for(const i of this.metroGraphData.GetIjInfo(t,e).Metrolines){let r=null;for(const e of i.Polyline.polylinePoints())if(e.point.equal(t.Position)){r=e;break}null!=r.next&&r.next.point.equal(e.Position)?this.SplitPolylinePoint(r,n):this.SplitPolylinePoint(r.prev,n)}return!0}return!1}RemoveDoublePathCrossings(){const t=new ks(this.metroGraphData,this.metroGraphData.PointIsAcceptableForEdge.bind(this)).run();return t&&(this.metroGraphData.Initialize(!1),qs.FixRouting(this.metroGraphData,this.bundlingSettings)),t}}Xs.debCount=0;class Ys{constructor(t,e,i){this.upperBound=Number.POSITIVE_INFINITY,this._visGraph=i,i.ClearPrevEdgesTable();for(const t of i.Vertices())t.Distance=Number.POSITIVE_INFINITY;this.sources=t,this.targets=new Set(e)}GetPath(){const t=new Qi;for(const e of this.sources)e.Distance=0,t.Enqueue(e,0);for(;!t.IsEmpty()&&(this._current=t.Dequeue(),!this.targets.has(this._current));){for(const e of this._current.OutEdges)this.PassableOutEdge(e)&&this.ProcessNeighbor(t,e,e.Target);for(const e of this._current.InEdges.filter(this.PassableInEdge.bind))this.ProcessNeighbor(t,e,e.Source)}return null==this._visGraph.PreviosVertex(this._current)?null:this.CalculatePath()}PassableOutEdge(t){return this.targets.has(t.Target)||!Ys.IsForbidden(t)}PassableInEdge(t){return this.targets.has(t.Source)||!Ys.IsForbidden(t)}static IsForbidden(t){return(null!=t.IsPassable&&!t.IsPassable()||t)instanceof ui}ProcessNeighbor(t,e,i){const n=e.Length,r=this._current.Distance+n;r>=this.upperBound||(this.targets.has(i)&&(this.upperBound=r,this.closestTarget=i),null==this._visGraph.PreviosVertex(i)?(i.Distance=r,this._visGraph.SetPreviousEdge(i,e),t.Enqueue(i,r)):r<i.Distance&&(i.Distance=r,this._visGraph.SetPreviousEdge(i,e),t.DecreasePriority(i,r)))}CalculatePath(){if(null==this.closestTarget)return null;const t=new Array;let e=this.closestTarget;do{t.push(e),e=this._visGraph.PreviosVertex(e)}while(e.Distance>0);return t.push(e),t.reverse()}}class Qs extends K{constructor(t,e,i,n,r,s,o,a,l,h){super(null),this.bundlingSettings=n,this.edgesToRoute=t,this.regularEdges=t.filter(t=>t.source!=t.target),this.VisibilityGraph=i,this.shortestPathRouter=e,this.LoosePadding=r,this.LooseHierarchy=o,this.TightHierarchy=s,this.EdgeLooseEnterable=a,this.EdgeTightEnterable=l,this.loosePolylineOfPort=h}ThereAreOverlaps(t){return Gi(t,t,F.CurvesIntersect)}run(){this.ThereAreOverlaps(this.TightHierarchy)?this.Status=He.Overlaps:(this.FixLocationsForHookAnywherePorts(this.edgesToRoute),this.RoutePathsWithSteinerDijkstra()?(this.FixChildParentEdges(),this.bundlingSettings.StopAfterShortestPaths||this.OrderOptimizeNudgeEtc(),this.RouteSelfEdges(),this.FixArrowheads()):this.Status=He.EdgeSeparationIsTooLarge)}OrderOptimizeNudgeEtc(){const t=new Bs(this.regularEdges,this.LooseHierarchy,this.TightHierarchy,this.bundlingSettings,this.shortestPathRouter.CdtProperty,this.EdgeLooseEnterable,this.EdgeTightEnterable,this.loosePolylineOfPort);Xs.FixRouting(t,this.bundlingSettings),new Hs(t,this.bundlingSettings).run()}FixChildParentEdges(){for(const t of this.regularEdges){const e=t.sourcePort,i=t.targetPort;if(e.Curve.boundingBox.containsRect(i.Curve.boundingBox)){const i=F.intersectionOne(e.Curve,I.mkPP(t.curve.start,t.curve.end),!1);t.curve.startPoint.point=i.x}if(i.Curve.boundingBox.containsRect(e.Curve.boundingBox)){const e=F.intersectionOne(i.Curve,I.mkPP(t.curve.start,t.curve.end),!0);t.curve.endPoint.point=e.x}}}static CreateConstrainedDelaunayTriangulation(t){const e=Array.from(t.GetAllLeaves());let i=t.irect;return i=i.pad(i.diagonal/4),Qs.GetConstrainedDelaunayTriangulation(e.concat([i.perimeter()]))}static GetConstrainedDelaunayTriangulation(t){const e=new is(null,t,null);return e.run(),e}FixLocationsForHookAnywherePorts(t){for(const e of t){let t=e.sourcePort instanceof _i;if(t){const t=e.sourcePort;t.SetLocation(this.FigureOutHookLocation(t.LoosePolyline,e.targetPort,e))}else if(t=e.targetPort instanceof _i,t){const t=e.targetPort;t.SetLocation(this.FigureOutHookLocation(t.LoosePolyline,e.sourcePort,e))}}}FigureOutHookLocation(t,e,i){return e instanceof Li?this.FigureOutHookLocationForClusterOtherPort(t,e,i):this.FigureOutHookLocationForSimpleOtherPort(t,e,i)}FigureOutHookLocationForClusterOtherPort(t,e,i){const n=this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(i),r=new Ys(Array.from(e.LoosePolyline).map(this.VisibilityGraph.FindVertex.bind),Array.from(t).map(this.VisibilityGraph.FindVertex.bind),this.VisibilityGraph).GetPath();for(const t of n)t.IsTransparent=!1;return r[r.length-1].point}FigureOutHookLocationForSimpleOtherPort(t,e,i){const n=e.Location,r=this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(i),s=new Zi(this.VisibilityGraph.FindVertex(n),Array.from(t).map(t=>this.VisibilityGraph.FindVertex(t)),this.VisibilityGraph).GetPath();for(const t of r)t.IsTransparent=!1;return s[s.length-1].point}RoutePathsWithSteinerDijkstra(){return this.shortestPathRouter.VisibilityGraph=this.VisibilityGraph,this.shortestPathRouter.BundlingSettings=this.bundlingSettings,this.shortestPathRouter.geomEdges=this.regularEdges,this.shortestPathRouter.ObstacleHierarchy=this.LooseHierarchy,this.shortestPathRouter.RouteEdges(),!(null!=this.shortestPathRouter.CdtProperty&&!this.AnalyzeEdgeSeparation())}AnalyzeEdgeSeparation(){const t=new Map;this.shortestPathRouter.FillCrossedCdtEdges(t);const e=this.GetPathsOnCdtEdge(t),i=this.CalculateMaxAllowedEdgeSeparation(e);if(i>=this.bundlingSettings.EdgeSeparation)return!0;if(i<=.02){for(const t of this.regularEdges)t.curve=null;return!1}return this.bundlingSettings.EdgeSeparation=i,this.shortestPathRouter.RouteEdges(),!0}GetPathsOnCdtEdge(t){const e=new Map;for(const i of t.keys())for(const n of t.get(i))Pe(e,n,i);return e}CalculateMaxAllowedEdgeSeparation(t){let e=.01,i=10;if(this.EdgeSeparationIsOkMN(t,i))return i;for(;Math.abs(i-e)>.01;){const n=(e+i)/2;this.EdgeSeparationIsOkMN(t,n)?e=n:i=n}return e}EdgeSeparationIsOkMN(t,e){const i=t.size;if(0==i)return!0;let n=0;for(const i of t.keys())this.EdgeSeparationIsOk(i,t.get(i),e)&&n++;return n/i>this.bundlingSettings.MinimalRatioOfGoodCdtEdges}EdgeSeparationIsOk(t,e,i){return Array.from(e).map(t=>t.lineWidth).reduce((t,e)=>t+e,0)+(e.size-1)*i<=t.Capacity}RouteSelfEdges(){for(const t of this.edgesToRoute)if(t.source==t.target){const e={smoothedPolyline:null};t.curve=Z.RouteSelfEdge(t.source.boundaryCurve,2*this.LoosePadding,e)}}FixArrowheads(){for(const t of this.edgesToRoute)Q.trimSplineAndCalculateArrowheadsII(t,t.source.boundaryCurve,t.target.boundaryCurve,t.curve,!1)}}Qs.SuperLoosePaddingCoefficient=1.1;class Zs{constructor(t,e,i){this.numberOfPassedPaths=0,this.VisibilityEdge=t,this.Source=e,this.Target=i}get TargetPoint(){return this.Target.Point}get SourcePoint(){return this.Source.Point}get IsOccupied(){return this.numberOfPassedPaths>0}get IsPassable(){return this.Target.IsTargetOfRouting||this.Source.IsSourceOfRouting||null==this.VisibilityEdge.IsPassable||this.VisibilityEdge.IsPassable()}AddOccupiedEdge(){this.numberOfPassedPaths++}RemoveOccupiedEdge(){this.numberOfPassedPaths--}}class Ks{constructor(t){this.InBoneEdges=new Array,this.OutBoneEdges=new Array,this.VisibilityVertex=t}get Prev(){return null==this.PrevEdge?null:this.PrevEdge.Source==this?this.PrevEdge.Target:this.PrevEdge.Source}get Point(){return this.VisibilityVertex.point}get Cost(){return this.IsSourceOfRouting?this.cost:null==this.Prev?Number.POSITIVE_INFINITY:this.cost}set Cost(t){this.cost=t}SetPreviousToNull(){this.PrevEdge=null}}class $s{constructor(t,e,i){this.EdgesToRoutes=new Map,this.EdgesToRouteSources=new Map,this.MakeTransparentShapesOfEdgeGeometry=t,this.CdtProperty=e,this.Gates=i}CreateGraphElements(){for(const t of this.vertexArray){const e=t.VisibilityVertex;for(const i of e.InEdges){const e=new Zs(i,this.VisibilityVerticesToSdVerts.get(i.Source),this.VisibilityVerticesToSdVerts.get(i.Target)),n=this.VisibilityVerticesToSdVerts.get(i.Source);t.InBoneEdges.push(e),n.OutBoneEdges.push(e)}}}CreateRoutingGraph(){this.vertexArray=[],this.VisibilityVerticesToSdVerts=new Map;for(const t of this.VisibilityGraph.Vertices()){const e=new Ks(t);this.vertexArray.push(e),this.VisibilityVerticesToSdVerts.set(t,e)}this.CreateGraphElements()}RouteEdges(){this.Initialize(),this.RestoreCapacities();for(const t of this.geomEdges)this.EdgesToRoutes.set(t,this.RouteEdge(t));this.RerouteEdges();for(const t of this.geomEdges)this.SetEdgeGeometryCurve(t)}SetEdgeGeometryCurve(t){const e=new k;let i=this.EdgesToRouteSources.get(t);e.addPoint(i.Point);for(const n of this.EdgesToRoutes.get(t))n.SourcePoint.equal(i.Point)?(e.addPoint(n.TargetPoint),i=n.Target):(e.addPoint(n.SourcePoint),i=n.Source);t.curve=e;t.sourcePort instanceof Li&&$s.ExtendPolylineStartToClusterBoundary(e,t.sourcePort.Curve);t.targetPort instanceof Li&&$s.ExtendPolylineEndToClusterBoundary(e,t.targetPort.Curve)}static ExtendPolylineEndToClusterBoundary(t,e){const i=e.closestParameter(t.end);t.addPoint(e.value(i))}static ExtendPolylineStartToClusterBoundary(t,e){const i=e.closestParameter(t.start);t.PrependPoint(e.value(i))}RerouteEdges(){this.RestoreCapacities();for(const t of this.geomEdges){const e=this.RerouteEdge(t);this.EdgesToRoutes.set(t,e)}}RestoreCapacities(){null!=this.CdtProperty&&this.CdtProperty.RestoreEdgeCapacities()}RerouteEdge(t){const e=this.EdgesToRoutes.get(t);for(const t of e)t.RemoveOccupiedEdge();return this.RouteEdge(t)}RouteEdge(t){this.CurrentEdgeGeometry=t;for(let t=0;t<this.vertexArray.length;t++){const e=this.vertexArray[t];e.SetPreviousToNull(),e.IsTargetOfRouting=e.IsSourceOfRouting=!1}const e=this.MakeTransparentShapesOfEdgeGeometry(t),i=this.RouteEdgeWithGroups();for(const t of e)t.IsTransparent=!1;return i}RouteEdgeWithGroups(){for(let t=0;t<2;t++){this.SetLengthCoefficient(),this.Queue=new Qi,this.sourceLoosePoly=this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.sourcePort,!0),this.targetLoosePoly=this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.targetPort,!1);const e=this.RouteOnKnownSourceTargetVertices(this.CurrentEdgeGeometry.targetPort.Location.sub(this.CurrentEdgeGeometry.sourcePort.Location).normalize(),0==t);if(null!=e)return e;for(let t=0;t<this.vertexArray.length;t++)this.vertexArray[t].SetPreviousToNull()}throw new Error}RouteOnKnownSourceTargetVertices(t,e){for(this.LowestCostToTarget=Number.POSITIVE_INFINITY,this.ClosestTargetVertex=null;this.Queue.count>0;){const i={priority:0},n=this.Queue.DequeueAndGetPriority(i);if(!(i.priority>=this.LowestCostToTarget)){for(let i=0;i<n.OutBoneEdges.length;i++){const r=n.OutBoneEdges[i];r.IsPassable&&this.ProcessOutcomingBoneEdge(n,r,t,e)}for(let i=0;i<n.InBoneEdges.length;i++){const r=n.InBoneEdges[i];r.IsPassable&&this.ProcessIncomingBoneEdge(n,r,t,e)}}}return this.GetPathAndUpdateRelatedCosts()}ProcessOutcomingBoneEdge(t,e,i,n){n&&i.dot(e.TargetPoint.sub(e.SourcePoint))<0||this.ProcessBoneEdge(t,e.Target,e)}ProcessIncomingBoneEdge(t,e,i,n){n&&i.dot(e.SourcePoint.sub(e.TargetPoint))<0||this.ProcessBoneEdge(t,e.Source,e)}ProcessBoneEdge(t,e,i){const n=this.GetEdgeAdditionalCost(i,t.Cost);if(!(e.Cost<=n))if(e.Cost=n,e.PrevEdge=i,this.Queue.ContainsElement(e))this.Queue.DecreasePriority(e,n);else{if(e.IsTargetOfRouting){let t=0;return this.CurrentEdgeGeometry.targetPort instanceof Li&&(t=this.LengthCoefficient*e.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length),void(n+t<this.LowestCostToTarget&&(this.LowestCostToTarget=n+t,this.ClosestTargetVertex=e))}this.Enqueue(e)}}GetPathAndUpdateRelatedCosts(){let t=this.ClosestTargetVertex;if(null==t)return null;const e=new Array;for(;null!=t.PrevEdge;)e.push(t.PrevEdge),this.RegisterPathInBoneEdge(t.PrevEdge),t=t.Prev;return this.EdgesToRouteSources.set(this.CurrentEdgeGeometry,t),e.reverse(),e}RegisterPathInBoneEdge(t){t.AddOccupiedEdge(),null!=this.CdtProperty&&0!=this.BundlingSettings.CapacityOverflowCoefficient&&this.UpdateResidualCostsOfCrossedCdtEdges(t)}UpdateResidualCostsOfCrossedCdtEdges(t){for(const e of t.CrossedCdtEdges)this.AdjacentToSourceOrTarget(e)||(e.ResidualCapacity==e.Capacity?e.ResidualCapacity-=this.CurrentEdgeGeometry.lineWidth:e.ResidualCapacity-=this.CurrentEdgeGeometry.lineWidth+this.BundlingSettings.EdgeSeparation)}H(t){return t.Cost+this.LengthCoefficient*t.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length}GetEdgeAdditionalCost(t,e){const i=t.TargetPoint.sub(t.SourcePoint).length;return this.LengthCoefficient*i+e+(t.IsOccupied?0:this.BundlingSettings.InkImportance*i)+this.CapacityOverflowCost(t)}CapacityOverflowCost(t){if(null==this.CdtProperty||0==this.BundlingSettings.CapacityOverflowCoefficient)return 0;let e=0;for(const i of this.CrossedCdtEdgesOfBoneEdge(t))e+=this.CostOfCrossingCdtEdgeLocal(this.capacityOverlowPenaltyMultiplier,this.BundlingSettings,this.CurrentEdgeGeometry,i);return e}CrossedCdtEdgesOfBoneEdge(t){return null!=t.CrossedCdtEdges?Array.from(t.CrossedCdtEdges):Array.from(t.CrossedCdtEdges=this.ThreadBoneEdgeThroughCdt(t))}ThreadBoneEdgeThroughCdt(t){const e=t.SourcePoint,i=t.Source.Triangle,n=new Set,r=t.TargetPoint;if(is.PointIsInsideOfTriangle(r,i))return n;const s=new ws(i,e,r);for(;s.MoveNext();){const t=s.CurrentPiercedEdge;this.Gates.has(t)&&n.add(t)}return n}static CostOfCrossingCdtEdge(t,e,i,n){let r=i.lineWidth;n.Capacity!=n.ResidualCapacity&&(r+=e.EdgeSeparation);const s=n.ResidualCapacity-r;return s>=0?0:s*t*-1}CostOfCrossingCdtEdgeLocal(t,e,i,n){return this.AdjacentToSourceOrTarget(n)?0:$s.CostOfCrossingCdtEdge(t,e,i,n)}AdjacentToSourceOrTarget(t){return t.upperSite.Owner==this.sourceLoosePoly||t.lowerSite.Owner==this.sourceLoosePoly||t.upperSite.Owner==this.targetLoosePoly||t.lowerSite.Owner==this.targetLoosePoly}SetLengthCoefficient(){const t=this.GetIdealDistanceBetweenSourceAndTarget(this.CurrentEdgeGeometry);this.LengthCoefficient=this.BundlingSettings.PathLengthImportance/t}GetIdealDistanceBetweenSourceAndTarget(t){return t.sourcePort.Location.sub(t.targetPort.Location).length}SetPortVerticesAndObstacles(t,e){let i;if(t instanceof Li){i=t.LoosePolyline;for(const t of i){let i=0;e&&(i=this.LengthCoefficient*t.sub(this.CurrentEdgeGeometry.sourcePort.Location).length),this.AddAndEnqueueVertexToEnds(t,e,i)}}else if(t instanceof _i){i=t.LoosePolyline;for(const t of i)this.AddAndEnqueueVertexToEnds(t,e,0)}else{this.AddAndEnqueueVertexToEnds(t.Location,e,0);const n=Array.from(this.ObstacleHierarchy.GetNodeItemsIntersectingRectangle(t.Curve.boundingBox));let r=n[0].boundingBox.diagonal;i=n[0];for(let t=1;t<n.length;t++){const e=n[t],s=e.boundingBox.diagonal;s<r&&(r=s,i=e)}}return i}Enqueue(t){this.Queue.Enqueue(t,this.H(t))}AddAndEnqueueVertexToEnds(t,e,i){const n=this.FindVertex(t),r=this.VisibilityVerticesToSdVerts.get(n);e?(r.IsSourceOfRouting=!0,r.Cost=i,this.Enqueue(r)):r.IsTargetOfRouting=!0}FindVertex(t){return this.VisibilityGraph.FindVertex(t)}Initialize(){this.CreateRoutingGraph(),null!=this.CdtProperty&&(this.capacityOverlowPenaltyMultiplier=$s.CapacityOverflowPenaltyMultiplier(this.BundlingSettings),this.SetVertexTriangles(),this.CalculateCapacitiesOfTrianglulation())}CalculateCapacitiesOfTrianglulation(){for(const t of this.Gates)$s.CalculateCdtEdgeCapacityForEdge(t)}static CalculateCdtEdgeCapacityForEdge(t){if(t.Constrained||null==t.CwTriangle||null==t.CcwTriangle)return;const e=t.upperSite.Owner,i=t.lowerSite.Owner;if(e!=i){const n=Wi.DistancePoint(new Wi(e),t.lowerSite.point),r=Wi.DistancePoint(new Wi(i),t.upperSite.point);t.Capacity=(n+r)/2}}SetVertexTriangles(){ki(ot(Array.from(this.CdtProperty.GetTriangles()).map(t=>ut(t,t.BoundingBox()))),ot(this.vertexArray.map(t=>ut(t,G.mkOnPoints([t.Point])))),(t,e)=>this.TryToAssigenTriangleToVertex(t,e));for(const t of this.vertexArray);}TryToAssigenTriangleToVertex(t,e){null==e.Triangle&&is.PointIsInsideOfTriangle(e.Point,t)&&(e.Triangle=t)}static CapacityOverflowPenaltyMultiplier(t){return t.CapacityOverflowCoefficient*(t.PathLengthImportance+t.InkImportance)}FillCrossedCdtEdges(t){for(const e of this.geomEdges){this.sourceLoosePoly=this.SetPortVerticesAndObstacles(e.sourcePort,!0),this.targetLoosePoly=this.SetPortVerticesAndObstacles(e.targetPort,!1);for(const i of this.EdgesToRoutes.get(e))for(const n of this.CrossedCdtEdgesOfBoneEdge(i))this.AdjacentToSourceOrTarget(n)||Pe(t,e,n)}}}class Js{constructor(t,e,i,n,r){this.multiEdges=t,this.interactiveEdgeRouter=e,this.bundlingSettings=n,this.transparentShapeSetter=r,this.nodeTree=lt(i,t=>t.boundingBox)}run(){for(const t of this.GetIndependantPreGraphs()){new Qs(t.edges,new $s(this.transparentShapeSetter,null,null),this.interactiveEdgeRouter.VisibilityGraph,this.bundlingSettings,this.interactiveEdgeRouter.LoosePadding,this.interactiveEdgeRouter.TightHierarchy,this.interactiveEdgeRouter.LooseHierarchy,null,null,null).run()}}GetPortCurve(t){return this.nodeTree.FirstHitNodeWithPredicate(t.Location,(t,e)=>F.PointRelativeToCurveLocation(t,e)!=a.Outside?tt.Stop:tt.Continue).UserData}GetIndependantPreGraphs(){const t=this.CreateInitialPregraphs();for(;;){const e=t.length,i={preGraphs:t};if(this.UniteConnectedPreGraphs(i),e<=t.length)break}return t}UniteConnectedPreGraphs(t){const e=Js.GetIntersectionGraphOfPreGraphs(t.preGraphs);if(null==e)return;const i=Ft(e),n=new Array;for(const e of i){let i=null;for(const r of e)null==i?(i=t.preGraphs[r],n.push(i)):i.AddGraph(t.preGraphs[r])}t.preGraphs=n;for(const e of t.preGraphs)this.AddIntersectingNodes(e)}AddIntersectingNodes(t){const e=t.boundingBox;for(const i of this.nodeTree.GetNodeItemsIntersectingRectangle(e))t.AddNodeBoundary(i)}static GetIntersectionGraphOfPreGraphs(t){const e=Js.EnumeratePairsOfIntersectedPreGraphs(t);return e.length?St(e,t.length):null}static EnumeratePairsOfIntersectedPreGraphs(t){const e=lt(Array.from(Array(t.length).keys()),e=>t[e].boundingBox),i=new Array;return Vi(e,e,(t,e)=>i.push(new wt(t,e))),i}CreateInitialPregraphs(){return this.multiEdges.map(t=>this.CreatePregraphFromSetOfEdgeGeometries(t))}CreatePregraphFromSetOfEdgeGeometries(t){const e=new Set,i=t[0],n=this.GetPortCurve(i.sourcePort),r=n.boundingBox;e.add(n),e.add(i.targetPort.Curve),r.addRec(i.targetPort.Curve.boundingBox);const s=this.nodeTree.GetNodeItemsIntersectingRectangle(r);for(const t of s)e.add(t);return ys.constructorStatic(t,e)}}class to extends K{constructor(t,e,i=2,n=1.5,r=Math.PI/180*30,s=null,o=null){super(o),this.continueOnOverlaps=!0,this.shapesToTightLooseCouples=new Map,this.portLocationsToLoosePolylines=new Ie,this.multiEdgesSeparation=5,this.routeMultiEdgesAsBundles=!0,this.UsePolylineEndShortcutting=!0,this.UseInnerPolylingShortcutting=!0,this.AllowedShootingStraightLines=!0,this._overlapsDetected=!1,this.KeepOriginalSpline=!1,this.ArrowHeadRatio=0,this.bidirectional=!1,this._edges=e,this.BundlingSettings=s,this.geomGraph=t,this.LoosePadding=n,this.tightPadding=i,this.coneAngle=r}get ContinueOnOverlaps(){return this.continueOnOverlaps}set ContinueOnOverlaps(t){this.continueOnOverlaps=t}*edges(){if(null!=this._edges)for(const t of this._edges)yield t}get LoosePadding(){return this.loosePadding}set LoosePadding(t){this.loosePadding=t}get MultiEdgesSeparation(){return this.multiEdgesSeparation}set MultiEdgesSeparation(t){this.multiEdgesSeparation=t}static mk2(t,e){return to.mk5(t,e.Padding,e.PolylinePadding,e.ConeAngle,e.BundlingSettings)}static mk4(t,e,i,n){return new to(t,Array.from(t.edges()),e,i,n,null)}static mk5(t,e,i,n,r){return new to(t,Array.from(t.edges()),e,i,n,r)}static mk6(t,e,i,n,r,s){const o=to.mk4(t,e,i,n),a=Mi.GetShapes(r,s);return o.Initialize(a,n),o}Initialize(t,e){this.rootShapes=t.filter(t=>null==t.Parents||0==t.Parents.length),this.coneAngle=e,0==this.coneAngle&&(this.coneAngle=Math.PI/6)}run(){if(this.geomGraph.isEmpty())return;const t=cn.GetShapes(this.geomGraph,this._edges);null==this.BundlingSettings&&this.geomGraph.layoutSettings&&this.geomGraph.layoutSettings.edgeRoutingSettings&&this.geomGraph.layoutSettings.edgeRoutingSettings.BundlingSettings&&(this.BundlingSettings=this.geomGraph.layoutSettings.edgeRoutingSettings.BundlingSettings),this.Initialize(t,this.coneAngle),this.GetOrCreateRoot(),this.RouteOnRoot(),this.RemoveRoot()}RouteOnRoot(){this.CalculatePortsToShapes(),this.CalculatePortsToEnterableShapes(),this.CalculateShapeToBoundaries(this.root),this.OverlapsDetected&&!this.ContinueOnOverlaps||(this.BindLooseShapes(),this.SetLoosePolylinesForAnywherePorts(),this.CalculateVisibilityGraph(),this.RouteOnVisGraph())}CalculatePortsToEnterableShapes(){this.portsToEnterableShapes=new Map;for(const[t,e]of this.portsToShapes){const i=new Set;to.EdgesAttachedToPortAvoidTheNode(t)||i.add(e),this.portsToEnterableShapes.set(t,i)}for(const t of this.rootShapes)for(const e of t.Descendants())for(const t of e.Ports){me(this.portsToEnterableShapes.get(t),Array.from(e.Ancestors()).filter(t=>null!=t.BoundaryCurve))}}static EdgesAttachedToPortAvoidTheNode(t){return t instanceof Ri||t instanceof Li}SetLoosePolylinesForAnywherePorts(){for(const[t,e]of this.shapesToTightLooseCouples)for(const i of t.Ports){if(i instanceof _i){i.LoosePolyline=e.LooseShape.BoundaryCurve}if(i instanceof Li){i.LoosePolyline=e.LooseShape.BoundaryCurve}}}BindLooseShapes(){this.looseRoot=new Ze;for(const t of this.root.Children){const e=this.shapesToTightLooseCouples.get(t).LooseShape;this.BindLooseShapesUnderShape(t),this.looseRoot.AddChild(e)}}BindLooseShapesUnderShape(t){const e=this.shapesToTightLooseCouples.get(t).LooseShape;for(const i of t.Children){const t=this.shapesToTightLooseCouples.get(i).LooseShape;e.AddChild(t),this.BindLooseShapesUnderShape(i)}}CalculateShapeToBoundaries(t){if(this.ProgressStep(),0==t.Children.length)return;for(const e of t.Children)this.CalculateShapeToBoundaries(e);const e=new Xi(t,this.tightPadding,this.AdjustedLoosePadding,this.shapesToTightLooseCouples);e.Calculate(),this.OverlapsDetected||(this.OverlapsDetected=e.OverlapsDetected)}get OverlapsDetected(){return this._overlapsDetected}set OverlapsDetected(t){this._overlapsDetected=t}get AdjustedLoosePadding(){return null==this.BundlingSettings?this.LoosePadding:this.LoosePadding*Qs.SuperLoosePaddingCoefficient}GroupEdgesByPassport(){const t=new Array;for(const e of this._edges){const i=this.EdgePassport(e);let n=t.find(t=>ye(t.passport,i));n||(n={passport:i,edges:[]},t.push(n)),n.edges.push(e)}return t}RouteOnVisGraph(){if(this.ancestorSets=to.GetAncestorSetsMap(Array.from(this.root.Descendants())),null==this.BundlingSettings)for(const t of this.GroupEdgesByPassport()){const e=t.passport,i=this.GetObstaclesFromPassport(e),n=this.CreateInteractiveEdgeRouter(Array.from(i));this.RouteEdgesWithTheSamePassport(t,n,i)}else this.RouteBundles()}RouteEdgesWithTheSamePassport(t,e,i){const n={regularEdges:[],multiEdges:[]};if(this.RouteMultiEdgesAsBundles){this.SplitOnRegularAndMultiedges(t.edges,n);for(const t of n.regularEdges)this.RouteEdge(e,t);null!=n.multiEdges&&(this.ScaleDownLooseHierarchy(e,i),this.RouteMultiEdges(n.multiEdges,e,t.passport))}else for(const i of t.edges)this.RouteEdge(e,i)}get RouteMultiEdgesAsBundles(){return this.routeMultiEdgesAsBundles}set RouteMultiEdgesAsBundles(t){this.routeMultiEdgesAsBundles=t}RouteEdge(t,e){const i=this.MakeTransparentShapesOfEdgeGeometryAndGetTheShapes(e);this.ProgressStep(),this.RouteEdgeInternal(e,t),to.SetTransparency(i,!1)}ScaleDownLooseHierarchy(t,e){const i=new Array;for(const t of e){const e=this.shapesToTightLooseCouples.get(t);i.push(Hi.LoosePolylineWithFewCorners(e.TightPolyline,e.Distance/1.1))}t.LooseHierarchy=to.CreateLooseObstacleHierarachy(i),t.ClearActivePolygons(),t.AddActivePolygons(i.map(t=>new Wi(t)))}RouteMultiEdges(t,e,i){const n=[];for(const t of i)for(const e of t.Children)n.push(e.BoundaryCurve);const r=new Gt;r.InkImportance=1e-5,r.EdgeSeparation=this.MultiEdgesSeparation;new Js(t,e,n,r,t=>this.MakeTransparentShapesOfEdgeGeometryAndGetTheShapes(t)).run()}SplitOnRegularAndMultiedges(t,e){const i=new un;for(const n of t)to.IsEdgeToParent(n)?e.regularEdges.push(n):to.RegisterInPortLocationsToEdges(n,i);e.multiEdges=null;for(const t of i.values())1==t.length||this.OverlapsDetected?e.regularEdges.push(t[0]):(null==e.multiEdges&&(e.multiEdges=new Array),e.multiEdges.push(t))}static RegisterInPortLocationsToEdges(t,e){let i;const n=new ue(t.sourcePort.Location,t.targetPort.Location);i=e.get(n),i||(i=new Array,e.set(n,i)),i.push(t)}static IsEdgeToParent(t){return t.sourcePort instanceof _i||t.targetPort instanceof _i}CreateInteractiveEdgeRouter(t){const e=new Set(t.map(t=>this.shapesToTightLooseCouples.get(t).LooseShape.BoundaryCurve)),i=new hn(this.cancelToken);return i.ObstacleCalculator=new Hi(t.map(t=>t.BoundaryCurve),this.tightPadding,this.loosePadding,!1),i.VisibilityGraph=this.visGraph,i.TightHierarchy=this.CreateTightObstacleHierarachy(t),i.LooseHierarchy=to.CreateLooseObstacleHierarachy(Array.from(e)),i.UseSpanner=!0,i.LookForRoundedVertices=!0,i.TightPadding=this.tightPadding,i.LoosePadding=this.LoosePadding,i.UseEdgeLengthMultiplier=this.UseEdgeLengthMultiplier,i.UsePolylineEndShortcutting=this.UsePolylineEndShortcutting,i.UseInnerPolylingShortcutting=this.UseInnerPolylingShortcutting,i.AllowedShootingStraightLines=this.AllowedShootingStraightLines,i.AddActivePolygons(Array.from(e).map(t=>new Wi(t))),i}GetObstaclesFromPassport(t){if(0==t.size)return new Set(this.root.Children);const e=this.GetCommonAncestorsAbovePassport(t),i=this.GetAllAncestors(t),n=new Set;for(const e of t)for(const t of e.Children)i.has(t)||n.add(t);const r=ge(new Set(t),n),s=new h.Queue;for(const i of t)e.has(i)||s.enqueue(i);for(;s.length>0;){const t=s.dequeue();for(const o of t.Parents){for(const t of o.Children)i.has(t)||n.add(t);e.has(o)||r.has(o)||(s.enqueue(o),r.add(o))}}return n}GetAllAncestors(t){if(0==t.size)return new Set;let e=new Set(t);for(const i of t)e=ge(e,this.ancestorSets.get(i));return e}GetCommonAncestorsAbovePassport(t){if(0==t.size)return new Set;const e=Array.from(t);let i=this.ancestorSets.get(e[0]);for(let t=1;t<e.length;t++){const n=e[t];i=pe(i,this.ancestorSets.get(n))}return i}RouteBundles(){this.ScaleLooseShapesDown(),this.CalculateEdgeEnterablePolylines();const t=this.GetLooseHierarchy(),e=Qs.CreateConstrainedDelaunayTriangulation(t),i=new $s(t=>this.MakeTransparentShapesOfEdgeGeometryAndGetTheShapes(t),e,this.FindCdtGates(e));new Qs(this._edges,i,this.visGraph,this.BundlingSettings,this.LoosePadding,this.GetTightHierarchy(),t,this.enterableLoose,this.enterableTight,t=>this.LoosePolyOfOriginalShape(this.portsToShapes.get(t))).run()}CreateTheMapToParentLooseShapes(t,e){for(const i of t.Children){const n=this.shapesToTightLooseCouples.get(i).LooseShape.BoundaryCurve;e.set(n,t),this.CreateTheMapToParentLooseShapes(i,e)}}FindCdtGates(t){const e=new Map;this.CreateTheMapToParentLooseShapes(this.root,e);const i=new Set;for(const n of t.PointsToSites.values())for(const t of n.Edges){if(null==t.CwTriangle&&null==t.CcwTriangle)continue;const r=n.Owner,s=t.lowerSite.Owner;if(r==s)continue;const o=e.get(r);if(o){o==e.get(s)&&i.add(t)}}return i}CalculateEdgeEnterablePolylines(){this.enterableLoose=new Map,this.enterableTight=new Map;for(const t of this.edges()){const e=new Set,i=new Set;this.GetEdgeEnterablePolylines(t,e,i),this.enterableLoose.set(t,e),this.enterableTight.set(t,i)}}GetEdgeEnterablePolylines(t,e,i){const n=this.portsToShapes.get(t.sourcePort),r=this.portsToShapes.get(t.targetPort);n!=this.root&&this.GetEnterablesForShape(n,e,i),r!=this.root&&this.GetEnterablesForShape(r,e,i)}GetEnterablesForShape(t,e,i){for(const n of this.ancestorSets.get(t)){const t=this.LoosePolyOfOriginalShape(n);t&&e.add(t);const r=this.TightPolyOfOriginalShape(n);r&&i.add(r)}}GetTightHierarchy(){return ot(Array.from(this.shapesToTightLooseCouples.values()).map(t=>ut(t.TightPolyline,t.TightPolyline.boundingBox)))}GetLooseHierarchy(){const t=new Set;for(const e of this.shapesToTightLooseCouples.values())t.add(e.LooseShape.BoundaryCurve);return ot(Array.from(t).map(t=>ut(t,t.boundingBox)))}ScaleLooseShapesDown(){for(const[,t]of this.shapesToTightLooseCouples)t.LooseShape.BoundaryCurve=Hi.LoosePolylineWithFewCorners(t.TightPolyline,t.Distance/Qs.SuperLoosePaddingCoefficient)}EdgePassport(t){const e=new Set,i=this.portsToShapes.get(t.sourcePort),n=this.portsToShapes.get(t.targetPort);return this.IsAncestor(i,n)?(me(e,n.Parents),e.add(i),e):this.IsAncestor(n,i)?(me(e,i.Parents),e.add(n),e):(i!=this.looseRoot&&me(e,i.Parents),n!=this.looseRoot&&me(e,n.Parents),e)}*AllPorts(){for(const t of this.edges())yield t.sourcePort,yield t.targetPort}CalculatePortsToShapes(){this.portsToShapes=new Map;for(const t of this.root.Descendants())for(const e of t.Ports)this.portsToShapes.set(e,t);for(const t of this.AllPorts())this.portsToShapes.has(t)||(this.root.Ports.add(t),this.portsToShapes.set(t,this.root))}RouteEdgeInternal(t,e){const i=new Array;t.sourcePort instanceof _i||fe(i,this.AddVisibilityEdgesFromPort(t.sourcePort)),t.targetPort instanceof _i||fe(i,this.AddVisibilityEdgesFromPort(t.targetPort));const n={smoothedPolyline:null};if(E.closeDistEps(t.sourcePort.Location,t.targetPort.Location)?t.curve=Z.RouteSelfEdge(t.sourcePort.Curve,Math.max(2*this.LoosePadding,t.GetMaxArrowheadLength()),n):t.curve=e.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(t.sourcePort,t.targetPort,!0,n),t.smoothedPolyline=n.smoothedPolyline,null==t.curve)throw new Error;for(const t of i)di.RemoveEdge(t);Q.trimSplineAndCalculateArrowheadsII(t,t.sourcePort.Curve,t.targetPort.Curve,t.curve,!1)}*AddVisibilityEdgesFromPort(t){let e,i;if(t instanceof Ri||!(e=this.portsToShapes.get(t))||!(i=this.shapesToTightLooseCouples.get(e)))return;const n=i.LooseShape;for(const e of n.BoundaryCurve)null==this.visGraph.FindEdgePP(t.Location,e)&&(yield this.visGraph.AddEdgePP(t.Location,e))}MakeTransparentShapesOfEdgeGeometryAndGetTheShapes(t){const e=this.portsToShapes.get(t.sourcePort),i=this.portsToShapes.get(t.targetPort),n=new Array;for(const r of this.GetTransparentShapes(t.sourcePort,t.targetPort,e,i))null!=r&&n.push(this.LooseShapeOfOriginalShape(r));for(const e of this.portsToEnterableShapes.get(t.sourcePort))n.push(this.LooseShapeOfOriginalShape(e));for(const e of this.portsToEnterableShapes.get(t.targetPort))n.push(this.LooseShapeOfOriginalShape(e));return to.SetTransparency(n,!0),n}LooseShapeOfOriginalShape(t){return t==this.root?this.looseRoot:this.shapesToTightLooseCouples.get(t).LooseShape}LoosePolyOfOriginalShape(t){return this.LooseShapeOfOriginalShape(t).BoundaryCurve}TightPolyOfOriginalShape(t){return t==this.root?null:this.shapesToTightLooseCouples.get(t).TightPolyline}*GetTransparentShapes(t,e,i,n){for(const t of this.ancestorSets.get(i))yield t;for(const t of this.ancestorSets.get(n))yield t;to.EdgesAttachedToPortAvoidTheNode(t)||(yield i),to.EdgesAttachedToPortAvoidTheNode(e)||(yield n)}static SetTransparency(t,e){for(const i of t)i.IsTransparent=e}IsAncestor(t,e){let i;return null!=e&&null!=(i=this.ancestorSets.get(e))&&i.has(t)}static CreateLooseObstacleHierarachy(t){return ot(t.map(t=>ut(t,t.boundingBox)))}CreateTightObstacleHierarachy(t){return ot(t.map(t=>this.shapesToTightLooseCouples.get(t).TightPolyline).map(t=>ut(t,t.boundingBox)))}CalculateVisibilityGraph(){const t=null!=this.LineSweeperPorts?ce.mk(this.LineSweeperPorts):new ce;this.ProcessHookAnyWherePorts(t),this.portRTree=dt(Array.from(t.values()).map(t=>[G.rectangleOnPoint(t),t])),this.visGraph=new di,this.FillVisibilityGraphUnderShape(this.root)}static ShowVisGraph(t,e,i,n=null,r=null){const s=Array.from(e.Edges).map(t=>Xe.mkDebugCurveTWCI(100,1,null!=t.IsPassable&&t.IsPassable()?"green":"black",I.mkPP(t.SourcePoint,t.TargetPoint)));if(null!=i)for(const t of i){s.push(Xe.mkDebugCurveTWCI(100,.3,"brown",t));for(const e of t)s.push(Xe.mkDebugCurveTWCI(100,1,"green",H.mkCircle(1,e)))}if(null!=n)for(const t of n)s.push(Xe.mkDebugCurveTWCI(100,10,"navy",t));if(null!=r)for(const t of r)s.push(Xe.mkDebugCurveTWCI(100,10,"red",t))}ProcessHookAnyWherePorts(t){for(const e of this.edges())e.sourcePort instanceof _i||e.sourcePort instanceof Li||t.add(e.sourcePort.Location),e.targetPort instanceof _i||e.targetPort instanceof Li||t.add(e.targetPort.Location)}FillVisibilityGraphUnderShape(t){const e=t.Children;for(const t of e)this.FillVisibilityGraphUnderShape(t);const i=this.shapesToTightLooseCouples.get(t),n=i?i.LooseShape.BoundaryCurve:null,r=i?i.LooseShape:this.looseRoot,s=new Set(r.Children.map(t=>t.BoundaryCurve)),o=this.RemoveInsidePortsAndSplitBoundaryIfNeeded(n);let a=new di,l=Oi.mk([],a,this.coneAngle,o,n);l.run(),a=new di,l=Oi.mk(Array.from(s),a,this.coneAngle,o,n),l.run(),this.ProgressStep();for(const t of a.Edges)this.TryToCreateNewEdgeAndSetIsPassable(t,r);this.AddBoundaryEdgesToVisGraph(n)}get Bidirectional(){return this.bidirectional}set Bidirectional(t){this.bidirectional=t}TryToCreateNewEdgeAndSetIsPassable(t,e){let i=this.visGraph.FindEdgePP(t.SourcePoint,t.TargetPoint);null==i&&(i=this.visGraph.AddEdgePP(t.SourcePoint,t.TargetPoint),null!=e&&(i.IsPassable=()=>e.IsTransparent))}AddBoundaryEdgesToVisGraph(t){if(null==t)return;let e;for(let i=t.startPoint;e=i.nextOnPolyline,this.visGraph.AddEdgePP(i.point,e.point),e!=t.startPoint;i=e);}RemoveInsidePortsAndSplitBoundaryIfNeeded(t){const e=new ce;if(null==t){for(const t of this.portRTree.GetAllLeaves())e.add(t);return this.portRTree.Clear(),e}const i=t.boundingBox,n=this.portRTree.GetAllIntersecting(i);for(const i of n)switch(F.PointRelativeToCurveLocation(i,t)){case a.Inside:e.add(i),this.portLocationsToLoosePolylines.set(i,t),this.portRTree.Remove(G.rectangleOnPoint(i),i);break;case a.Boundary:this.portRTree.Remove(G.rectangleOnPoint(i),i),this.portLocationsToLoosePolylines.set(i,t);const n=to.FindPointOnPolylineToInsertAfter(t,i);if(null==n)throw new Error;Ii.InsertPointIntoPolylineAfter(t,n,i)}return e}static FindPointOnPolylineToInsertAfter(t,e){for(let i=t.startPoint;;){const n=i.nextOnPolyline;if(E.closeDistEps(e,i.point)||E.closeDistEps(e,n.point))return null;if(v(E.distToLineSegment(e,i.point,n.point).dist,0))return i;if(i=n,i==t.startPoint)throw new Error}}GetOrCreateRoot(){if(1==this.rootShapes.length){const t=this.rootShapes[0];if(null==t.BoundaryCurve)return void(this.root=t)}this.rootWasCreated=!0,this.root=new Ze(null);for(const t of this.rootShapes)this.root.AddChild(t)}RemoveRoot(){if(this.rootWasCreated)for(const t of this.rootShapes)t.RemoveParent(this.root)}static GetAncestorSetsMap(t){const e=new Map;for(const i of t.filter(t=>!e.has(t)))e.set(i,to.GetAncestorSet(i,e));return e}static GetAncestorSet(t,e){const i=new Set(t.Parents);for(const n of t.Parents){let t=e.get(n);t||e.set(n,t=to.GetAncestorSet(n,e));for(const e of t)i.add(e)}return i}static CreatePortsIfNeeded(t){for(const e of t){if(null==e.sourcePort){const t=e;new Je(()=>t.source.boundaryCurve,()=>t.source.center,new E(0,0))}if(null==e.targetPort){const t=e;new Je(()=>t.target.boundaryCurve,()=>t.target.center,new E(0,0))}}}static ComputeLooseSplinePadding(t,e){return(t-2*e)/8}}to.debCount=0;class eo extends K{constructor(t,e){super(null),this.edges=t,this.padding=e}run(){to.CreatePortsIfNeeded(this.edges);for(const t of this.edges)eo.RouteEdge(t,this.padding)}static RouteEdge(t,e){const i=t;null==i.sourcePort&&(i.sourcePort=Je.mk(()=>t.source.boundaryCurve,()=>t.source.center)),null==i.targetPort&&(i.targetPort=Je.mk(()=>t.target.boundaryCurve,()=>t.target.center)),eo.ContainmentLoop(i,e)||(i.curve=eo.GetEdgeLine(t)),Q.trimSplineAndCalculateArrowheadsII(i,i.sourcePort.Curve,i.targetPort.Curve,t.curve,!1)}static ContainmentLoop(t,e){const i=t.sourcePort.Curve,n=t.targetPort.Curve;if(null==i||null==n)return!1;const r=i.boundingBox,s=n.boundingBox,o=r.containsRect(s),a=!o&&s.containsRect(r);return!(!o&&!a)&&(t.curve=eo.CreateLoop(r,s,a,e),!0)}static CreateLoop(t,e,i,n){return i?eo.CreateLoop_(t,e,n,!1):eo.CreateLoop_(e,t,n,!0)}static CreateLoop_(t,e,i,n){const r=t.center,s=eo.FindClosestPointOnBoxBoundary(t.center,e);let o=s.sub(r);const a=(Math.abs(o.x)<y.distanceEpsilon?Math.min(r.y-e.bottom,e.top-r.y):Math.min(r.x-e.left,e.right-r.x))/2,l=Math.min(i,a);o.length<=y.distanceEpsilon&&(o=new E(1,0));const h=o.normalize(),u=h.rotate(Math.PI/2),c=s.add(h.mul(i)),d=c.add(u.mul(l)),g=s.add(u.mul(l)),f=r.add(u.mul(l));return(n?Y.mkFromPoints([f,g,d,c,s,r]):Y.mkFromPoints([r,s,c,d,g,f])).createCurve()}static FindClosestPointOnBoxBoundary(t,e){const i=t.x-e.left<e.right-t.x?e.left:e.right,n=t.y-e.bottom<e.top-t.y?e.bottom:e.top;return Math.abs(i-t.x)<Math.abs(n-t.y)?new E(i,t.y):new E(t.x,n)}static GetEdgeLine(t){let e,i,n,r;null==t.sourcePort?(e=t.source.center,i=t.source.boundaryCurve):(e=t.sourcePort.Location,i=t.sourcePort.Curve),null==t.targetPort?(n=t.target.center,r=t.target.boundaryCurve):(n=t.targetPort.Location,r=t.targetPort.Curve);let s=I.mkPP(e,n),o=F.getAllIntersections(i,s,!1);if(o.length>0){let t=s.trim(o[0].par1,1);t instanceof I&&(s=t,o=F.getAllIntersections(r,s,!1),o.length>0&&(t=s.trim(0,o[0].par1),t instanceof I&&(s=t)))}return s}static CreateSimpleEdgeCurveWithUnderlyingPolyline(t){const e=t.source.center,i=t.target.center;if(t.source==t.target){const i=2/(3*t.source.boundaryCurve.boundingBox.width),n=t.source.boundingBox.height/4;t.underlyingPolyline=eo.CreateUnderlyingPolylineForSelfEdge(e,i,n),t.curve=t.underlyingPolyline.createCurve()}else t.underlyingPolyline=Y.mkFromPoints([e,i]),t.curve=t.underlyingPolyline.createCurve();Q.trimSplineAndCalculateArrowheadsII(t,t.source.boundaryCurve,t.target.boundaryCurve,t.curve,!1)}static CreateUnderlyingPolylineForSelfEdge(t,e,i){const n=t.add(new E(0,i)),r=t.add(new E(e,i)),s=t.add(new E(e,-1*i)),o=t.add(new E(0,-1*i));let a=X.mkSiteP(t);const l=new Y(a);return a=X.mkSiteSP(a,n),a=X.mkSiteSP(a,r),a=X.mkSiteSP(a,s),a=X.mkSiteSP(a,o),X.mkSiteSP(a,t),l}static SetStraightLineEdgesWithUnderlyingPolylines(t){to.CreatePortsIfNeeded(Array.from(t.edges()));for(const e of t.edges())eo.CreateSimpleEdgeCurveWithUnderlyingPolyline(e)}}class io extends K{constructor(t,e,i,n,r,s){super(null),this.settings=t,this.OriginalGraph=e,this.Database=i,this.ProperLayeredGraph=r,this.LayerArrays=n,this.IntGraph=s}run(){this.createSplines()}createSplines(){this.createRegularSplines(),this.createSelfSplines(),null!=this.IntGraph&&this.RouteFlatEdges(),null==this.OriginalGraph.graph.parent&&this.RouteUnroutedEdges()}RouteUnroutedEdges(){for(const t of this.OriginalGraph.deepNodes())for(const e of t.outEdges())e.curve||eo.RouteEdge(e,Math.max(e.source.padding,e.target.padding))}RouteFlatEdges(){}createRegularSplines(){for(const t of this.Database.RegularMultiedges()){const e=t.length,i=1==e&&!this.FanAtSourceOrTarget(t[0]);for(let n=Math.floor(e/2);n<e;n++)this.createSplineForNonSelfEdge(t[n],i);for(let n=Math.floor(e/2)-1;n>=0;n--)this.createSplineForNonSelfEdge(t[n],i)}}FanAtSourceOrTarget(t){return this.ProperLayeredGraph.OutDegreeIsMoreThanOne(t.source)||this.ProperLayeredGraph.InDegreeIsMoreThanOne(t.target)}createSelfSplines(){for(const[t,e]of this.Database.Multiedges.keyValues()){const i=t;if(i.x==i.y){const t=this.Database.Anchors[i.x];let n=t.leftAnchor;for(const i of e){const e=this.settings.NodeSeparation+(this.settings.MinNodeWidth+n),r=t.bottomAnchor/2,s=t.origin,o=s.add(new E(0,r)),a=s.add(new E(e,r)),l=s.add(new E(e,-1*r)),h=s.add(new E(0,-1*r));let u=X.mkSiteP(s);const c=new Y(u);u=X.mkSiteSP(u,o),u=X.mkSiteSP(u,a),u=X.mkSiteSP(u,l),u=X.mkSiteSP(u,h),X.mkSiteSP(u,s);const d=c.createCurve();if(i.curve=d,i.edge.underlyingPolyline=c,n=e,null!=i.edge.label){n+=i.edge.label.width;const e=i.edge.label.center=new E(d.value((d.parStart+d.parEnd)/2).x+i.labelWidth/2,t.y),r=new E(i.edge.label.width/2,i.edge.label.height/2),s=G.mkPP(e.add(r),e.sub(r));i.edge.label.boundingBox=s}Q.trimSplineAndCalculateArrowheadsII(i.edge,i.edge.source.boundaryCurve,i.edge.target.boundaryCurve,d,!1)}}}}createSplineForNonSelfEdge(t,e){null!=t.LayerEdges&&(this.drawSplineBySmothingThePolyline(t,e),t.IsVirtualEdge||(t.updateEdgeLabelPosition(this.Database.Anchors),Q.trimSplineAndCalculateArrowheadsII(t.edge,t.edge.source.boundaryCurve,t.edge.target.boundaryCurve,t.curve,!0)))}drawSplineBySmothingThePolyline(t,e){const i=new Qe(t,this.Database.Anchors,this.OriginalGraph,this.settings,this.LayerArrays,this.ProperLayeredGraph,this.Database),n=i.getSpline(e);t.reversed?(t.curve=n.reverse(),t.underlyingPolyline=i.Reverse().GetPolyline):(t.curve=n,t.underlyingPolyline=i.GetPolyline)}static UpdateLabel(t,e){let i=null;e.labelIsToTheRightOfTheSpline?(t.label.center=new E(e.x+e.rightAnchor/2,e.y),i=I.mkPP(t.labelBBox.leftTop,t.labelBBox.leftBottom)):e.labelIsToTheLeftOfTheSpline&&(t.label.center=new E(e.x-e.leftAnchor/2,e.y),i=I.mkPP(t.labelBBox.rightTop,t.labelBBox.rightBottom));const n=io.GetSegmentInFrontOfLabel(t.curve,t.label.center.y);if(null!=n&&0==F.getAllIntersections(t.curve,F.polyFromBox(t.labelBBox),!1).length){const e={curveClosestPoint:void 0,labelSideClosest:void 0};if(io.FindClosestPoints(e,n,i))io.ShiftLabel(t,e);else{const r=n.closestParameter(i.start),s=n.closestParameter(i.end);n.value(r).sub(i.start).length<n.value(s).sub(i.end).length?(e.curveClosestPoint=n.value(r),e.labelSideClosest=i.start):(e.curveClosestPoint=n.value(s),e.labelSideClosest=i.end),io.ShiftLabel(t,e)}}}static ShiftLabel(t,e){const i=t.lineWidth/2,n=e.curveClosestPoint.sub(e.labelSideClosest),r=n.length;r>i&&(t.label.center=t.label.center.add(n.div(r*(r-i))))}static FindClosestPoints(t,e,i){const n=F.minDistWithinIntervals(e,i,e.parStart,e.parEnd,i.parStart,i.parEnd,(e.parStart+e.parEnd)/2,(i.parStart+i.parEnd)/2);return!!n&&(t.curveClosestPoint=n.aX,t.labelSideClosest=n.bX,!0)}static GetSegmentInFrontOfLabel(t,e){if(t instanceof F){const i=t;for(const t of i.segs)if((t.start.y-e)*(t.end.y-e)<=0)return t}return null}static GetNodeKind(t,e){return 0==t?Ge.Top:t<e.count?Ge.Internal:Ge.Bottom}}class no extends K{constructor(t,e,i){if(super(i),this.LayersAreDoubled=!1,null==t)return;this.originalGraph=t,this.sugiyamaSettings=e;const n=Array.from(t.shallowNodes());this.nodeIdToIndex=new Map;let r=0;for(const t of n)this.nodeIdToIndex.set(t.id,r++);const s=[];for(const t of this.originalGraph.edges()){const e=this.nodeIdToIndex.get(t.source.id);if(null==e)continue;const i=this.nodeIdToIndex.get(t.target.id);if(null==i)continue;const n=new Bt(e,i,t);s.push(n)}this.IntGraph=new Ht(s,t.shallowNodeCount),this.IntGraph.nodes=n,this.database=new qt(n.length);for(const t of this.IntGraph.edges)this.database.registerOriginalEdgeInMultiedges(t);this.cycleRemoval()}get verticalConstraints(){return this.sugiyamaSettings.verticalConstraints}get HorizontalConstraints(){return this.sugiyamaSettings.horizontalConstraints}run(){0!=this.originalGraph.shallowNodeCount?(!function(t,e){if(e.isIdentity())return;const i=e.inverse();for(const e of t.shallowNodes())e.transform(i);for(const e of t.edges())if(null!=e.label){const t=G.mkPP(i.multiplyPoint(new E(0,0)),i.multiplyPoint(new E(e.label.width,e.label.height)));e.label.width=t.width,e.label.height=t.height}}(this.originalGraph,this.sugiyamaSettings.transform),this.engineLayerArrays=this.calculateLayers(),this.sugiyamaSettings.edgeRoutingSettings.EdgeRoutingMode==It.SugiyamaSplines&&this.runPostLayering(),function(t,e){if(e.isIdentity())return;for(const i of t.shallowNodes())i.transform(e);for(const i of t.edges())if(null!=i.label){const t=G.mkPP(e.multiplyPoint(new E(0,0)),e.multiplyPoint(new E(i.label.width,i.label.height)));i.label.width=t.width,i.label.height=t.height}!function(t,e){for(const i of t.edges())null!=i.label&&(i.label.center=e.multiplyPoint(i.label.center)),fo(e,i)}(t,e)}(this.originalGraph,this.sugiyamaSettings.transform),this.originalGraph.updateBoundingBox(),this.SetMargins()):this.originalGraph.boundingBox=G.mkEmpty()}SetMargins(){this.originalGraph.boundingBox.right+=this.sugiyamaSettings.margins.right,this.originalGraph.boundingBox.top+=this.sugiyamaSettings.margins.bottom,this.originalGraph.boundingBox.left-=this.sugiyamaSettings.margins.left,this.originalGraph.boundingBox.bottom-=this.sugiyamaSettings.margins.bottom}runPostLayering(){const t=this.sugiyamaSettings.edgeRoutingSettings,e=null!=this.constrainedOrdering?It.Spline:t.EdgeRoutingMode;switch(e){case It.SugiyamaSplines:this.calculateEdgeSplines();break;case It.StraightLine:case It.Spline:case It.SplineBundling:throw new Error("not implemented");case It.Rectilinear:case It.RectilinearToCenter:throw new Error("Not implemented yet");default:throw new Error("Unexpected mode "+e)}}SetLabels(){throw new Error("not implementedt")}cycleRemoval(){const t=this.sugiyamaSettings.verticalConstraints,e=t.isEmpty?At.getFeedbackSet(this.IntGraph):t.getFeedbackSetExternal(this.IntGraph,this.nodeIdToIndex);this.database.addFeedbackSet(e)}calculateLayers(){this.CreateGluedDagSkeletonForLayering();const t=this.CalculateLayerArrays();return this.UpdateNodePositionData(),t}UpdateNodePositionData(){this.TryToSatisfyMinWidhtAndMinHeight();for(let t=0;t<this.IntGraph.nodeCount&&t<this.database.Anchors.length;t++)this.IntGraph.nodes[t].center=this.database.Anchors[t].origin;if(this.sugiyamaSettings.GridSizeByX>0)for(let t=0;t<this.originalGraph.shallowNodeCount;t++)this.SnapLeftSidesOfTheNodeToGrid(t,this.sugiyamaSettings.GridSizeByX)}SnapLeftSidesOfTheNodeToGrid(t,e){const i=this.IntGraph.nodes[t],n=this.database.Anchors[t];n.leftAnchor-=e/2,n.rightAnchor-=e/2;const r=i.boundingBox.left,s=r-Math.floor(r/e)*e;Math.abs(s)<.001||(Math.abs(s)<=e/2?i.center=i.center.add(new E(-s,0)):i.center=i.center.add(new E(e-s,0)),n.x=i.center.x)}TryToSatisfyMinWidhtAndMinHeight(){this.TryToSatisfyMinWidth(),this.TryToSatisfyMinHeight()}TryToSatisfyMinWidth(){if(0==this.sugiyamaSettings.MinimalWidth)return;this.GetCurrentWidth()<this.sugiyamaSettings.MinimalWidth&&this.StretchWidth()}StretchWidth(){const t=new Wt;for(const e of this.originalGraph.shallowNodes())t.AddValue(e.boundingBox.width/2),t.AddValue(this.sugiyamaSettings.MinimalWidth-e.boundingBox.width/2);const e=new Wt;for(const t of this.NodeAnchors())e.AddValue(t.x);if(e.length>y.distanceEpsilon){const i=t.length/e.length;if(i>1)for(const t of this.anchors)t.x*=i}}TryToSatisfyMinHeight(){if(0==this.sugiyamaSettings.MinimalHeight)return;this.GetCurrentHeight()<this.sugiyamaSettings.MinimalHeight&&this.StretchHeight()}GetCurrentHeight(){const t=new Wt;for(const e of this.NodeAnchors())t.AddValue(e.top),t.AddValue(e.bottom);return t.length}StretchHeight(){const t=new Wt;for(const e of this.originalGraph.shallowNodes())t.AddValue(e.boundingBox.height/2),t.AddValue(this.sugiyamaSettings.MinimalHeight-e.boundingBox.height/2);const e=new Wt;for(const t of this.NodeAnchors())e.AddValue(t.y);if(e.length>y.distanceEpsilon){const i=t.length/e.length;if(i>1)for(const t of this.anchors)t.y*=i}}*NodeAnchors(){const t=Math.min(this.IntGraph.nodeCount,this.anchors.length);for(let e=0;e<t;e++)yield this.anchors[e]}GetCurrentWidth(){const t=new Wt;for(const e of this.NodeAnchors())t.AddValue(e.left),t.AddValue(e.right);return t.length}ExtendLayeringToUngluedSameLayerVertices(t){const e=this.verticalConstraints;for(let i=0;i<t.length;i++)t[i]=t[e.nodeToRepr(i)];return t}calculateEdgeSplines(){new io(this.sugiyamaSettings,this.originalGraph,this.database,this.engineLayerArrays,this.properLayeredGraph,this.IntGraph).run()}YLayeringAndOrdering(t){let e=t.GetLayers();Qt.Balance(this.gluedDagSkeletonForLayering,e,this.GetNodeCountsOfGluedDag(),null),e=this.ExtendLayeringToUngluedSameLayerVertices(e);let i=new Yt(e);if(null==this.HorizontalConstraints||this.HorizontalConstraints.IsEmpty)return i=this.YLayeringAndOrderingWithoutHorizontalConstraints(i),i;throw new Error("not implemented")}CreateProperLayeredGraph(t){const e=t.length;let i=0;for(const n of this.database.SkeletonEdges()){const r=ao(t,n);r>0&&(n.LayerEdges=new Array(r));let s=0;if(r>1){let t=e+i++,o=new Lt(n.source,t,n.CrossingWeight,n.weight);n.LayerEdges[s++]=o;for(let e=0;e<r-2;e++)t++,i++,o=new Lt(t-1,t,n.CrossingWeight,n.weight),n.LayerEdges[s++]=o;o=new Lt(t,n.target,n.CrossingWeight,n.weight),n.LayerEdges[s]=o}else if(1==r){const t=new Lt(n.source,n.target,n.CrossingWeight,n.weight);n.LayerEdges[s]=t}}const n=new Array(this.originalGraph.shallowNodeCount+i).fill(0);for(const e of this.database.SkeletonEdges())if(null!=e.LayerEdges){let i=t[e.source];n[e.source]=i--;for(const t of e.LayerEdges)n[t.Target]=i--}else n[e.source]=t[e.source],n[e.target]=t[e.target];return this.properLayeredGraph=new Zt(new Ht(Array.from(this.database.SkeletonEdges()),t.length)),this.properLayeredGraph.BaseGraph.nodes=this.IntGraph.nodes,new Yt(n)}YLayeringAndOrderingWithoutHorizontalConstraints(t){const e=this.CreateProperLayeredGraph(t.y);return Te.OrderLayers(this.properLayeredGraph,e,this.originalGraph.shallowNodeCount,this.sugiyamaSettings,this.cancelToken),Oe.UpdateLayerArrays1(this.properLayeredGraph,e),e}CalculateYLayers(){const t=this.YLayeringAndOrdering(new De(this.gluedDagSkeletonForLayering,this.cancelToken));return null!=this.constrainedOrdering?t:this.InsertLayersIfNeeded(t)}InsertLayersIfNeeded(t){this.InsertVirtualEdgesIfNeeded(t);const e=this.AnalyzeNeedToInsertLayersAndHasMultiedges(t);if(e.needToInsertLayers){const e=$t.InsertLayers(this.properLayeredGraph,t,this.database,this.IntGraph);this.properLayeredGraph=e.layeredGraph,t=e.la,this.LayersAreDoubled=!0}else if(e.multipleEdges){const e=Jt.InsertPaths(this.properLayeredGraph,t,this.database,this.IntGraph);this.properLayeredGraph=e.layeredGraph,t=e.la}return this.RecreateIntGraphFromDataBase(),t}RecreateIntGraphFromDataBase(){let t=new Array;for(const e of this.database.Multiedges.values())t=t.concat(e);this.IntGraph.SetEdges(t,this.IntGraph.nodeCount)}InsertVirtualEdgesIfNeeded(t){if(null==this.constrainedOrdering)for(const[e,i]of this.database.Multiedges.keyValues())if(i.length%2==0&&t.y[e.x]-1==t.y[e.y]){const t=new Z(null),n=new Bt(e.x,e.y,t);n.IsVirtualEdge=!0,i.splice(i.length/2,0,n),this.IntGraph.addEdge(n)}}AnalyzeNeedToInsertLayersAndHasMultiedges(t){let e=!1,i=!1;for(const i of this.IntGraph.edges)if(i.hasLabel&&t.y[i.source]!=t.y[i.target]){e=!0;break}if(0==e&&null==this.constrainedOrdering)for(const[n,r]of this.database.Multiedges.keyValues())if(r.length>1&&(i=!0,t.y[n.x]-t.y[n.y]==1)){e=!0;break}return{needToInsertLayers:e,multipleEdges:i}}UseBrandesXCalculations(t){return t.x.length>=this.sugiyamaSettings.BrandesThreshold}CalculateAnchorsAndYPositions(t){this.anchors=function(t,e,i,n,r){const s=t.Anchors=new Array(e.NodeCount);for(let t=0;t<s.length;t++)s[t]=new Ne(r.LabelCornersPreserveCoefficient);for(let e=0;e<i.shallowNodeCount;e++)no.CalcAnchorsForOriginalNode(e,n,s,t,r);for(const e of t.AllIntEdges())if(null!=e.LayerEdges){for(const i of e.LayerEdges){const n=i.Target;if(n!=e.target){const e=s[n];t.MultipleMiddles.has(n)?(e.leftAnchor=e.rightAnchor=4,e.topAnchor=e.bottomAnchor=so(r)/2):(e.leftAnchor=e.rightAnchor=.5,e.topAnchor=e.bottomAnchor=so(r)/2)}}if(e.hasLabel){const t=e.LayerEdges[e.LayerEdges.length/2].Source,i=s[t],n=e.labelWidth,r=e.labelHeight;i.rightAnchor=n,i.leftAnchor=8,i.topAnchor<r/2&&(i.topAnchor=i.bottomAnchor=r/2),i.labelIsToTheRightOfTheSpline=!0}}return s}(this.database,this.properLayeredGraph,this.originalGraph,this.IntGraph,this.sugiyamaSettings),function(t,e,i,n,r,s,o){const a=n.Anchors;let l=i.Margins+e,h=0;for(const e of t.Layers){let u=0,c=0;for(const t of e){const e=a[t];e.bottomAnchor>u&&(u=e.bottomAnchor),e.topAnchor>c&&(c=e.topAnchor)}lo(e,u,c,i.shallowNodeCount,n.Anchors);const d=oo(n,t,h,r,s,l),g=l+u+d;let f=g+c;if(ho(s)){f+=ro(f,s.GridSizeByY);for(const t of e)a[t].top=f}else if(uo(s)){let t=g-u;t+=ro(t,t);for(const i of e)a[i].bottom=t,f=Math.max(a[i].top,f)}else for(const t of e)a[t].y=g;const p=s.ActualLayerSeparation(o);l=f+p,h++}oo(n,t,h,r,s,l)}(t,500,this.originalGraph,this.database,this.IntGraph,this.sugiyamaSettings,this.LayersAreDoubled)}OptimizeEdgeLabelsLocations(){for(let t=0;t<this.anchors.length;t++){const e=this.anchors[t];if(e.labelIsToTheRightOfTheSpline){const i=this.GetSuccessorAndPredecessor(t);if(!co(e,i.predecessor,i.successor)){const t=i.predecessor.origin.sub(e.origin).length+i.successor.origin.sub(e.origin).length,n=e.right-e.leftAnchor,r=new E(n,e.y);i.predecessor.origin.sub(r).length+i.successor.origin.sub(r).length<t&&go(e)}}}}GetSuccessorAndPredecessor(t){let e,i;for(const i of this.properLayeredGraph.InEdges(t))e=i.Source;for(const e of this.properLayeredGraph.OutEdges(t))i=e.Target;return{predecessor:this.anchors[e],successor:this.anchors[i]}}CalculateLayerArrays(){const t=this.CalculateYLayers();return null==this.constrainedOrdering?(this.CalculateAnchorsAndYPositions(t),this.UseBrandesXCalculations(t)?this.CalculateXPositionsByBrandes(t):this.CalculateXLayersByGansnerNorth(t)):this.anchors=this.database.Anchors,this.OptimizeEdgeLabelsLocations(),this.engineLayerArrays=t,this.StraightensShortEdges(),this.CalculateOriginalGraphBox(),t}StretchToDesiredAspectRatio(t,e){t>e?this.StretchInYDirection(t/e):t<e&&this.StretchInXDirection(e/t)}StretchInYDirection(t){const e=(this.originalGraph.boundingBox.top+this.originalGraph.boundingBox.bottom)/2;for(const i of this.database.Anchors)i.bottomAnchor=i.bottomAnchor*t,i.topAnchor=i.topAnchor*t,i.y=e+t*(i.y-e);const i=this.originalGraph.height*t;this.originalGraph.boundingBox=new G({left:this.originalGraph.boundingBox.left,top:e+i/2,right:this.originalGraph.boundingBox.right,bottom:e-i/2})}StretchInXDirection(t){const e=(this.originalGraph.boundingBox.left+this.originalGraph.boundingBox.right)/2;for(const i of this.database.Anchors)i.leftAnchor=i.leftAnchor*t,i.rightAnchor=i.rightAnchor*t,i.x=e+t*(i.x-e);const i=this.originalGraph.width*t;this.originalGraph.boundingBox=new G({left:e-i/2,top:this.originalGraph.boundingBox.top,right:e+i/2,bottom:this.originalGraph.boundingBox.bottom})}CalculateOriginalGraphBox(){if(0==this.anchors.length)return 0;const t=new G({left:this.anchors[0].left,top:this.anchors[0].top,right:this.anchors[0].right,bottom:this.anchors[0].bottom});for(let e=1;e<this.anchors.length;e++){const i=this.anchors[e];t.add(i.leftTop),t.add(i.rightBottom)}const e=t.leftTop.sub(t.rightBottom).length/2,i=new E(-1*e,e);return t.add(t.leftTop.add(i)),t.add(t.rightBottom.sub(i)),this.originalGraph.boundingBox=t,0!=t.height?t.width/t.height:0}StraightensShortEdges(){for(;this.StraightenEdgePaths(););}StraightenEdgePaths(){let t=!1;for(const e of this.database.AllIntEdges())2==e.LayerSpan&&(t=this.ShiftVertexWithNeighbors(e.LayerEdges[0].Source,e.LayerEdges[0].Target,e.LayerEdges[1].Target)||t);return t}ShiftVertexWithNeighbors(t,e,i){const n=this.database.Anchors[t],r=this.database.Anchors[i],s=this.database.Anchors[e],o=(s.y-n.y)*((r.x-n.x)/(r.y-n.y))+n.x;return o>s.x+1e-4?this.TryShiftToTheRight(o,e):o<s.x-1e-4&&this.TryShiftToTheLeft(o,e)}TryShiftToTheLeft(t,e){const i=this.engineLayerArrays.Layers[this.engineLayerArrays.y[e]],n=this.engineLayerArrays.x[e];if(n>0){const r=this.database.Anchors[i[n-1]],s=Math.max(r.right+(this.sugiyamaSettings.NodeSeparation+this.database.Anchors[e].leftAnchor),t);return s<this.database.Anchors[e].x-1&&(this.database.Anchors[e].x=s,!0)}return this.database.Anchors[e].x=t,!0}TryShiftToTheRight(t,e){const i=this.engineLayerArrays.Layers[this.engineLayerArrays.y[e]],n=this.engineLayerArrays.x[e];if(n<i.length-1){const r=this.database.Anchors[i[n+1]],s=Math.min(r.left-(this.sugiyamaSettings.NodeSeparation-this.database.Anchors[e].rightAnchor),t);return s>this.database.Anchors[e].x+1&&(this.database.Anchors[e].x=s,!0)}return this.database.Anchors[e].x=t,!0}CalculateXLayersByGansnerNorth(t){this.xLayoutGraph=this.CreateXLayoutGraph(t),this.CalculateXLayersByGansnerNorthOnProperLayeredGraph()}CalculateXLayersByGansnerNorthOnProperLayeredGraph(){const t=new Fe(this.xLayoutGraph,null).GetLayers();for(let e=0;e<this.database.Anchors.length;e++)this.anchors[e].x=t[e]}CreateXLayoutGraph(t){let e=this.properLayeredGraph.NodeCount;const i=new Array;for(const t of this.properLayeredGraph.Edges){const n=new Bt(e,t.Source,null),r=new Bt(e,t.Target,null);r.weight=t.Weight,n.weight=t.Weight,n.separation=0,r.separation=0,e++,i.push(n),i.push(r)}for(const e of t.Layers)for(let t=e.length-1;t>0;t--){const n=e[t],r=e[t-1],s=new Bt(n,r,null),o=this.database.Anchors[n],a=this.database.Anchors[r],l=o.leftAnchor+(a.rightAnchor+this.sugiyamaSettings.NodeSeparation);s.separation=Math.ceil(l+.5),i.push(s)}const n=new Ve(this.IntGraph,this.properLayeredGraph,t,i,e);return n.SetEdgeWeights(),n}CalculateXPositionsByBrandes(t){ke.CalculateXCoordinates(t,this.properLayeredGraph,this.originalGraph.shallowNodeCount,this.database.Anchors,this.sugiyamaSettings.NodeSeparation)}GluedDagSkeletonEdges(){const t=new Et(this.IntGraph.nodeCount);for(const[e,i]of this.database.Multiedges.keyValues()){if(e.isDiagonal())continue;const n=this.verticalConstraints.gluedIntEdge(i[0]);n.source!=n.target&&t.set(n.source,n.target,n)}const e=Array.from(this.verticalConstraints.gluedUpDownIntConstraints.values()).map(t=>function(t,e){const i=new Bt(t.x,t.y,e);return i.weight=0,i.separation=1,i}(t,null));for(const i of e)t.set(i.source,i.target,i);return Array.from(t.values())}static CalcAnchorsForOriginalNode(t,e,i,n,r){const s={leftAnchor:0,rightAnchor:0,topAnchor:0,bottomAnchor:0};if(null!=e.nodes){!function(t,e,i){t.rightAnchor=t.leftAnchor=(e.width+i.GridSizeByX)/2,t.topAnchor=t.bottomAnchor=e.height/2}(s,e.nodes[t],r)}!function(t,e,i,n){const r=function(t,e,i,n){let r=0;const s=t.GetMultiedge(e,e);if(s.length>0){for(const t of s)null!=t.edge.label&&(i.rightAnchor+=t.edge.label.width,i.topAnchor<t.edge.label.height/2&&(i.topAnchor=i.bottomAnchor=t.edge.label.height/2));r+=(n.NodeSeparation+n.MinNodeWidth)*s.length}return r}(i,t,e,n);e.rightAnchor+=r}(t,s,n,r);const o=r.MinNodeWidth/2;s.leftAnchor<o&&(s.leftAnchor=o),s.rightAnchor<o&&(s.rightAnchor=o);const a=r.MinNodeHeight/2;s.topAnchor<a&&(s.topAnchor=a),s.bottomAnchor<a&&(s.bottomAnchor=a),i[t]=Ne.mkAnchor(s.leftAnchor,s.rightAnchor,s.topAnchor,s.bottomAnchor,e.nodes[t],r.LabelCornersPreserveCoefficient),i[t].padding=e.nodes[t].padding}CreateGluedDagSkeletonForLayering(){this.gluedDagSkeletonForLayering=new Ht(this.GluedDagSkeletonEdges(),this.originalGraph.shallowNodeCount),this.SetGluedEdgesWeights()}SetGluedEdgesWeights(){const t=new Et(this.IntGraph.nodeCount);for(const e of this.gluedDagSkeletonForLayering.edges)t.set(e.source,e.target,e);for(const[e,i]of this.database.Multiedges.keyValues())if(e.x!=e.y){const n=this.verticalConstraints.gluedIntPair(e);if(n.x==n.y)continue;const r=t.get(n.x,n.y);for(const t of i)r.weight+=t.weight}}GetNodeCountsOfGluedDag(){return this.verticalConstraints.isEmpty?new Array(this.IntGraph.nodeCount).fill(1):this.verticalConstraints.getGluedNodeCounts()}}function ro(t,e){if(0==e)return 0;const i=t-Math.floor(t/e)*e;return Math.abs(i)<1e-4?0:e-i}function so(t){return 1.5*t.MinNodeHeight/8}function oo(t,e,i,n,r,s){let o=0;if(i>0){const a=function(t,e,i){const n=new Mt;for(const r of t)if(!(r>=i.nodeCount))for(const t of i.outEdges[r])e[t.source]==e[t.target]&&n.addNN(t.source,t.target);return Array.from(n.values())}(e.Layers[i-1],e.y,n);if(a.length){const e=r.LayerSeparation/3,i=s;o=Math.max(...a.map(n=>function(t,e,i,n){let r=0;const s=n.GetMultiedgeI(t);for(const t of s){r+=i;const n=t.edge.label;null!=n&&(n.center=new E(n.center.x,e+r+n.height/2),r+=n.height)}return r}(n,i,e,t)))}}return o}function ao(t,e){return t[e.source]-t[e.target]}function lo(t,e,i,n,r){if(function(t,e){for(const i of t)if(i<e)return!0;return!1}(t,n))for(const s of t)if(s>=n){const t=r[s];t.bottomAnchor=e,t.topAnchor=i}}function ho(t){return t.SnapToGridByY==Ot.Top}function uo(t){return t.SnapToGridByY==Ot.Bottom}function co(t,e,i){if(t.labelIsToTheRightOfTheSpline){if(E.getTriangleOrientation(e.origin,t.origin,i.origin)==s.Clockwise)return!0;const n=t.leftAnchor,r=t.rightAnchor,o=t.x;return go(t),E.getTriangleOrientation(e.origin,t.origin,i.origin)==s.Counterclockwise?!0:(t.x=o,t.leftAnchor=n,t.rightAnchor=r,t.labelIsToTheRightOfTheSpline=!0,t.labelIsToTheLeftOfTheSpline=!1,!1)}return!1}function go(t){const e=t.right,i=t.leftAnchor;t.leftAnchor=t.rightAnchor,t.rightAnchor=i,t.x=e-t.rightAnchor,t.labelIsToTheLeftOfTheSpline=!0,t.labelIsToTheRightOfTheSpline=!1}function fo(t,e){if(null!=e.curve){e.curve=e.curve.transform(t);const i=e;null!=i.sourceArrowhead&&(i.sourceArrowhead.tipPosition=t.multiplyPoint(i.sourceArrowhead.tipPosition)),null!=i.targetArrowhead&&(i.targetArrowhead.tipPosition=t.multiplyPoint(i.targetArrowhead.tipPosition)),function(t,e){if(null!=t.underlyingPolyline)for(let i=t.underlyingPolyline.headSite;null!=i;i=i.next)i.point=e.multiplyPoint(i.point)}(e,t)}}!function(t){t[t.normal=0]="normal",t[t.inv=1]="inv",t[t.dot=2]="dot",t[t.invdot=3]="invdot",t[t.odot=4]="odot",t[t.invodot=5]="invodot",t[t.none=6]="none",t[t.tee=7]="tee",t[t.empty=8]="empty",t[t.invempty=9]="invempty",t[t.diamond=10]="diamond",t[t.odiamond=11]="odiamond",t[t.ediamond=12]="ediamond",t[t.crow=13]="crow",t[t.box=14]="box",t[t.obox=15]="obox",t[t.open=16]="open",t[t.halfopen=17]="halfopen",t[t.vee=18]="vee"}(bs||(bs={})),function(t){t[t.diamond=0]="diamond",t[t.ellipse=1]="ellipse",t[t.box=2]="box",t[t.circle=3]="circle",t[t.record=4]="record",t[t.plaintext=5]="plaintext",t[t.point=6]="point",t[t.mdiamond=7]="mdiamond",t[t.msquare=8]="msquare",t[t.polygon=9]="polygon",t[t.doublecircle=10]="doublecircle",t[t.house=11]="house",t[t.invhouse=12]="invhouse",t[t.parallelogram=13]="parallelogram",t[t.octagon=14]="octagon",t[t.tripleoctagon=15]="tripleoctagon",t[t.triangle=16]="triangle",t[t.trapezium=17]="trapezium",t[t.drawfromgeometry=18]="drawfromgeometry",t[t.hexagon=19]="hexagon"}(Ps||(Ps={})),function(t){t[t.same=0]="same",t[t.min=1]="min",t[t.source=2]="source",t[t.max=3]="max",t[t.sink=4]="sink"}(vs||(vs={})),function(t){t[t.none=0]="none",t[t.dashed=1]="dashed",t[t.solid=2]="solid",t[t.invis=3]="invis",t[t.bold=4]="bold",t[t.filled=5]="filled",t[t.diagonals=6]="diagonals",t[t.dotted=7]="dotted",t[t.rounded=8]="rounded"}(Ss||(Ss={}));class po{constructor(t,e,i,n){this.a=t,this.r=e,this.g=i,this.b=n}static parse(t){switch(t.toLowerCase()){case"aliceblue":return po.AliceBlue;case"antiquewhite":return po.AntiqueWhite;case"aqua":po.Aqua;case"aquamarine":po.Aquamarine;case"azure":return po.Azure;case"beige":return po.Beige;case"bisque":return po.Bisque;case"black":return po.Black;case"blanchedalmond":return po.BlanchedAlmond;case"blue":return po.Blue;case"blueviolet":return po.BlueViolet;case"brown":return po.Brown;case"burlywood":return po.BurlyWood;case"cadetblue":return po.CadetBlue;case"chartreuse":return po.Chartreuse;case"chocolate":return po.Chocolate;case"coral":return po.Coral;case"cornflowerblue":return po.CornflowerBlue;case"cornsilk":return po.Cornsilk;case"crimson":return po.Crimson;case"cyan":return po.Cyan;case"darkblue":return po.DarkBlue;case"darkcyan":return po.DarkCyan;case"darkgoldenrod":return po.DarkGoldenrod;case"darkgray":return po.DarkGray;case"darkgreen":return po.DarkGreen;case"darkkhaki":return po.DarkKhaki;case"darkmagenta":return po.DarkMagenta;case"darkolivegreen":return po.DarkOliveGreen;case"darkorange":return po.DarkOrange;case"darkorchid":return po.DarkOrchid;case"darkred":return po.DarkRed;case"darksalmon":return po.DarkSalmon;case"darkseagreen":return po.DarkSeaGreen;case"darkslateblue":return po.DarkSlateBlue;case"darkslategray":return po.DarkSlateGray;case"darkturquoise":return po.DarkTurquoise;case"darkviolet":return po.DarkViolet;case"deeppink":return po.DeepPink;case"deepskyblue":return po.DeepSkyBlue;case"dimgray":return po.DimGray;case"dodgerblue":return po.DodgerBlue;case"firebrick":return po.Firebrick;case"floralwhite":return po.FloralWhite;case"forestgreen":return po.ForestGreen;case"fuchsia":return po.Fuchsia;case"gainsboro":return po.Gainsboro;case"ghostwhite":return po.GhostWhite;case"gold":return po.Gold;case"goldenrod":return po.Goldenrod;case"gray":return po.Gray;case"green":return po.Green;case"greenyellow":return po.GreenYellow;case"honeydew":return po.Honeydew;case"hotpink":return po.HotPink;case"indianred":return po.IndianRed;case"indigo":return po.Indigo;case"ivory":return po.Ivory;case"khaki":return po.Khaki;case"lavender":return po.Lavender;case"lavenderblush":return po.LavenderBlush;case"lawngreen":return po.LawnGreen;case"lemonchiffon":return po.LemonChiffon;case"lightblue":return po.LightBlue;case"lightcoral":return po.LightCoral;case"lightcyan":return po.LightCyan;case"lightgoldenrodyellow":return po.LightGoldenrodYellow;case"lightgray":return po.LightGray;case"lightgreen":return po.LightGreen;case"lightpink":return po.LightPink;case"lightsalmon":return po.LightSalmon;case"lightseagreen":return po.LightSeaGreen;case"lightskyblue":return po.LightSkyBlue;case"lightslategray":return po.LightSlateGray;case"lightsteelblue":return po.LightSteelBlue;case"lightyellow":return po.LightYellow;case"lime":return po.Lime;case"limegreen":return po.LimeGreen;case"linen":return po.Linen;case"magenta":return po.Magenta;case"maroon":return po.Maroon;case"mediumaquamarine":return po.MediumAquamarine;case"mediumblue":return po.MediumBlue;case"mediumorchid":return po.MediumOrchid;case"mediumpurple":return po.MediumPurple;case"mediumseagreen":return po.MediumSeaGreen;case"mediumslateblue":return po.MediumSlateBlue;case"mediumspringgreen":return po.MediumSpringGreen;case"mediumturquoise":return po.MediumTurquoise;case"mediumvioletred":return po.MediumVioletRed;case"midnightblue":return po.MidnightBlue;case"mintcream":return po.MintCream;case"mistyrose":return po.MistyRose;case"moccasin":return po.Moccasin;case"navajowhite":return po.NavajoWhite;case"navy":return po.Navy;case"oldlace":return po.OldLace;case"olive":return po.Olive;case"olivedrab":return po.OliveDrab;case"orange":return po.Orange;case"orangered":return po.OrangeRed;case"orchid":return po.Orchid;case"palegoldenrod":return po.PaleGoldenrod;case"palegreen":return po.PaleGreen;case"paleturquoise":return po.PaleTurquoise;case"palevioletred":return po.PaleVioletRed;case"papayawhip":return po.PapayaWhip;case"peachpuff":return po.PeachPuff;case"peru":return po.Peru;case"pink":return po.Pink;case"plum":return po.Plum;case"powderblue":return po.PowderBlue;case"purple":return po.Purple;case"red":return po.Red;case"rosybrown":return po.RosyBrown;case"royalblue":return po.RoyalBlue;case"saddlebrown":return po.SaddleBrown;case"salmon":return po.Salmon;case"sandybrown":return po.SandyBrown;case"seagreen":return po.SeaGreen;case"seashell":return po.SeaShell;case"sienna":return po.Sienna;case"silver":return po.Silver;case"skyblue":return po.SkyBlue;case"slateblue":return po.SlateBlue;case"slategray":return po.SlateGray;case"snow":return po.Snow;case"springgreen":return po.SpringGreen;case"steelblue":return po.SteelBlue;case"tan":return po.Tan;case"teal":return po.Teal;case"thistle":return po.Thistle;case"tomato":return po.Tomato;case"transparent":return po.Transparent;case"turquoise":return po.Turquoise;case"violet":return po.Violet;case"wheat":return po.Wheat;case"white":return po.White;case"whitesmoke":return po.WhiteSmoke;case"yellow":return po.Yellow;case"yellowgreen":return po.YellowGreen}}static mkRGB(t,e,i){return new po(255,t,e,i)}get A(){return this.a}set A(t){this.a=t}get R(){return this.r}set R(t){this.r=t}get G(){return this.g}set G(t){this.g=t}get B(){return this.b}set B(t){this.b=t}static Xex(t){const e=t.toString(16);return 1==e.length?"0"+e:e.substring(e.length-2,2)}static equal(t,e){return t.a==e.a&&t.r==e.r&&t.b==e.b&&t.g==e.g}toString(){return'"#'+po.Xex(this.R)+po.Xex(this.G)+po.Xex(this.B)+(255==this.A?"":po.Xex(this.A))+'"'}static get AliceBlue(){return new po(255,240,248,255)}static get AntiqueWhite(){return new po(255,250,235,215)}static get Aqua(){return new po(255,0,255,255)}static get Aquamarine(){return new po(255,127,255,212)}static get Azure(){return new po(255,240,255,255)}static get Beige(){return new po(255,245,245,220)}static get Bisque(){return new po(255,255,228,196)}static get Black(){return new po(255,0,0,0)}static get BlanchedAlmond(){return new po(255,255,235,205)}static get Blue(){return new po(255,0,0,255)}static get BlueViolet(){return new po(255,138,43,226)}static get Brown(){return new po(255,165,42,42)}static get BurlyWood(){return new po(255,222,184,135)}static get CadetBlue(){return new po(255,95,158,160)}static get Chartreuse(){return new po(255,127,255,0)}static get Chocolate(){return new po(255,210,105,30)}static get Coral(){return new po(255,255,127,80)}static get CornflowerBlue(){return new po(255,100,149,237)}static get Cornsilk(){return new po(255,255,248,220)}static get Crimson(){return new po(255,220,20,60)}static get Cyan(){return new po(255,0,255,255)}static get DarkBlue(){return new po(255,0,0,139)}static get DarkCyan(){return new po(255,0,139,139)}static get DarkGoldenrod(){return new po(255,184,134,11)}static get DarkGray(){return new po(255,169,169,169)}static get DarkGreen(){return new po(255,0,100,0)}static get DarkKhaki(){return new po(255,189,183,107)}static get DarkMagenta(){return new po(255,139,0,139)}static get DarkOliveGreen(){return new po(255,85,107,47)}static get DarkOrange(){return new po(255,255,140,0)}static get DarkOrchid(){return new po(255,153,50,204)}static get DarkRed(){return new po(255,139,0,0)}static get DarkSalmon(){return new po(255,233,150,122)}static get DarkSeaGreen(){return new po(255,143,188,139)}static get DarkSlateBlue(){return new po(255,72,61,139)}static get DarkSlateGray(){return new po(255,47,79,79)}static get DarkTurquoise(){return new po(255,0,206,209)}static get DarkViolet(){return new po(255,148,0,211)}static get DeepPink(){return new po(255,255,20,147)}static get DeepSkyBlue(){return new po(255,0,191,255)}static get DimGray(){return new po(255,105,105,105)}static get DodgerBlue(){return new po(255,30,144,255)}static get Firebrick(){return new po(255,178,34,34)}static get FloralWhite(){return new po(255,255,250,240)}static get ForestGreen(){return new po(255,34,139,34)}static get Fuchsia(){return new po(255,255,0,255)}static get Gainsboro(){return new po(255,220,220,220)}static get GhostWhite(){return new po(255,248,248,255)}static get Gold(){return new po(255,255,215,0)}static get Goldenrod(){return new po(255,218,165,32)}static get Gray(){return new po(255,128,128,128)}static get Green(){return new po(255,0,128,0)}static get GreenYellow(){return new po(255,173,255,47)}static get Honeydew(){return new po(255,240,255,240)}static get HotPink(){return new po(255,255,105,180)}static get IndianRed(){return new po(255,205,92,92)}static get Indigo(){return new po(255,75,0,130)}static get Ivory(){return new po(255,255,255,240)}static get Khaki(){return new po(255,240,230,140)}static get Lavender(){return new po(255,230,230,250)}static get LavenderBlush(){return new po(255,255,240,245)}static get LawnGreen(){return new po(255,124,252,0)}static get LemonChiffon(){return new po(255,255,250,205)}static get LightBlue(){return new po(255,173,216,230)}static get LightCoral(){return new po(255,240,128,128)}static get LightCyan(){return new po(255,224,255,255)}static get LightGoldenrodYellow(){return new po(255,250,250,210)}static get LightGray(){return new po(255,211,211,211)}static get LightGreen(){return new po(255,144,238,144)}static get LightPink(){return new po(255,255,182,193)}static get LightSalmon(){return new po(255,255,160,122)}static get LightSeaGreen(){return new po(255,32,178,170)}static get LightSkyBlue(){return new po(255,135,206,250)}static get LightSlateGray(){return new po(255,119,136,153)}static get LightSteelBlue(){return new po(255,176,196,222)}static get LightYellow(){return new po(255,255,255,224)}static get Lime(){return new po(255,0,255,0)}static get LimeGreen(){return new po(255,50,205,50)}static get Linen(){return new po(255,250,240,230)}static get Magenta(){return new po(255,255,0,255)}static get Maroon(){return new po(255,128,0,0)}static get MediumAquamarine(){return new po(255,102,205,170)}static get MediumBlue(){return new po(255,0,0,205)}static get MediumOrchid(){return new po(255,186,85,211)}static get MediumPurple(){return new po(255,147,112,219)}static get MediumSeaGreen(){return new po(255,60,179,113)}static get MediumSlateBlue(){return new po(255,123,104,238)}static get MediumSpringGreen(){return new po(255,0,250,154)}static get MediumTurquoise(){return new po(255,72,209,204)}static get MediumVioletRed(){return new po(255,199,21,133)}static get MidnightBlue(){return new po(255,25,25,112)}static get MintCream(){return new po(255,245,255,250)}static get MistyRose(){return new po(255,255,228,225)}static get Moccasin(){return new po(255,255,228,181)}static get NavajoWhite(){return new po(255,255,222,173)}static get Navy(){return new po(255,0,0,128)}static get OldLace(){return new po(255,253,245,230)}static get Olive(){return new po(255,128,128,0)}static get OliveDrab(){return new po(255,107,142,35)}static get Orange(){return new po(255,255,165,0)}static get OrangeRed(){return new po(255,255,69,0)}static get Orchid(){return new po(255,218,112,214)}static get PaleGoldenrod(){return new po(255,238,232,170)}static get PaleGreen(){return new po(255,152,251,152)}static get PaleTurquoise(){return new po(255,175,238,238)}static get PaleVioletRed(){return new po(255,219,112,147)}static get PapayaWhip(){return new po(255,255,239,213)}static get PeachPuff(){return new po(255,255,218,185)}static get Peru(){return new po(255,205,133,63)}static get Pink(){return new po(255,255,192,203)}static get Plum(){return new po(255,221,160,221)}static get PowderBlue(){return new po(255,176,224,230)}static get Purple(){return new po(255,128,0,128)}static get Red(){return new po(255,255,0,0)}static get RosyBrown(){return new po(255,188,143,143)}static get RoyalBlue(){return new po(255,65,105,225)}static get SaddleBrown(){return new po(255,139,69,19)}static get Salmon(){return new po(255,250,128,114)}static get SandyBrown(){return new po(255,244,164,96)}static get SeaGreen(){return new po(255,46,139,87)}static get SeaShell(){return new po(255,255,245,238)}static get Sienna(){return new po(255,160,82,45)}static get Silver(){return new po(255,192,192,192)}static get SkyBlue(){return new po(255,135,206,235)}static get SlateBlue(){return new po(255,106,90,205)}static get SlateGray(){return new po(255,112,128,144)}static get Snow(){return new po(255,255,250,250)}static get SpringGreen(){return new po(255,0,255,127)}static get SteelBlue(){return new po(255,70,130,180)}static get Tan(){return new po(255,210,180,140)}static get Teal(){return new po(255,0,128,128)}static get Thistle(){return new po(255,216,191,216)}static get Tomato(){return new po(255,255,99,71)}static get Transparent(){return new po(0,255,255,255)}static get Turquoise(){return new po(255,64,224,208)}static get Violet(){return new po(255,238,130,238)}static get Wheat(){return new po(255,245,222,179)}static get White(){return new po(255,255,255,255)}static get WhiteSmoke(){return new po(255,245,245,245)}static get Yellow(){return new po(255,255,255,0)}static get YellowGreen(){return new po(255,154,205,50)}}class mo{constructor(t){this.color=po.parse("Black"),this.labelfontcolor=po.parse("Black"),this.attrCont=t,this.bind()}get labelText(){return this._labelText}set labelText(t){this._labelText=t}bind(){null!=this.attrCont&&this.attrCont.setAttr(1,this)}static getDrawingObj(t){return null==t?null:t.getAttr(1)}}mo.defaultLabelFontName="Times-Roman",mo.defaultLabelFontSize=12;class yo{constructor(t){this.text=t}}class bo extends mo{constructor(t){super(t),this.shape=Ps.box,this.padding=2,this.xRad=3,this.yRad=3,this.fillcolor=po.Transparent,this.labelMargin=1,this.labelWidthToHeightRatio=1,null!=t&&(this.label=new yo(t.id)),this.fontname=mo.defaultLabelFontName,this.fontsize=mo.defaultLabelFontSize}get labelText(){return this.label?this.label.text:null}set labelText(t){null!=this.label&&(this.label.text=t)}get Padding(){return this.padding}set Padding(t){this.padding=Math.max(0,t)}get XRadius(){return this.xRad}set XRadius(t){this.xRad=t}get YRadius(){return this.yRad}set YRadius(t){this.yRad=t}static get DefaultFillColor(){return bo.defaultFillColor}static set DefaultFillColor(t){bo.defaultFillColor=t}get FillColor(){return this.fillcolor}set FillColor(t){this.fillcolor=t}get ShapeEnum(){return this.shape}set ShapeEnum(t){this.shape=t}get LabelMargin(){return this.labelMargin}set LabelMargin(t){this.labelMargin=t}get LabelWidthToHeightRatio(){return this.labelWidthToHeightRatio}set LabelWidthToHeightRatio(t){this.labelWidthToHeightRatio=t}get node(){return this.attrCont}}bo.defaultFillColor=po.LightGray;class Po extends bo{constructor(){super(...arguments),this.graphVisData={sameRanks:new Array,minRanks:new Array,maxRanks:new Array,sourceRanks:new Array,sinkRanks:new Array}}get graph(){return this.attrCont}findNode(t){const e=this.graph.findNode(t);return null==e?null:mo.getDrawingObj(e)}hasDirectedEdge(){for(const t of this.graph.edges){if(mo.getDrawingObj(t).directed)return!0}return!1}createGeometry(t=(t=>t?new V(8*t.length+8,20):null)){const e=new yt(this.graph);e.labelSize=t(this.labelText);for(const e of this.graph.deepNodes)this.createNodeGeometry(e,t);for(const e of this.graph.edges)this.createEdgeGeometry(e,t);return e}createEdgeGeometry(t,e){const i=vo.getDrawingObj(t),n=new Z(t);if(0==i.directed&&(n.targetArrowhead=null),t.label){const i=e(t.label.text);n.label=new bt(G.mkPP(new E(0,0),new E(i.width,i.height)),t.label)}}curveByShape(t,e,i,n,r){let s;switch(n){case Ps.diamond:s=H.CreateDiamond(t,e,i);break;case Ps.ellipse:break;case Ps.box:s=H.mkRectangleWithRoundedCorners(t,e,r.XRadius,r.YRadius,i);break;case Ps.circle:s=H.mkCircle(t/2,i);break;case Ps.record:case Ps.plaintext:case Ps.point:case Ps.mdiamond:case Ps.msquare:case Ps.polygon:break;case Ps.doublecircle:s=H.mkCircle(t/2,i);break;case Ps.house:s=H.createHouse(t,e,i);break;case Ps.invhouse:s=H.createInvertedHouse(t,e,i);break;case Ps.parallelogram:break;case Ps.octagon:s=H.createOctagon(t,e,i);break;case Ps.tripleoctagon:case Ps.triangle:case Ps.trapezium:case Ps.drawfromgeometry:break;case Ps.hexagon:s=H.createHexagon(t,e,i)}return null!=s?s:R.mkFullEllipseNNP(t/2,e/2,i)}createNodeGeometry(t,e){if(t instanceof p){mo.getDrawingObj(t).createGeometry(e)}else{const i=bo.getDrawingObj(t);let n=new V(1,1);i.labelText&&(n=e(i.labelText));const r=n.width+2*i.LabelMargin,s=n.height+2*i.LabelMargin,o=new E(0,0);new q(t).boundaryCurve=this.curveByShape(r,s,o,i.shape,i)}}}class vo extends mo{constructor(){super(...arguments),this.directed=!0}}var So,Co,wo=i(66),Eo=i.n(wo),xo=i(67),Ao=i.n(xo);class To extends u{constructor(t){super(),this.text=t}toString(){return this.text}}function Io(t,e,i,n,r){const s=i.graph.nodeCollection;let o,a;if("node_id"!=t.type){const s=[];for(const o of t.children)if("node_stmt"===o.type)for(const t of Io(o.node_id,e,i,n,r))s.push(t);else if("attr_stmt"!==o.type)throw new Error("not implemented");for(const e of t.children)if("attr_stmt"===e.type)for(const t of s)Lo(e,t);return s}{const e=t.id.toString();if(s.hasNode(e))o=s.getNode(e);else{i.graph.addNode(o=new g(e));new bo(o).labelText=e}}if("node_id"==e.type){const t=e.id.toString();if(s.hasNode(t))a=s.getNode(t);else{i.graph.addNode(a=new g(t));new bo(a).labelText=t}}else if("subgraph"==e.type){const s=new Array;for(const o of e.children)if("node_stmt"===o.type)for(const e of Io(t,o.node_id,i,n,r))s.push(e);else if("attr_stmt"!==o.type)throw new Error("not implemented");for(const t of e.children)if("attr_stmt"===t.type)for(const e of s)Lo(t,e);return s}const l=new c(o,a);s.addEdge(l);const h=new vo(l);return Lo(r,h),h.labelText&&(l.label=new To(h.labelText),h.label=new yo(h.labelText)),h.directed=n,[h]}function Oo(t,e,i){Ro(t.children,e,i)}function _o(t,e){const i=t.node_id.id.toString();let n,r=e.graph.findNode(i);return r?(n=mo.getDrawingObj(r),n||(n=new bo(r))):(r=new g(i),e.graph.addNode(r),n=new bo(r)),Lo(t,n),n}function Lo(t,e){if(null!=t.attr_list)for(const i of t.attr_list){if("attr"!=i.type)throw new Error("unexpected type "+i.type);{const t=i.eq;switch(i.id){case"color":e.color=Fo(t);break;case"pencolor":e.pencolor=Fo(t);break;case"labelfontcolor":e.labelfontcolor=Fo(t);break;case"fontcolor":e.fontColor=Fo(t);break;case"fillcolor":e.fillColor=Fo(t);break;case"style":e.styleEnum=No(t);break;case"shape":e.shape=ko(t);break;case"peripheries":e.peripheries=parseInt(t);break;case"headlabel":e.headlabel=t;break;case"label":"string"!=typeof t&&"number"!=typeof t||(e.labelText=t.toString());break;case"size":e.size=Vo(t);break;case"pos":e.pos=Vo(t);break;case"rankdir":e.rankdir=Go(t);break;case"fontname":e.fontname=t;break;case"fontsize":e.fontsize=parseFloat(t);break;case"width":e.width=parseFloat(t);break;case"height":e.height=parseFloat(t);break;case"margin":e.margin=parseFloat(t);break;case"len":e.len=parseFloat(t);break;case"minlen":e.minlen=parseFloat(t);break;case"rank":e.rank=zo(t);break;case"charset":e.charset=t;break;case"orientation":e.orientation=t;break;case"ratio":e.ratio=t;break;case"weight":e.weight=parseFloat(t);break;case"nodesep":e.nodesep=parseFloat(t);break;case"layersep":e.layersep=parseFloat(t);break;case"arrowsize":e.arrowsize=parseFloat(t);break;case"rotate":e.rotate=parseFloat(t);break;case"ranksep":e.ranksep=parseFloat(t);break;case"splines":e.splines="true"==t;break;case"overlap":e.overlap="true"==t;break;case"arrowtail":e.arrowtail=jo(t);break;case"taillabel":e.taillabel=t;break;case"arrowhead":e.arrowhead=jo(t);break;case"ordering":e.ordering=Uo(t);break;case"URL":e.URL=t;break;case"dir":e.dir=Wo(t);break;case"concentrate":e.concentrate="true"==t;break;case"compound":e.compound="true"==t;break;case"lhead":e.lhead=t;break;case"ltail":e.ltail=t;break;case"bgcolor":e.bgcolor=Fo(t);break;case"center":e.center=1==t||1==parseInt(t);break;case"colorscheme":e.colorscheme=t;break;case"sides":e.sides=parseInt(t);break;case"distortion":e.distortion=parseFloat(t);break;case"skew":e.skew=parseFloat(t);break;case"bb":e.bb=Ho(t);break;case"labelloc":e.labelloc=t;break;case"decorate":e.decorate="true"==t;break;case"tailclip":e.tailclip="true"==t;break;case"headclip":e.headclip="true"==t;break;case"constraint":e.constraint="true"==t;break;case"gradientangle":e.gradientangle=parseFloat(t);break;case"samehead":e.samehead=t;break;case"href":e.href=t;break;case"imagepath":e.imagepath=t;break;case"image":e.image=t;break;case"labeljust":e.labejust=t;break;case"layers":e.layers=t.split(",");break;case"layer":e.layer=t;break;case"f":e.f=parseFloat(t);break;case"nojustify":e.nojustify="true"==t;break;case"root":e.root="true"==t;break;case"page":e.page=Vo(t);break;case"pname":e.pname=t;break;case"kind":e.kind=t;break;case"fname":e.fname=t;break;case"subkind":e.subkind=t;break;case"area":e.area=parseFloat(t);break;case"tailport":e.tailport=t;break;case"headport":e.headport=t;break;case"wt":e.wt=t;break;case"id":e.id=t;break;case"edgetooltip":e.edgetooltip=t;break;case"headtooltip":e.headtooltip=t;break;case"tailtooltip":e.tailtooltip=t;break;case"headURL":e.headURL=t;break;case"tailURL":e.tailURL=t;break;case"labelURL":e.labelURL=t;break;case"edgeurl":e.edgeurl=t;break;case"shapefile":e.shapefile=t;break;case"xlabel":e.xlabel=t;break;case"sametail":e.sametail=t;break;case"clusterrank":e.clusterRank=t}}}}function Ro(t,e,i){for(const n of t)switch(n.type){case"node_stmt":_o(n,e);break;case"edge_stmt":{const t=n.edge_list;for(let r=0;r<t.length-1;r++)Io(t[r],t[r+1],e,i,n)}break;case"subgraph":if(Mo(n,e));else if(null==n.id){Xo(n,e,qo(n,e,i))}else{const t=new p(n.id);Oo(n,new Po(t),i),t.isEmpty()||e.graph.addNode(t)}break;case"attr_stmt":Do(n,e);break;default:throw new Error("not implemented")}}function Bo(t){const e=Eo()(t);if(null==e)return null;const i=new p,n=new Po(i);return Ro(e[0].children,n,"digraph"==e[0].type),n}function Mo(t,e){const i=t.children[0];if(null==i)return!1;if("attr_stmt"!=i.type)return!1;const n=i.attr_list;if(null==n)return!1;if(0==n.length)return!1;const r=n[0];if("attr"!=r.type)return!1;if("rank"!=r.id)return!1;switch(r.eq){case"min":for(let i=1;i<t.children.length;i++){const n=t.children[i];e.graphVisData.minRanks.push(n.id)}return!0;case"max":for(let i=1;i<t.children.length;i++){const n=t.children[i];e.graphVisData.maxRanks.push(n.id)}return!0;case"same":{const i=[];for(let e=1;e<t.children.length;e++){const n=t.children[e];i.push(n.id)}return e.graphVisData.sameRanks.push(i),!0}case"source":for(let i=1;i<t.children.length;i++){const n=t.children[i];e.graphVisData.sourceRanks.push(n.id)}return!0;case"sink":for(let i=1;i<t.children.length;i++){const n=t.children[i];e.graphVisData.sinkRanks.push(n.id)}return!0;default:throw new Error("incorrect rank")}}function Fo(t){const e=Ao()(t);if(null!=e){if(null!=e.rgba)return new po(255*e.rgba[3],e.rgba[0],e.rgba[1],e.rgba[2]);if(null!=e.rgb)return po.mkRGB(e.rgb[0],e.rgb[1],e.rgb[2])}return null!=e.keyword?po.parse(e.keyword):po.Black}function Do(t,e){null==e.defaultNode&&"node"==t.target?(e.defaultNode=new bo(null),Lo(t,e.defaultNode)):"graph"==t.target&&Lo(t,e)}function No(t){return Ss[t]}function ko(t){const e=t.toLowerCase();return Ps[e]}function Vo(t){const e=t.split(",");return[parseFloat(e[0]),parseFloat(e[1])]}function Go(t){return Tt[t]}function zo(t){return vs[t]}function jo(t){return bs[t]}function Uo(t){return So[t]}function Wo(t){return Co[t]}function Ho(t){const e=t.split(",");return[parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])]}function qo(t,e,i){let n=[];for(const r of t.children)if("edge_stmt"==r.type){const t=r.edge_list;for(let s=0;s<t.length-1;s++)for(const o of Io(t[s],t[s+1],e,i,r))n.push(o)}else if("attr_stmt"==r.type);else if("node_stmt"==r.type)n.push(_o(r,e));else{if("subgraph"!==r.type)throw new Error("Function not implemented.");if(null!=r.id){const t=new p(r.id);e.graph.addNode(t);const s=new Po(t);Oo(r,s,i),n.push(s)}else n=n.concat(qo(r,e,i))}return n}function Xo(t,e,i){for(const e of t.children)if("attr_stmt"==e.type)for(const t of i)Lo(e,t)}function Yo(t){return"Arya"==t.source.id||"Arya"==t.target.id}!function(t){t[t.in=0]="in",t[t.out=1]="out"}(So||(So={})),function(t){t[t.forward=0]="forward",t[t.back=1]="back",t[t.both=2]="both",t[t.none=3]="none"}(Co||(Co={}));let Qo=1,Zo=1;class Ko{constructor(){this.time=0,this.channels=new Map,this.animations=new Map,this.playing=!1,this.lastEngineTime=-1}addChannel(t){const{delay:e=0,duration:i=Number.POSITIVE_INFINITY,rate:n=1,repeat:r=1}=t,s=Qo++,o={time:0,delay:e,duration:i,rate:n,repeat:r};return this._setChannelTime(o,this.time),this.channels.set(s,o),s}removeChannel(t){this.channels.delete(t);for(const[e,i]of this.animations)i.channel===t&&this.detachAnimation(e)}isFinished(t){const e=this.channels.get(t);return void 0!==e&&this.time>=e.delay+e.duration*e.repeat}getTime(t){if(void 0===t)return this.time;const e=this.channels.get(t);return void 0===e?-1:e.time}setTime(t){this.time=Math.max(0,t);const e=this.channels.values();for(const t of e)this._setChannelTime(t,this.time);const i=this.animations.values();for(const t of i){const{animation:e,channel:i}=t;e.setTime(this.getTime(i))}}play(){this.playing=!0}pause(){this.playing=!1,this.lastEngineTime=-1}reset(){this.setTime(0)}attachAnimation(t,e){const i=Zo++;return this.animations.set(i,{animation:t,channel:e}),t.setTime(this.getTime(e)),i}detachAnimation(t){this.animations.delete(t)}update(t){this.playing&&(-1===this.lastEngineTime&&(this.lastEngineTime=t),this.setTime(this.time+(t-this.lastEngineTime)),this.lastEngineTime=t)}_setChannelTime(t,e){const i=e-t.delay;i>=t.duration*t.repeat?t.time=t.duration*t.rate:(t.time=Math.max(0,i)%t.duration,t.time*=t.rate)}}const $o="Awaiting state",Jo="Matched. State transferred from previous layer",ta="Initialized",ea="Discarded. Awaiting garbage collection",ia="No longer matched. Awaiting garbage collection",na="Finalized! Awaiting garbage collection",ra=Symbol.for("component"),sa=Symbol.for("asyncPropDefaults"),oa=Symbol.for("asyncPropOriginal"),aa=Symbol.for("asyncPropResolved");function la(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}var ha=i(25),ua=i(61);class ca{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"sessionStorage";la(this,"storage",void 0),la(this,"id",void 0),la(this,"config",{}),this.storage=function(t){try{const e=window[t],i="__storage_test__";return e.setItem(i,i),e.removeItem(i),e}catch(t){return null}}(i),this.id=t,this.config={},Object.assign(this.config,e),this._loadConfiguration()}getConfiguration(){return this.config}setConfiguration(t){return this.config={},this.updateConfiguration(t)}updateConfiguration(t){if(Object.assign(this.config,t),this.storage){const t=JSON.stringify(this.config);this.storage.setItem(this.id,t)}return this}_loadConfiguration(){let t={};if(this.storage){const e=this.storage.getItem(this.id);t=e?JSON.parse(e):{}}return Object.assign(this.config,t),this}}function da(t,e,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:600;const r=t.src.replace(/\(/g,"%28").replace(/\)/g,"%29");t.width>n&&(i=Math.min(i,n/t.width));const s=t.width*i,o=t.height*i,a=["font-size:1px;","padding:".concat(Math.floor(o/2),"px ").concat(Math.floor(s/2),"px;"),"line-height:".concat(o,"px;"),"background:url(".concat(r,");"),"background-size:".concat(s,"px ").concat(o,"px;"),"color:transparent;"].join("");return["".concat(e," %c+"),a]}let ga;function fa(t){return"string"==typeof t?ga[t.toUpperCase()]||ga.WHITE:t}function pa(t,e){if(!t)throw new Error(e||"Assertion failed")}!function(t){t[t.BLACK=30]="BLACK",t[t.RED=31]="RED",t[t.GREEN=32]="GREEN",t[t.YELLOW=33]="YELLOW",t[t.BLUE=34]="BLUE",t[t.MAGENTA=35]="MAGENTA",t[t.CYAN=36]="CYAN",t[t.WHITE=37]="WHITE",t[t.BRIGHT_BLACK=90]="BRIGHT_BLACK",t[t.BRIGHT_RED=91]="BRIGHT_RED",t[t.BRIGHT_GREEN=92]="BRIGHT_GREEN",t[t.BRIGHT_YELLOW=93]="BRIGHT_YELLOW",t[t.BRIGHT_BLUE=94]="BRIGHT_BLUE",t[t.BRIGHT_MAGENTA=95]="BRIGHT_MAGENTA",t[t.BRIGHT_CYAN=96]="BRIGHT_CYAN",t[t.BRIGHT_WHITE=97]="BRIGHT_WHITE"}(ga||(ga={}));var ma=i(15);function ya(){let t;var e,i;if(ha.a&&"performance"in ma.f)t=null===ma.f||void 0===ma.f||null===(e=ma.f.performance)||void 0===e||null===(i=e.now)||void 0===i?void 0:i.call(e);else if("hrtime"in ma.d){var n;const e=null===ma.d||void 0===ma.d||null===(n=ma.d.hrtime)||void 0===n?void 0:n.call(ma.d);t=1e3*e[0]+e[1]/1e6}else t=Date.now();return t}const ba={debug:ha.a&&console.debug||console.log,log:console.log,info:console.info,warn:console.warn,error:console.error},Pa={enabled:!0,level:0};function va(){}const Sa={},Ca={once:!0};class wa{constructor(){let{id:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{id:""};la(this,"id",void 0),la(this,"VERSION",ua.a),la(this,"_startTs",ya()),la(this,"_deltaTs",ya()),la(this,"_storage",void 0),la(this,"userData",{}),la(this,"LOG_THROTTLE_TIMEOUT",0),this.id=t,this._storage=new ca("__probe-".concat(this.id,"__"),Pa),this.userData={},this.timeStamp("".concat(this.id," started")),function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:["constructor"];const i=Object.getPrototypeOf(t),n=Object.getOwnPropertyNames(i);for(const i of n)"function"==typeof t[i]&&(e.find(t=>i===t)||(t[i]=t[i].bind(t)))}(this),Object.seal(this)}set level(t){this.setLevel(t)}get level(){return this.getLevel()}isEnabled(){return this._storage.config.enabled}getLevel(){return this._storage.config.level}getTotal(){return Number((ya()-this._startTs).toPrecision(10))}getDelta(){return Number((ya()-this._deltaTs).toPrecision(10))}set priority(t){this.level=t}get priority(){return this.level}getPriority(){return this.level}enable(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this._storage.updateConfiguration({enabled:t}),this}setLevel(t){return this._storage.updateConfiguration({level:t}),this}get(t){return this._storage.config[t]}set(t,e){this._storage.updateConfiguration({[t]:e})}settings(){console.table?console.table(this._storage.config):console.log(this._storage.config)}assert(t,e){pa(t,e)}warn(t){return this._getLogFunction(0,t,ba.warn,arguments,Ca)}error(t){return this._getLogFunction(0,t,ba.error,arguments)}deprecated(t,e){return this.warn("`".concat(t,"` is deprecated and will be removed in a later version. Use `").concat(e,"` instead"))}removed(t,e){return this.error("`".concat(t,"` has been removed. Use `").concat(e,"` instead"))}probe(t,e){return this._getLogFunction(t,e,ba.log,arguments,{time:!0,once:!0})}log(t,e){return this._getLogFunction(t,e,ba.debug,arguments)}info(t,e){return this._getLogFunction(t,e,console.info,arguments)}once(t,e){for(var i=arguments.length,n=new Array(i>2?i-2:0),r=2;r<i;r++)n[r-2]=arguments[r];return this._getLogFunction(t,e,ba.debug||ba.info,arguments,Ca)}table(t,e,i){return e?this._getLogFunction(t,e,console.table||va,i&&[i],{tag:Aa(e)}):va}image(t){let{logLevel:e,priority:n,image:r,message:s="",scale:o=1}=t;return this._shouldLog(e||n)?ha.a?function(t){let{image:e,message:i="",scale:n=1}=t;if("string"==typeof e){const t=new Image;return t.onload=()=>{const e=da(t,i,n);console.log(...e)},t.src=e,va}const r=e.nodeName||"";if("img"===r.toLowerCase())return console.log(...da(e,i,n)),va;if("canvas"===r.toLowerCase()){const t=new Image;return t.onload=()=>console.log(...da(t,i,n)),t.src=e.toDataURL(),va}return va}({image:r,message:s,scale:o}):function(t){let{image:e,message:n="",scale:r=1}=t,s=null;try{s=i(104)}catch(t){}if(s)return()=>s(e,{fit:"box",width:"".concat(Math.round(80*r),"%")}).then(t=>console.log(t));return va}({image:r,message:s,scale:o}):va}time(t,e){return this._getLogFunction(t,e,console.time?console.time:console.info)}timeEnd(t,e){return this._getLogFunction(t,e,console.timeEnd?console.timeEnd:console.info)}timeStamp(t,e){return this._getLogFunction(t,e,console.timeStamp||va)}group(t,e){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{collapsed:!1};const n=xa({logLevel:t,message:e,opts:i}),{collapsed:r}=i;return n.method=(r?console.groupCollapsed:console.group)||console.info,this._getLogFunction(n)}groupCollapsed(t,e){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.group(t,e,Object.assign({},i,{collapsed:!0}))}groupEnd(t){return this._getLogFunction(t,"",console.groupEnd||va)}withGroup(t,e,i){this.group(t,e)();try{i()}finally{this.groupEnd(t)()}}trace(){console.trace&&console.trace()}_shouldLog(t){return this.isEnabled()&&this.getLevel()>=Ea(t)}_getLogFunction(t,e,i,n,r){if(this._shouldLog(t)){r=xa({logLevel:t,message:e,args:n,opts:r}),pa(i=i||r.method),r.total=this.getTotal(),r.delta=this.getDelta(),this._deltaTs=ya();const s=r.tag||r.message;if(r.once){if(Sa[s])return va;Sa[s]=ya()}return e=function(t,e,i){if("string"==typeof e){const o=i.time?function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:8;const i=Math.max(e-t.length,0);return"".concat(" ".repeat(i)).concat(t)}(function(t){let e;return e=t<10?"".concat(t.toFixed(2),"ms"):t<100?"".concat(t.toFixed(1),"ms"):t<1e3?"".concat(t.toFixed(0),"ms"):"".concat((t/1e3).toFixed(2),"s"),e}(i.total)):"";e=i.time?"".concat(t,": ").concat(o,"  ").concat(e):"".concat(t,": ").concat(e),n=e,r=i.color,s=i.background,ha.a||"string"!=typeof n||(r&&(r=fa(r),n="[".concat(r,"m").concat(n,"[39m")),s&&(r=fa(s),n="[".concat(s+10,"m").concat(n,"[49m"))),e=n}var n,r,s;return e}(this.id,r.message,r),i.bind(console,e,...r.args)}return va}}function Ea(t){if(!t)return 0;let e;switch(typeof t){case"number":e=t;break;case"object":e=t.logLevel||t.priority||0;break;default:return 0}return pa(Number.isFinite(e)&&e>=0),e}function xa(t){const{logLevel:e,message:i}=t;t.logLevel=Ea(e);const n=t.args?Array.from(t.args):[];for(;n.length&&n.shift()!==i;);switch(typeof e){case"string":case"function":void 0!==i&&n.unshift(i),t.message=e;break;case"object":Object.assign(t,e)}"function"==typeof t.message&&(t.message=t.message());const r=typeof t.message;return pa("string"===r||"object"===r),Object.assign(t,{args:n},t.opts)}function Aa(t){for(const e in t)for(const i in t[e])return i||"untitled";return"empty"}la(wa,"VERSION",ua.a);var Ta=new wa({id:"deck"});let Ia={};function Oa(t){Ta.level>0&&Ia[t]&&Ia[t].call(...arguments)}function _a(t,e=(()=>!0)){return Array.isArray(t)?function t(e,i,n){let r=-1;for(;++r<e.length;){const s=e[r];Array.isArray(s)?t(s,i,n):i(s)&&n.push(s)}return n}(t,e,[]):e(t)?[t]:[]}function La({target:t,source:e,start:i=0,count:n=1}){const r=e.length,s=n*r;let o=0;for(let n=i;o<r;o++)t[n++]=e[o];for(;o<s;)o<s-o?(t.copyWithin(i+o,i,i+o),o*=2):(t.copyWithin(i+o,i,i+s-o),o=s);return t}var Ra=i(34);class Ba{constructor(t,e){la(this,"name",void 0),la(this,"type",void 0),la(this,"sampleSize",1),la(this,"time",void 0),la(this,"count",void 0),la(this,"samples",void 0),la(this,"lastTiming",void 0),la(this,"lastSampleTime",void 0),la(this,"lastSampleCount",void 0),la(this,"_count",0),la(this,"_time",0),la(this,"_samples",0),la(this,"_startTime",0),la(this,"_timerPending",!1),this.name=t,this.type=e,this.reset()}setSampleSize(t){return this.sampleSize=t,this}incrementCount(){return this.addCount(1),this}decrementCount(){return this.subtractCount(1),this}addCount(t){return this._count+=t,this._samples++,this._checkSampling(),this}subtractCount(t){return this._count-=t,this._samples++,this._checkSampling(),this}addTime(t){return this._time+=t,this.lastTiming=t,this._samples++,this._checkSampling(),this}timeStart(){return this._startTime=Object(Ra.a)(),this._timerPending=!0,this}timeEnd(){return this._timerPending?(this.addTime(Object(Ra.a)()-this._startTime),this._timerPending=!1,this._checkSampling(),this):this}getSampleAverageCount(){return this.sampleSize>0?this.lastSampleCount/this.sampleSize:0}getSampleAverageTime(){return this.sampleSize>0?this.lastSampleTime/this.sampleSize:0}getSampleHz(){return this.lastSampleTime>0?this.sampleSize/(this.lastSampleTime/1e3):0}getAverageCount(){return this.samples>0?this.count/this.samples:0}getAverageTime(){return this.samples>0?this.time/this.samples:0}getHz(){return this.time>0?this.samples/(this.time/1e3):0}reset(){return this.time=0,this.count=0,this.samples=0,this.lastTiming=0,this.lastSampleTime=0,this.lastSampleCount=0,this._count=0,this._time=0,this._samples=0,this._startTime=0,this._timerPending=!1,this}_checkSampling(){this._samples===this.sampleSize&&(this.lastSampleTime=this._time,this.lastSampleCount=this._count,this.count+=this._count,this.time+=this._time,this.samples+=this._samples,this._time=0,this._count=0,this._samples=0)}}class Ma{constructor(t){la(this,"id",void 0),la(this,"stats",{}),this.id=t.id,this.stats={},this._initializeStats(t.stats),Object.seal(this)}get(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"count";return this._getOrCreate({name:t,type:e})}get size(){return Object.keys(this.stats).length}reset(){for(const t in this.stats)this.stats[t].reset();return this}forEach(t){for(const e in this.stats)t(this.stats[e])}getTable(){const t={};return this.forEach(e=>{t[e.name]={time:e.time||0,count:e.count||0,average:e.getAverageTime()||0,hz:e.getHz()||0}}),t}_initializeStats(){(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]).forEach(t=>this._getOrCreate(t))}_getOrCreate(t){if(!t||!t.name)return null;const{name:e,type:i}=t;return this.stats[e]||(this.stats[e]=t instanceof Ba?t:new Ba(e,i)),this.stats[e]}}const Fa=t=>"boolean"==typeof t,Da=t=>"function"==typeof t,Na=t=>null!==t&&"object"==typeof t,ka=t=>Na(t)&&t.constructor==={}.constructor,Va=t=>t&&"function"==typeof t[Symbol.iterator],Ga=t=>t&&"function"==typeof t[Symbol.asyncIterator],za=t=>"undefined"!=typeof Response&&t instanceof Response||t&&t.arrayBuffer&&t.text&&t.json,ja=t=>"undefined"!=typeof Blob&&t instanceof Blob,Ua=t=>(t=>"undefined"!=typeof ReadableStream&&t instanceof ReadableStream||Na(t)&&Da(t.tee)&&Da(t.cancel)&&Da(t.getReader))(t)||(t=>Na(t)&&Da(t.read)&&Da(t.pipe)&&Fa(t.readable))(t);function Wa(t,e){if(!t)throw new Error(e||"loader assertion failed.")}function Ha(t){var e;if(!t)return!1;Array.isArray(t)&&(t=t[0]);return Array.isArray(null===(e=t)||void 0===e?void 0:e.extensions)}function qa(t){var e,i;let n;return Wa(t,"null loader"),Wa(Ha(t),"invalid loader"),Array.isArray(t)&&(n=t[1],t=t[0],t={...t,options:{...t.options,...n}}),(null!==(e=t)&&void 0!==e&&e.parseTextSync||null!==(i=t)&&void 0!==i&&i.parseText)&&(t.text=!0),t.text||(t.binary=!0),t}let Xa="";const Ya={};const Qa=/^data:([-\w.]+\/[-\w.+]+)(;|,)/,Za=/^([-\w.]+\/[-\w.+]+)/;function Ka(t){const e=Za.exec(t);return e?e[1]:t}function $a(t){const e=Qa.exec(t);return e?e[1]:""}const Ja=/\?.*/;function tl(t){if(za(t)){const e=el(t.url||"");return{url:e,type:Ka(t.headers.get("content-type")||"")||$a(e)}}return ja(t)?{url:el(t.name||""),type:t.type||""}:"string"==typeof t?{url:el(t),type:$a(t)}:{url:"",type:""}}function el(t){return t.replace(Ja,"")}async function il(t){if(za(t))return t;const e={},i=function(t){return za(t)?t.headers["content-length"]||-1:ja(t)?t.size:"string"==typeof t?t.length:t instanceof ArrayBuffer||ArrayBuffer.isView(t)?t.byteLength:-1}(t);i>=0&&(e["content-length"]=String(i));const{url:n,type:r}=tl(t);r&&(e["content-type"]=r);const s=await async function(t){if("string"==typeof t)return"data:,".concat(t.slice(0,5));if(t instanceof Blob){const e=t.slice(0,5);return await new Promise(t=>{const i=new FileReader;i.onload=e=>{var i;return t(null==e||null===(i=e.target)||void 0===i?void 0:i.result)},i.readAsDataURL(e)})}if(t instanceof ArrayBuffer){const e=function(t){let e="";const i=new Uint8Array(t);for(let t=0;t<i.byteLength;t++)e+=String.fromCharCode(i[t]);return btoa(e)}(t.slice(0,5));return"data:base64,".concat(e)}return null}(t);s&&(e["x-first-bytes"]=s),"string"==typeof t&&(t=(new TextEncoder).encode(t));const o=new Response(t,{headers:e});return Object.defineProperty(o,"url",{value:n}),o}async function nl(t){if(!t.ok){const e=await async function(t){let e="Failed to fetch resource ".concat(t.url," (").concat(t.status,"): ");try{const i=t.headers.get("Content-Type");let n=t.statusText;i.includes("application/json")&&(n+=" ".concat(await t.text())),e+=n,e=e.length>60?"".concat(e.slice(60),"..."):e}catch(t){}return e}(t);throw new Error(e)}}async function rl(t,e){if("string"==typeof t){t=function(t){for(const e in Ya)if(t.startsWith(e)){const i=Ya[e];t=t.replace(e,i)}return t.startsWith("http://")||t.startsWith("https://")||(t="".concat(Xa).concat(t)),t}(t);let i=e;return null!=e&&e.fetch&&"function"!=typeof(null==e?void 0:e.fetch)&&(i=e.fetch),await fetch(t,i)}return await il(t)}const sl=new wa({id:"loaders.gl"});class ol{log(){return()=>{}}info(){return()=>{}}warn(){return()=>{}}error(){return()=>{}}}const al={fetch:null,mimeType:void 0,nothrow:!1,log:new class{constructor(){la(this,"console",void 0),this.console=console}log(...t){return this.console.log.bind(this.console,...t)}info(...t){return this.console.info.bind(this.console,...t)}warn(...t){return this.console.warn.bind(this.console,...t)}error(...t){return this.console.error.bind(this.console,...t)}},CDN:"https://unpkg.com/@loaders.gl",worker:!0,maxConcurrency:3,maxMobileConcurrency:1,reuseWorkers:!0,_workerType:"",limit:0,_limitMB:0,batchSize:"auto",batchDebounceMs:0,metadata:!1,transforms:[]},ll={throws:"nothrow",dataType:"(no longer used)",uri:"baseUri",method:"fetch.method",headers:"fetch.headers",body:"fetch.body",mode:"fetch.mode",credentials:"fetch.credentials",cache:"fetch.cache",redirect:"fetch.redirect",referrer:"fetch.referrer",referrerPolicy:"fetch.referrerPolicy",integrity:"fetch.integrity",keepalive:"fetch.keepalive",signal:"fetch.signal"};function hl(){globalThis.loaders=globalThis.loaders||{};const{loaders:t}=globalThis;return t._state=t._state||{},t._state}const ul=()=>{const t=hl();return t.globalOptions=t.globalOptions||{...al},t.globalOptions};function cl(t,e,i,n){return i=i||[],function(t,e){gl(t,null,al,ll,e);for(const i of e){const n=t&&t[i.id]||{},r=i.options&&i.options[i.id]||{},s=i.deprecatedOptions&&i.deprecatedOptions[i.id]||{};gl(n,i.id,r,s,e)}}(t,i=Array.isArray(i)?i:[i]),pl(e,t,n)}function dl(t,e){const i=ul(),n=t||i;return"function"==typeof n.fetch?n.fetch:Na(n.fetch)?t=>rl(t,n):null!=e&&e.fetch?null==e?void 0:e.fetch:rl}function gl(t,e,i,n,r){const s=e||"Top level",o=e?"".concat(e,"."):"";for(const a in t){const l=!e&&Na(t[a]),h="baseUri"===a&&!e,u="workerUrl"===a&&e;if(!(a in i)&&!h&&!u)if(a in n)sl.warn("".concat(s," loader option '").concat(o).concat(a,"' no longer supported, use '").concat(n[a],"'"))();else if(!l){const t=fl(a,r);sl.warn("".concat(s," loader option '").concat(o).concat(a,"' not recognized. ").concat(t))()}}}function fl(t,e){const i=t.toLowerCase();let n="";for(const r of e)for(const e in r.options){if(t===e)return"Did you mean '".concat(r.id,".").concat(e,"'?");const s=e.toLowerCase();(i.startsWith(s)||s.startsWith(i))&&(n=n||"Did you mean '".concat(r.id,".").concat(e,"'?"))}return n}function pl(t,e,i){const n={...t.options||{}};return function(t,e){e&&!("baseUri"in t)&&(t.baseUri=e)}(n,i),null===n.log&&(n.log=new ol),ml(n,ul()),ml(n,e),n}function ml(t,e){for(const i in e)if(i in e){const n=e[i];ka(n)&&ka(t[i])?t[i]={...t[i],...e[i]}:t[i]=e[i]}}function yl(t,e){if(!t)throw new Error(e||"loaders.gl assertion failed.")}var bl=i(68);const Pl=new Map;function vl(t){yl(t.source&&!t.url||!t.source&&t.url);let e=Pl.get(t.source||t.url);return e||(t.url&&(e=function(t){if(!t.startsWith("http"))return t;return Sl((e=t,"try {\n  importScripts('".concat(e,"');\n} catch (error) {\n  console.error(error);\n  throw error;\n}")));var e}(t.url),Pl.set(t.url,e)),t.source&&(e=Sl(t.source),Pl.set(t.source,e))),yl(e),e}function Sl(t){const e=new Blob([t],{type:"application/javascript"});return URL.createObjectURL(e)}function Cl(t){return!!t&&(t instanceof ArrayBuffer||("undefined"!=typeof MessagePort&&t instanceof MessagePort||("undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas)))}const wl=()=>{};class El{static isSupported(){return"undefined"!=typeof Worker}constructor(t){la(this,"name",void 0),la(this,"source",void 0),la(this,"url",void 0),la(this,"terminated",!1),la(this,"worker",void 0),la(this,"onMessage",void 0),la(this,"onError",void 0),la(this,"_loadableURL","");const{name:e,source:i,url:n}=t;yl(i||n),this.name=e,this.source=i,this.url=n,this.onMessage=wl,this.onError=t=>console.log(t),this.worker=this._createBrowserWorker()}destroy(){this.onMessage=wl,this.onError=wl,this.worker.terminate(),this.terminated=!0}get isRunning(){return Boolean(this.onMessage)}postMessage(t,e){e=e||function t(e,i=!0,n){const r=n||new Set;if(e){if(Cl(e))r.add(e);else if(Cl(e.buffer))r.add(e.buffer);else if(ArrayBuffer.isView(e));else if(i&&"object"==typeof e)for(const n in e)t(e[n],i,r)}else;return void 0===n?Array.from(r):[]}(t),this.worker.postMessage(t,e)}_getErrorFromErrorEvent(t){let e="Failed to load ";return e+="worker ".concat(this.name," from ").concat(this.url,". "),t.message&&(e+="".concat(t.message," in ")),t.lineno&&(e+=":".concat(t.lineno,":").concat(t.colno)),new Error(e)}_createBrowserWorker(){this._loadableURL=vl({source:this.source,url:this.url});const t=new Worker(this._loadableURL,{name:this.name});return t.onmessage=t=>{t.data?this.onMessage(t.data):this.onError(new Error("No data received"))},t.onerror=t=>{this.onError(this._getErrorFromErrorEvent(t)),this.terminated=!0},t.onmessageerror=t=>console.error(t),t}}class xl{constructor(t,e){la(this,"name",void 0),la(this,"workerThread",void 0),la(this,"isRunning",void 0),la(this,"result",void 0),la(this,"_resolve",void 0),la(this,"_reject",void 0),this.name=t,this.workerThread=e,this.isRunning=!0,this._resolve=()=>{},this._reject=()=>{},this.result=new Promise((t,e)=>{this._resolve=t,this._reject=e})}postMessage(t,e){this.workerThread.postMessage({source:"loaders.gl",type:t,payload:e})}done(t){yl(this.isRunning),this.isRunning=!1,this._resolve(t)}error(t){yl(this.isRunning),this.isRunning=!1,this._reject(t)}}class Al{constructor(t){la(this,"name","unnamed"),la(this,"source",void 0),la(this,"url",void 0),la(this,"maxConcurrency",1),la(this,"maxMobileConcurrency",1),la(this,"onDebug",()=>{}),la(this,"reuseWorkers",!0),la(this,"props",{}),la(this,"jobQueue",[]),la(this,"idleQueue",[]),la(this,"count",0),la(this,"isDestroyed",!1),this.source=t.source,this.url=t.url,this.setProps(t)}destroy(){this.idleQueue.forEach(t=>t.destroy()),this.isDestroyed=!0}setProps(t){this.props={...this.props,...t},void 0!==t.name&&(this.name=t.name),void 0!==t.maxConcurrency&&(this.maxConcurrency=t.maxConcurrency),void 0!==t.maxMobileConcurrency&&(this.maxMobileConcurrency=t.maxMobileConcurrency),void 0!==t.reuseWorkers&&(this.reuseWorkers=t.reuseWorkers),void 0!==t.onDebug&&(this.onDebug=t.onDebug)}async startJob(t,e=((t,e,i)=>t.done(i)),i=((t,e)=>t.error(e))){const n=new Promise(n=>(this.jobQueue.push({name:t,onMessage:e,onError:i,onStart:n}),this));return this._startQueuedJob(),await n}async _startQueuedJob(){if(!this.jobQueue.length)return;const t=this._getAvailableWorker();if(!t)return;const e=this.jobQueue.shift();if(e){this.onDebug({message:"Starting job",name:e.name,workerThread:t,backlog:this.jobQueue.length});const i=new xl(e.name,t);t.onMessage=t=>e.onMessage(i,t.type,t.payload),t.onError=t=>e.onError(i,t),e.onStart(i);try{await i.result}finally{this.returnWorkerToQueue(t)}}}returnWorkerToQueue(t){this.isDestroyed||!this.reuseWorkers||this.count>this._getMaxConcurrency()?(t.destroy(),this.count--):this.idleQueue.push(t),this.isDestroyed||this._startQueuedJob()}_getAvailableWorker(){if(this.idleQueue.length>0)return this.idleQueue.shift()||null;if(this.count<this._getMaxConcurrency()){this.count++;const t="".concat(this.name.toLowerCase()," (#").concat(this.count," of ").concat(this.maxConcurrency,")");return new El({name:t,source:this.source,url:this.url})}return null}_getMaxConcurrency(){return bl.a?this.maxMobileConcurrency:this.maxConcurrency}}const Tl={maxConcurrency:3,maxMobileConcurrency:1,onDebug:()=>{},reuseWorkers:!0};class Il{static isSupported(){return El.isSupported()}static getWorkerFarm(t={}){return Il._workerFarm=Il._workerFarm||new Il({}),Il._workerFarm.setProps(t),Il._workerFarm}constructor(t){la(this,"props",void 0),la(this,"workerPools",new Map),this.props={...Tl},this.setProps(t),this.workerPools=new Map}destroy(){for(const t of this.workerPools.values())t.destroy()}setProps(t){this.props={...this.props,...t};for(const t of this.workerPools.values())t.setProps(this._getWorkerPoolProps())}getWorkerPool(t){const{name:e,source:i,url:n}=t;let r=this.workerPools.get(e);return r||(r=new Al({name:e,source:i,url:n}),r.setProps(this._getWorkerPoolProps()),this.workerPools.set(e,r)),r}_getWorkerPoolProps(){return{maxConcurrency:this.props.maxConcurrency,maxMobileConcurrency:this.props.maxMobileConcurrency,reuseWorkers:this.props.reuseWorkers,onDebug:this.props.onDebug}}}la(Il,"_workerFarm",void 0);async function Ol(t,e,i,n,r){const s=t.id,o=function(t,e={}){const i=e[t.id]||{},n="".concat(t.id,"-worker.js");let r=i.workerUrl;if(r||"compression"!==t.id||(r=e.workerUrl),"test"===e._workerType&&(r="modules/".concat(t.module,"/dist/").concat(n)),!r){let e=t.version;"latest"===e&&(e="latest");const i=e?"@".concat(e):"";r="https://unpkg.com/@loaders.gl/".concat(t.module).concat(i,"/dist/").concat(n)}return yl(r),r}(t,i),a=Il.getWorkerFarm(i).getWorkerPool({name:s,url:o});i=JSON.parse(JSON.stringify(i));const l=await a.startJob("process-on-worker",_l.bind(null,r));l.postMessage("process",{input:e,options:i});const h=await l.result;return await h.result}async function _l(t,e,i,n){switch(i){case"done":e.done(n);break;case"error":e.error(new Error(n.error));break;case"process":const{id:r,input:s,options:o}=n;try{const i=await t(s,o);e.postMessage("done",{id:r,result:i})}catch(t){const i=t instanceof Error?t.message:"unknown error";e.postMessage("error",{id:r,error:i})}break;default:console.warn("parse-with-worker unknown message ".concat(i))}}i(52);function Ll(t){return t&&"object"==typeof t&&t.isBuffer}function Rl(t){if(Ll(t))return function(t){if(Ll(t)){return new Uint8Array(t.buffer,t.byteOffset,t.length).slice().buffer}return t}(t);if(t instanceof ArrayBuffer)return t;if(ArrayBuffer.isView(t))return 0===t.byteOffset&&t.byteLength===t.buffer.byteLength?t.buffer:t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength);if("string"==typeof t){const e=t;return(new TextEncoder).encode(e).buffer}if(t&&"object"==typeof t&&t._toArrayBuffer)return t._toArrayBuffer();throw new Error("toArrayBuffer")}async function Bl(t){const e=[];for await(const i of t)e.push(i);return function(...t){const e=t.map(t=>t instanceof ArrayBuffer?new Uint8Array(t):t),i=e.reduce((t,e)=>t+e.byteLength,0),n=new Uint8Array(i);let r=0;for(const t of e)n.set(t,r),r+=t.byteLength;return n.buffer}(...e)}const Ml=262144;var Fl=i(22);function Dl(t,e){return Fl.a?async function*(t,e){const i=t.getReader();let n;try{for(;;){const t=n||i.read();null!=e&&e._streamReadAhead&&(n=i.read());const{done:r,value:s}=await t;if(r)return;yield Rl(s)}}catch(t){i.releaseLock()}}(t,e):async function*(t,e){for await(const e of t)yield Rl(e)}(t)}function Nl(t,e){if("string"==typeof t)return function*(t,e){const i=(null==e?void 0:e.chunkSize)||262144;let n=0;const r=new TextEncoder;for(;n<t.length;){const e=Math.min(t.length-n,i),s=t.slice(n,n+e);n+=e,yield r.encode(s)}}(t,e);if(t instanceof ArrayBuffer)return function*(t,e={}){const{chunkSize:i=Ml}=e;let n=0;for(;n<t.byteLength;){const e=Math.min(t.byteLength-n,i),r=new ArrayBuffer(e),s=new Uint8Array(t,n,e);new Uint8Array(r).set(s),n+=e,yield r}}(t,e);if(ja(t))return async function*(t,e){const i=(null==e?void 0:e.chunkSize)||1048576;let n=0;for(;n<t.size;){const e=n+i,r=await t.slice(n,e).arrayBuffer();n=e,yield r}}(t,e);if(Ua(t))return Dl(t,e);if(za(t)){return Dl(t.body,e)}throw new Error("makeIterator")}const kl="Cannot convert supplied data type";async function Vl(t,e,i){const n=t instanceof ArrayBuffer||ArrayBuffer.isView(t);if("string"==typeof t||n)return function(t,e,i){if(e.text&&"string"==typeof t)return t;var n;if((n=t)&&"object"==typeof n&&n.isBuffer&&(t=t.buffer),t instanceof ArrayBuffer){const i=t;if(e.text&&!e.binary){return new TextDecoder("utf8").decode(i)}return i}if(ArrayBuffer.isView(t)){if(e.text&&!e.binary){return new TextDecoder("utf8").decode(t)}let i=t.buffer;const n=t.byteLength||t.length;return 0===t.byteOffset&&n===i.byteLength||(i=i.slice(t.byteOffset,t.byteOffset+n)),i}throw new Error(kl)}(t,e);if(ja(t)&&(t=await il(t)),za(t)){const i=t;return await nl(i),e.binary?await i.arrayBuffer():await i.text()}if(Ua(t)&&(t=Nl(t,i)),Va(t)||Ga(t))return Bl(t);throw new Error(kl)}function Gl(t){const e=t&&t.lastIndexOf("/");return e>=0?t.substr(e+1):""}function zl(t){const e=t&&t.lastIndexOf("/");return e>=0?t.substr(0,e):""}function jl(...t){return(t=t.map((e,i)=>(i&&(e=e.replace(new RegExp("^".concat("/")),"")),i!==t.length-1&&(e=e.replace(new RegExp("".concat("/","$")),"")),e))).join("/")}i(41),i(62);const Ul=new wa({id:"loaders.gl"}),Wl=()=>{const t=hl();return t.loaderRegistry=t.loaderRegistry||[],t.loaderRegistry};const Hl=/\.([^.]+)$/;function ql(t,e=[],i,n){if(!Xl(t))return null;if(e&&!Array.isArray(e))return qa(e);let r=[];e&&(r=r.concat(e)),null!=i&&i.ignoreRegisteredLoaders||r.push(...Wl()),function(t){for(const e of t)qa(e)}(r);const s=function(t,e,i,n){const{url:r,type:s}=tl(t),o=r||(null==n?void 0:n.url);let a=null,l="";null!=i&&i.mimeType&&(a=Ql(e,null==i?void 0:i.mimeType),l="match forced by supplied MIME type ".concat(null==i?void 0:i.mimeType));var h;a=a||function(t,e){const i=e&&Hl.exec(e),n=i&&i[1];return n?function(t,e){e=e.toLowerCase();for(const i of t)for(const t of i.extensions)if(t.toLowerCase()===e)return i;return null}(t,n):null}(e,o),l=l||(a?"matched url ".concat(o):""),a=a||Ql(e,s),l=l||(a?"matched MIME type ".concat(s):""),a=a||function(t,e){if(!e)return null;for(const i of t)if("string"==typeof e){if(Zl(e,i))return i}else if(ArrayBuffer.isView(e)){if(Kl(e.buffer,e.byteOffset,i))return i}else if(e instanceof ArrayBuffer){if(Kl(e,0,i))return i}return null}(e,t),l=l||(a?"matched initial data ".concat($l(t)):""),a=a||Ql(e,null==i?void 0:i.fallbackMimeType),l=l||(a?"matched fallback MIME type ".concat(s):""),l&&Ul.log(1,"selectLoader selected ".concat(null===(h=a)||void 0===h?void 0:h.name,": ").concat(l,"."));return a}(t,r,i,n);if(!(s||null!=i&&i.nothrow))throw new Error(Yl(t));return s}function Xl(t){return!(t instanceof Response&&204===t.status)}function Yl(t){const{url:e,type:i}=tl(t);let r="No valid loader found (";r+=e?"".concat(n.filename(e),", "):"no url provided, ",r+="MIME type: ".concat(i?'"'.concat(i,'"'):"not provided",", ");const s=t?$l(t):"";return r+=s?' first bytes: "'.concat(s,'"'):"first bytes: not available",r+=")",r}function Ql(t,e){for(const i of t){if(i.mimeTypes&&i.mimeTypes.includes(e))return i;if(e==="application/x.".concat(i.id))return i}return null}function Zl(t,e){if(e.testText)return e.testText(t);return(Array.isArray(e.tests)?e.tests:[e.tests]).some(e=>t.startsWith(e))}function Kl(t,e,i){return(Array.isArray(i.tests)?i.tests:[i.tests]).some(n=>function(t,e,i,n){if(n instanceof ArrayBuffer)return function(t,e,i){if(i=i||t.byteLength,t.byteLength<i||e.byteLength<i)return!1;const n=new Uint8Array(t),r=new Uint8Array(e);for(let t=0;t<n.length;++t)if(n[t]!==r[t])return!1;return!0}(n,t,n.byteLength);switch(typeof n){case"function":return n(t,i);case"string":const r=Jl(t,e,n.length);return n===r;default:return!1}}(t,e,i,n))}function $l(t,e=5){if("string"==typeof t)return t.slice(0,e);if(ArrayBuffer.isView(t))return Jl(t.buffer,t.byteOffset,e);if(t instanceof ArrayBuffer){return Jl(t,0,e)}return""}function Jl(t,e,i){if(t.byteLength<e+i)return"";const n=new DataView(t);let r="";for(let t=0;t<i;t++)r+=String.fromCharCode(n.getUint8(e+t));return r}async function th(t,e,i,n){yl(!n||"object"==typeof n),!e||Array.isArray(e)||Ha(e)||(n=void 0,i=e,e=void 0),t=await t,i=i||{};const{url:r}=tl(t),s=function(t,e){if(!e&&t&&!Array.isArray(t))return t;let i;if(t&&(i=Array.isArray(t)?t:[t]),e&&e.loaders){const t=Array.isArray(e.loaders)?e.loaders:[e.loaders];i=i?[...i,...t]:t}return i&&i.length?i:null}(e,n),o=await async function(t,e=[],i,n){if(!Xl(t))return null;let r=ql(t,e,{...i,nothrow:!0},n);if(r)return r;if(ja(t)&&(r=ql(t=await t.slice(0,10).arrayBuffer(),e,i,n)),!(r||null!=i&&i.nothrow))throw new Error(Yl(t));return r}(t,s,i);return o?(n=function(t,e,i=null){if(i)return i;const n={fetch:dl(e,t),...t};return Array.isArray(n.loaders)||(n.loaders=null),n}({url:r,parse:th,loaders:s},i=cl(i,o,s,r),n),await async function(t,e,i,n){if(function(t,e="3.1.8"){yl(t,"no worker provided");const i=t.version}(t),e=await Vl(e,t,i),t.parseTextSync&&"string"==typeof e)return i.dataType="text",t.parseTextSync(e,i,n,t);if(function(t,e){return!!Il.isSupported()&&(t.worker&&(null==e?void 0:e.worker))}(t,i))return await Ol(t,e,i,0,th);if(t.parseText&&"string"==typeof e)return await t.parseText(e,i,n,t);if(t.parse)return await t.parse(e,i,n,t);throw yl(!t.parseSync),new Error("".concat(t.id," loader - no parser found and worker is disabled"))}(o,t,i,n)):null}async function eh(t,e,i,n){Array.isArray(e)||Ha(e)||(void 0,i=e,e=void 0);const r=dl(i);let s=t;return"string"==typeof t&&(s=await r(t)),ja(t)&&(s=await r(t)),await th(s,e,i)}class ih{constructor(t,e,i){this.id=t,this.context=i,this._loadCount=0,this._subscribers=new Set,this.setData(e)}subscribe(t){this._subscribers.add(t)}unsubscribe(t){this._subscribers.delete(t)}inUse(){return this._subscribers.size>0}delete(){}getData(){return this.isLoaded?this._error?Promise.reject(this._error):this._content:this._loader.then(()=>this.getData())}setData(t,e){if(t===this._data&&!e)return;this._data=t;const i=++this._loadCount;let n=t;"string"==typeof t&&(n=eh(t)),n instanceof Promise?(this.isLoaded=!1,this._loader=n.then(t=>{this._loadCount===i&&(this.isLoaded=!0,this._error=null,this._content=t)}).catch(t=>{this._loadCount===i&&(this.isLoaded=!0,this._error=t||!0)})):(this.isLoaded=!0,this._error=null,this._content=t);for(const t of this._subscribers)t.onChange(this.getData())}}class nh{constructor({gl:t,protocol:e}){this.protocol=e||"resource://",this._context={gl:t,resourceManager:this},this._resources={},this._consumers={},this._pruneRequest=null}contains(t){return!!t.startsWith(this.protocol)||t in this._resources}add({resourceId:t,data:e,forceUpdate:i=!1,persistent:n=!0}){let r=this._resources[t];r?r.setData(e,i):(r=new ih(t,e,this._context),this._resources[t]=r),r.persistent=n}remove(t){const e=this._resources[t];e&&(e.delete(),delete this._resources[t])}unsubscribe({consumerId:t}){const e=this._consumers[t];if(e){for(const t in e){const i=e[t];i.resource&&i.resource.unsubscribe(i)}delete this._consumers[t],this.prune()}}subscribe({resourceId:t,onChange:e,consumerId:i,requestId:n="default"}){const{_resources:r,protocol:s}=this;t.startsWith(s)&&(r[t=t.replace(s,"")]||this.add({resourceId:t,data:null,persistent:!1}));const o=r[t];if(this._track(i,n,o,e),o)return o.getData()}prune(){this._pruneRequest||(this._pruneRequest=setTimeout(()=>this._prune(),0))}finalize(){for(const t in this._resources)this._resources[t].delete()}_track(t,e,i,n){const r=this._consumers,s=r[t]=r[t]||{},o=s[e]||{};o.resource&&(o.resource.unsubscribe(o),o.resource=null,this.prune()),i&&(s[e]=o,o.onChange=n,o.resource=i,i.subscribe(o))}_prune(){this._pruneRequest=null;for(const t of Object.keys(this._resources)){const e=this._resources[t];e.persistent||e.inUse()||(e.delete(),delete this._resources[t])}}}var rh=new class{constructor(t){this._pool=[],this.props={overAlloc:2,poolSize:100},this.setProps(t)}setProps(t){Object.assign(this.props,t)}allocate(t,e,{size:i=1,type:n,padding:r=0,copy:s=!1,initialize:o=!1,maxCount:a}){const l=n||t&&t.constructor||Float32Array,h=e*i+r;if(ArrayBuffer.isView(t)){if(h<=t.length)return t;if(h*t.BYTES_PER_ELEMENT<=t.buffer.byteLength)return new l(t.buffer,0,h)}let u;a&&(u=a*i+r);const c=this._allocate(l,h,o,u);return t&&s?c.set(t):o||c.fill(0,0,4),this._release(t),c}release(t){this._release(t)}_allocate(t,e,i,n){let r=Math.max(Math.ceil(e*this.props.overAlloc),1);r>n&&(r=n);const s=this._pool,o=t.BYTES_PER_ELEMENT*r,a=s.findIndex(t=>t.byteLength>=o);if(a>=0){const e=new t(s.splice(a,1)[0],0,r);return i&&e.fill(0),e}return new t(r)}_release(t){if(!ArrayBuffer.isView(t))return;const e=this._pool,{buffer:i}=t,{byteLength:n}=i,r=e.findIndex(t=>t.byteLength>=n);r<0?e.push(i):(r>0||e.length<this.props.poolSize)&&e.splice(r,0,i),e.length>this.props.poolSize&&e.shift()}},sh=i(10);const oh=new sh.a;function ah(t,e,i,n){oh.set(t,e,i);const r=oh.len();return{distance:n/r,normal:new sh.a(-t/r,-e/r,-i/r)}}let lh;function hh(t,e){const{size:i=1,startIndex:n=0}=e,r=void 0!==e.endIndex?e.endIndex:t.length,s=(r-n)/i;lh=rh.allocate(lh,s,{type:Float32Array,size:2*i});let o=n,a=0;for(;o<r;){for(let e=0;e<i;e++){const n=t[o++];lh[a+e]=n,lh[a+e+i]=(l=n)-Math.fround(l)}a+=2*i}var l;return lh.subarray(0,s*i*2)}var uh=i(1),ch=i(65),dh=i(64),gh="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;Math.PI;function fh(t,e){var i=e[0],n=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],h=e[7],u=e[8],c=e[9],d=e[10],g=e[11],f=e[12],p=e[13],m=e[14],y=e[15],b=i*a-n*o,P=i*l-r*o,v=i*h-s*o,S=n*l-r*a,C=n*h-s*a,w=r*h-s*l,E=u*p-c*f,x=u*m-d*f,A=u*y-g*f,T=c*m-d*p,I=c*y-g*p,O=d*y-g*m,_=b*O-P*I+v*T+S*A-C*x+w*E;return _?(_=1/_,t[0]=(a*O-l*I+h*T)*_,t[1]=(r*I-n*O-s*T)*_,t[2]=(p*w-m*C+y*S)*_,t[3]=(d*C-c*w-g*S)*_,t[4]=(l*A-o*O-h*x)*_,t[5]=(i*O-r*A+s*x)*_,t[6]=(m*v-f*w-y*P)*_,t[7]=(u*w-d*v+g*P)*_,t[8]=(o*I-a*A+h*E)*_,t[9]=(n*A-i*I-s*E)*_,t[10]=(f*C-p*v+y*b)*_,t[11]=(c*v-u*C-g*b)*_,t[12]=(a*x-o*T-l*E)*_,t[13]=(i*T-n*x+r*E)*_,t[14]=(p*P-f*S-m*b)*_,t[15]=(u*S-c*P+d*b)*_,t):null}function ph(t,e,i){var n=e[0],r=e[1],s=e[2],o=e[3],a=e[4],l=e[5],h=e[6],u=e[7],c=e[8],d=e[9],g=e[10],f=e[11],p=e[12],m=e[13],y=e[14],b=e[15],P=i[0],v=i[1],S=i[2],C=i[3];return t[0]=P*n+v*a+S*c+C*p,t[1]=P*r+v*l+S*d+C*m,t[2]=P*s+v*h+S*g+C*y,t[3]=P*o+v*u+S*f+C*b,P=i[4],v=i[5],S=i[6],C=i[7],t[4]=P*n+v*a+S*c+C*p,t[5]=P*r+v*l+S*d+C*m,t[6]=P*s+v*h+S*g+C*y,t[7]=P*o+v*u+S*f+C*b,P=i[8],v=i[9],S=i[10],C=i[11],t[8]=P*n+v*a+S*c+C*p,t[9]=P*r+v*l+S*d+C*m,t[10]=P*s+v*h+S*g+C*y,t[11]=P*o+v*u+S*f+C*b,P=i[12],v=i[13],S=i[14],C=i[15],t[12]=P*n+v*a+S*c+C*p,t[13]=P*r+v*l+S*d+C*m,t[14]=P*s+v*h+S*g+C*y,t[15]=P*o+v*u+S*f+C*b,t}Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});var mh=i(35);function yh(t,e){const i=mh.b([],e,t);return mh.a(i,i,1/i[3]),i}function bh(t,e){const i=t%e;return i<0?e+i:i}function Ph(t,e,i){return t<e?e:t>i?i:t}const vh=Math.log2||function(t){return Math.log(t)*Math.LOG2E};var Sh=i(4),Ch=i(13),wh=i(11);function Eh(t,e){if(!t)throw new Error(e||"@math.gl/web-mercator: assertion failed.")}const xh=Math.PI,Ah=xh/4,Th=xh/180,Ih=180/xh;function Oh(t){return vh(t)}function _h([t,e]){Eh(Number.isFinite(t)),Eh(Number.isFinite(e)&&e>=-90&&e<=90,"invalid latitude");const i=e*Th;return[512*(t*Th+xh)/(2*xh),512*(xh+Math.log(Math.tan(Ah+.5*i)))/(2*xh)]}function Lh([t,e]){const i=t/512*(2*xh)-xh,n=2*(Math.atan(Math.exp(e/512*(2*xh)-xh))-Ah);return[i*Ih,n*Ih]}function Rh({latitude:t,longitude:e,highPrecision:i=!1}){Eh(Number.isFinite(t)&&Number.isFinite(e));const n={},r=Math.cos(t*Th),s=512/360/r,o=512/4003e4/r;if(n.unitsPerMeter=[o,o,o],n.metersPerUnit=[1/o,1/o,1/o],n.unitsPerDegree=[512/360,s,o],n.degreesPerUnit=[.703125,1/s,1/o],i){const e=Th*Math.tan(t*Th)/r,i=512/360*e/2,a=512/4003e4*e,l=a/s*o;n.unitsPerDegree2=[0,i,a],n.unitsPerMeter2=[l,0,l]}return n}function Bh(t,e){const[i,n,r]=t,[s,o,a]=e,{unitsPerMeter:l,unitsPerMeter2:h}=Rh({longitude:i,latitude:n,highPrecision:!0}),u=_h(t);u[0]+=s*(l[0]+h[0]*o),u[1]+=o*(l[1]+h[1]*o);const c=Lh(u),d=(r||0)+(a||0);return Number.isFinite(r)||Number.isFinite(a)?[c[0],c[1],d]:c}function Mh({height:t,pitch:e,bearing:i,altitude:n,scale:r,center:s=null}){const o=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return Sh.o(o,o,[0,0,-n]),Sh.k(o,o,-e*Th),Sh.m(o,o,i*Th),r/=t,Sh.n(o,o,[r,r,r]),s&&Sh.o(o,o,wh.e([],s)),o}function Fh({width:t,height:e,fovy:i=Dh(1.5),altitude:n,pitch:r=0,nearZMultiplier:s=1,farZMultiplier:o=1}){void 0!==n&&(i=Dh(n));const a=.5*i*Th,l=Nh(i),h=r*Th,u=Math.sin(a)*l/Math.sin(Math.min(Math.max(Math.PI/2-h-a,.01),Math.PI-.01));return{fov:2*a,aspect:t/e,focalDistance:l,near:s,far:(Math.sin(h)*u+l)*o}}function Dh(t){return 2*Math.atan(.5/t)*Ih}function Nh(t){return.5/Math.tan(.5*t*Th)}function kh(t,e){const[i,n,r=0]=t;return Eh(Number.isFinite(i)&&Number.isFinite(n)&&Number.isFinite(r)),yh(e,[i,n,r,1])}function Vh(t,e,i=0){const[n,r,s]=t;if(Eh(Number.isFinite(n)&&Number.isFinite(r),"invalid pixel coordinate"),Number.isFinite(s)){return yh(e,[n,r,s,1])}const o=yh(e,[n,r,0,1]),a=yh(e,[n,r,1,1]),l=o[2],h=a[2],u=l===h?0:((i||0)-l)/(h-l);return Ch.c([],o,a,u)}function Gh({width:t,height:e,bounds:i,minExtent:n=0,maxZoom:r=24,padding:s=0,offset:o=[0,0]}){const[[a,l],[h,u]]=i;if(Number.isFinite(s)){s={top:s,bottom:s,left:s,right:s}}else Eh(Number.isFinite(s.top)&&Number.isFinite(s.bottom)&&Number.isFinite(s.left)&&Number.isFinite(s.right));const c=_h([a,Ph(u,-85.051129,85.051129)]),d=_h([h,Ph(l,-85.051129,85.051129)]),g=[Math.max(Math.abs(d[0]-c[0]),n),Math.max(Math.abs(d[1]-c[1]),n)],f=[t-s.left-s.right-2*Math.abs(o[0]),e-s.top-s.bottom-2*Math.abs(o[1])];Eh(f[0]>0&&f[1]>0);const p=f[0]/g[0],m=f[1]/g[1],y=(s.right-s.left)/2/p,b=(s.bottom-s.top)/2/m,P=Lh([(d[0]+c[0])/2+y,(d[1]+c[1])/2+b]),v=Math.min(r,vh(Math.abs(Math.min(p,m))));return Eh(Number.isFinite(v)),{longitude:P[0],latitude:P[1],zoom:v}}const zh=Math.PI/180;function jh(t,e=0){const{width:i,height:n,unproject:r}=t,s={targetZ:e},o=r([0,n],s),a=r([i,n],s);let l,h;return(t.fovy?.5*t.fovy*zh:Math.atan(.5/t.altitude))>(90-t.pitch)*zh-.01?(l=Uh(t,0,e),h=Uh(t,i,e)):(l=r([0,0],s),h=r([i,0],s)),[o,a,h,l]}function Uh(t,e,i){const{pixelUnprojectionMatrix:n}=t,r=yh(n,[e,0,1,1]),s=yh(n,[e,t.height,1,1]),o=(i*t.distanceScales.unitsPerMeter[2]-r[2])/(s[2]-r[2]),a=Lh(Ch.c([],r,s,o));return a[2]=i,a}const Wh={DEFAULT:-1,LNGLAT:1,METER_OFFSETS:2,LNGLAT_OFFSETS:3,CARTESIAN:0};Object.defineProperty(Wh,"IDENTITY",{get:()=>Ta.deprecated("COORDINATE_SYSTEM.IDENTITY","COORDINATE_SYSTEM.CARTESIAN")()||0});const Hh={WEB_MERCATOR:1,GLOBE:2,WEB_MERCATOR_AUTO_OFFSET:4,IDENTITY:0},qh={common:0,meters:1,pixels:2},Xh={click:{handler:"onClick"},panstart:{handler:"onDragStart"},panmove:{handler:"onDrag"},panend:{handler:"onDragEnd"}},Yh="draw",Qh="mask",Zh=Math.PI/180,Kh=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],$h=[0,0,0],Jh={unitsPerMeter:[1,1,1],metersPerUnit:[1,1,1]};class tu{constructor(t={}){const{id:e=null,x:i=0,y:n=0,width:r=1,height:s=1}=t;this.id=e||this.constructor.displayName||"viewport",this.x=i,this.y=n,this.width=r||1,this.height=s||1,this._frustumPlanes={},this._initViewMatrix(t),this._initProjectionMatrix(t),this._initPixelMatrices(),this.equals=this.equals.bind(this),this.project=this.project.bind(this),this.unproject=this.unproject.bind(this),this.projectPosition=this.projectPosition.bind(this),this.unprojectPosition=this.unprojectPosition.bind(this),this.projectFlat=this.projectFlat.bind(this),this.unprojectFlat=this.unprojectFlat.bind(this)}get metersPerPixel(){return this.distanceScales.metersPerUnit[2]/this.scale}get projectionMode(){return this.isGeospatial?this.zoom<12?Hh.WEB_MERCATOR:Hh.WEB_MERCATOR_AUTO_OFFSET:Hh.IDENTITY}equals(t){return t instanceof tu&&(this===t||t.width===this.width&&t.height===this.height&&t.scale===this.scale&&Object(uh.c)(t.projectionMatrix,this.projectionMatrix)&&Object(uh.c)(t.viewMatrix,this.viewMatrix))}project(t,{topLeft:e=!0}={}){const i=kh(this.projectPosition(t),this.pixelProjectionMatrix),[n,r]=i,s=e?r:this.height-r;return 2===t.length?[n,s]:[n,s,i[2]]}unproject(t,{topLeft:e=!0,targetZ:i}={}){const[n,r,s]=t,o=e?r:this.height-r,a=i&&i*this.distanceScales.unitsPerMeter[2],l=Vh([n,o,s],this.pixelUnprojectionMatrix,a),[h,u,c]=this.unprojectPosition(l);return Number.isFinite(s)?[h,u,c]:Number.isFinite(i)?[h,u,i]:[h,u]}projectPosition(t){const[e,i]=this.projectFlat(t);return[e,i,(t[2]||0)*this.distanceScales.unitsPerMeter[2]]}unprojectPosition(t){const[e,i]=this.unprojectFlat(t);return[e,i,(t[2]||0)*this.distanceScales.metersPerUnit[2]]}projectFlat(t){return this.isGeospatial?_h(t):t}unprojectFlat(t){return this.isGeospatial?Lh(t):t}getBounds(t={}){const e={targetZ:t.z||0},i=this.unproject([0,0],e),n=this.unproject([this.width,0],e),r=this.unproject([0,this.height],e),s=this.unproject([this.width,this.height],e);return[Math.min(i[0],n[0],r[0],s[0]),Math.min(i[1],n[1],r[1],s[1]),Math.max(i[0],n[0],r[0],s[0]),Math.max(i[1],n[1],r[1],s[1])]}getDistanceScales(t=null){return t?Rh({longitude:t[0],latitude:t[1],highPrecision:!0}):this.distanceScales}containsPixel({x:t,y:e,width:i=1,height:n=1}){return t<this.x+this.width&&this.x<t+i&&e<this.y+this.height&&this.y<e+n}getFrustumPlanes(){return this._frustumPlanes.near||Object.assign(this._frustumPlanes,{left:ah((t=this.viewProjectionMatrix)[3]+t[0],t[7]+t[4],t[11]+t[8],t[15]+t[12]),right:ah(t[3]-t[0],t[7]-t[4],t[11]-t[8],t[15]-t[12]),bottom:ah(t[3]+t[1],t[7]+t[5],t[11]+t[9],t[15]+t[13]),top:ah(t[3]-t[1],t[7]-t[5],t[11]-t[9],t[15]-t[13]),near:ah(t[3]+t[2],t[7]+t[6],t[11]+t[10],t[15]+t[14]),far:ah(t[3]-t[2],t[7]-t[6],t[11]-t[10],t[15]-t[14])}),this._frustumPlanes;var t}panByPosition(t,e){return null}getCameraPosition(){return this.cameraPosition}getCameraDirection(){return this.cameraDirection}getCameraUp(){return this.cameraUp}_createProjectionMatrix({orthographic:t,fovyRadians:e,aspect:i,focalDistance:n,near:r,far:s}){return t?(new ch.a).orthographic({fovy:e,aspect:i,focalDistance:n,near:r,far:s}):(new ch.a).perspective({fovy:e,aspect:i,near:r,far:s})}_initViewMatrix(t){const{viewMatrix:e=Kh,longitude:i=null,latitude:n=null,zoom:r=null,position:s=null,modelMatrix:o=null,focalDistance:a=1,distanceScales:l=null}=t;this.isGeospatial=Number.isFinite(n)&&Number.isFinite(i),this.zoom=r,Number.isFinite(this.zoom)||(this.zoom=this.isGeospatial?function({latitude:t}){return Eh(Number.isFinite(t)),Oh(4003e4*Math.cos(t*Th))-9}({latitude:n})+Math.log2(a):0);const h=Math.pow(2,this.zoom);this.scale=h,this.distanceScales=this.isGeospatial?Rh({latitude:n,longitude:i}):l||Jh,this.focalDistance=a,this.distanceScales.metersPerUnit=new dh.a(this.distanceScales.metersPerUnit),this.distanceScales.unitsPerMeter=new dh.a(this.distanceScales.unitsPerMeter),this.position=$h,this.meterOffset=$h,s&&(this.position=s,this.modelMatrix=o,this.meterOffset=o?o.transformVector(s):s),this.isGeospatial?(this.longitude=i,this.latitude=n,this.center=this._getCenterInWorld({longitude:i,latitude:n})):this.center=s?this.projectPosition(s):[0,0,0],this.viewMatrixUncentered=e,this.viewMatrix=(new ch.a).multiplyRight(this.viewMatrixUncentered).translate(new dh.a(this.center||$h).negate())}_getCenterInWorld({longitude:t,latitude:e}){const{meterOffset:i,distanceScales:n}=this,r=new dh.a(this.projectPosition([t,e,0]));if(i){const t=new dh.a(i).scale(n.unitsPerMeter);r.add(t)}return r}_initProjectionMatrix(t){const{projectionMatrix:e=null,orthographic:i=!1,fovyRadians:n,fovy:r=75,near:s=.1,far:o=1e3,focalDistance:a=1}=t;this.projectionMatrix=e||this._createProjectionMatrix({orthographic:i,fovyRadians:n||r*Zh,aspect:this.width/this.height,focalDistance:a,near:s,far:o})}_initPixelMatrices(){const t=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];var e;ph(t,t,this.projectionMatrix),ph(t,t,this.viewMatrix),this.viewProjectionMatrix=t,this.viewMatrixInverse=fh([],this.viewMatrix)||this.viewMatrix,this.cameraPosition=[(e=this.viewMatrixInverse)[12],e[13],e[14]];const i=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],n=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];var r,s,o,a,l,h;r=i,s=i,o=[this.width/2,-this.height/2,1],a=o[0],l=o[1],h=o[2],r[0]=s[0]*a,r[1]=s[1]*a,r[2]=s[2]*a,r[3]=s[3]*a,r[4]=s[4]*l,r[5]=s[5]*l,r[6]=s[6]*l,r[7]=s[7]*l,r[8]=s[8]*h,r[9]=s[9]*h,r[10]=s[10]*h,r[11]=s[11]*h,r[12]=s[12],r[13]=s[13],r[14]=s[14],r[15]=s[15],function(t,e,i){var n,r,s,o,a,l,h,u,c,d,g,f,p=i[0],m=i[1],y=i[2];e===t?(t[12]=e[0]*p+e[4]*m+e[8]*y+e[12],t[13]=e[1]*p+e[5]*m+e[9]*y+e[13],t[14]=e[2]*p+e[6]*m+e[10]*y+e[14],t[15]=e[3]*p+e[7]*m+e[11]*y+e[15]):(n=e[0],r=e[1],s=e[2],o=e[3],a=e[4],l=e[5],h=e[6],u=e[7],c=e[8],d=e[9],g=e[10],f=e[11],t[0]=n,t[1]=r,t[2]=s,t[3]=o,t[4]=a,t[5]=l,t[6]=h,t[7]=u,t[8]=c,t[9]=d,t[10]=g,t[11]=f,t[12]=n*p+a*m+c*y+e[12],t[13]=r*p+l*m+d*y+e[13],t[14]=s*p+h*m+g*y+e[14],t[15]=o*p+u*m+f*y+e[15])}(i,i,[1,-1,0]),ph(n,i,this.viewProjectionMatrix),this.pixelProjectionMatrix=n,this.viewportMatrix=i,this.pixelUnprojectionMatrix=fh([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],this.pixelProjectionMatrix),this.pixelUnprojectionMatrix||Ta.warn("Pixel project matrix not invertible")()}}tu.displayName="Viewport";function eu(t,e){if(!t)throw new Error(e||"shadertools: assertion failed.")}const iu={number:{validate:(t,e)=>Number.isFinite(t)&&(!("max"in e)||t<=e.max)&&(!("min"in e)||t>=e.min)},array:{validate:(t,e)=>Array.isArray(t)||ArrayBuffer.isView(t)}};function nu(t){let e=ru(t);return"object"===e?t?"type"in t?Object.assign({},t,iu[t.type]):"value"in t?(e=ru(t.value),Object.assign({type:e},t,iu[e])):{type:"object",value:t}:{type:"object",value:null}:Object.assign({type:e,value:t},iu[e])}function ru(t){return Array.isArray(t)||ArrayBuffer.isView(t)?"array":typeof t}class su{constructor({name:t,vs:e,fs:i,dependencies:n=[],uniforms:r,getUniforms:s,deprecations:o=[],defines:a={},inject:l={},vertexShader:h,fragmentShader:u}){eu("string"==typeof t),this.name=t,this.vs=e||h,this.fs=i||u,this.getModuleUniforms=s,this.dependencies=n,this.deprecations=this._parseDeprecationDefinitions(o),this.defines=a,this.injections=function(t){const e={vs:{},fs:{}};for(const i in t){let n=t[i];const r=i.slice(0,2);"string"==typeof n&&(n={order:0,injection:n}),e[r][i]=n}return e}(l),r&&(this.uniforms=function(t){const e={};for(const i in t){const n=nu(t[i]);e[i]=n}return e}(r))}getModuleSource(t){let e;switch(t){case"vs":e=this.vs||"";break;case"fs":e=this.fs||"";break;default:eu(!1)}return`#define MODULE_${this.name.toUpperCase().replace(/[^0-9a-z]/gi,"_")}\n${e}// END MODULE_${this.name}\n\n`}getUniforms(t,e){return this.getModuleUniforms?this.getModuleUniforms(t,e):this.uniforms?this._defaultGetUniforms(t):{}}getDefines(){return this.defines}checkDeprecations(t,e){this.deprecations.forEach(i=>{i.regex.test(t)&&(i.deprecated?e.deprecated(i.old,i.new)():e.removed(i.old,i.new)())})}_parseDeprecationDefinitions(t){return t.forEach(t=>{switch(t.type){case"function":t.regex=new RegExp(`\\b${t.old}\\(`);break;default:t.regex=new RegExp(`${t.type} ${t.old};`)}}),t}_defaultGetUniforms(t={}){const e={},i=this.uniforms;for(const n in i){const r=i[n];n in t&&!r.private?(r.validate&&eu(r.validate(t[n],r),`${this.name}: invalid ${n}`),e[n]=t[n]):e[n]=r.value}return e}}function ou(t){return au(function t(e,i){return e.map(e=>(e instanceof su||(eu("string"!=typeof e,`Shader module use by name is deprecated. Import shader module '${e}' and use it directly.`),eu(e.name,"shader module has no name"),(e=new su(e)).dependencies=t(e.dependencies)),e))}(t))}function au(t){const e={},i={};return lu({modules:t,level:0,moduleMap:e,moduleDepth:i}),Object.keys(i).sort((t,e)=>i[e]-i[t]).map(t=>e[t])}function lu({modules:t,level:e,moduleMap:i,moduleDepth:n}){if(e>=5)throw new Error("Possible loop in shader dependency graph");for(const r of t)i[r.name]=r,(void 0===n[r.name]||n[r.name]<e)&&(n[r.name]=e);for(const r of t)r.dependencies&&lu({modules:r.dependencies,level:e+1,moduleMap:i,moduleDepth:n})}const hu={GLSL_FRAG_DATA:["WEBGL_draw_buffers",!0],GLSL_FRAG_DEPTH:["EXT_frag_depth",!0],GLSL_DERIVATIVES:["OES_standard_derivatives",!0],GLSL_TEXTURE_LOD:["EXT_shader_texture_lod",!0]},uu={};Object.keys(hu).forEach(t=>{uu[t]=t});const cu={};function du(t,e,i={}){const n=hu[e];if(eu(n,e),!function(t={}){const e="undefined"!=typeof window&&window.navigator||{},i=t.userAgent||e.userAgent||"",n=-1!==i.indexOf("MSIE "),r=-1!==i.indexOf("Trident/");return n||r}(i))return!0;if(e in cu)return cu[e];const r=`#extension GL_${n[0]} : ${i.behavior||"enable"}\nvoid main(void) {}`,s=t.createShader(35633);t.shaderSource(s,r),t.compileShader(s);const o=t.getShaderParameter(s,35713);return t.deleteShader(s),cu[e]=o,o}function gu(t,e){const i=hu[e];eu(i,e);const n=function(t){return"undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||Boolean(t&&2===t._version)}(t)&&i[1]||i[0],r="string"==typeof n?Boolean(t.getExtension(n)):n;return eu(!1===r||!0===r),r}function fu(t,e){return(e=Array.isArray(e)?e:[e]).every(e=>gu(t,e))}const pu={vs:"#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n",fs:"#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n"},mu=/void\s+main\s*\([^)]*\)\s*\{\n?/,yu=/}\n?[^{}]*$/,bu=[];function Pu(t,e,i,n=!1){const r="vs"===e;for(const e in i){const n=i[e];n.sort((t,e)=>t.order-e.order),bu.length=n.length;for(let t=0,e=n.length;t<e;++t)bu[t]=n[t].injection;const s=bu.join("\n")+"\n";switch(e){case"vs:#decl":r&&(t=t.replace("__LUMA_INJECT_DECLARATIONS__",s));break;case"vs:#main-start":r&&(t=t.replace(mu,t=>t+s));break;case"vs:#main-end":r&&(t=t.replace(yu,t=>s+t));break;case"fs:#decl":r||(t=t.replace("__LUMA_INJECT_DECLARATIONS__",s));break;case"fs:#main-start":r||(t=t.replace(mu,t=>t+s));break;case"fs:#main-end":r||(t=t.replace(yu,t=>s+t));break;default:t=t.replace(e,t=>t+s)}}return t=t.replace("__LUMA_INJECT_DECLARATIONS__",""),n&&(t=t.replace(/\}\s*$/,t=>t+pu[e])),t}function vu(t){const e={};return eu(Array.isArray(t)&&t.length>1),t.forEach(t=>{for(const i in t)e[i]=e[i]?`${e[i]}\n${t[i]}`:t[i]}),e}function Su(t){return new RegExp(`\\b${t}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`,"g")}const Cu=[[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,"#version 300 es\n"],[/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,"textureLod("],[/\btexture(2D|2DProj|Cube)(EXT)?\(/g,"texture("]],wu=[...Cu,[Su("attribute"),"in $1"],[Su("varying"),"out $1"]],Eu=[...Cu,[Su("varying"),"in $1"]],xu=[[/^#version[ \t]+300[ \t]+es/,"#version 100"],[/\btexture(2D|2DProj|Cube)Lod\(/g,"texture$1LodEXT("],[/\btexture\(/g,"texture2D("],[/\btextureLod\(/g,"texture2DLodEXT("]],Au=[...xu,[Su("in"),"attribute $1"],[Su("out"),"varying $1"]],Tu=[...xu,[Su("in"),"varying $1"]],Iu=/\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/,Ou=/void\s+main\s*\([^)]*\)\s*\{\n?/;function _u(t,e,i){switch(e){case 300:return i?Lu(t,wu):function(t){const e=(t=Lu(t,Eu)).match(Iu);if(e){const i=e[1];t=t.replace(new RegExp("\\bgl_FragColor\\b","g"),i)}else{const e="fragmentColor";t=t.replace(Ou,t=>`out vec4 ${e};\n${t}`).replace(new RegExp("\\bgl_FragColor\\b","g"),e)}return t}(t);case 100:return i?Lu(t,Au):function(t){const e=(t=Lu(t,Tu)).match(Iu);if(e){const i=e[1];t=t.replace(Iu,"").replace(new RegExp(`\\b${i}\\b`,"g"),"gl_FragColor")}return t}(t);default:throw new Error("unknown GLSL version "+e)}}function Lu(t,e){for(const[i,n]of e)t=t.replace(i,n);return t}const Ru={vs:"vertex",fs:"fragment"};function Bu(t,{id:e,source:i,type:n,modules:r,defines:s={},hookFunctions:o=[],inject:a={},transpileToGLSL100:l=!1,prologue:h=!0,log:u}){eu("string"==typeof i,"shader source must be a string");const c="vs"===n,d=i.split("\n");let g=100,f="",p=i;0===d[0].indexOf("#version ")?(g=300,f=d[0],p=d.slice(1).join("\n")):f="#version "+g;const m={};r.forEach(t=>{Object.assign(m,t.getDefines())}),Object.assign(m,s);let y=h?`${f}\n${function({id:t,source:e,type:i}){return t&&"string"==typeof t&&-1===e.indexOf("SHADER_NAME")?`\n#define SHADER_NAME ${t}_${Ru[i]}\n\n`:""}({id:e,source:i,type:n})}\n${function({type:t}){return`\n#define SHADER_TYPE_${Ru[t].toUpperCase()}\n`}({type:n})}\n${function(t){switch(function(t){const e=t.getExtension("WEBGL_debug_renderer_info"),i=t.getParameter(e&&e.UNMASKED_VENDOR_WEBGL||7936),n=t.getParameter(e&&e.UNMASKED_RENDERER_WEBGL||7937);return{gpuVendor:function(t,e){if(t.match(/NVIDIA/i)||e.match(/NVIDIA/i))return"NVIDIA";if(t.match(/INTEL/i)||e.match(/INTEL/i))return"INTEL";if(t.match(/AMD/i)||e.match(/AMD/i)||t.match(/ATI/i)||e.match(/ATI/i))return"AMD";return"UNKNOWN GPU"}(i,n),vendor:i,renderer:n,version:t.getParameter(7938),shadingLanguageVersion:t.getParameter(35724)}}(t).gpuVendor.toLowerCase()){case"nvidia":return"#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";case"intel":return"#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";case"amd":return"#define AMD_GPU\n";default:return"#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n"}}(t)}\n${function(t,e,i){let n="#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";return fu(t,uu.GLSL_FRAG_DEPTH)&&(n+="\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n"),fu(t,uu.GLSL_DERIVATIVES)&&du(t,uu.GLSL_DERIVATIVES)&&(n+="\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n"),fu(t,uu.GLSL_FRAG_DATA)&&du(t,uu.GLSL_FRAG_DATA,{behavior:"require"})&&(n+="\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n"),fu(t,uu.GLSL_TEXTURE_LOD)&&(n+="// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n"),n}(t)}\n${function(t={}){let e=0,i="";for(const n in t){0===e&&(i+="\n// APPLICATION DEFINES\n"),e++;const r=t[n];(r||Number.isFinite(r))&&(i+=`#define ${n.toUpperCase()} ${t[n]}\n`)}0===e&&(i+="\n");return i}(m)}\n${c?"":"precision highp float;\n\n"}\n`:f+"\n";const b=function(t){const e={vs:{},fs:{}};return t.forEach(t=>{let i;"string"!=typeof t?(i=t,t=i.hook):i={},t=t.trim();const[n,r]=t.split(":"),s=t.replace(/\(.+/,"");e[n][s]=Object.assign(i,{signature:r})}),e}(o),P={},v={},S={};for(const t in a){const e="string"==typeof a[t]?{injection:a[t],order:0}:a[t],i=t.match(/^(v|f)s:(#)?([\w-]+)$/);if(i){const n=i[2],r=i[3];n?"decl"===r?v[t]=[e]:S[t]=[e]:P[t]=[e]}else S[t]=[e]}for(const t of r){u&&t.checkDeprecations(p,u);y+=t.getModuleSource(n,g);const e=t.injections[n];for(const t in e){const i=t.match(/^(v|f)s:#([\w-]+)$/);if(i){const n="decl"===i[2]?v:S;n[t]=n[t]||[],n[t].push(e[t])}else P[t]=P[t]||[],P[t].push(e[t])}}return y+="\n\n__LUMA_INJECT_DECLARATIONS__\n\n",y=Pu(y,n,v),y+=function(t,e){let i="";for(const n in t){const r=t[n];if(i+=`void ${r.signature} {\n`,r.header&&(i+="  "+r.header),e[n]){const t=e[n];t.sort((t,e)=>t.order-e.order);for(const e of t)i+=`  ${e.injection}\n`}r.footer&&(i+="  "+r.footer),i+="}\n"}return i}(b[n],P),y+=p,y=Pu(y,n,S),y=_u(y,l?100:g,c),y}function Mu(t){return function(e){const i={};for(const n of t){const t=n.getUniforms(e,i);Object.assign(i,t)}return i}}const Fu=new wa({id:"luma.gl"});var Du=i(7),Nu=(i(63),i(23)),ku=i(19),Vu=i(8),Gu=i(9);function zu(t){const{luma:e}=t;if(t.canvas&&e){const{clientWidth:i}=e.canvasSizeInfo;return i?t.drawingBufferWidth/i:1}return 1}function ju(t,e,i=!0){return function(t,e,i,n,r){const s=Uu(t[0],e,i);let o=Wu(t[1],e,n,r),a=Uu(t[0]+1,e,i);const l=a===i-1?a:a-1;let h;a=Wu(t[1]+1,e,n,r),r?(a=0===a?a:a+1,h=o,o=a):h=a===n-1?a:a-1;return{x:s,y:o,width:Math.max(l-s+1,1),height:Math.max(h-o+1,1)}}(e,zu(t),t.drawingBufferWidth,t.drawingBufferHeight,i)}function Uu(t,e,i){return Math.min(Math.round(t*e),i-1)}function Wu(t,e,i,n){return n?Math.max(0,i-1-Math.round(t*e)):Math.min(Math.round(t*e),i-1)}const Hu=Object(Vu.isBrowser)(),qu=Hu&&"undefined"!=typeof document,Xu={webgl2:!0,webgl1:!0,throwOnError:!0,manageState:!0,canvas:null,debug:!1,width:800,height:600};function Yu(t={}){Object(Gu.a)(Hu,"createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils"),t=Object.assign({},Xu,t);const{width:e,height:i}=t;function n(e){if(t.throwOnError)throw new Error(e);return console.error(e),null}let r;t.onError=n;const{canvas:s}=t;return r=function(t,e){const{onError:i}=e;let n=null;const r=t=>n=t.statusMessage||n;t.addEventListener("webglcontextcreationerror",r,!1);const{webgl1:s=!0,webgl2:o=!0}=e;let a=null;o&&(a=a||t.getContext("webgl2",e),a=a||t.getContext("experimental-webgl2",e));s&&(a=a||t.getContext("webgl",e),a=a||t.getContext("experimental-webgl",e));if(t.removeEventListener("webglcontextcreationerror",r,!1),!a)return i(`Failed to create ${o&&!s?"WebGL2":"WebGL"} context: ${n||"Unknown error"}`);e.onContextLost&&t.addEventListener("webglcontextlost",e.onContextLost,!1);e.onContextRestored&&t.addEventListener("webglcontextrestored",e.onContextRestored,!1);return a}(function({canvas:t,width:e=800,height:i=600,onError:n}){let r;if("string"==typeof t){qu&&"complete"===document.readyState||n(`createGLContext called on canvas '${t}' before page was loaded`),r=document.getElementById(t)}else t?r=t:(r=document.createElement("canvas"),r.id="lumagl-canvas",r.style.width=Number.isFinite(e)?e+"px":"100%",r.style.height=Number.isFinite(i)?i+"px":"100%",document.body.insertBefore(r,document.body.firstChild));return r}({canvas:s,width:e,height:i,onError:n}),t),r?(r=Qu(r,t),function(t){const e=Object(Du.e)(t)?"WebGL2":"WebGL1",i=function(t){const e=t.getParameter(7936),i=t.getParameter(7937),n=t.getExtension("WEBGL_debug_renderer_info"),r=n&&t.getParameter(n.UNMASKED_VENDOR_WEBGL||7936),s=n&&t.getParameter(n.UNMASKED_RENDERER_WEBGL||7937);return{vendor:r||e,renderer:s||i,vendorMasked:e,rendererMasked:i,version:t.getParameter(7938),shadingLanguageVersion:t.getParameter(35724)}}(t),n=i?`(${i.vendor},${i.renderer})`:"",r=t.debug?" debug":"";Fu.info(1,`${e}${r} context ${n}`)()}(r),r):null}function Qu(t,e={}){if(!t||t._instrumented)return t;t._version=t._version||function(t){if("undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext)return 2;return 1}(t),t.luma=t.luma||{},t.luma.canvasSizeInfo=t.luma.canvasSizeInfo||{},e=Object.assign({},Xu,e);const{manageState:i,debug:n}=e;return i&&Object(ku.c)(t,{copyState:!1,log:(...t)=>Fu.log(1,...t)()}),Hu&&n&&(Vu.global.makeDebugContext?(t=Vu.global.makeDebugContext(t,e),Fu.level=Math.max(Fu.level,1)):Fu.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')()),t._instrumented=!0,t}function Zu(t,e={}){if(t.canvas){return void function(t,e,i){let n="width"in i?i.width:t.canvas.clientWidth,r="height"in i?i.height:t.canvas.clientHeight;n&&r||(Fu.log(1,"Canvas clientWidth/clientHeight is 0")(),e=1,n=t.canvas.width||1,r=t.canvas.height||1);t.luma=t.luma||{},t.luma.canvasSizeInfo=t.luma.canvasSizeInfo||{};const s=t.luma.canvasSizeInfo;if(s.clientWidth!==n||s.clientHeight!==r||s.devicePixelRatio!==e){let i=e;const s=Math.floor(n*i),o=Math.floor(r*i);t.canvas.width=s,t.canvas.height=o,t.drawingBufferWidth===s&&t.drawingBufferHeight===o||(Fu.warn("Device pixel ratio clamped")(),i=Math.min(t.drawingBufferWidth/n,t.drawingBufferHeight/r),t.canvas.width=Math.floor(n*i),t.canvas.height=Math.floor(r*i)),Object.assign(t.luma.canvasSizeInfo,{clientWidth:n,clientHeight:r,devicePixelRatio:e})}}(t,function(t){const e="undefined"==typeof window?1:window.devicePixelRatio||1;return Number.isFinite(t)?t<=0?1:t:t?e:1}(e.useDevicePixels),e)}const i=t.getExtension("STACKGL_resize_drawingbuffer");i&&"width"in e&&"height"in e&&i.resize(e.width,e.height)}const Ku=new class{constructor(){this.stats=new Map}get(t){return this.stats.has(t)||this.stats.set(t,new Ma({id:t})),this.stats.get(t)}};if(Vu.global.luma&&"8.5.10"!==Vu.global.luma.VERSION)throw new Error(`luma.gl - multiple VERSIONs detected: ${Vu.global.luma.VERSION} vs 8.5.10`);Vu.global.luma||(Object(Vu.isBrowser)()&&Fu.log(1,"luma.gl 8.5.10 - set luma.log.level=1 (or higher) to trace rendering")(),Vu.global.luma=Vu.global.luma||{VERSION:"8.5.10",version:"8.5.10",log:Fu,stats:Ku,globals:{modules:{},nodeIO:{}}});Vu.global.luma;function $u(t,e){if(!t)throw new Error(e||"luma.gl: assertion failed.")}function Ju(t,e){if("string"!=typeof e)return e;const i=Number(e);if(!isNaN(i))return i;const n=t[e=e.replace(/^.*\./,"")];return $u(void 0!==n,"Accessing undefined constant GL."+e),n}function tc(t,e){e=Number(e);for(const i in t)if(t[i]===e)return"GL."+i;return String(e)}const ec={};function ic(t="id"){ec[t]=ec[t]||1;return`${t}-${ec[t]++}`}function nc(t){return $u("number"==typeof t,"Input must be a number"),t&&0==(t&t-1)}function rc(t){let e=!0;for(const i in t){e=!1;break}return e}function sc(t,e,i,n){const r=`See luma.gl ${i} Upgrade Guide at https://luma.gl/docs/upgrade-guide`,s=Object.getPrototypeOf(t);n.forEach(t=>{s.methodName||(s[t]=()=>{throw Fu.removed(`Calling removed method ${e}.${t}: `,r)(),new Error(t)})})}const oc="Resource subclass must define virtual methods";class ac{constructor(t,e={}){Object(Du.b)(t);const{id:i,userData:n={}}=e;this.gl=t,this.gl2=t,this.id=i||ic(this.constructor.name),this.userData=n,this._bound=!1,this._handle=e.handle,void 0===this._handle&&(this._handle=this._createHandle()),this.byteLength=0,this._addStats()}toString(){return`${this.constructor.name}(${this.id})`}get handle(){return this._handle}delete({deleteChildren:t=!1}={}){const e=this._handle&&this._deleteHandle(this._handle);return this._handle&&this._removeStats(),this._handle=null,e&&t&&e.filter(Boolean).forEach(t=>t.delete()),this}bind(t=this.handle){if("function"!=typeof t)return this._bindHandle(t),this;let e;return this._bound?e=t():(this._bindHandle(this.handle),this._bound=!0,e=t(),this._bound=!1,this._bindHandle(null)),e}unbind(){this.bind(null)}getParameter(t,e={}){$u(t=Ju(this.gl,t));const i=(this.constructor.PARAMETERS||{})[t];if(i){const t=Object(Du.e)(this.gl);if(!((!("webgl2"in i)||t)&&(!("extension"in i)||this.gl.getExtension(i.extension)))){const e=i.webgl1,n="webgl2"in i?i.webgl2:i.webgl1;return t?n:e}}return this._getParameter(t,e)}getParameters(t={}){const{parameters:e,keys:i}=t,n=this.constructor.PARAMETERS||{},r=Object(Du.e)(this.gl),s={},o=e||Object.keys(n);for(const e of o){const o=n[e];if(o&&(!("webgl2"in o)||r)&&(!("extension"in o)||this.gl.getExtension(o.extension))){const n=i?tc(this.gl,e):e;s[n]=this.getParameter(e,t),i&&"GLenum"===o.type&&(s[n]=tc(this.gl,s[n]))}}return s}setParameter(t,e){$u(t=Ju(this.gl,t));const i=(this.constructor.PARAMETERS||{})[t];if(i){const t=Object(Du.e)(this.gl);if(!((!("webgl2"in i)||t)&&(!("extension"in i)||this.gl.getExtension(i.extension))))throw new Error("Parameter not available on this platform");"GLenum"===i.type&&(e=Ju(e))}return this._setParameter(t,e),this}setParameters(t){for(const e in t)this.setParameter(e,t[e]);return this}stubRemovedMethods(t,e,i){return sc(this,t,e,i)}initialize(t){}_createHandle(){throw new Error(oc)}_deleteHandle(){throw new Error(oc)}_bindHandle(t){throw new Error(oc)}_getOptsFromHandle(){throw new Error(oc)}_getParameter(t,e){throw new Error(oc)}_setParameter(t,e){throw new Error(oc)}_context(){return this.gl.luma=this.gl.luma||{},this.gl.luma}_addStats(){const t=this.constructor.name,e=Ku.get("Resource Counts");e.get("Resources Created").incrementCount(),e.get(t+"s Created").incrementCount(),e.get(t+"s Active").incrementCount()}_removeStats(){const t=this.constructor.name;Ku.get("Resource Counts").get(t+"s Active").decrementCount()}_trackAllocatedMemory(t,e=this.constructor.name){const i=Ku.get("Memory Usage");i.get("GPU Memory").addCount(t),i.get(e+" Memory").addCount(t),this.byteLength=t}_trackDeallocatedMemory(t=this.constructor.name){const e=Ku.get("Memory Usage");e.get("GPU Memory").subtractCount(this.byteLength),e.get(t+" Memory").subtractCount(this.byteLength),this.byteLength=0}}function lc(t){switch(ArrayBuffer.isView(t)?t.constructor:t){case Float32Array:return 5126;case Uint16Array:return 5123;case Uint32Array:return 5125;case Uint8Array:case Uint8ClampedArray:return 5121;case Int8Array:return 5120;case Int16Array:return 5122;case Int32Array:return 5124;default:throw new Error("Failed to deduce GL constant from typed array")}}function hc(t,{clamped:e=!0}={}){switch(t){case 5126:return Float32Array;case 5123:case 33635:case 32819:case 32820:return Uint16Array;case 5125:return Uint32Array;case 5121:return e?Uint8ClampedArray:Uint8Array;case 5120:return Int8Array;case 5122:return Int16Array;case 5124:return Int32Array;default:throw new Error("Failed to deduce typed array type from GL constant")}}function uc({data:t,width:e,height:i}){const n=Math.round(e/2),r=Math.round(i/2),s=new Uint8Array(n*r*4);for(let i=0;i<r;i++)for(let r=0;r<n;r++)for(let o=0;o<4;o++)s[4*(i*n+r)+o]=t[4*(2*i*e+2*r)+o];return{data:s,width:n,height:r}}function cc(t,e,i){const{removedProps:n={},deprecatedProps:r={},replacedProps:s={}}=i;for(const i in n)if(i in e){const e=n[i]?`${t}.${n[i]}`:"N/A";Fu.removed(`${t}.${i}`,e)()}for(const i in r)if(i in e){const e=r[i];Fu.deprecated(`${t}.${i}`,`${t}.${e}`)()}let o=null;for(const i in s)if(i in e){const n=s[i];Fu.deprecated(`${t}.${i}`,`${t}.${n}`)(),o=o||Object.assign({},e),o[n]=e[i],delete o[i]}return o||e}const dc={offset:0,stride:0,type:5126,size:1,divisor:0,normalized:!1,integer:!1},gc={deprecatedProps:{instanced:"divisor",isInstanced:"divisor"}};class fc{static getBytesPerElement(t){return hc(t.type||5126).BYTES_PER_ELEMENT}static getBytesPerVertex(t){$u(t.size);return hc(t.type||5126).BYTES_PER_ELEMENT*t.size}static resolve(...t){return new fc(...[dc,...t])}constructor(...t){t.forEach(t=>this._assign(t)),Object.freeze(this)}toString(){return JSON.stringify(this)}get BYTES_PER_ELEMENT(){return fc.getBytesPerElement(this)}get BYTES_PER_VERTEX(){return fc.getBytesPerVertex(this)}_assign(t={}){return void 0!==(t=cc("Accessor",t,gc)).type&&(this.type=t.type,5124!==t.type&&5125!==t.type||(this.integer=!0)),void 0!==t.size&&(this.size=t.size),void 0!==t.offset&&(this.offset=t.offset),void 0!==t.stride&&(this.stride=t.stride),void 0!==t.normalized&&(this.normalized=t.normalized),void 0!==t.integer&&(this.integer=t.integer),void 0!==t.divisor&&(this.divisor=t.divisor),void 0!==t.buffer&&(this.buffer=t.buffer),void 0!==t.index&&("boolean"==typeof t.index?this.index=t.index?1:0:this.index=t.index),void 0!==t.instanced&&(this.divisor=t.instanced?1:0),void 0!==t.isInstanced&&(this.divisor=t.isInstanced?1:0),this}}const pc={offset:"accessor.offset",stride:"accessor.stride",type:"accessor.type",size:"accessor.size",divisor:"accessor.divisor",normalized:"accessor.normalized",integer:"accessor.integer",instanced:"accessor.divisor",isInstanced:"accessor.divisor"},mc={removedProps:{},replacedProps:{bytes:"byteLength"},deprecatedProps:pc},yc={removedProps:pc};class bc extends ac{constructor(t,e={}){super(t,e),this.stubRemovedMethods("Buffer","v6.0",["layout","setLayout","getIndexedParameter"]),this.target=e.target||(this.gl.webgl2?36662:34962),this.initialize(e),Object.seal(this)}getElementCount(t=this.accessor){return Math.round(this.byteLength/fc.getBytesPerElement(t))}getVertexCount(t=this.accessor){return Math.round(this.byteLength/fc.getBytesPerVertex(t))}initialize(t={}){return ArrayBuffer.isView(t)&&(t={data:t}),Number.isFinite(t)&&(t={byteLength:t}),t=cc("Buffer",t,mc),this.usage=t.usage||35044,this.debugData=null,this.setAccessor(Object.assign({},t,t.accessor)),t.data?this._setData(t.data,t.offset,t.byteLength):this._setByteLength(t.byteLength||0),this}setProps(t){return"accessor"in(t=cc("Buffer",t,yc))&&this.setAccessor(t.accessor),this}setAccessor(t){return delete(t=Object.assign({},t)).buffer,this.accessor=new fc(t),this}reallocate(t){return t>this.byteLength?(this._setByteLength(t),!0):(this.bytesUsed=t,!1)}setData(t){return this.initialize(t)}subData(t){ArrayBuffer.isView(t)&&(t={data:t});const{data:e,offset:i=0,srcOffset:n=0}=t,r=t.byteLength||t.length;$u(e);const s=this.gl.webgl2?36663:this.target;return this.gl.bindBuffer(s,this.handle),0!==n||void 0!==r?(Object(Du.a)(this.gl),this.gl.bufferSubData(this.target,i,e,n,r)):this.gl.bufferSubData(s,i,e),this.gl.bindBuffer(s,null),this.debugData=null,this._inferType(e),this}copyData({sourceBuffer:t,readOffset:e=0,writeOffset:i=0,size:n}){const{gl:r}=this;return Object(Du.a)(r),r.bindBuffer(36662,t.handle),r.bindBuffer(36663,this.handle),r.copyBufferSubData(36662,36663,e,i,n),r.bindBuffer(36662,null),r.bindBuffer(36663,null),this.debugData=null,this}getData({dstData:t=null,srcByteOffset:e=0,dstOffset:i=0,length:n=0}={}){Object(Du.a)(this.gl);const r=hc(this.accessor.type||5126,{clamped:!1}),s=this._getAvailableElementCount(e),o=i;let a,l;t?(l=t.length,a=l-o):(a=Math.min(s,n||s),l=o+a);const h=Math.min(s,a);return $u((n=n||h)<=h),t=t||new r(l),this.gl.bindBuffer(36662,this.handle),this.gl.getBufferSubData(36662,e,t,i,n),this.gl.bindBuffer(36662,null),t}bind({target:t=this.target,index:e=this.accessor&&this.accessor.index,offset:i=0,size:n}={}){return 35345===t||35982===t?void 0!==n?this.gl.bindBufferRange(t,e,this.handle,i,n):($u(0===i),this.gl.bindBufferBase(t,e,this.handle)):this.gl.bindBuffer(t,this.handle),this}unbind({target:t=this.target,index:e=this.accessor&&this.accessor.index}={}){return 35345===t||35982===t?this.gl.bindBufferBase(t,e,null):this.gl.bindBuffer(t,null),this}getDebugData(){return this.debugData?{data:this.debugData,changed:!1}:(this.debugData=this.getData({length:Math.min(10,this.byteLength)}),{data:this.debugData,changed:!0})}invalidateDebugData(){this.debugData=null}_setData(t,e=0,i=t.byteLength+e){$u(ArrayBuffer.isView(t)),this._trackDeallocatedMemory();const n=this._getTarget();this.gl.bindBuffer(n,this.handle),this.gl.bufferData(n,i,this.usage),this.gl.bufferSubData(n,e,t),this.gl.bindBuffer(n,null),this.debugData=t.slice(0,10),this.bytesUsed=i,this._trackAllocatedMemory(i);const r=lc(t);return $u(r),this.setAccessor(new fc(this.accessor,{type:r})),this}_setByteLength(t,e=this.usage){$u(t>=0),this._trackDeallocatedMemory();let i=t;0===t&&(i=new Float32Array(0));const n=this._getTarget();return this.gl.bindBuffer(n,this.handle),this.gl.bufferData(n,i,e),this.gl.bindBuffer(n,null),this.usage=e,this.debugData=null,this.bytesUsed=t,this._trackAllocatedMemory(t),this}_getTarget(){return this.gl.webgl2?36663:this.target}_getAvailableElementCount(t){const e=t/hc(this.accessor.type||5126,{clamped:!1}).BYTES_PER_ELEMENT;return this.getElementCount()-e}_inferType(t){this.accessor.type||this.setAccessor(new fc(this.accessor,{type:lc(t)}))}_createHandle(){return this.gl.createBuffer()}_deleteHandle(){this.gl.deleteBuffer(this.handle),this._trackDeallocatedMemory()}_getParameter(t){this.gl.bindBuffer(this.target,this.handle);const e=this.gl.getBufferParameter(this.target,t);return this.gl.bindBuffer(this.target,null),e}get type(){return Fu.deprecated("Buffer.type","Buffer.accessor.type")(),this.accessor.type}get bytes(){return Fu.deprecated("Buffer.bytes","Buffer.byteLength")(),this.byteLength}setByteLength(t){return Fu.deprecated("setByteLength","reallocate")(),this.reallocate(t)}updateAccessor(t){return Fu.deprecated("updateAccessor(...)","setAccessor(new Accessor(buffer.accessor, ...)")(),this.accessor=new fc(this.accessor,t),this}}const Pc={6407:{dataFormat:6407,types:[5121,33635]},6408:{dataFormat:6408,types:[5121,32819,32820]},6406:{dataFormat:6406,types:[5121]},6409:{dataFormat:6409,types:[5121]},6410:{dataFormat:6410,types:[5121]},33326:{dataFormat:6403,types:[5126],gl2:!0},33328:{dataFormat:33319,types:[5126],gl2:!0},34837:{dataFormat:6407,types:[5126],gl2:!0},34836:{dataFormat:6408,types:[5126],gl2:!0}},vc={6403:1,36244:1,33319:2,33320:2,6407:3,36248:3,6408:4,36249:4,6402:1,34041:1,6406:1,6409:1,6410:2},Sc={5126:4,5125:4,5124:4,5123:2,5122:2,5131:2,5120:1,5121:1};const Cc=[9729,9728],wc=Vu.global.WebGLBuffer||function(){};class Ec extends ac{static isSupported(t,e={}){const{format:i,linearFiltering:n}=e;let r=!0;return i&&(r=r&&function(t,e){const i=Pc[e];if(!i)return!1;if(void 0===i.gl1&&void 0===i.gl2)return!0;const n=Object(Du.e)(t)&&i.gl2||i.gl1;return"string"==typeof n?t.getExtension(n):n}(t,i),r=r&&(!n||function(t,e){const i=Pc[e];switch(i&&i.types[0]){case 5126:return t.getExtension("OES_texture_float_linear");case 5131:return t.getExtension("OES_texture_half_float_linear");default:return!0}}(t,i))),r}constructor(t,e){const{id:i=ic("texture"),handle:n,target:r}=e;super(t,{id:i,handle:n}),this.target=r,this.textureUnit=void 0,this.loaded=!1,this.width=void 0,this.height=void 0,this.depth=void 0,this.format=void 0,this.type=void 0,this.dataFormat=void 0,this.border=void 0,this.textureUnit=void 0,this.mipmaps=void 0}toString(){return`Texture(${this.id},${this.width}x${this.height})`}initialize(t={}){let e=t.data;if(e instanceof Promise)return e.then(e=>this.initialize(Object.assign({},t,{pixels:e,data:e}))),this;const i="undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement;if(i&&e.readyState<HTMLVideoElement.HAVE_METADATA)return this._video=null,e.addEventListener("loadeddata",()=>this.initialize(t)),this;const{pixels:n=null,format:r=6408,border:s=0,recreate:o=!1,parameters:a={},pixelStore:l={},textureUnit:h}=t;e||(e=n);let{width:u,height:c,dataFormat:d,type:g,compressed:f=!1,mipmaps:p=!0}=t;const{depth:m=0}=t;return({width:u,height:c,compressed:f,dataFormat:d,type:g}=this._deduceParameters({format:r,type:g,dataFormat:d,compressed:f,data:e,width:u,height:c})),this.width=u,this.height=c,this.depth=m,this.format=r,this.type=g,this.dataFormat=d,this.border=s,this.textureUnit=h,Number.isFinite(this.textureUnit)&&(this.gl.activeTexture(33984+this.textureUnit),this.gl.bindTexture(this.target,this.handle)),p&&this._isNPOT()&&(Fu.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)(),p=!1,this._updateForNPOT(a)),this.mipmaps=p,this.setImageData({data:e,width:u,height:c,depth:m,format:r,type:g,dataFormat:d,border:s,mipmaps:p,parameters:l,compressed:f}),p&&this.generateMipmap(),this.setParameters(a),o&&(this.data=e),i&&(this._video={video:e,parameters:a,lastTime:e.readyState>=HTMLVideoElement.HAVE_CURRENT_DATA?e.currentTime:-1}),this}update(){if(this._video){const{video:t,parameters:e,lastTime:i}=this._video;if(i===t.currentTime||t.readyState<HTMLVideoElement.HAVE_CURRENT_DATA)return;this.setSubImageData({data:t,parameters:e}),this.mipmaps&&this.generateMipmap(),this._video.lastTime=t.currentTime}}resize({height:t,width:e,mipmaps:i=!1}){return e!==this.width||t!==this.height?this.initialize({width:e,height:t,format:this.format,type:this.type,dataFormat:this.dataFormat,border:this.border,mipmaps:i}):this}generateMipmap(t={}){return this._isNPOT()?(Fu.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)(),this):(this.mipmaps=!0,this.gl.bindTexture(this.target,this.handle),Object(Nu.d)(this.gl,t,()=>{this.gl.generateMipmap(this.target)}),this.gl.bindTexture(this.target,null),this)}setImageData(t){this._trackDeallocatedMemory("Texture");const{target:e=this.target,pixels:i=null,level:n=0,format:r=this.format,border:s=this.border,offset:o=0,parameters:a={}}=t;let{data:l=null,type:h=this.type,width:u=this.width,height:c=this.height,dataFormat:d=this.dataFormat,compressed:g=!1}=t;l||(l=i),({type:h,dataFormat:d,compressed:g,width:u,height:c}=this._deduceParameters({format:r,type:h,dataFormat:d,compressed:g,data:l,width:u,height:c}));const{gl:f}=this;f.bindTexture(this.target,this.handle);let p,m=null;if(({data:l,dataType:m}=this._getDataType({data:l,compressed:g})),Object(Nu.d)(this.gl,a,()=>{switch(m){case"null":f.texImage2D(e,n,r,u,c,s,d,h,l);break;case"typed-array":f.texImage2D(e,n,r,u,c,s,d,h,l,o);break;case"buffer":p=Object(Du.a)(f),p.bindBuffer(35052,l.handle||l),p.texImage2D(e,n,r,u,c,s,d,h,o),p.bindBuffer(35052,null);break;case"browser-object":Object(Du.e)(f)?f.texImage2D(e,n,r,u,c,s,d,h,l):f.texImage2D(e,n,r,d,h,l);break;case"compressed":for(const[t,i]of l.entries())f.compressedTexImage2D(e,t,i.format,i.width,i.height,s,i.data);break;default:$u(!1,"Unknown image data type")}}),l&&l.byteLength)this._trackAllocatedMemory(l.byteLength,"Texture");else{const t=vc[this.dataFormat]||4,e=Sc[this.type]||1;this._trackAllocatedMemory(this.width*this.height*t*e,"Texture")}return this.loaded=!0,this}setSubImageData({target:t=this.target,pixels:e=null,data:i=null,x:n=0,y:r=0,width:s=this.width,height:o=this.height,level:a=0,format:l=this.format,type:h=this.type,dataFormat:u=this.dataFormat,compressed:c=!1,offset:d=0,border:g=this.border,parameters:f={}}){if(({type:h,dataFormat:u,compressed:c,width:s,height:o}=this._deduceParameters({format:l,type:h,dataFormat:u,compressed:c,data:i,width:s,height:o})),$u(0===this.depth,"texSubImage not supported for 3D textures"),i||(i=e),i&&i.data){const t=i;i=t.data,s=t.shape[0],o=t.shape[1]}i instanceof bc&&(i=i.handle),this.gl.bindTexture(this.target,this.handle),Object(Nu.d)(this.gl,f,()=>{if(c)this.gl.compressedTexSubImage2D(t,a,n,r,s,o,l,i);else if(null===i)this.gl.texSubImage2D(t,a,n,r,s,o,u,h,null);else if(ArrayBuffer.isView(i))this.gl.texSubImage2D(t,a,n,r,s,o,u,h,i,d);else if(i instanceof wc){const e=Object(Du.a)(this.gl);e.bindBuffer(35052,i),e.texSubImage2D(t,a,n,r,s,o,u,h,d),e.bindBuffer(35052,null)}else if(Object(Du.e)(this.gl)){Object(Du.a)(this.gl).texSubImage2D(t,a,n,r,s,o,u,h,i)}else this.gl.texSubImage2D(t,a,n,r,u,h,i)}),this.gl.bindTexture(this.target,null)}copyFramebuffer(t={}){return Fu.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(),null}getActiveUnit(){return this.gl.getParameter(34016)-33984}bind(t=this.textureUnit){const{gl:e}=this;return void 0!==t&&(this.textureUnit=t,e.activeTexture(33984+t)),e.bindTexture(this.target,this.handle),t}unbind(t=this.textureUnit){const{gl:e}=this;return void 0!==t&&(this.textureUnit=t,e.activeTexture(33984+t)),e.bindTexture(this.target,null),t}_getDataType({data:t,compressed:e=!1}){return e?{data:t,dataType:"compressed"}:null===t?{data:t,dataType:"null"}:ArrayBuffer.isView(t)?{data:t,dataType:"typed-array"}:t instanceof bc?{data:t.handle,dataType:"buffer"}:t instanceof wc?{data:t,dataType:"buffer"}:{data:t,dataType:"browser-object"}}_deduceParameters(t){const{format:e,data:i}=t;let{width:n,height:r,dataFormat:s,type:o,compressed:a}=t;const l=Pc[e];return s=s||l&&l.dataFormat,o=o||l&&l.types[0],a=a||l&&l.compressed,({width:n,height:r}=this._deduceImageSize(i,n,r)),{dataFormat:s,type:o,compressed:a,width:n,height:r,format:e,data:i}}_deduceImageSize(t,e,i){let n;return n="undefined"!=typeof ImageData&&t instanceof ImageData?{width:t.width,height:t.height}:"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement?{width:t.naturalWidth,height:t.naturalHeight}:"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?{width:t.width,height:t.height}:"undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement?{width:t.videoWidth,height:t.videoHeight}:t?{width:e,height:i}:{width:e>=0?e:1,height:i>=0?i:1},$u(n,"Could not deduced texture size"),$u(void 0===e||n.width===e,"Deduced texture width does not match supplied width"),$u(void 0===i||n.height===i,"Deduced texture height does not match supplied height"),n}_createHandle(){return this.gl.createTexture()}_deleteHandle(){this.gl.deleteTexture(this.handle),this._trackDeallocatedMemory("Texture")}_getParameter(t){switch(t){case 4096:return this.width;case 4097:return this.height;default:this.gl.bindTexture(this.target,this.handle);const e=this.gl.getTexParameter(this.target,t);return this.gl.bindTexture(this.target,null),e}}_setParameter(t,e){switch(this.gl.bindTexture(this.target,this.handle),e=this._getNPOTParam(t,e),t){case 33082:case 33083:this.gl.texParameterf(this.handle,t,e);break;case 4096:case 4097:$u(!1);break;default:this.gl.texParameteri(this.target,t,e)}return this.gl.bindTexture(this.target,null),this}_isNPOT(){return!Object(Du.e)(this.gl)&&(!(!this.width||!this.height)&&(!nc(this.width)||!nc(this.height)))}_updateForNPOT(t){void 0===t[this.gl.TEXTURE_MIN_FILTER]&&(t[this.gl.TEXTURE_MIN_FILTER]=this.gl.LINEAR),void 0===t[this.gl.TEXTURE_WRAP_S]&&(t[this.gl.TEXTURE_WRAP_S]=this.gl.CLAMP_TO_EDGE),void 0===t[this.gl.TEXTURE_WRAP_T]&&(t[this.gl.TEXTURE_WRAP_T]=this.gl.CLAMP_TO_EDGE)}_getNPOTParam(t,e){if(this._isNPOT())switch(t){case 10241:-1===Cc.indexOf(e)&&(e=9729);break;case 10242:case 10243:33071!==e&&(e=33071)}return e}}let xc="";class Ac extends Ec{static isSupported(t,e){return Ec.isSupported(t,e)}constructor(t,e={}){var i,n;Object(Du.b)(t),(e instanceof Promise||"string"==typeof e)&&(e={data:e}),"string"==typeof e.data&&(e=Object.assign({},e,{data:(i=e.data,$u("string"==typeof i),i=xc+i,new Promise((t,e)=>{try{const r=new Image;r.onload=()=>t(r),r.onerror=()=>e(new Error(`Could not load image ${i}.`)),r.crossOrigin=n&&n.crossOrigin||"anonymous",r.src=i}catch(t){e(t)}}))})),super(t,Object.assign({},e,{target:3553})),this.initialize(e),Object.seal(this)}}const Tc="EXT_color_buffer_float";var Ic={33189:{bpp:2},33190:{gl2:!0,bpp:3},36012:{gl2:!0,bpp:4},36168:{bpp:1},34041:{bpp:4},35056:{gl2:!0,bpp:4},36013:{gl2:!0,bpp:5},32854:{bpp:2},36194:{bpp:2},32855:{bpp:2},33321:{gl2:!0,bpp:1},33330:{gl2:!0,bpp:1},33329:{gl2:!0,bpp:1},33332:{gl2:!0,bpp:2},33331:{gl2:!0,bpp:2},33334:{gl2:!0,bpp:4},33333:{gl2:!0,bpp:4},33323:{gl2:!0,bpp:2},33336:{gl2:!0,bpp:2},33335:{gl2:!0,bpp:2},33338:{gl2:!0,bpp:4},33337:{gl2:!0,bpp:4},33340:{gl2:!0,bpp:8},33339:{gl2:!0,bpp:8},32849:{gl2:!0,bpp:3},32856:{gl2:!0,bpp:4},32857:{gl2:!0,bpp:4},36220:{gl2:!0,bpp:4},36238:{gl2:!0,bpp:4},36975:{gl2:!0,bpp:4},36214:{gl2:!0,bpp:8},36232:{gl2:!0,bpp:8},36226:{gl2:!0,bpp:16},36208:{gl2:!0,bpp:16},33325:{gl2:Tc,bpp:2},33327:{gl2:Tc,bpp:4},34842:{gl2:Tc,bpp:8},33326:{gl2:Tc,bpp:4},33328:{gl2:Tc,bpp:8},34836:{gl2:Tc,bpp:16},35898:{gl2:Tc,bpp:4}};class Oc extends ac{static isSupported(t,{format:e}={format:null}){return!e||function(t,e,i){const n=i[e];if(!n)return!1;const r=Object(Du.e)(t)&&n.gl2||n.gl1;return"string"==typeof r?t.getExtension(r):r}(t,e,Ic)}static getSamplesForFormat(t,{format:e}){return t.getInternalformatParameter(36161,e,32937)}constructor(t,e={}){super(t,e),this.initialize(e),Object.seal(this)}initialize({format:t,width:e=1,height:i=1,samples:n=0}){return $u(t,"Needs format"),this._trackDeallocatedMemory(),this.gl.bindRenderbuffer(36161,this.handle),0!==n&&Object(Du.e)(this.gl)?this.gl.renderbufferStorageMultisample(36161,n,t,e,i):this.gl.renderbufferStorage(36161,t,e,i),this.format=t,this.width=e,this.height=i,this.samples=n,this._trackAllocatedMemory(this.width*this.height*(this.samples||1)*Ic[this.format].bpp),this}resize({width:t,height:e}){return t!==this.width||e!==this.height?this.initialize({width:t,height:e,format:this.format,samples:this.samples}):this}_createHandle(){return this.gl.createRenderbuffer()}_deleteHandle(){this.gl.deleteRenderbuffer(this.handle),this._trackDeallocatedMemory()}_bindHandle(t){this.gl.bindRenderbuffer(36161,t)}_syncHandle(t){this.format=this.getParameter(36164),this.width=this.getParameter(36162),this.height=this.getParameter(36163),this.samples=this.getParameter(36011)}_getParameter(t){this.gl.bindRenderbuffer(36161,this.handle);return this.gl.getRenderbufferParameter(36161,t)}}function _c(t,{framebuffer:e=null,color:i=null,depth:n=null,stencil:r=null}={}){const s={};e&&(s.framebuffer=e);let o=0;i&&(o|=16384,!0!==i&&(s.clearColor=i)),n&&(o|=256,!0!==n&&(s.clearDepth=n)),r&&(o|=1024,!0!==n&&(s.clearStencil=n)),$u(0!==o,"clear: bad arguments"),Object(Nu.d)(t,s,()=>{t.clear(o)})}function Lc(t){switch(t){case 6406:case 33326:case 6403:return 1;case 33328:case 33319:return 2;case 6407:case 34837:return 3;case 6408:case 34836:return 4;default:return $u(!1),0}}const Rc=[34069,34070,34071,34072,34073,34074];class Bc extends Ec{constructor(t,e={}){Object(Du.b)(t),super(t,Object.assign({},e,{target:34067})),this.initialize(e),Object.seal(this)}initialize(t={}){const{mipmaps:e=!0,parameters:i={}}=t;return this.opts=t,this.setCubeMapImageData(t).then(()=>{this.loaded=!0,e&&this.generateMipmap(t),this.setParameters(i)}),this}subImage({face:t,data:e,x:i=0,y:n=0,mipmapLevel:r=0}){return this._subImage({target:t,data:e,x:i,y:n,mipmapLevel:r})}async setCubeMapImageData({width:t,height:e,pixels:i,data:n,border:r=0,format:s=6408,type:o=5121}){const{gl:a}=this,l=i||n,h=await Promise.all(Rc.map(t=>{const e=l[t];return Promise.all(Array.isArray(e)?e:[e])}));this.bind(),Rc.forEach((i,n)=>{h[n].length>1&&!1!==this.opts.mipmaps&&Fu.warn(this.id+" has mipmap and multiple LODs.")(),h[n].forEach((n,l)=>{t&&e?a.texImage2D(i,l,s,t,e,r,s,o,n):a.texImage2D(i,l,s,s,o,n)})}),this.unbind()}setImageDataForFace(t){const{face:e,width:i,height:n,pixels:r,data:s,border:o=0,format:a=6408,type:l=5121}=t,{gl:h}=this,u=r||s;return this.bind(),u instanceof Promise?u.then(i=>this.setImageDataForFace(Object.assign({},t,{face:e,data:i,pixels:i}))):this.width||this.height?h.texImage2D(e,0,a,i,n,o,a,l,u):h.texImage2D(e,0,a,a,l,u),this}}Bc.FACES=Rc;class Mc extends Ec{static isSupported(t){return Object(Du.e)(t)}constructor(t,e={}){Object(Du.a)(t),super(t,e=Object.assign({depth:1},e,{target:32879,unpackFlipY:!1})),this.initialize(e),Object.seal(this)}setImageData({level:t=0,dataFormat:e=6408,width:i,height:n,depth:r=1,border:s=0,format:o,type:a=5121,offset:l=0,data:h,parameters:u={}}){if(this._trackDeallocatedMemory("Texture"),this.gl.bindTexture(this.target,this.handle),Object(Nu.d)(this.gl,u,()=>{ArrayBuffer.isView(h)&&this.gl.texImage3D(this.target,t,e,i,n,r,s,o,a,h),h instanceof bc&&(this.gl.bindBuffer(35052,h.handle),this.gl.texImage3D(this.target,t,e,i,n,r,s,o,a,l))}),h&&h.byteLength)this._trackAllocatedMemory(h.byteLength,"Texture");else{const t=vc[this.dataFormat]||4,e=Sc[this.type]||1;this._trackAllocatedMemory(this.width*this.height*this.depth*t*e,"Texture")}return this.loaded=!0,this}}function Fc(t,e){$u(t instanceof Ac||t instanceof Bc||t instanceof Mc);const i=t.constructor,{gl:n,width:r,height:s,format:o,type:a,dataFormat:l,border:h,mipmaps:u}=t;return new i(n,Object.assign({width:r,height:s,format:o,type:a,dataFormat:l,border:h,mipmaps:u},e))}function Dc(t,e){const{gl:i,width:n,height:r,id:s}=t;return new Hc(i,Object.assign({},e,{id:"framebuffer-for-"+s,width:n,height:r,attachments:{36064:t}}))}function Nc(t,e={}){const{sourceX:i=0,sourceY:n=0,sourceFormat:r=6408}=e;let{sourceAttachment:s=36064,target:o=null,sourceWidth:a,sourceHeight:l,sourceType:h}=e;const{framebuffer:u,deleteFramebuffer:c}=Vc(t);$u(u);const{gl:d,handle:g,attachments:f}=u;a=a||u.width,l=l||u.height,36064===s&&null===g&&(s=1028),$u(f[s]),h=h||f[s].type,o=function(t,e,i,n,r){if(t)return t;const s=hc(e=e||5121,{clamped:!1}),o=Lc(i);return new s(n*r*o)}(o,h,r,a,l),h=h||lc(o);const p=d.bindFramebuffer(36160,g);return d.readPixels(i,n,a,l,r,h,o),d.bindFramebuffer(36160,p||null),c&&u.delete(),o}function kc(t,{sourceAttachment:e=36064,targetMaxHeight:i=Number.MAX_SAFE_INTEGER}={}){let n=Nc(t,{sourceAttachment:e}),{width:r,height:s}=t;for(;s>i;)({data:n,width:r,height:s}=uc({data:n,width:r,height:s}));!function({data:t,width:e,height:i,bytesPerPixel:n=4,temp:r}){const s=e*n;r=r||new Uint8Array(s);for(let e=0;e<i/2;++e){const n=e*s,o=(i-e-1)*s;r.set(t.subarray(n,n+s)),t.copyWithin(n,o,o+s),t.set(r,o)}}({data:n,width:r,height:s});const o=document.createElement("canvas");o.width=r,o.height=s;const a=o.getContext("2d"),l=a.createImageData(r,s);return l.data.set(n),a.putImageData(l,0,0),o.toDataURL()}function Vc(t){return t instanceof Hc?{framebuffer:t,deleteFramebuffer:!1}:{framebuffer:Dc(t),deleteFramebuffer:!0}}const Gc="TIMER_QUERY",zc="ELEMENT_INDEX_UINT32";var jc={["WEBGL2"]:[!1,!0],["VERTEX_ARRAY_OBJECT"]:["OES_vertex_array_object",!0],[Gc]:["EXT_disjoint_timer_query","EXT_disjoint_timer_query_webgl2"],["INSTANCED_RENDERING"]:["ANGLE_instanced_arrays",!0],["MULTIPLE_RENDER_TARGETS"]:["WEBGL_draw_buffers",!0],[zc]:["OES_element_index_uint",!0],["BLEND_EQUATION_MINMAX"]:["EXT_blend_minmax",!0],["FLOAT_BLEND"]:["EXT_float_blend"],["COLOR_ENCODING_SRGB"]:["EXT_sRGB",!0],["TEXTURE_DEPTH"]:["WEBGL_depth_texture",!0],["TEXTURE_FLOAT"]:["OES_texture_float",!0],["TEXTURE_HALF_FLOAT"]:["OES_texture_half_float",!0],["TEXTURE_FILTER_LINEAR_FLOAT"]:["OES_texture_float_linear"],["TEXTURE_FILTER_LINEAR_HALF_FLOAT"]:["OES_texture_half_float_linear"],["TEXTURE_FILTER_ANISOTROPIC"]:["EXT_texture_filter_anisotropic"],["COLOR_ATTACHMENT_RGBA32F"]:[function(t){const e=new Ac(t,{format:6408,type:5126,dataFormat:6408}),i=new Hc(t,{id:"test-framebuffer",check:!1,attachments:{36064:e}}),n=i.getStatus();return e.delete(),i.delete(),36053===n},"EXT_color_buffer_float"],["COLOR_ATTACHMENT_FLOAT"]:[!1,"EXT_color_buffer_float"],["COLOR_ATTACHMENT_HALF_FLOAT"]:["EXT_color_buffer_half_float"],["GLSL_FRAG_DATA"]:["WEBGL_draw_buffers",!0],["GLSL_FRAG_DEPTH"]:["EXT_frag_depth",!0],["GLSL_DERIVATIVES"]:["OES_standard_derivatives",!0],["GLSL_TEXTURE_LOD"]:["EXT_shader_texture_lod",!0]};function Uc(t,e){return(e=Array.isArray(e)?e:[e]).every(e=>Wc(t,e))}function Wc(t,e){return t.luma=t.luma||{},t.luma.caps=t.luma.caps||{},void 0===t.luma.caps[e]&&(t.luma.caps[e]=function(t,e){const i=jc[e];let n;$u(i,e);const r=Object(Du.e)(t)&&i[1]||i[0];if("function"==typeof r)n=r(t);else if(Array.isArray(r)){n=!0;for(const e of r)n=n&&Boolean(t.getExtension(e))}else"string"==typeof r?n=Boolean(t.getExtension(r)):"boolean"==typeof r?n=r:$u(!1);return n}(t,e)),t.luma.caps[e]||Fu.log(2,`Feature: ${e} not supported`)(),t.luma.caps[e]}class Hc extends ac{static isSupported(t,e={}){const{colorBufferFloat:i,colorBufferHalfFloat:n}=e;let r=!0;return i&&(r=Boolean(t.getExtension("EXT_color_buffer_float")||t.getExtension("WEBGL_color_buffer_float")||t.getExtension("OES_texture_float"))),n&&(r=r&&Boolean(t.getExtension("EXT_color_buffer_float")||t.getExtension("EXT_color_buffer_half_float"))),r}static getDefaultFramebuffer(t){return t.luma=t.luma||{},t.luma.defaultFramebuffer=t.luma.defaultFramebuffer||new Hc(t,{id:"default-framebuffer",handle:null,attachments:{}}),t.luma.defaultFramebuffer}get MAX_COLOR_ATTACHMENTS(){const t=Object(Du.a)(this.gl);return t.getParameter(t.MAX_COLOR_ATTACHMENTS)}get MAX_DRAW_BUFFERS(){const t=Object(Du.a)(this.gl);return t.getParameter(t.MAX_DRAW_BUFFERS)}constructor(t,e={}){super(t,e),this.width=null,this.height=null,this.attachments={},this.readBuffer=36064,this.drawBuffers=[36064],this.ownResources=[],this.initialize(e),Object.seal(this)}get color(){return this.attachments[36064]||null}get texture(){return this.attachments[36064]||null}get depth(){return this.attachments[36096]||this.attachments[33306]||null}get stencil(){return this.attachments[36128]||this.attachments[33306]||null}initialize({width:t=1,height:e=1,attachments:i=null,color:n=!0,depth:r=!0,stencil:s=!1,check:o=!0,readBuffer:a,drawBuffers:l}){if($u(t>=0&&e>=0,"Width and height need to be integers"),this.width=t,this.height=e,i)for(const n in i){const r=i[n];(Array.isArray(r)?r[0]:r).resize({width:t,height:e})}else i=this._createDefaultAttachments(n,r,s,t,e);this.update({clearAttachments:!0,attachments:i,readBuffer:a,drawBuffers:l}),i&&o&&this.checkStatus()}delete(){for(const t of this.ownResources)t.delete();return super.delete(),this}update({attachments:t={},readBuffer:e,drawBuffers:i,clearAttachments:n=!1,resizeAttachments:r=!0}){this.attach(t,{clearAttachments:n,resizeAttachments:r});const{gl:s}=this,o=s.bindFramebuffer(36160,this.handle);return e&&this._setReadBuffer(e),i&&this._setDrawBuffers(i),s.bindFramebuffer(36160,o||null),this}resize(t={}){let{width:e,height:i}=t;if(null===this.handle)return $u(void 0===e&&void 0===i),this.width=this.gl.drawingBufferWidth,this.height=this.gl.drawingBufferHeight,this;void 0===e&&(e=this.gl.drawingBufferWidth),void 0===i&&(i=this.gl.drawingBufferHeight),e!==this.width&&i!==this.height&&Fu.log(2,`Resizing framebuffer ${this.id} to ${e}x${i}`)();for(const t in this.attachments)this.attachments[t].resize({width:e,height:i});return this.width=e,this.height=i,this}attach(t,{clearAttachments:e=!1,resizeAttachments:i=!0}={}){const n={};e&&Object.keys(this.attachments).forEach(t=>{n[t]=null}),Object.assign(n,t);const r=this.gl.bindFramebuffer(36160,this.handle);for(const t in n){$u(void 0!==t,"Misspelled framebuffer binding point?");const e=Number(t),r=n[e];let s=r;if(s)if(s instanceof Oc)this._attachRenderbuffer({attachment:e,renderbuffer:s});else if(Array.isArray(r)){const[t,i=0,n=0]=r;s=t,this._attachTexture({attachment:e,texture:t,layer:i,level:n})}else this._attachTexture({attachment:e,texture:s,layer:0,level:0});else this._unattach(e);i&&s&&s.resize({width:this.width,height:this.height})}this.gl.bindFramebuffer(36160,r||null),Object.assign(this.attachments,t),Object.keys(this.attachments).filter(t=>!this.attachments[t]).forEach(t=>{delete this.attachments[t]})}checkStatus(){const{gl:t}=this,e=this.getStatus();if(36053!==e)throw new Error(function(t){return(Hc.STATUS||{})[t]||"Framebuffer error "+t}(e));return this}getStatus(){const{gl:t}=this,e=t.bindFramebuffer(36160,this.handle),i=t.checkFramebufferStatus(36160);return t.bindFramebuffer(36160,e||null),i}clear(t={}){const{color:e,depth:i,stencil:n,drawBuffers:r=[]}=t,s=this.gl.bindFramebuffer(36160,this.handle);return(e||i||n)&&_c(this.gl,{color:e,depth:i,stencil:n}),r.forEach((t,e)=>{!function(t,{framebuffer:e=null,buffer:i=6144,drawBuffer:n=0,value:r=[0,0,0,0]}={}){Object(Du.a)(t),Object(Nu.d)(t,{framebuffer:e},()=>{switch(i){case 6144:switch(r.constructor){case Int32Array:t.clearBufferiv(i,n,r);break;case Uint32Array:t.clearBufferuiv(i,n,r);break;case Float32Array:default:t.clearBufferfv(i,n,r)}break;case 6145:t.clearBufferfv(6145,0,[r]);break;case 6146:t.clearBufferiv(6146,0,[r]);break;case 34041:const[e,s]=r;t.clearBufferfi(34041,0,e,s);break;default:$u(!1,"clear: bad arguments")}})}(this.gl,{drawBuffer:e,value:t})}),this.gl.bindFramebuffer(36160,s||null),this}readPixels(t={}){return Fu.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")(),null}readPixelsToBuffer(t={}){return Fu.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")(),null}copyToDataUrl(t={}){return Fu.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")(),null}copyToImage(t={}){return Fu.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")(),null}copyToTexture(t={}){return Fu.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")(),null}blit(t={}){return Fu.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")(),null}invalidate({attachments:t=[],x:e=0,y:i=0,width:n,height:r}){const s=Object(Du.a)(this.gl),o=s.bindFramebuffer(36008,this.handle);return 0===e&&0===i&&void 0===n&&void 0===r?s.invalidateFramebuffer(36008,t):s.invalidateFramebuffer(36008,t,e,i,n,r),s.bindFramebuffer(36008,o),this}getAttachmentParameter(t,e,i){let n=this._getAttachmentParameterFallback(e);return null===n&&(this.gl.bindFramebuffer(36160,this.handle),n=this.gl.getFramebufferAttachmentParameter(36160,t,e),this.gl.bindFramebuffer(36160,null)),i&&n>1e3&&(n=tc(this.gl,n)),n}getAttachmentParameters(t=36064,e,i=this.constructor.ATTACHMENT_PARAMETERS||[]){const n={};for(const r of i){n[e?tc(this.gl,r):r]=this.getAttachmentParameter(t,r,e)}return n}getParameters(t=!0){const e=Object.keys(this.attachments),i={};for(const n of e){const e=Number(n);i[t?tc(this.gl,e):e]=this.getAttachmentParameters(e,t)}return i}show(){return"undefined"!=typeof window&&window.open(kc(this),"luma-debug-texture"),this}log(t=0,e=""){if(t>Fu.level||"undefined"==typeof window)return this;e=e||"Framebuffer "+this.id;const i=kc(this,{targetMaxHeight:100});return Fu.image({logLevel:t,message:e,image:i},e)(),this}bind({target:t=36160}={}){return this.gl.bindFramebuffer(t,this.handle),this}unbind({target:t=36160}={}){return this.gl.bindFramebuffer(t,null),this}_createDefaultAttachments(t,e,i,n,r){let s=null;return t&&(s=s||{},s[36064]=new Ac(this.gl,{id:this.id+"-color0",pixels:null,format:6408,type:5121,width:n,height:r,mipmaps:!1,parameters:{10241:9729,10240:9729,10242:33071,10243:33071}}),this.ownResources.push(s[36064])),e&&i?(s=s||{},s[33306]=new Oc(this.gl,{id:this.id+"-depth-stencil",format:35056,width:n,height:111}),this.ownResources.push(s[33306])):e?(s=s||{},s[36096]=new Oc(this.gl,{id:this.id+"-depth",format:33189,width:n,height:r}),this.ownResources.push(s[36096])):i&&$u(!1),s}_unattach(t){const e=this.attachments[t];e&&(e instanceof Oc?this.gl.framebufferRenderbuffer(36160,t,36161,null):this.gl.framebufferTexture2D(36160,t,3553,null,0),delete this.attachments[t])}_attachRenderbuffer({attachment:t=36064,renderbuffer:e}){const{gl:i}=this;i.framebufferRenderbuffer(36160,t,36161,e.handle),this.attachments[t]=e}_attachTexture({attachment:t=36064,texture:e,layer:i,level:n}){const{gl:r}=this;switch(r.bindTexture(e.target,e.handle),e.target){case 35866:case 32879:Object(Du.a)(r).framebufferTextureLayer(36160,t,e.target,n,i);break;case 34067:const s=function(t){return t<34069?t+34069:t}(i);r.framebufferTexture2D(36160,t,s,e.handle,n);break;case 3553:r.framebufferTexture2D(36160,t,3553,e.handle,n);break;default:$u(!1,"Illegal texture type")}r.bindTexture(e.target,null),this.attachments[t]=e}_setReadBuffer(t){const e=Object(Du.c)(this.gl);e?e.readBuffer(t):$u(36064===t||1029===t,"Multiple render targets not supported"),this.readBuffer=t}_setDrawBuffers(t){const{gl:e}=this,i=Object(Du.a)(e);if(i)i.drawBuffers(t);else{const i=e.getExtension("WEBGL_draw_buffers");i?i.drawBuffersWEBGL(t):$u(1===t.length&&(36064===t[0]||1029===t[0]),"Multiple render targets not supported")}this.drawBuffers=t}_getAttachmentParameterFallback(t){const e=function(t){t.luma=t.luma||{},t.luma.caps=t.luma.caps||{};for(const e in jc)void 0===t.luma.caps[e]&&(t.luma.caps[e]=Wc(t,e));return t.luma.caps}(this.gl);switch(t){case 36052:return e.WEBGL2?null:0;case 33298:case 33299:case 33300:case 33301:case 33302:case 33303:return e.WEBGL2?null:8;case 33297:return e.WEBGL2?null:5125;case 33296:return e.WEBGL2||e.EXT_sRGB?null:9729;default:return null}}_createHandle(){return this.gl.createFramebuffer()}_deleteHandle(){this.gl.deleteFramebuffer(this.handle)}_bindHandle(t){return this.gl.bindFramebuffer(36160,t)}}Hc.ATTACHMENT_PARAMETERS=[36049,36048,33296,33298,33299,33300,33301,33302,33303];const qc={5126:od.bind(null,"uniform1fv",$c,1,ad),35664:od.bind(null,"uniform2fv",$c,2,ad),35665:od.bind(null,"uniform3fv",$c,3,ad),35666:od.bind(null,"uniform4fv",$c,4,ad),5124:od.bind(null,"uniform1iv",Jc,1,ad),35667:od.bind(null,"uniform2iv",Jc,2,ad),35668:od.bind(null,"uniform3iv",Jc,3,ad),35669:od.bind(null,"uniform4iv",Jc,4,ad),35670:od.bind(null,"uniform1iv",Jc,1,ad),35671:od.bind(null,"uniform2iv",Jc,2,ad),35672:od.bind(null,"uniform3iv",Jc,3,ad),35673:od.bind(null,"uniform4iv",Jc,4,ad),35674:od.bind(null,"uniformMatrix2fv",$c,4,ld),35675:od.bind(null,"uniformMatrix3fv",$c,9,ld),35676:od.bind(null,"uniformMatrix4fv",$c,16,ld),35678:sd,35680:sd,5125:od.bind(null,"uniform1uiv",td,1,ad),36294:od.bind(null,"uniform2uiv",td,2,ad),36295:od.bind(null,"uniform3uiv",td,3,ad),36296:od.bind(null,"uniform4uiv",td,4,ad),35685:od.bind(null,"uniformMatrix2x3fv",$c,6,ld),35686:od.bind(null,"uniformMatrix2x4fv",$c,8,ld),35687:od.bind(null,"uniformMatrix3x2fv",$c,6,ld),35688:od.bind(null,"uniformMatrix3x4fv",$c,12,ld),35689:od.bind(null,"uniformMatrix4x2fv",$c,8,ld),35690:od.bind(null,"uniformMatrix4x3fv",$c,12,ld),35678:sd,35680:sd,35679:sd,35682:sd,36289:sd,36292:sd,36293:sd,36298:sd,36299:sd,36300:sd,36303:sd,36306:sd,36307:sd,36308:sd,36311:sd},Xc={},Yc={},Qc={},Zc=[0];function Kc(t,e,i,n){1===e&&"boolean"==typeof t&&(t=t?1:0),Number.isFinite(t)&&(Zc[0]=t,t=Zc);const r=t.length;if(r%e&&Fu.warn("Uniform size should be multiples of "+e,t)(),t instanceof i)return t;let s=n[r];s||(s=new i(r),n[r]=s);for(let e=0;e<r;e++)s[e]=t[e];return s}function $c(t,e){return Kc(t,e,Float32Array,Xc)}function Jc(t,e){return Kc(t,e,Int32Array,Yc)}function td(t,e){return Kc(t,e,Uint32Array,Qc)}function ed(t,e,i){const n=qc[i.type];if(!n)throw new Error("Unknown GLSL uniform type "+i.type);return n().bind(null,t,e)}function id(t){if("]"!==t[t.length-1])return{name:t,length:1,isArray:!1};const e=t.match(/([^[]*)(\[[0-9]+\])?/);if(!e||e.length<2)throw new Error("Failed to parse GLSL uniform name "+t);return{name:e[1],length:e[2]||1,isArray:Boolean(e[2])}}function nd(t){return Array.isArray(t)||ArrayBuffer.isView(t)?function(t){if(0===t.length)return!1;const e=Math.min(t.length,16);for(let i=0;i<e;++i)if(!Number.isFinite(t[i]))return!1;return!0}(t):!!isFinite(t)||(!0===t||!1===t||(t instanceof Ec||(t instanceof Oc||t instanceof Hc&&Boolean(t.texture))))}function rd(t,e,i){if(Array.isArray(i)||ArrayBuffer.isView(i))if(t[e]){const n=t[e];for(let t=0,e=i.length;t<e;++t)n[t]=i[t]}else t[e]=i.slice();else t[e]=i}function sd(){let t=null;return(e,i,n)=>{const r=t!==n;return r&&(e.uniform1i(i,n),t=n),r}}function od(t,e,i,n){let r=null,s=null;return(o,a,l)=>{const h=e(l,i),u=h.length;let c=!1;if(null===r)r=new Float32Array(u),s=u,c=!0;else{$u(s===u,"Uniform length cannot change.");for(let t=0;t<u;++t)if(h[t]!==r[t]){c=!0;break}}return c&&(n(o,t,a,h),r.set(h)),c}}function ad(t,e,i,n){t[e](i,n)}function ld(t,e,i,n){t[e](i,!1,n)}function hd(t,e="unnamed"){const i=t.match(/#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/);return i?i[1]:e}function ud(t,e,i,n){const r=t.split(/\r?\n/),s={},o={},a=n||hd(e)||"(unnamed)",l=`${function(t){switch(t){case 35632:return"fragment";case 35633:return"vertex";default:return"unknown type"}}(i)} shader ${a}`;for(let e=0;e<r.length;e++){const i=r[e];if(i.length<=1)continue;const n=i.split(":"),a=n[0],h=parseInt(n[2],10);if(isNaN(h))throw new Error(`GLSL compilation error in ${l}: ${t}`);"WARNING"!==a?s[h]=i:o[h]=i}const h=function(t,e=1,i=": "){const n=t.split(/\r?\n/),r=String(n.length+e-1).length;return n.map((t,n)=>{const s=String(n+e),o=s.length;return dd(s,r-o)+i+t})}(e);return{shaderName:l,errors:cd(s,h),warnings:cd(o,h)}}function cd(t,e){let i="";for(let n=0;n<e.length;n++){const r=e[n];if((t[n+3]||t[n+2]||t[n+1])&&(i+=r+"\n",t[n+1])){const e=t[n+1],r=e.split(":",3),s=r[0],o=parseInt(r[1],10)||0;i+=dd(`^^^ ${s}: ${e.substring(r.join(":").length+1).trim()}\n\n`,o)}}return i}function dd(t,e){let i="";for(let t=0;t<e;++t)i+=" ";return`${i}${t}`}class gd extends ac{static getTypeName(t){switch(t){case 35633:return"vertex-shader";case 35632:return"fragment-shader";default:return $u(!1),"unknown"}}constructor(t,e){Object(Du.b)(t),$u("string"==typeof e.source,"Shader: GLSL source code must be a JavaScript string");super(t,{id:hd(e.source,null)||e.id||ic("unnamed "+gd.getTypeName(e.shaderType))}),this.shaderType=e.shaderType,this.source=e.source,this.initialize(e)}initialize({source:t}){const e=hd(t,null);e&&(this.id=ic(e)),this._compile(t)}getParameter(t){return this.gl.getShaderParameter(this.handle,t)}toString(){return`${gd.getTypeName(this.shaderType)}:${this.id}`}getName(){return hd(this.source)||"unnamed-shader"}getSource(){return this.gl.getShaderSource(this.handle)}getTranslatedSource(){const t=this.gl.getExtension("WEBGL_debug_shaders");return t?t.getTranslatedShaderSource(this.handle):"No translated source available. WEBGL_debug_shaders not implemented"}_compile(t=this.source){t.startsWith("#version ")||(t="#version 100\n"+t),this.source=t,this.gl.shaderSource(this.handle,this.source),this.gl.compileShader(this.handle);if(!this.getParameter(35713)){const t=this.gl.getShaderInfoLog(this.handle),{shaderName:e,errors:i,warnings:n}=ud(t,this.source,this.shaderType,this.id);throw Fu.error(`GLSL compilation errors in ${e}\n${i}`)(),Fu.warn(`GLSL compilation warnings in ${e}\n${n}`)(),new Error("GLSL compilation errors in "+e)}}_deleteHandle(){this.gl.deleteShader(this.handle)}_getOptsFromHandle(){return{type:this.getParameter(35663),source:this.getSource()}}}class fd extends gd{constructor(t,e){"string"==typeof e&&(e={source:e}),super(t,Object.assign({},e,{shaderType:35633}))}_createHandle(){return this.gl.createShader(35633)}}class pd extends gd{constructor(t,e){"string"==typeof e&&(e={source:e}),super(t,Object.assign({},e,{shaderType:35632}))}_createHandle(){return this.gl.createShader(35632)}}const md={5126:[5126,1,"float"],35664:[5126,2,"vec2"],35665:[5126,3,"vec3"],35666:[5126,4,"vec4"],5124:[5124,1,"int"],35667:[5124,2,"ivec2"],35668:[5124,3,"ivec3"],35669:[5124,4,"ivec4"],5125:[5125,1,"uint"],36294:[5125,2,"uvec2"],36295:[5125,3,"uvec3"],36296:[5125,4,"uvec4"],35670:[5126,1,"bool"],35671:[5126,2,"bvec2"],35672:[5126,3,"bvec3"],35673:[5126,4,"bvec4"],35674:[5126,8,"mat2"],35685:[5126,8,"mat2x3"],35686:[5126,8,"mat2x4"],35675:[5126,12,"mat3"],35687:[5126,12,"mat3x2"],35688:[5126,12,"mat3x4"],35676:[5126,16,"mat4"],35689:[5126,16,"mat4x2"],35690:[5126,16,"mat4x3"]};function yd(t){switch(t){case 0:return 0;case 1:case 3:case 2:return 1;case 4:case 5:case 6:return 4;default:return $u(!1),0}}function bd(t){const e=md[t];if(!e)return null;const[i,n]=e;return{type:i,components:n}}function Pd(t,e){switch(t){case 5120:case 5121:case 5122:case 5123:t=5126}for(const i in md){const[n,r,s]=md[i];if(n===t&&r===e)return{glType:i,name:s}}return null}class vd{constructor(t){this.id=t.id,this.attributeInfos=[],this.attributeInfosByName={},this.attributeInfosByLocation=[],this.varyingInfos=[],this.varyingInfosByName={},Object.seal(this),this._readAttributesFromProgram(t),this._readVaryingsFromProgram(t)}getAttributeInfo(t){const e=Number(t);return Number.isFinite(e)?this.attributeInfosByLocation[e]:this.attributeInfosByName[t]||null}getAttributeLocation(t){const e=this.getAttributeInfo(t);return e?e.location:-1}getAttributeAccessor(t){const e=this.getAttributeInfo(t);return e?e.accessor:null}getVaryingInfo(t){const e=Number(t);return Number.isFinite(e)?this.varyingInfos[e]:this.varyingInfosByName[t]||null}getVaryingIndex(t){const e=this.getVaryingInfo();return e?e.location:-1}getVaryingAccessor(t){const e=this.getVaryingInfo();return e?e.accessor:null}_readAttributesFromProgram(t){const{gl:e}=t,i=e.getProgramParameter(t.handle,35721);for(let n=0;n<i;n++){const{name:i,type:r,size:s}=e.getActiveAttrib(t.handle,n),o=e.getAttribLocation(t.handle,i);o>=0&&this._addAttribute(o,i,r,s)}this.attributeInfos.sort((t,e)=>t.location-e.location)}_readVaryingsFromProgram(t){const{gl:e}=t;if(!Object(Du.e)(e))return;const i=e.getProgramParameter(t.handle,35971);for(let n=0;n<i;n++){const{name:i,type:r,size:s}=e.getTransformFeedbackVarying(t.handle,n);this._addVarying(n,i,r,s)}this.varyingInfos.sort((t,e)=>t.location-e.location)}_addAttribute(t,e,i,n){const{type:r,components:s}=bd(i),o={type:r,size:n*s};this._inferProperties(t,e,o);const a={location:t,name:e,accessor:new fc(o)};this.attributeInfos.push(a),this.attributeInfosByLocation[t]=a,this.attributeInfosByName[a.name]=a}_inferProperties(t,e,i){/instance/i.test(e)&&(i.divisor=1)}_addVarying(t,e,i,n){const{type:r,components:s}=bd(i),o={location:t,name:e,accessor:new fc({type:r,size:n*s})};this.varyingInfos.push(o),this.varyingInfosByName[o.name]=o}}const Sd=35981,Cd=["setVertexArray","setAttributes","setBuffers","unsetBuffers","use","getUniformCount","getUniformInfo","getUniformLocation","getUniformValue","getVarying","getFragDataLocation","getAttachedShaders","getAttributeCount","getAttributeLocation","getAttributeInfo"];class wd extends ac{constructor(t,e={}){super(t,e),this.stubRemovedMethods("Program","v6.0",Cd),this._isCached=!1,this.initialize(e),Object.seal(this),this._setId(e.id)}initialize(t={}){const{hash:e,vs:i,fs:n,varyings:r,bufferMode:s=Sd}=t;return this.hash=e||"",this.vs="string"==typeof i?new fd(this.gl,{id:t.id+"-vs",source:i}):i,this.fs="string"==typeof n?new pd(this.gl,{id:t.id+"-fs",source:n}):n,$u(this.vs instanceof fd),$u(this.fs instanceof pd),this.uniforms={},this._textureUniforms={},r&&r.length>0&&(Object(Du.a)(this.gl),this.varyings=r,this.gl2.transformFeedbackVaryings(this.handle,r,s)),this._compileAndLink(),this._readUniformLocationsFromLinkedProgram(),this.configuration=new vd(this),this.setProps(t)}delete(t={}){return this._isCached?this:super.delete(t)}setProps(t){return"uniforms"in t&&this.setUniforms(t.uniforms),this}draw({logPriority:t,drawMode:e=4,vertexCount:i,offset:n=0,start:r,end:s,isIndexed:o=!1,indexType:a=5123,instanceCount:l=0,isInstanced:h=l>0,vertexArray:u=null,transformFeedback:c,framebuffer:d,parameters:g={},uniforms:f,samplers:p}){if((f||p)&&(Fu.deprecated("Program.draw({uniforms})","Program.setUniforms(uniforms)")(),this.setUniforms(f||{})),Fu.priority>=t){const n=d?d.id:"default",r=`mode=${tc(this.gl,e)} verts=${i} instances=${l} indexType=${tc(this.gl,a)} isInstanced=${h} isIndexed=${o} Framebuffer=`+n;Fu.log(t,r)()}return $u(u),this.gl.useProgram(this.handle),!(!this._areTexturesRenderable()||0===i||h&&0===l)&&(u.bindForDraw(i,l,()=>{if(void 0!==d&&(g=Object.assign({},g,{framebuffer:d})),c){const t=yd(e);c.begin(t)}this._bindTextures(),Object(Nu.d)(this.gl,g,()=>{o&&h?this.gl2.drawElementsInstanced(e,i,a,n,l):o&&Object(Du.e)(this.gl)&&!isNaN(r)&&!isNaN(s)?this.gl2.drawRangeElements(e,r,s,i,a,n):o?this.gl.drawElements(e,i,a,n):h?this.gl2.drawArraysInstanced(e,n,i,l):this.gl.drawArrays(e,n,i)}),c&&c.end()}),!0)}setUniforms(t={}){Fu.priority>=2&&function(t,e,i){for(const n in t){const r=t[n];if((!i||Boolean(i[n]))&&!nd(r))throw e=e?e+" ":"",console.error(`${e} Bad uniform ${n}`,r),new Error(`${e} Bad uniform ${n}`)}}(t,this.id,this._uniformSetters),this.gl.useProgram(this.handle);for(const e in t){const i=t[e],n=this._uniformSetters[e];if(n){let t=i,r=!1;if(t instanceof Hc&&(t=t.texture),t instanceof Ec)if(r=this.uniforms[e]!==i,r){void 0===n.textureIndex&&(n.textureIndex=this._textureIndexCounter++);const i=t,{textureIndex:r}=n;i.bind(r),t=r,this._textureUniforms[e]=i}else t=n.textureIndex;else this._textureUniforms[e]&&delete this._textureUniforms[e];(n(t)||r)&&rd(this.uniforms,e,i)}}return this}_areTexturesRenderable(){let t=!0;for(const e in this._textureUniforms){const i=this._textureUniforms[e];i.update(),t=t&&i.loaded}return t}_bindTextures(){for(const t in this._textureUniforms){const e=this._uniformSetters[t].textureIndex;this._textureUniforms[t].bind(e)}}_createHandle(){return this.gl.createProgram()}_deleteHandle(){this.gl.deleteProgram(this.handle)}_getOptionsFromHandle(t){const e=this.gl.getAttachedShaders(t),i={};for(const t of e){switch(this.gl.getShaderParameter(this.handle,35663)){case 35633:i.vs=new fd({handle:t});break;case 35632:i.fs=new pd({handle:t})}}return i}_getParameter(t){return this.gl.getProgramParameter(this.handle,t)}_setId(t){if(!t){const t=this._getName();this.id=ic(t)}}_getName(){let t=this.vs.getName()||this.fs.getName();return t=t.replace(/shader/i,""),t=t?t+"-program":"program",t}_compileAndLink(){const{gl:t}=this;if(t.attachShader(this.handle,this.vs.handle),t.attachShader(this.handle,this.fs.handle),Fu.time(4,"linkProgram for "+this._getName())(),t.linkProgram(this.handle),Fu.timeEnd(4,"linkProgram for "+this._getName())(),t.debug||Fu.level>0){if(!t.getProgramParameter(this.handle,35714))throw new Error("Error linking: "+t.getProgramInfoLog(this.handle));t.validateProgram(this.handle);if(!t.getProgramParameter(this.handle,35715))throw new Error("Error validating: "+t.getProgramInfoLog(this.handle))}}_readUniformLocationsFromLinkedProgram(){const{gl:t}=this;this._uniformSetters={},this._uniformCount=this._getParameter(35718);for(let e=0;e<this._uniformCount;e++){const i=this.gl.getActiveUniform(this.handle,e),{name:n}=id(i.name);let r=t.getUniformLocation(this.handle,n);if(this._uniformSetters[n]=ed(t,r,i),i.size>1)for(let e=0;e<i.size;e++)r=t.getUniformLocation(this.handle,`${n}[${e}]`),this._uniformSetters[`${n}[${e}]`]=ed(t,r,i)}this._textureIndexCounter=0}getActiveUniforms(t,e){return this.gl2.getActiveUniforms(this.handle,t,e)}getUniformBlockIndex(t){return this.gl2.getUniformBlockIndex(this.handle,t)}getActiveUniformBlockParameter(t,e){return this.gl2.getActiveUniformBlockParameter(this.handle,t,e)}uniformBlockBinding(t,e){this.gl2.uniformBlockBinding(this.handle,t,e)}}class Ed{static getDefaultProgramManager(t){return t.luma=t.luma||{},t.luma.defaultProgramManager=t.luma.defaultProgramManager||new Ed(t),t.luma.defaultProgramManager}constructor(t){this.gl=t,this._programCache={},this._getUniforms={},this._registeredModules={},this._hookFunctions=[],this._defaultModules=[],this._hashes={},this._hashCounter=0,this.stateHash=0,this._useCounts={}}addDefaultModule(t){this._defaultModules.find(e=>e.name===t.name)||this._defaultModules.push(t),this.stateHash++}removeDefaultModule(t){const e="string"==typeof t?t:t.name;this._defaultModules=this._defaultModules.filter(t=>t.name!==e),this.stateHash++}addShaderHook(t,e){e&&(t=Object.assign(e,{hook:t})),this._hookFunctions.push(t),this.stateHash++}get(t={}){const{vs:e="",fs:i="",defines:n={},inject:r={},varyings:s=[],bufferMode:o=35981,transpileToGLSL100:a=!1}=t,l=this._getModuleList(t.modules),h=this._getHash(e),u=this._getHash(i),c=l.map(t=>this._getHash(t.name)).sort(),d=s.map(t=>this._getHash(t)),g=Object.keys(n).sort(),f=Object.keys(r).sort(),p=[],m=[];for(const t of g)p.push(this._getHash(t)),p.push(this._getHash(n[t]));for(const t of f)m.push(this._getHash(t)),m.push(this._getHash(r[t]));const y=`${h}/${u}D${p.join("/")}M${c.join("/")}I${m.join("/")}V${d.join("/")}H${this.stateHash}B${o}${a?"T":""}`;if(!this._programCache[y]){const t=function(t,e){const{vs:i,fs:n}=e,r=ou(e.modules||[]);return{gl:t,vs:Bu(t,Object.assign({},e,{source:i,type:"vs",modules:r})),fs:Bu(t,Object.assign({},e,{source:n,type:"fs",modules:r})),getUniforms:Mu(r)}}(this.gl,{vs:e,fs:i,modules:l,inject:r,defines:n,hookFunctions:this._hookFunctions,transpileToGLSL100:a});this._programCache[y]=new wd(this.gl,{hash:y,vs:t.vs,fs:t.fs,varyings:s,bufferMode:o}),this._getUniforms[y]=t.getUniforms||(t=>{}),this._useCounts[y]=0}return this._useCounts[y]++,this._programCache[y]}getUniforms(t){return this._getUniforms[t.hash]||null}release(t){const e=t.hash;this._useCounts[e]--,0===this._useCounts[e]&&(this._programCache[e].delete(),delete this._programCache[e],delete this._getUniforms[e],delete this._useCounts[e])}_getHash(t){return void 0===this._hashes[t]&&(this._hashes[t]=this._hashCounter++),this._hashes[t]}_getModuleList(t=[]){const e=new Array(this._defaultModules.length+t.length),i={};let n=0;for(let t=0,r=this._defaultModules.length;t<r;++t){const r=this._defaultModules[t],s=r.name;e[n++]=r,i[s]=!0}for(let r=0,s=t.length;r<s;++r){const s=t[r],o=s.name;i[o]||(e[n++]=s,i[o]=!0)}return e.length=n,e}}const xd={name:"fp32",vs:"#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n",fs:null};var Ad={name:"geometry",vs:"\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n",fs:"\n#define SMOOTH_EDGE_RADIUS 0.5\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n"};const Td=Object.keys(Wh).map(t=>"const int COORDINATE_SYSTEM_".concat(t," = ").concat(Wh[t],";")).join(""),Id=Object.keys(Hh).map(t=>"const int PROJECTION_MODE_".concat(t," = ").concat(Hh[t],";")).join(""),Od=Object.keys(qh).map(t=>"const int UNIT_".concat(t.toUpperCase()," = ").concat(qh[t],";")).join("");var _d="".concat(Td,"\n").concat(Id,"\n").concat(Od,"\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      float y = clamp(geometry.worldPosition.y, -89.9, 89.9);\n      return 1.0 / cos(radians(y));\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size(position_world.z),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n");function Ld(t,e,i){var n=e[0],r=e[1],s=e[2],o=e[3];return t[0]=i[0]*n+i[4]*r+i[8]*s+i[12]*o,t[1]=i[1]*n+i[5]*r+i[9]*s+i[13]*o,t[2]=i[2]*n+i[6]*r+i[10]*s+i[14]*o,t[3]=i[3]*n+i[7]*r+i[11]*s+i[15]*o,t}var Rd,Bd;Rd=new gh(4),gh!=Float32Array&&(Rd[0]=0,Rd[1]=0,Rd[2]=0,Rd[3]=0),Bd=Rd;function Md(t,e){if(t===e)return!0;if(Array.isArray(t)){const i=t.length;if(!e||e.length!==i)return!1;for(let n=0;n<i;n++)if(t[n]!==e[n])return!1;return!0}return!1}function Fd(t){let e,i={};return n=>{for(const r in n)if(!Md(n[r],i[r])){e=t(n),i=n;break}return e}}const Dd=[0,0,0,0],Nd=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0],kd=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],Vd=[0,0,0],Gd=[0,0,0],zd=Fd((function({viewport:t,devicePixelRatio:e,coordinateSystem:i,coordinateOrigin:n}){const{projectionCenter:r,viewProjectionMatrix:s,originCommon:o,cameraPosCommon:a,shaderCoordinateOrigin:l,geospatialOrigin:h}=function(t,e,i){const{viewMatrixUncentered:n,projectionMatrix:r}=t;let{viewMatrix:s,viewProjectionMatrix:o}=t,a=Dd,l=Dd,h=t.cameraPosition;const{geospatialOrigin:u,shaderCoordinateOrigin:c,offsetMode:d}=jd(t,e,i);d&&(l=t.projectPosition(u||c),h=[h[0]-l[0],h[1]-l[1],h[2]-l[2]],l[3]=1,a=Ld([],l,o),s=n||s,o=ph([],r,s),o=ph([],o,Nd));return{viewMatrix:s,viewProjectionMatrix:o,projectionCenter:a,originCommon:l,cameraPosCommon:h,shaderCoordinateOrigin:c,geospatialOrigin:u}}(t,i,n),u=t.getDistanceScales(),c=[t.width*e,t.height*e],d=Ld([],[0,0,-t.focalDistance,1],t.projectionMatrix)[3]||1,g={project_uCoordinateSystem:i,project_uProjectionMode:t.projectionMode,project_uCoordinateOrigin:l,project_uCommonOrigin:o.slice(0,3),project_uCenter:r,project_uPseudoMeters:Boolean(t._pseudoMeters),project_uViewportSize:c,project_uDevicePixelRatio:e,project_uFocalDistance:d,project_uCommonUnitsPerMeter:u.unitsPerMeter,project_uCommonUnitsPerWorldUnit:u.unitsPerMeter,project_uCommonUnitsPerWorldUnit2:Vd,project_uScale:t.scale,project_uViewProjectionMatrix:s,project_uCameraPosition:a};if(h){const e=t.getDistanceScales(h);switch(i){case Wh.METER_OFFSETS:g.project_uCommonUnitsPerWorldUnit=e.unitsPerMeter,g.project_uCommonUnitsPerWorldUnit2=e.unitsPerMeter2;break;case Wh.LNGLAT:case Wh.LNGLAT_OFFSETS:t._pseudoMeters||(g.project_uCommonUnitsPerMeter=e.unitsPerMeter),g.project_uCommonUnitsPerWorldUnit=e.unitsPerDegree,g.project_uCommonUnitsPerWorldUnit2=e.unitsPerDegree2;break;case Wh.CARTESIAN:g.project_uCommonUnitsPerWorldUnit=[1,1,e.unitsPerMeter[2]],g.project_uCommonUnitsPerWorldUnit2=[0,0,e.unitsPerMeter2[2]]}}return g}));function jd(t,e,i=Gd){i.length<3&&(i=[i[0],i[1],0]);let n,r=i,s=!0;switch(n=e===Wh.LNGLAT_OFFSETS||e===Wh.METER_OFFSETS?i:t.isGeospatial?[Math.fround(t.longitude),Math.fround(t.latitude),0]:null,t.projectionMode){case Hh.WEB_MERCATOR:e!==Wh.LNGLAT&&e!==Wh.CARTESIAN||(n=[0,0,0],s=!1);break;case Hh.WEB_MERCATOR_AUTO_OFFSET:e===Wh.LNGLAT?r=n:e===Wh.CARTESIAN&&(r=[Math.fround(t.center[0]),Math.fround(t.center[1]),0],n=t.unprojectPosition(r),r[0]-=i[0],r[1]-=i[1],r[2]-=i[2]);break;case Hh.IDENTITY:r=t.position.map(Math.fround),r[2]=r[2]||0;break;case Hh.GLOBE:s=!1,n=null;break;default:s=!1}return{geospatialOrigin:n,shaderCoordinateOrigin:r,offsetMode:s}}const Ud={};var Wd={name:"project",dependencies:[xd,Ad],vs:_d,getUniforms:function(t=Ud){return t.viewport?function({viewport:t,devicePixelRatio:e=1,modelMatrix:i=null,coordinateSystem:n=Wh.DEFAULT,coordinateOrigin:r,autoWrapLongitude:s=!1}={}){n===Wh.DEFAULT&&(n=t.isGeospatial?Wh.LNGLAT:Wh.CARTESIAN);const o=zd({viewport:t,devicePixelRatio:e,coordinateSystem:n,coordinateOrigin:r});return o.project_uWrapLongitude=s,o.project_uModelMatrix=i||kd,o}(t):{}}};const Hd=[Wd],qd=["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)","vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)","vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)","fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];function Xd(t){const e=Ed.getDefaultProgramManager(t);for(const t of Hd)e.addDefaultModule(t);for(const t of qd)e.addShaderHook(t);return e}const Yd=Object.seal({layerManager:null,resourceManager:null,deck:null,gl:null,stats:null,shaderCache:null,pickingFBO:null,mousePosition:null,userData:{}});class Qd{constructor(t,{deck:e,stats:i,viewport:n,timeline:r}={}){this.lastRenderedLayers=[],this.layers=[],this.resourceManager=new nh({gl:t,protocol:"deck://"}),this.context={...Yd,layerManager:this,gl:t,deck:e,programManager:t&&Xd(t),stats:i||new Ma({id:"deck.gl"}),viewport:n||new tu({id:"DEFAULT-INITIAL-VIEWPORT"}),timeline:r||new Ko,resourceManager:this.resourceManager},this._nextLayers=null,this._needsRedraw="Initial render",this._needsUpdate=!1,this._debug=!1,this.activateViewport=this.activateViewport.bind(this),Object.seal(this)}finalize(){this.resourceManager.finalize();for(const t of this.layers)this._finalizeLayer(t)}needsRedraw(t={clearRedrawFlags:!1}){let e=this._needsRedraw;t.clearRedrawFlags&&(this._needsRedraw=!1);for(const i of this.layers){const n=i.getNeedsRedraw(t);e=e||n}return e}needsUpdate(){return this._nextLayers&&this._nextLayers!==this.lastRenderedLayers?"layers changed":this._needsUpdate}setNeedsRedraw(t){this._needsRedraw=this._needsRedraw||t}setNeedsUpdate(t){this._needsUpdate=this._needsUpdate||t}getLayers({layerIds:t=null}={}){return t?this.layers.filter(e=>t.find(t=>0===e.id.indexOf(t))):this.layers}setProps(t){"debug"in t&&(this._debug=t.debug),"userData"in t&&(this.context.userData=t.userData),"layers"in t&&(this._nextLayers=t.layers),"onError"in t&&(this.context.onError=t.onError)}setLayers(t,e){Oa("layerManager.setLayers",this,e,t),this.lastRenderedLayers=t,t=_a(t,Boolean);for(const e of t)e.context=this.context;return this._updateLayers(this.layers,t),this}updateLayers(){const t=this.needsUpdate();t&&(this.setNeedsRedraw("updating layers: ".concat(t)),this.setLayers(this._nextLayers||this.lastRenderedLayers,t)),this._nextLayers=null}activateViewport(t){return Oa("layerManager.activateViewport",this,t),t&&(this.context.viewport=t),this}_handleError(t,e,i){i.raiseError(e,"".concat(t," of ").concat(i))}_updateLayers(t,e){const i={};for(const e of t)i[e.id]?Ta.warn("Multiple old layers with same id ".concat(e.id))():i[e.id]=e;const n=[];this._updateSublayersRecursively(e,i,n),this._finalizeOldLayers(i);let r=!1;for(const t of n)if(t.hasUniformTransition()){r=!0;break}this._needsUpdate=r,this.layers=n}_updateSublayersRecursively(t,e,i){for(const n of t){n.context=this.context;const t=e[n.id];null===t&&Ta.warn("Multiple new layers with same id ".concat(n.id))(),e[n.id]=null;let r=null;try{this._debug&&t!==n&&n.validateProps(),t?(this._transferLayerState(t,n),this._updateLayer(n)):this._initializeLayer(n),i.push(n),r=n.isComposite&&n.getSubLayers()}catch(t){this._handleError("matching",t,n)}r&&this._updateSublayersRecursively(r,e,i)}}_finalizeOldLayers(t){for(const e in t){const i=t[e];i&&this._finalizeLayer(i)}}_initializeLayer(t){try{t._initialize(),t.lifecycle=ta}catch(e){this._handleError("initialization",e,t)}}_transferLayerState(t,e){e._transferState(t),e.lifecycle=Jo,e!==t&&(t.lifecycle=ea)}_updateLayer(t){try{t._update()}catch(e){this._handleError("update",e,t)}}_finalizeLayer(t){this._needsRedraw=this._needsRedraw||"finalized ".concat(t),t.lifecycle=ia;try{t._finalize(),t.lifecycle=na}catch(e){this._handleError("finalization",e,t)}}}function Zd(t,e){if(t===e)return!0;if(!t||!e)return!1;for(const i in t){const n=t[i],r=e[i];if(!(n===r||Array.isArray(n)&&Array.isArray(r)&&Zd(n,r)))return!1}return!0}class Kd{constructor(t={}){this.views=[],this.width=100,this.height=100,this.viewState={},this.controllers={},this.timeline=t.timeline,this._viewports=[],this._viewportMap={},this._isUpdating=!1,this._needsRedraw="Initial render",this._needsUpdate=!0,this._eventManager=t.eventManager,this._eventCallbacks={onViewStateChange:t.onViewStateChange,onInteractionStateChange:t.onInteractionStateChange},Object.seal(this),this.setProps(t)}finalize(){for(const t in this.controllers)this.controllers[t]&&this.controllers[t].finalize();this.controllers={}}needsRedraw(t={clearRedrawFlags:!1}){const e=this._needsRedraw;return t.clearRedrawFlags&&(this._needsRedraw=!1),e}setNeedsUpdate(t){this._needsUpdate=this._needsUpdate||t,this._needsRedraw=this._needsRedraw||t}updateViewStates(){for(const t in this.controllers){const e=this.controllers[t];e&&e.updateTransition()}}getViewports(t){return t?this._viewports.filter(e=>e.containsPixel(t)):this._viewports}getViews(){const t={};return this.views.forEach(e=>{t[e.id]=e}),t}getView(t){return"string"==typeof t?this.views.find(e=>e.id===t):t}getViewState(t){const e=this.getView(t),i=e&&this.viewState[e.getViewStateId()]||this.viewState;return e?e.filterViewState(i):i}getViewport(t){return this._viewportMap[t]}unproject(t,e){const i=this.getViewports(),n={x:t[0],y:t[1]};for(let r=i.length-1;r>=0;--r){const s=i[r];if(s.containsPixel(n)){const i=t.slice();return i[0]-=s.x,i[1]-=s.y,s.unproject(i,e)}}return null}setProps(t){"views"in t&&this._setViews(t.views),"viewState"in t&&this._setViewState(t.viewState),("width"in t||"height"in t)&&this._setSize(t.width,t.height),this._isUpdating||this._update()}_update(){this._isUpdating=!0,this._needsUpdate&&(this._needsUpdate=!1,this._rebuildViewports()),this._needsUpdate&&(this._needsUpdate=!1,this._rebuildViewports()),this._isUpdating=!1}_setSize(t,e){t===this.width&&e===this.height||(this.width=t,this.height=e,this.setNeedsUpdate("Size changed"))}_setViews(t){t=_a(t,Boolean);this._diffViews(t,this.views)&&this.setNeedsUpdate("views changed"),this.views=t}_setViewState(t){if(t){!Zd(t,this.viewState)&&this.setNeedsUpdate("viewState changed"),this.viewState=t}else Ta.warn("missing `viewState` or `initialViewState`")()}_onViewStateChange(t,e){e.viewId=t,this._eventCallbacks.onViewStateChange&&this._eventCallbacks.onViewStateChange(e)}_createController(t,e){return new(0,e.type)({timeline:this.timeline,eventManager:this._eventManager,onViewStateChange:this._onViewStateChange.bind(this,e.id),onStateChange:this._eventCallbacks.onInteractionStateChange,makeViewport:e=>t._getViewport(e,{width:e.width,height:e.height}),...e})}_updateController(t,e,i,n){let r=t.controller;return r?(r={...e,...t.props,...r,id:t.id,x:i.x,y:i.y,width:i.width,height:i.height},n?n.setProps(r):n=this._createController(t,r),n):null}_rebuildViewports(){const{width:t,height:e,views:i}=this,n=this.controllers;this._viewports=[],this.controllers={};let r=!1;for(let s=i.length;s--;){const o=i[s],a=this.getViewState(o),l=o.makeViewport({width:t,height:e,viewState:a});let h=n[o.id];o.controller&&!h&&(r=!0),!r&&o.controller||!h||(h.finalize(),h=null),this.controllers[o.id]=this._updateController(o,a,l,h),this._viewports.unshift(l)}for(const t in n)n[t]&&!this.controllers[t]&&n[t].finalize();this._buildViewportMap()}_buildViewportMap(){this._viewportMap={},this._viewports.forEach(t=>{t.id&&(this._viewportMap[t.id]=this._viewportMap[t.id]||t)})}_diffViews(t,e){return t.length!==e.length||t.some((i,n)=>!t[n].equals(e[n]))}}const $d=/([0-9]+\.?[0-9]*)(%|px)/;function Jd(t){switch(typeof t){case"number":return{position:t,relative:!1};case"string":const e=$d.exec(t);if(e&&e.length>=3){const t="%"===e[2],i=parseFloat(e[1]);return{position:t?i/100:i,relative:t}}default:throw new Error("Could not parse position string ".concat(t))}}function tg(t,e){return t.relative?Math.round(t.position*e):t.position}function eg(t,e){if(!t)throw new Error(e||"deck.gl: assertion failed.")}class ig{constructor(t={}){const{id:e=null,x:i=0,y:n=0,width:r="100%",height:s="100%",viewportInstance:o,type:a=tu}=t;eg(!o||o instanceof tu),this.viewportInstance=o,this.id=e||this.constructor.displayName||"view",this.type=a,this.props={...t,id:this.id},this._parseDimensions({x:i,y:n,width:r,height:s}),this.equals=this.equals.bind(this),Object.seal(this)}equals(t){if(this===t)return!0;if(this.viewportInstance)return t.viewportInstance&&this.viewportInstance.equals(t.viewportInstance);return Zd(this.props,t.props)}makeViewport({width:t,height:e,viewState:i}){if(this.viewportInstance)return this.viewportInstance;i=this.filterViewState(i);const n=this.getDimensions({width:t,height:e});return this._getViewport(i,n)}getViewStateId(){switch(typeof this.props.viewState){case"string":return this.props.viewState;case"object":return this.props.viewState&&this.props.viewState.id;default:return this.id}}filterViewState(t){if(this.props.viewState&&"object"==typeof this.props.viewState){if(!this.props.viewState.id)return this.props.viewState;const e={...t};for(const t in this.props.viewState)"id"!==t&&(e[t]=this.props.viewState[t]);return e}return t}getDimensions({width:t,height:e}){return{x:tg(this._x,t),y:tg(this._y,e),width:tg(this._width,t),height:tg(this._height,e)}}_getControllerProps(t){let e=this.props.controller;return e?!0===e?t:("function"==typeof e&&(e={type:e}),{...t,...e}):null}_getViewport(t,e){const{type:i}=this;return new i({...t,...this.props,...e})}_parseDimensions({x:t,y:e,width:i,height:n}){this._x=Jd(t),this._y=Jd(e),this._width=Jd(i),this._height=Jd(n)}}function ng(t,e,i){return t[0]=e[0]+i[0],t[1]=e[1]+i[1],t}function rg(t,e){return t[0]=-e[0],t[1]=-e[1],t}!function(){var t=function(){var t=new gh(2);return gh!=Float32Array&&(t[0]=0,t[1]=0),t}()}();const sg=Math.PI/180;function og(t){return 512/4003e4/Math.cos(t*sg)}class ag extends tu{constructor(t={}){const{latitude:e=0,longitude:i=0,zoom:n=11,pitch:r=0,bearing:s=0,nearZMultiplier:o=.1,farZMultiplier:a=1.01,orthographic:l=!1,projectionMatrix:h,repeat:u=!1,worldOffset:c=0,legacyMeterSizes:d=!1}=t;let{width:g,height:f,altitude:p=1.5}=t;const m=Math.pow(2,n);let y;g=g||1,f=f||1;let b=null;h?(p=h[5]/2,y=Dh(p)):(t.fovy?(y=t.fovy,p=Nh(y)):y=Dh(p),b=Fh({width:g,height:f,pitch:r,fovy:y,nearZMultiplier:o,farZMultiplier:a}));let P=Mh({height:f,pitch:r,bearing:s,scale:m,altitude:p});if(c){P=(new ch.a).translate([512*c,0,0]).multiplyLeft(P)}super({...t,width:g,height:f,viewMatrix:P,longitude:i,latitude:e,zoom:n,...b,fovy:y,focalDistance:p}),this.latitude=e,this.longitude=i,this.zoom=n,this.pitch=r,this.bearing=s,this.altitude=p,this.fovy=y,this.orthographic=l,this._subViewports=u?[]:null,this._pseudoMeters=d,Object.freeze(this)}get subViewports(){if(this._subViewports&&!this._subViewports.length){const t=this.getBounds(),e=Math.floor((t[0]+180)/360),i=Math.ceil((t[2]-180)/360);for(let t=e;t<=i;t++){const e=t?new ag({...this,worldOffset:t}):this;this._subViewports.push(e)}}return this._subViewports}projectPosition(t){if(this._pseudoMeters)return super.projectPosition(t);const[e,i]=this.projectFlat(t);return[e,i,(t[2]||0)*og(t[1])]}unprojectPosition(t){if(this._pseudoMeters)return super.unprojectPosition(t);const[e,i]=this.unprojectFlat(t);return[e,i,(t[2]||0)/og(i)]}addMetersToLngLat(t,e){return Bh(t,e)}panByPosition(t,e){const i=Vh(e,this.pixelUnprojectionMatrix),n=ng([],this.projectFlat(t),rg([],i)),r=ng([],this.center,n),[s,o]=this.unprojectFlat(r);return{longitude:s,latitude:o}}getBounds(t={}){const e=jh(this,t.z||0);return[Math.min(e[0][0],e[1][0],e[2][0],e[3][0]),Math.min(e[0][1],e[1][1],e[2][1],e[3][1]),Math.max(e[0][0],e[1][0],e[2][0],e[3][0]),Math.max(e[0][1],e[1][1],e[2][1],e[3][1])]}fitBounds(t,e={}){const{width:i,height:n}=this,{longitude:r,latitude:s,zoom:o}=Gh({width:i,height:n,bounds:t,...e});return new ag({width:i,height:n,longitude:r,latitude:s,zoom:o})}}function lg(){}ag.displayName="WebMercatorViewport";const hg={onStart:lg,onUpdate:lg,onInterrupt:lg,onEnd:lg};class ug{constructor(t){this._inProgress=!1,this._handle=null,this.timeline=t,this.settings={}}get inProgress(){return this._inProgress}start(t){this.cancel(),this.settings={...hg,...t},this._inProgress=!0,this.settings.onStart(this)}end(){this._inProgress&&(this.timeline.removeChannel(this._handle),this._handle=null,this._inProgress=!1,this.settings.onEnd(this))}cancel(){this._inProgress&&(this.settings.onInterrupt(this),this.timeline.removeChannel(this._handle),this._handle=null,this._inProgress=!1)}update(){if(!this._inProgress)return!1;if(null===this._handle){const{timeline:t,settings:e}=this;this._handle=t.addChannel({delay:t.getTime(),duration:e.duration})}return this.time=this.timeline.getTime(this._handle),this._onUpdate(),this.settings.onUpdate(this),this.timeline.isFinished(this._handle)&&this.end(),!0}_onUpdate(){}}const cg=()=>{},dg=1,gg=2,fg=3,pg={transitionEasing:t=>t,transitionInterruption:dg,onTransitionStart:cg,onTransitionInterrupt:cg,onTransitionEnd:cg};class mg{constructor(t,e={}){this.ControllerState=t,this.props={...pg,...e},this.propsInTransition=null,this.transition=new ug(e.timeline),this.onViewStateChange=e.onViewStateChange||cg,this.onStateChange=e.onStateChange||cg,this._onTransitionUpdate=this._onTransitionUpdate.bind(this)}finalize(){this.transition.cancel()}getViewportInTransition(){return this.propsInTransition}processViewStateChange(t){let e=!1;const i=this.props;if(t={...pg,...t},this.props=t,this._shouldIgnoreViewportChange(i,t))return e;if(this._isTransitionEnabled(t)){const{interruption:n,endProps:r}=this.transition.settings,s={...i,...n===gg?r:this.propsInTransition||i};this._triggerTransition(s,t),e=!0}else this.transition.cancel();return e}updateTransition(){this.transition.update()}_isTransitionEnabled(t){const{transitionDuration:e,transitionInterpolator:i}=t;return(e>0||"auto"===e)&&Boolean(i)}_isUpdateDueToCurrentTransition(t){return!!this.transition.inProgress&&this.transition.settings.interpolator.arePropsEqual(t,this.propsInTransition)}_shouldIgnoreViewportChange(t,e){return this.transition.inProgress?this.transition.settings.interruption===fg||this._isUpdateDueToCurrentTransition(e):!this._isTransitionEnabled(e)||e.transitionInterpolator.arePropsEqual(t,e)}_triggerTransition(t,e){const i=new this.ControllerState(t),n=new this.ControllerState(e).shortestPathFrom(i),{transitionInterpolator:r}=e,s=r.getDuration?r.getDuration(t,e):e.transitionDuration;if(0===s)return;const o=e.transitionInterpolator.initializeProps(t,n);this.propsInTransition={},this.duration=s,this.transition.start({duration:s,easing:e.transitionEasing,interpolator:e.transitionInterpolator,interruption:e.transitionInterruption,startProps:o.start,endProps:o.end,onStart:e.onTransitionStart,onUpdate:this._onTransitionUpdate,onInterrupt:this._onTransitionEnd(e.onTransitionInterrupt),onEnd:this._onTransitionEnd(e.onTransitionEnd)}),this.onStateChange({inTransition:!0}),this.updateTransition()}_onTransitionEnd(t){return e=>{this.propsInTransition=null,this.onStateChange({inTransition:!1,isZooming:!1,isPanning:!1,isRotating:!1}),t(e)}}_onTransitionUpdate(t){const{time:e,settings:{interpolator:i,startProps:n,endProps:r,duration:s,easing:o}}=t,a=o(e/s),l=i.interpolateProps(n,r,a);this.propsInTransition=new this.ControllerState({...this.props,...l}).getViewportProps(),this.onViewStateChange({viewState:this.propsInTransition,oldViewState:this.props})}}const yg=["longitude","latitude","zoom","bearing","pitch"],bg=["longitude","latitude","zoom"];class Pg extends class{constructor(t={}){Array.isArray(t)&&(t={compare:t,extract:t,required:t});const{compare:e,extract:i,required:n}=t;this._propsToCompare=e,this._propsToExtract=i,this._requiredProps=n}arePropsEqual(t,e){for(const i of this._propsToCompare||Object.keys(e))if(!(i in t)||!(i in e)||!Object(uh.c)(t[i],e[i]))return!1;return!0}initializeProps(t,e){let i;if(this._propsToExtract){const n={},r={};for(const i of this._propsToExtract)n[i]=t[i],r[i]=e[i];i={start:n,end:r}}else i={start:t,end:e};return this._checkRequiredProps(i.start),this._checkRequiredProps(i.end),i}interpolateProps(t,e,i){return e}getDuration(t,e){return e.transitionDuration}_checkRequiredProps(t){this._requiredProps&&this._requiredProps.forEach(e=>{const i=t[e];eg(Number.isFinite(i)||Array.isArray(i),"".concat(e," is required for transition"))})}}{constructor(t={}){super((Array.isArray(t)?t:t.transitionProps)||{compare:yg,extract:yg,required:bg}),this.opts=t}initializeProps(t,e){const i=super.initializeProps(t,e),{makeViewport:n,around:r}=this.opts;if(n&&r){const s=n(t),o=n(e),a=s.unproject(r);i.start.around=r,Object.assign(i.end,{around:o.project(a),aroundPosition:a,width:e.width,height:e.height})}return i}interpolateProps(t,e,i){const n={};for(const r of this._propsToExtract)n[r]=Object(uh.f)(t[r]||0,e[r]||0,i);if(e.aroundPosition){const r=this.opts.makeViewport({...e,...n});Object.assign(n,r.panByPosition(e.aroundPosition,Object(uh.f)(t.around,e.around,i)))}return n}}const vg={transitionDuration:0},Sg={transitionDuration:300,transitionEasing:t=>t,transitionInterruption:dg},Cg=t=>1-(1-t)*(1-t),wg=["wheel"],Eg=["panstart","panmove","panend"],xg=["pinchstart","pinchmove","pinchend"],Ag=["tripanstart","tripanmove","tripanend"],Tg=["doubletap"],Ig=["keydown"];class Og{constructor(t,e={}){la(this,"ControllerState",void 0),la(this,"controllerState",null),la(this,"controllerStateProps",null),la(this,"transitionManager",void 0),la(this,"_transition",void 0),la(this,"_events",null),la(this,"eventManager",null),la(this,"_interactionState",{isDragging:!1}),la(this,"_customEvents",[]),la(this,"onViewStateChange",null),la(this,"onStateChange",null),la(this,"makeViewport",void 0),la(this,"_eventStartBlocked",void 0),la(this,"_state",void 0),la(this,"_panMove",void 0),la(this,"invertPan",void 0),la(this,"dragMode","rotate"),la(this,"inertia",0),la(this,"scrollZoom",!0),la(this,"dragPan",!0),la(this,"dragRotate",!0),la(this,"doubleClickZoom",!0),la(this,"touchZoom",!0),la(this,"touchRotate",!1),la(this,"keyboard",!0),this.ControllerState=t,this.transitionManager=new mg(t,{...e,onViewStateChange:this._onTransition.bind(this),onStateChange:this._setInteractionState.bind(this)});const i=this.linearTransitionProps;this._transition=i&&{...Sg,transitionInterpolator:new Pg({transitionProps:i})},this.handleEvent=this.handleEvent.bind(this),this.setProps(e)}get linearTransitionProps(){return null}set events(t){this.toggleEvents(this._customEvents,!1),this.toggleEvents(t,!0),this._customEvents=t,this.setProps(this.controllerStateProps)}finalize(){for(const t in this._events)this._events[t]&&this.eventManager.off(t,this.handleEvent);this.transitionManager.finalize()}handleEvent(t){const{ControllerState:e}=this;this.controllerState=new e({makeViewport:this.makeViewport,...this.controllerStateProps,...this._state});const i=this._eventStartBlocked;switch(t.type){case"panstart":return!i&&this._onPanStart(t);case"panmove":return this._onPan(t);case"panend":return this._onPanEnd(t);case"pinchstart":return!i&&this._onPinchStart(t);case"pinchmove":return this._onPinch(t);case"pinchend":return this._onPinchEnd(t);case"tripanstart":return!i&&this._onTriplePanStart(t);case"tripanmove":return this._onTriplePan(t);case"tripanend":return this._onTriplePanEnd(t);case"doubletap":return this._onDoubleTap(t);case"wheel":return this._onWheel(t);case"keydown":return this._onKeyDown(t);default:return!1}}getCenter(t){const{x:e,y:i}=this.controllerStateProps,{offsetCenter:n}=t;return[n.x-e,n.y-i]}isPointInBounds(t,e){const{width:i,height:n}=this.controllerStateProps;if(e&&e.handled)return!1;const r=t[0]>=0&&t[0]<=i&&t[1]>=0&&t[1]<=n;return r&&e&&e.stopPropagation(),r}isFunctionKeyPressed(t){const{srcEvent:e}=t;return Boolean(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}isDragging(){return this._interactionState.isDragging}blockEvents(t){const e=setTimeout(()=>{this._eventStartBlocked===e&&(this._eventStartBlocked=null)},t);this._eventStartBlocked=e}setProps(t){"onViewStateChange"in t&&(this.onViewStateChange=t.onViewStateChange),"onStateChange"in t&&(this.onStateChange=t.onStateChange),"makeViewport"in t&&(this.makeViewport=t.makeViewport),"dragMode"in t&&(this.dragMode=t.dragMode),this.controllerStateProps=t,"eventManager"in t&&this.eventManager!==t.eventManager&&(this.eventManager=t.eventManager,this._events={},this.toggleEvents(this._customEvents,!0)),"transitionInterpolator"in t||(t.transitionInterpolator=this._getTransitionProps().transitionInterpolator),this.transitionManager.processViewStateChange(t);let{inertia:e}=t;!0===e&&(e=300),this.inertia=e;const{scrollZoom:i=!0,dragPan:n=!0,dragRotate:r=!0,doubleClickZoom:s=!0,touchZoom:o=!0,touchRotate:a=!1,keyboard:l=!0}=t,h=Boolean(this.onViewStateChange);this.toggleEvents(wg,h&&i),this.toggleEvents(Eg,h&&(n||r)),this.toggleEvents(xg,h&&(o||a)),this.toggleEvents(Ag,h&&a),this.toggleEvents(Tg,h&&s),this.toggleEvents(Ig,h&&l),this.scrollZoom=i,this.dragPan=n,this.dragRotate=r,this.doubleClickZoom=s,this.touchZoom=o,this.touchRotate=a,this.keyboard=l}updateTransition(){this.transitionManager.updateTransition()}toggleEvents(t,e){this.eventManager&&t.forEach(t=>{this._events[t]!==e&&(this._events[t]=e,e?this.eventManager.on(t,this.handleEvent):this.eventManager.off(t,this.handleEvent))})}updateViewport(t,e={},i={}){const n={...t.getViewportProps(),...e},r=this.controllerState!==t;if(this._state=t.getState(),this._setInteractionState(i),r){const t=this.controllerState?this.controllerState.getViewportProps():null;this.onViewStateChange&&this.onViewStateChange({viewState:n,interactionState:this._interactionState,oldViewState:t})}}_onTransition(t){this.onViewStateChange&&(t.interactionState=this._interactionState,this.onViewStateChange(t))}_setInteractionState(t){Object.assign(this._interactionState,t),this.onStateChange&&this.onStateChange(this._interactionState)}_onPanStart(t){const e=this.getCenter(t);if(!this.isPointInBounds(e,t))return!1;let i=this.isFunctionKeyPressed(t)||t.rightButton;(this.invertPan||"pan"===this.dragMode)&&(i=!i);const n=this.controllerState[i?"panStart":"rotateStart"]({pos:e});return this._panMove=i,this.updateViewport(n,vg,{isDragging:!0}),!0}_onPan(t){return!!this.isDragging()&&(this._panMove?this._onPanMove(t):this._onPanRotate(t))}_onPanEnd(t){return!!this.isDragging()&&(this._panMove?this._onPanMoveEnd(t):this._onPanRotateEnd(t))}_onPanMove(t){if(!this.dragPan)return!1;const e=this.getCenter(t),i=this.controllerState.pan({pos:e});return this.updateViewport(i,vg,{isDragging:!0,isPanning:!0}),!0}_onPanMoveEnd(t){const{inertia:e}=this;if(this.dragPan&&e&&t.velocity){const i=this.getCenter(t),n=[i[0]+t.velocityX*e/2,i[1]+t.velocityY*e/2],r=this.controllerState.pan({pos:n}).panEnd();this.updateViewport(r,{...this._getTransitionProps(),transitionDuration:e,transitionEasing:Cg},{isDragging:!1,isPanning:!0})}else{const t=this.controllerState.panEnd();this.updateViewport(t,null,{isDragging:!1,isPanning:!1})}return!0}_onPanRotate(t){if(!this.dragRotate)return!1;const e=this.getCenter(t),i=this.controllerState.rotate({pos:e});return this.updateViewport(i,vg,{isDragging:!0,isRotating:!0}),!0}_onPanRotateEnd(t){const{inertia:e}=this;if(this.dragRotate&&e&&t.velocity){const i=this.getCenter(t),n=[i[0]+t.velocityX*e/2,i[1]+t.velocityY*e/2],r=this.controllerState.rotate({pos:n}).rotateEnd();this.updateViewport(r,{...this._getTransitionProps(),transitionDuration:e,transitionEasing:Cg},{isDragging:!1,isRotating:!0})}else{const t=this.controllerState.rotateEnd();this.updateViewport(t,null,{isDragging:!1,isRotating:!1})}return!0}_onWheel(t){if(!this.scrollZoom)return!1;t.preventDefault();const e=this.getCenter(t);if(!this.isPointInBounds(e,t))return!1;const{speed:i=.01,smooth:n=!1}=this.scrollZoom,{delta:r}=t;let s=2/(1+Math.exp(-Math.abs(r*i)));r<0&&0!==s&&(s=1/s);const o=this.controllerState.zoom({pos:e,scale:s});return this.updateViewport(o,{...this._getTransitionProps({around:e}),transitionDuration:n?250:1},{isZooming:!0,isPanning:!0}),!0}_onTriplePanStart(t){const e=this.getCenter(t);if(!this.isPointInBounds(e,t))return!1;const i=this.controllerState.rotateStart({pos:e});return this.updateViewport(i,vg,{isDragging:!0}),!0}_onTriplePan(t){if(!this.touchRotate)return!1;if(!this.isDragging())return!1;const e=this.getCenter(t);e[0]-=t.deltaX;const i=this.controllerState.rotate({pos:e});return this.updateViewport(i,vg,{isDragging:!0,isRotating:!0}),!0}_onTriplePanEnd(t){if(!this.isDragging())return!1;const{inertia:e}=this;if(this.touchRotate&&e&&t.velocityY){const i=this.getCenter(t),n=[i[0],i[1]+=t.velocityY*e/2],r=this.controllerState.rotate({pos:n});this.updateViewport(r,{...this._getTransitionProps(),transitionDuration:e,transitionEasing:Cg},{isDragging:!1,isRotating:!0}),this.blockEvents(e)}else{const t=this.controllerState.rotateEnd();this.updateViewport(t,null,{isDragging:!1,isRotating:!1})}return!0}_onPinchStart(t){const e=this.getCenter(t);if(!this.isPointInBounds(e,t))return!1;const i=this.controllerState.zoomStart({pos:e}).rotateStart({pos:e});return this._startPinchRotation=t.rotation,this._lastPinchEvent=t,this.updateViewport(i,vg,{isDragging:!0}),!0}_onPinch(t){if(!this.touchZoom&&!this.touchRotate)return!1;if(!this.isDragging())return!1;let e=this.controllerState;if(this.touchZoom){const{scale:i}=t,n=this.getCenter(t);e=e.zoom({pos:n,scale:i})}if(this.touchRotate){const{rotation:i}=t;e=e.rotate({deltaAngleX:this._startPinchRotation-i})}return this.updateViewport(e,vg,{isDragging:!0,isPanning:this.touchZoom,isZooming:this.touchZoom,isRotating:this.touchRotate}),this._lastPinchEvent=t,!0}_onPinchEnd(t){if(!this.isDragging())return!1;const{inertia:e,_lastPinchEvent:i}=this;if(this.touchZoom&&e&&i&&t.scale!==i.scale){const n=this.getCenter(t);let r=this.controllerState.rotateEnd();const s=Math.log2(t.scale),o=(s-Math.log2(i.scale))/(t.deltaTime-i.deltaTime),a=Math.pow(2,s+o*e/2);r=r.zoom({pos:n,scale:a}).zoomEnd(),this.updateViewport(r,{...this._getTransitionProps({around:n}),transitionDuration:e,transitionEasing:Cg},{isDragging:!1,isPanning:this.touchZoom,isZooming:this.touchZoom,isRotating:!1}),this.blockEvents(e)}else{const t=this.controllerState.zoomEnd().rotateEnd();this.updateViewport(t,null,{isDragging:!1,isPanning:!1,isZooming:!1,isRotating:!1})}return this._startPinchRotation=null,this._lastPinchEvent=null,!0}_onDoubleTap(t){if(!this.doubleClickZoom)return!1;const e=this.getCenter(t);if(!this.isPointInBounds(e,t))return!1;const i=this.isFunctionKeyPressed(t),n=this.controllerState.zoom({pos:e,scale:i?.5:2});return this.updateViewport(n,this._getTransitionProps({around:e}),{isZooming:!0,isPanning:!0}),this.blockEvents(100),!0}_onKeyDown(t){if(!this.keyboard)return!1;const e=this.isFunctionKeyPressed(t),{zoomSpeed:i,moveSpeed:n,rotateSpeedX:r,rotateSpeedY:s}=this.keyboard,{controllerState:o}=this;let a;const l={};switch(t.srcEvent.code){case"Minus":a=e?o.zoomOut(i).zoomOut(i):o.zoomOut(i),l.isZooming=!0;break;case"Equal":a=e?o.zoomIn(i).zoomIn(i):o.zoomIn(i),l.isZooming=!0;break;case"ArrowLeft":e?(a=o.rotateLeft(r),l.isRotating=!0):(a=o.moveLeft(n),l.isPanning=!0);break;case"ArrowRight":e?(a=o.rotateRight(r),l.isRotating=!0):(a=o.moveRight(n),l.isPanning=!0);break;case"ArrowUp":e?(a=o.rotateUp(s),l.isRotating=!0):(a=o.moveUp(n),l.isPanning=!0);break;case"ArrowDown":e?(a=o.rotateDown(s),l.isRotating=!0):(a=o.moveDown(n),l.isPanning=!0);break;default:return!1}return this.updateViewport(a,this._getTransitionProps(),l),!0}_getTransitionProps(t){const{_transition:e}=this;return e?t?{...e,transitionInterpolator:new Pg({...t,transitionProps:this.linearTransitionProps,makeViewport:this.controllerState.makeViewport})}:e:vg}}class _g{constructor(t){la(this,"_viewportProps",void 0),la(this,"_state",void 0),this._viewportProps=this._applyConstraints(t)}getViewportProps(){return this._viewportProps}getState(){return this._state}shortestPathFrom(t){return this._viewportProps}_applyConstraints(t){return t}}const Lg={pitch:0,bearing:0,altitude:1.5,minZoom:0,maxZoom:20,minPitch:0,maxPitch:60,position:[0,0,0]};class Rg extends _g{constructor(t){t={...Lg,...t};const{makeViewport:e,width:i,height:n,latitude:r,longitude:s,zoom:o,bearing:a,pitch:l,altitude:h,position:u,maxZoom:c,minZoom:d,maxPitch:g,minPitch:f,startPanLngLat:p,startZoomLngLat:m,startRotatePos:y,startBearing:b,startPitch:P,startZoom:v,normalize:S}=t||{};eg(Number.isFinite(s)),eg(Number.isFinite(r)),eg(Number.isFinite(o)),super({width:i,height:n,latitude:r,longitude:s,zoom:o,bearing:a,pitch:l,altitude:h,maxZoom:c,minZoom:d,maxPitch:g,minPitch:f,normalize:S,position:u}),this._state={startPanLngLat:p,startZoomLngLat:m,startRotatePos:y,startBearing:b,startPitch:P,startZoom:v},this.makeViewport=e}panStart({pos:t}){return this._getUpdatedState({startPanLngLat:this._unproject(t)})}pan({pos:t,startPos:e}){const i=this._state.startPanLngLat||this._unproject(e);if(!i)return this;const n=this.makeViewport(this._viewportProps).panByPosition(i,t);return this._getUpdatedState(n)}panEnd(){return this._getUpdatedState({startPanLngLat:null})}rotateStart({pos:t}){return this._getUpdatedState({startRotatePos:t,startBearing:this._viewportProps.bearing,startPitch:this._viewportProps.pitch})}rotate({pos:t,deltaAngleX:e=0,deltaAngleY:i=0}){const{startRotatePos:n,startBearing:r,startPitch:s}=this._state;if(!n||!Number.isFinite(r)||!Number.isFinite(s))return this;let o;return o=t?this._calculateNewPitchAndBearing({...this._getRotationParams(t,n),startBearing:r,startPitch:s}):{bearing:r+e,pitch:s+i},this._getUpdatedState(o)}rotateEnd(){return this._getUpdatedState({startBearing:null,startPitch:null})}zoomStart({pos:t}){return this._getUpdatedState({startZoomLngLat:this._unproject(t),startZoom:this._viewportProps.zoom})}zoom({pos:t,startPos:e,scale:i}){let{startZoom:n,startZoomLngLat:r}=this._state;Number.isFinite(n)||(n=this._viewportProps.zoom,r=this._unproject(e)||this._unproject(t));const s=this._calculateNewZoom({scale:i,startZoom:n}),o=this.makeViewport({...this._viewportProps,zoom:s});return this._getUpdatedState({zoom:s,...o.panByPosition(r,t)})}zoomEnd(){return this._getUpdatedState({startZoomLngLat:null,startZoom:null})}zoomIn(t=2){return this._zoomFromCenter(t)}zoomOut(t=2){return this._zoomFromCenter(1/t)}moveLeft(t=100){return this._panFromCenter([t,0])}moveRight(t=100){return this._panFromCenter([-t,0])}moveUp(t=100){return this._panFromCenter([0,t])}moveDown(t=100){return this._panFromCenter([0,-t])}rotateLeft(t=15){return this._getUpdatedState({bearing:this._viewportProps.bearing-t})}rotateRight(t=15){return this._getUpdatedState({bearing:this._viewportProps.bearing+t})}rotateUp(t=10){return this._getUpdatedState({pitch:this._viewportProps.pitch+t})}rotateDown(t=10){return this._getUpdatedState({pitch:this._viewportProps.pitch-t})}shortestPathFrom(t){const e=t.getViewportProps(),i={...this._viewportProps},{bearing:n,longitude:r}=i;return Math.abs(n-e.bearing)>180&&(i.bearing=n<0?n+360:n-360),Math.abs(r-e.longitude)>180&&(i.longitude=r<0?r+360:r-360),i}_zoomFromCenter(t){const{width:e,height:i}=this._viewportProps;return this.zoom({pos:[e/2,i/2],scale:t})}_panFromCenter(t){const{width:e,height:i}=this._viewportProps;return this.pan({startPos:[e/2,i/2],pos:[e/2+t[0],i/2+t[1]]})}_getUpdatedState(t){return new this.constructor({makeViewport:this.makeViewport,...this._viewportProps,...this._state,...t})}_applyConstraints(t){const{maxZoom:e,minZoom:i,zoom:n}=t;t.zoom=Object(uh.a)(n,i,e);const{maxPitch:r,minPitch:s,pitch:o}=t;t.pitch=Object(uh.a)(o,s,r);const{normalize:a=!0}=t;return a&&Object.assign(t,function({width:t,height:e,longitude:i,latitude:n,zoom:r,pitch:s=0,bearing:o=0}){(i<-180||i>180)&&(i=bh(i+180,360)-180),(o<-180||o>180)&&(o=bh(o+180,360)-180);const a=vh(e/512);if(r<=a)r=a,n=0;else{const t=e/2/Math.pow(2,r),i=Lh([0,t])[1];if(n<i)n=i;else{const e=Lh([0,512-t])[1];n>e&&(n=e)}}return{width:t,height:e,longitude:i,latitude:n,zoom:r,pitch:s,bearing:o}}(t)),t}_unproject(t){const e=this.makeViewport(this._viewportProps);return t&&e.unproject(t)}_calculateNewZoom({scale:t,startZoom:e}){const{maxZoom:i,minZoom:n}=this._viewportProps,r=e+Math.log2(t);return Object(uh.a)(r,n,i)}_calculateNewPitchAndBearing({deltaScaleX:t,deltaScaleY:e,startBearing:i,startPitch:n}){e=Object(uh.a)(e,-1,1);const{minPitch:r,maxPitch:s}=this._viewportProps;let o=n;return e>0?o=n+e*(s-n):e<0&&(o=n-e*(r-n)),{pitch:o,bearing:i+180*t}}_getRotationParams(t,e){const i=t[0]-e[0],n=t[1]-e[1],r=t[1],s=e[1],{width:o,height:a}=this._viewportProps,l=i/o;let h=0;return n>0?Math.abs(a-s)>5&&(h=n/(s-a)*1.2):n<0&&s>5&&(h=1-r/s),h=Math.min(1,Math.max(-1,h)),{deltaScaleX:l,deltaScaleY:h}}}class Bg extends Og{constructor(t){t.dragMode=t.dragMode||"pan",super(Rg,t)}setProps(t){t.position=t.position||[0,0,0];const e=this.controllerStateProps;super.setProps(t);(!e||e.height!==t.height)&&this.updateViewport(new this.ControllerState({makeViewport:this.makeViewport,...this.controllerStateProps,...this._state}))}get linearTransitionProps(){return["longitude","latitude","zoom","bearing","pitch","position"]}}class Mg extends ig{constructor(t){super({...t,type:ag})}get controller(){return this._getControllerProps({type:Bg})}}Mg.displayName="MapView";const Fg=[255,255,255],Dg=1;let Ng=0;class kg{constructor(t={}){const{color:e=Fg}=t,{intensity:i=Dg}=t;this.id=t.id||"ambient-".concat(Ng++),this.color=e,this.intensity=i,this.type="ambient"}}const Vg=[255,255,255],Gg=1,zg=[0,0,-1];let jg=0;class Ug{constructor(t={}){const{color:e=Vg}=t,{intensity:i=Gg}=t,{direction:n=zg}=t,{_shadow:r=!1}=t;this.id=t.id||"directional-".concat(jg++),this.color=e,this.intensity=i,this.type="directional",this.direction=new dh.a(n).normalize().toArray(),this.shadow=r}getProjectedLight(){return this}}class Wg{constructor(t={}){la(this,"id",void 0),la(this,"props",void 0),la(this,"useInPicking",void 0);const{id:e="effect"}=t;this.id=e,this.props={...t},this.useInPicking=!1}preRender(){}getModuleParameters(t){}cleanup(){}}class Hg extends class{constructor(t,e={id:"pass"}){la(this,"id",void 0),la(this,"gl",void 0),la(this,"props",void 0);const{id:i}=e;this.id=i,this.gl=t,this.props={...e}}setProps(t){Object.assign(this.props,t)}render(t){}cleanup(){}}{render(t){const e=this.gl;return Object(Nu.c)(e,{framebuffer:t.target}),this._drawLayers(t)}_drawLayers(t){const{target:e,moduleParameters:i,viewports:n,views:r,onViewportActive:s,clearCanvas:o=!0}=t;t.pass=t.pass||"unknown";const a=this.gl;o&&function(t){const e=t.drawingBufferWidth,i=t.drawingBufferHeight;Object(Nu.c)(t,{viewport:[0,0,e,i]}),t.clear(16640)}(a);const l=[];for(const o of n){const n=r&&r[o.id];s(o);const h=this._getDrawLayerParams(o,t),u=o.subViewports||[o];for(const r of u){const s=this._drawLayersInViewport(a,{target:e,moduleParameters:i,viewport:r,view:n,pass:t.pass,layers:t.layers},h);l.push(s)}}return l}_getDrawLayerParams(t,{layers:e,pass:i,layerFilter:n,effects:r,moduleParameters:s}){const o=[],a=function t(e=0,i={}){const n={},r=(s,o)=>{const a=s.props._offset,l=s.id,h=s.parent&&s.parent.id;let u;if(h&&!(h in i)&&r(s.parent,!1),h in n){const e=n[h]=n[h]||t(i[h],i);u=e(s,o),n[l]=e}else Number.isFinite(a)?(u=a+(i[h]||0),n[l]=null):u=e;return o&&u>=e&&(e=u+1),i[l]=u,u};return r}(),l={layer:e[0],viewport:t,isPicking:i.startsWith("picking"),renderPass:i},h={};for(let u=0;u<e.length;u++){const c=e[u],d=this._shouldDrawLayer(c,l,n,h),g={shouldDrawLayer:d,layerRenderIndex:a(c,d)};d&&(g.moduleParameters=this._getModuleParameters(c,r,i,s),g.layerParameters=this.getLayerParameters(c,u,t)),o[u]=g}return o}_drawLayersInViewport(t,{layers:e,moduleParameters:i,pass:n,target:r,viewport:s,view:o},a){const l=function(t,{moduleParameters:e,target:i,viewport:n}){const r=i&&"default-framebuffer"!==i.id,s=e&&e.devicePixelRatio||zu(t),o=r?i.height:t.drawingBufferHeight,a=n;return[a.x*s,o-(a.y+a.height)*s,a.width*s,a.height*s]}(t,{moduleParameters:i,target:r,viewport:s});if(o&&o.props.clear){const e=!0===o.props.clear?{color:!0,depth:!0}:o.props.clear;Object(Nu.d)(t,{scissorTest:!0,scissor:l},()=>_c(t,e))}const h={totalCount:e.length,visibleCount:0,compositeCount:0,pickableCount:0};Object(Nu.c)(t,{viewport:l});for(let t=0;t<e.length;t++){const i=e[t],{shouldDrawLayer:r,layerRenderIndex:o,moduleParameters:l,layerParameters:u}=a[t];if(r&&i.props.pickable&&h.pickableCount++,i.isComposite)h.compositeCount++;else if(r){h.visibleCount++,l.viewport=s;try{i.drawLayer({moduleParameters:l,uniforms:{layerIndex:o},parameters:u})}catch(t){i.raiseError(t,"drawing ".concat(i," to ").concat(n))}}}return h}shouldDrawLayer(t){return!0}getModuleParameters(t,e){return null}getLayerParameters(t,e,i){return t.props.parameters}_shouldDrawLayer(t,e,i,n){if(!(this.shouldDrawLayer(t)&&t.props.visible))return!1;e.layer=t;let r=t.parent;for(;r;){if(!r.props.visible||!r.filterSubLayer(e))return!1;e.layer=r,r=r.parent}if(i){const t=e.layer.id;if(t in n||(n[t]=i(e)),!n[t])return!1}return t.activateViewport(e.viewport),!0}_getModuleParameters(t,e,i,n){const r=Object.assign(Object.create(t.props),{autoWrapLongitude:t.wrapLongitude,viewport:t.context.viewport,mousePosition:t.context.mousePosition,pickingActive:0,devicePixelRatio:zu(this.gl)});if(e)for(const i of e)Object.assign(r,i.getModuleParameters(t));return Object.assign(r,this.getModuleParameters(t,e),n)}}class qg extends Hg{constructor(t,e){super(t,e),la(this,"shadowMap",void 0),la(this,"depthBuffer",void 0),la(this,"fbo",void 0),this.shadowMap=new Ac(t,{width:1,height:1,parameters:{10241:9729,10240:9729,10242:33071,10243:33071}}),this.depthBuffer=new Oc(t,{format:33189,width:1,height:1}),this.fbo=new Hc(t,{id:"shadowmap",width:1,height:1,attachments:{36064:this.shadowMap,36096:this.depthBuffer}})}render(t){const e=this.fbo;Object(Nu.d)(this.gl,{depthRange:[0,1],depthTest:!0,blend:!1,clearColor:[1,1,1,1]},()=>{const i=t.viewports[0],n=zu(this.gl),r=i.width*n,s=i.height*n;r===e.width&&s===e.height||e.resize({width:r,height:s}),super.render({...t,target:e,pass:"shadow"})})}shouldDrawLayer(t){return!1!==t.props.shadowEnabled}getModuleParameters(){return{drawToShadowMap:!0}}delete(){this.fbo&&(this.fbo.delete(),this.fbo=null),this.shadowMap&&(this.shadowMap.delete(),this.shadowMap=null),this.depthBuffer&&(this.depthBuffer.delete(),this.depthBuffer=null)}}const Xg=Fd((function({viewport:t,center:e}){return new ch.a(t.viewProjectionMatrix).invert().transform(e)})),Yg=Fd((function({viewport:t,shadowMatrices:e}){const i=[],n=t.pixelUnprojectionMatrix,r=t.isGeospatial?void 0:1,s=[[0,0,r],[t.width,0,r],[0,t.height,r],[t.width,t.height,r],[0,0,-1],[t.width,0,-1],[0,t.height,-1],[t.width,t.height,-1]].map(t=>function(t,e){const[i,n,r]=t,s=Vh([i,n,r],e);if(Number.isFinite(r))return s;return[s[0],s[1],0]}(t,n));for(const n of e){const e=n.clone().translate(new dh.a(t.center).negate()),r=s.map(t=>e.transform(t)),o=(new ch.a).ortho({left:Math.min(...r.map(t=>t[0])),right:Math.max(...r.map(t=>t[0])),bottom:Math.min(...r.map(t=>t[1])),top:Math.max(...r.map(t=>t[1])),near:Math.min(...r.map(t=>-t[2])),far:Math.max(...r.map(t=>-t[2]))});i.push(o.multiplyRight(n))}return i})),Qg=[0,0,0,1],Zg=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0];var Kg={name:"shadow",dependencies:[Wd],vs:"\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n",fs:"\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n",inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    position = shadow_setVertexPosition(geometry.position);\n    ","fs:DECKGL_FILTER_COLOR":"\n    color = shadow_filterShadowColor(color);\n    "},getUniforms:(t={},e={})=>{if(t.drawToShadowMap||t.shadowMaps&&t.shadowMaps.length>0){const{shadowEnabled:i=!0}=t;return i&&t.shadowMatrices&&t.shadowMatrices.length>0?function(t={},e={}){const i={shadow_uDrawShadowMap:Boolean(t.drawToShadowMap),shadow_uUseShadowMap:!!t.shadowMaps&&t.shadowMaps.length>0,shadow_uColor:t.shadowColor||Qg,shadow_uLightId:t.shadowLightId||0,shadow_uLightCount:t.shadowMatrices.length},n=Xg({viewport:t.viewport,center:e.project_uCenter}),r=[],s=Yg({shadowMatrices:t.shadowMatrices,viewport:t.viewport}).slice();for(let i=0;i<t.shadowMatrices.length;i++){const o=s[i],a=o.clone().translate(new dh.a(t.viewport.center).negate());e.project_uCoordinateSystem===Wh.LNGLAT&&e.project_uProjectionMode===Hh.WEB_MERCATOR?(s[i]=a,r[i]=n):(s[i]=o.clone().multiplyRight(Zg),r[i]=a.transform(n))}for(let e=0;e<s.length;e++)i["shadow_uViewProjectionMatrices[".concat(e,"]")]=s[e],i["shadow_uProjectCenters[".concat(e,"]")]=r[e],t.shadowMaps&&t.shadowMaps.length>0?i["shadow_uShadowMap".concat(e)]=t.shadowMaps[e]:i["shadow_uShadowMap".concat(e)]=t.dummyShadowMap;return i}(t,e):{shadow_uDrawShadowMap:!1,shadow_uUseShadowMap:!1}}return{}}};const $g={color:[255,255,255],intensity:1},Jg=[{color:[255,255,255],intensity:1,direction:[-1,3,-1]},{color:[255,255,255],intensity:.9,direction:[1,-8,-2.5]}],tf=[0,0,0,200/255];class ef extends Wg{constructor(t){super(t),this.ambientLight=null,this.directionalLights=[],this.pointLights=[],this.shadowColor=tf,this.shadowPasses=[],this.shadowMaps=[],this.dummyShadowMap=null,this.shadow=!1,this.programManager=null;for(const e in t){const i=t[e];switch(i.type){case"ambient":this.ambientLight=i;break;case"directional":this.directionalLights.push(i);break;case"point":this.pointLights.push(i)}}this._applyDefaultLights(),this.shadow=this.directionalLights.some(t=>t.shadow)}preRender(t,{layers:e,layerFilter:i,viewports:n,onViewportActive:r,views:s}){if(this.shadow){this.shadowMatrices=this._createLightMatrix(),0===this.shadowPasses.length&&this._createShadowPasses(t),this.programManager||(this.programManager=Ed.getDefaultProgramManager(t),Kg&&this.programManager.addDefaultModule(Kg)),this.dummyShadowMap||(this.dummyShadowMap=new Ac(t,{width:1,height:1}));for(let t=0;t<this.shadowPasses.length;t++){this.shadowPasses[t].render({layers:e,layerFilter:i,viewports:n,onViewportActive:r,views:s,moduleParameters:{shadowLightId:t,dummyShadowMap:this.dummyShadowMap,shadowMatrices:this.shadowMatrices}})}}}getModuleParameters(t){const e=this.shadow?{shadowMaps:this.shadowMaps,dummyShadowMap:this.dummyShadowMap,shadowColor:this.shadowColor,shadowMatrices:this.shadowMatrices}:{};return e.lightSources={ambientLight:this.ambientLight,directionalLights:this.directionalLights.map(e=>e.getProjectedLight({layer:t})),pointLights:this.pointLights.map(e=>e.getProjectedLight({layer:t}))},e}cleanup(){for(const t of this.shadowPasses)t.delete();this.shadowPasses.length=0,this.shadowMaps.length=0,this.dummyShadowMap&&(this.dummyShadowMap.delete(),this.dummyShadowMap=null),this.shadow&&this.programManager&&(this.programManager.removeDefaultModule(Kg),this.programManager=null)}_createLightMatrix(){const t=[];for(const e of this.directionalLights){const i=(new ch.a).lookAt({eye:new dh.a(e.direction).negate()});t.push(i)}return t}_createShadowPasses(t){for(let e=0;e<this.directionalLights.length;e++){const i=new qg(t);this.shadowPasses[e]=i,this.shadowMaps[e]=i.shadowMap}}_applyDefaultLights(){const{ambientLight:t,pointLights:e,directionalLights:i}=this;t||0!==e.length||0!==i.length||(this.ambientLight=new kg($g),this.directionalLights.push(new Ug(Jg[0]),new Ug(Jg[1])))}}class nf extends Hg{constructor(t,e){super(t,e),la(this,"maskMap",void 0),la(this,"fbo",void 0);const{mapSize:i=2048}=e;this.maskMap=new Ac(t,{width:i,height:i,parameters:{10241:9729,10240:9729,10242:33071,10243:33071}}),this.fbo=new Hc(t,{id:"maskmap",width:i,height:i,attachments:{36064:this.maskMap}})}render(t){const e=this.gl,i=[!1,!1,!1,!1];return i[t.channel]=!0,Object(Nu.d)(e,{clearColor:[255,255,255,255],blend:!0,blendFunc:[0,1],blendEquation:32778,colorMask:i,depthTest:!1},()=>super.render({...t,target:this.fbo,pass:"mask"}))}shouldDrawLayer(t){return t.props.operation===Qh}delete(){this.fbo.delete(),this.maskMap.delete()}}const rf=0,sf=0,of=0,af=[0,0,0],lf=-90,hf=90,uf=-1/0,cf=1/0;class df extends _g{constructor({makeViewport:t,width:e,height:i,rotationX:n=rf,rotationOrbit:r=sf,target:s=af,zoom:o=of,minRotationX:a=lf,maxRotationX:l=hf,minZoom:h=uf,maxZoom:u=cf,startPanPosition:c,startRotatePos:d,startRotationX:g,startRotationOrbit:f,startZoomPosition:p,startZoom:m}){super({width:e,height:i,rotationX:n,rotationOrbit:r,target:s,zoom:o,minRotationX:a,maxRotationX:l,minZoom:h,maxZoom:u}),this._state={startPanPosition:c,startRotatePos:d,startRotationX:g,startRotationOrbit:f,startZoomPosition:p,startZoom:m},this.makeViewport=t}panStart({pos:t}){return this._getUpdatedState({startPanPosition:this._unproject(t)})}pan({pos:t,startPosition:e}){const i=this._state.startPanPosition||e;if(!i)return this;const n=this.makeViewport(this._viewportProps).panByPosition(i,t);return this._getUpdatedState(n)}panEnd(){return this._getUpdatedState({startPanPosition:null})}rotateStart({pos:t}){return this._getUpdatedState({startRotatePos:t,startRotationX:this._viewportProps.rotationX,startRotationOrbit:this._viewportProps.rotationOrbit})}rotate({pos:t,deltaAngleX:e=0,deltaAngleY:i=0}){const{startRotatePos:n,startRotationX:r,startRotationOrbit:s}=this._state,{width:o,height:a}=this._viewportProps;if(!n||!Number.isFinite(r)||!Number.isFinite(s))return this;let l;if(t){let e=(t[0]-n[0])/o;const i=(t[1]-n[1])/a;(r<-90||r>90)&&(e*=-1),l={rotationX:r+180*i,rotationOrbit:s+180*e}}else l={rotationX:r+i,rotationOrbit:s+e};return this._getUpdatedState(l)}rotateEnd(){return this._getUpdatedState({startRotationX:null,startRotationOrbit:null})}shortestPathFrom(t){const e=t.getViewportProps(),i={...this._viewportProps},{rotationOrbit:n}=i;return Math.abs(n-e.rotationOrbit)>180&&(i.rotationOrbit=n<0?n+360:n-360),i}zoomStart({pos:t}){return this._getUpdatedState({startZoomPosition:this._unproject(t),startZoom:this._viewportProps.zoom})}zoom({pos:t,startPos:e,scale:i}){const{zoom:n}=this._viewportProps;let{startZoom:r,startZoomPosition:s}=this._state;Number.isFinite(r)||(r=n,s=this._unproject(e)||this._unproject(t));const o=this._calculateNewZoom({scale:i,startZoom:r}),a=this.makeViewport({...this._viewportProps,zoom:o});return this._getUpdatedState({zoom:o,...a.panByPosition(s,t)})}zoomEnd(){return this._getUpdatedState({startZoomPosition:null,startZoom:null})}zoomIn(t=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:t})})}zoomOut(t=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:1/t})})}moveLeft(t=50){return this._panFromCenter([-t,0])}moveRight(t=50){return this._panFromCenter([t,0])}moveUp(t=50){return this._panFromCenter([0,-t])}moveDown(t=50){return this._panFromCenter([0,t])}rotateLeft(t=15){return this._getUpdatedState({rotationOrbit:this._viewportProps.rotationOrbit-t})}rotateRight(t=15){return this._getUpdatedState({rotationOrbit:this._viewportProps.rotationOrbit+t})}rotateUp(t=10){return this._getUpdatedState({rotationX:this._viewportProps.rotationX-t})}rotateDown(t=10){return this._getUpdatedState({rotationX:this._viewportProps.rotationX+t})}_unproject(t){const e=this.makeViewport(this._viewportProps);return t&&e.unproject(t)}_calculateNewZoom({scale:t,startZoom:e}){const{maxZoom:i,minZoom:n}=this._viewportProps;Number.isFinite(e)||(e=this._viewportProps.zoom);const r=e+Math.log2(t);return Object(uh.a)(r,n,i)}_panFromCenter(t){const{width:e,height:i,target:n}=this._viewportProps;return this.pan({startPosition:n,pos:[e/2+t[0],i/2+t[1]]})}_getUpdatedState(t){return new this.constructor({...this._viewportProps,...this._state,...t})}_applyConstraints(t){const{maxZoom:e,minZoom:i,zoom:n,maxRotationX:r,minRotationX:s,rotationOrbit:o}=t;return t.zoom=Object(uh.a)(n,i,e),t.rotationX=Object(uh.a)(t.rotationX,s,r),(o<-180||o>180)&&(t.rotationOrbit=function(t,e){const i=t%e;return i<0?e+i:i}(o+180,360)-180),t}}class gf extends df{constructor(t){super(t),la(this,"zoomAxis",void 0),this.zoomAxis=t.zoomAxis||"all"}_applyConstraints(t){const{maxZoom:e,minZoom:i,zoom:n}=t;return t.zoom=Array.isArray(n)?[Object(uh.a)(n[0],i,e),Object(uh.a)(n[1],i,e)]:Object(uh.a)(n,i,e),t}_calculateNewZoom({scale:t,startZoom:e}){const{maxZoom:i,minZoom:n}=this._viewportProps;e||0===e||(e=this._viewportProps.zoom);let r=Math.log2(t);if(Array.isArray(e)){let[t,s]=e;switch(this.zoomAxis){case"X":t=Object(uh.a)(t+r,n,i);break;case"Y":s=Object(uh.a)(s+r,n,i);break;default:let e=Math.min(t+r,s+r);e<n&&(r+=n-e),e=Math.max(t+r,s+r),e>i&&(r+=i-e),t+=r,s+=r}return[t,s]}return Object(uh.a)(e+r,n,i)}}class ff extends Og{constructor(t){t.dragMode=t.dragMode||"pan",super(gf,t)}_onPanRotate(t){return!1}get linearTransitionProps(){return["target","zoom"]}}const pf=(new ch.a).lookAt({eye:[0,0,1]});function mf({width:t,height:e,near:i,far:n}){return t=t||1,e=e||1,(new ch.a).ortho({left:-t/2,right:t/2,bottom:-e/2,top:e/2,near:i,far:n})}class yf extends tu{constructor(t){const{width:e,height:i,near:n=.1,far:r=1e3,zoom:s=0,target:o=[0,0,0],flipY:a=!0}=t,l=Array.isArray(s)?s[0]:s,h=Array.isArray(s)?s[1]:s,u=Math.min(l,h),c=Math.pow(2,u);let d;if(l!==h){const t=Math.pow(2,l),e=Math.pow(2,h);d={unitsPerMeter:[t/c,e/c,1],metersPerUnit:[c/t,c/e,1]}}super({...t,longitude:null,position:o,viewMatrix:pf.clone().scale([c,c*(a?-1:1),c]),projectionMatrix:mf({width:e,height:i,near:n,far:r}),zoom:u,distanceScales:d})}projectFlat([t,e]){const{unitsPerMeter:i}=this.distanceScales;return[t*i[0],e*i[1]]}unprojectFlat([t,e]){const{metersPerUnit:i}=this.distanceScales;return[t*i[0],e*i[1]]}panByPosition(t,e){const i=Vh(e,this.pixelUnprojectionMatrix),n=ng([],this.projectFlat(t),rg([],i)),r=ng([],this.center,n);return{target:this.unprojectFlat(r)}}}class bf extends ig{constructor(t){super({...t,type:yf})}get controller(){return this._getControllerProps({type:ff})}}bf.displayName="OrthographicView";class Pf extends Wg{constructor(t){super(t),this.dummyMaskMap=null,this.useInPicking=!0,this.channels=[],this.masks=null}preRender(t,{layers:e,layerFilter:i,viewports:n,onViewportActive:r,views:s}){this.dummyMaskMap||(this.dummyMaskMap=new Ac(t,{width:1,height:1}));const o=e.filter(t=>t.props.operation===Qh&&t.props.visible);if(0===o.length)return this.masks=null,void(this.channels.length=0);this.masks={},this.maskPass||(this.maskPass=new nf(t,{id:"default-mask"}),this.maskMap=this.maskPass.maskMap);const a=this._sortMaskChannels(o),l=n[0],h=!this.lastViewport||!this.lastViewport.equals(l);for(const t in a)this._renderChannel(a[t],{layerFilter:i,onViewportActive:r,views:s,viewport:l,viewportChanged:h})}_renderChannel(t,{layerFilter:e,onViewportActive:i,views:n,viewport:r,viewportChanged:s}){const o=this.channels[t.index],a=t===o||o.layers.length!==t.layers.length||t.layerBounds.some((t,e)=>t!==o.layerBounds[e]);if(t.bounds=o.bounds,t.maskBounds=o.maskBounds,this.channels[t.index]=t,(a||s)&&(this.lastViewport=r,t.bounds=function({layers:t,viewport:e}){let i=null;for(const e of t){const t=e.getBounds();t&&(i?(i[0]=Math.min(i[0],t[0][0]),i[1]=Math.min(i[1],t[0][1]),i[2]=Math.max(i[2],t[1][0]),i[3]=Math.max(i[3],t[1][1])):i=[t[0][0],t[0][1],t[1][0],t[1][1]])}const n=e.getBounds();if(!i)return n;const r=function(t){const e={x:t[2]-t[0],y:t[3]-t[1]},i={x:t[0]+.5*e.x,y:t[1]+.5*e.y};return[i.x-e.x,i.y-e.y,i.x+e.x,i.y+e.y]}(n);return i[2]-i[0]<r[2]-r[0]||i[3]-i[1]<r[3]-r[1]||(i[0]=Math.max(i[0],r[0]),i[1]=Math.max(i[1],r[1]),i[2]=Math.min(i[2],r[2]),i[3]=Math.min(i[3],r[3])),i}({layers:t.layers,viewport:r}),a||!Object(uh.c)(t.bounds,o.bounds))){const{maskPass:s,maskMap:o}=this,a=function({bounds:t,viewport:e,width:i,height:n}){if(t[2]<=t[0]||t[3]<=t[1])return null;if(i-=2,n-=2,e instanceof ag){const{longitude:e,latitude:r,zoom:s}=Gh({width:i,height:n,bounds:[[t[0],t[1]],[t[2],t[3]]],maxZoom:20});return new ag({longitude:e,latitude:r,zoom:s,x:1,y:1,width:i,height:n})}const r=[(t[0]+t[2])/2,(t[1]+t[3])/2,0],s=Math.min(20,i/(t[2]-t[0]),n/(t[3]-t[1]));return new bf({x:1,y:1}).makeViewport({width:i,height:n,viewState:{target:r,zoom:Math.log2(s)}})}({bounds:t.bounds,viewport:r,width:o.width,height:o.height});t.maskBounds=a?a.getBounds():[0,0,1,1],s.render({channel:t.index,layers:t.layers,layerFilter:e,viewports:a?[a]:[],onViewportActive:i,views:n,moduleParameters:{devicePixelRatio:1}})}this.masks[t.id]={index:t.index,bounds:t.maskBounds,coordinateOrigin:t.coordinateOrigin,coordinateSystem:t.coordinateSystem}}_sortMaskChannels(t){const e={};let i=0;for(const n of t){const{id:t}=n.root;let r=e[t];if(!r){if(++i>4){Ta.warn("Too many mask layers. The max supported is 4")();continue}r={id:t,index:this.channels.findIndex(e=>(null==e?void 0:e.id)===t),layers:[],layerBounds:[],coordinateOrigin:n.root.props.coordinateOrigin,coordinateSystem:n.root.props.coordinateSystem},e[t]=r}r.layers.push(n),r.layerBounds.push(n.getBounds())}for(let t=0;t<4;t++){const i=this.channels[t];i&&i.id in e||(this.channels[t]=null)}for(const t in e){const i=e[t];i.index<0&&(i.index=this.channels.findIndex(t=>!t),this.channels[i.index]=i)}return e}getModuleParameters(){return{maskMap:this.masks?this.maskMap:this.dummyMaskMap,maskChannels:this.masks}}cleanup(){this.dummyMaskMap&&(this.dummyMaskMap.delete(),this.dummyMaskMap=null),this.maskPass&&(this.maskPass.delete(),this.maskPass=null,this.maskMap=null),this.lastViewport=null,this.masks=null,this.channels.length=0}}const vf=new ef;class Sf{constructor(){la(this,"effects",void 0),la(this,"_internalEffects",void 0),la(this,"_needsRedraw",void 0),this.effects=[],this._internalEffects=[],this._needsRedraw="Initial render",this.setEffects()}setProps(t){"effects"in t&&(t.effects.length===this.effects.length&&Zd(t.effects,this.effects)||(this.setEffects(t.effects),this._needsRedraw="effects changed"))}needsRedraw(t={clearRedrawFlags:!1}){const e=this._needsRedraw;return t.clearRedrawFlags&&(this._needsRedraw=!1),e}getEffects(){return this._internalEffects}finalize(){this.cleanup()}setEffects(t=[]){this.cleanup(),this.effects=t,this._internalEffects=t.slice(),this._internalEffects.push(new Pf),t.some(t=>t instanceof ef)||this._internalEffects.push(vf)}cleanup(){for(const t of this.effects)t.cleanup();for(const t of this._internalEffects)t.cleanup();this.effects.length=0,this._internalEffects.length=0}}class Cf extends Hg{shouldDrawLayer(t){return t.props.operation===Yh}}const wf={blendFunc:[1,0,32771,0],blendEquation:32774};class Ef extends Hg{constructor(...t){super(...t),la(this,"pickZ",void 0),la(this,"_colors",null)}render(t){return t.pickingFBO?this._drawPickingBuffer(t):super.render(t)}_drawPickingBuffer({layers:t,layerFilter:e,views:i,viewports:n,onViewportActive:r,pickingFBO:s,deviceRect:{x:o,y:a,width:l,height:h},effects:u,pass:c="picking",pickZ:d}){const g=this.gl;this.pickZ=d;const f=d?null:{byLayer:new Map,byAlpha:[]};this._colors=f;const p=Object(Nu.d)(g,{scissorTest:!0,scissor:[o,a,l,h],clearColor:[0,0,0,0],depthMask:!0,depthTest:!0,depthRange:[0,1],colorMask:[!0,!0,!0,!0],...wf,blend:!d},()=>super.render({target:s,layers:t,layerFilter:e,views:i,viewports:n,onViewportActive:r,effects:null==u?void 0:u.filter(t=>t.useInPicking),pass:c}));this._colors=null;return{decodePickingColor:f&&xf.bind(null,f),stats:p}}shouldDrawLayer(t){return t.props.pickable&&t.props.operation===Yh}getModuleParameters(){return{pickingActive:1,pickingAttribute:this.pickZ,lightSources:{}}}getLayerParameters(t,e,i){const n={...t.props.parameters};return this._colors?(Object.assign(n,wf),n.blend=!0,n.blendColor=function(t,e,i){const{byLayer:n,byAlpha:r}=t;let s,o=n.get(e);o?(o.viewports.push(i),s=o.a):(s=n.size+1,s<=255?(o={a:s,layer:e,viewports:[i]},n.set(e,o),r[s]=o):(Ta.warn("Too many pickable layers, only picking the first 255")(),s=0));return[0,0,0,s/255]}(this._colors,t,i)):n.blend=!1,n}}function xf(t,e){const i=t.byAlpha[e[3]];return i&&{pickedLayer:i.layer,pickedViewports:i.viewports,pickedObjectIndex:i.layer.decodePickingColor(e)}}class Af{constructor(t){this.gl=t,this.layerFilter=null,this.drawPickingColors=!1,this.drawLayersPass=new Cf(t),this.pickLayersPass=new Ef(t),this.renderCount=0,this._needsRedraw="Initial render",this.renderBuffers=[],this.lastPostProcessEffect=null}setProps(t){"layerFilter"in t&&this.layerFilter!==t.layerFilter&&(this.layerFilter=t.layerFilter,this._needsRedraw="layerFilter changed"),"drawPickingColors"in t&&this.drawPickingColors!==t.drawPickingColors&&(this.drawPickingColors=t.drawPickingColors,this._needsRedraw="drawPickingColors changed")}renderLayers(t){const e=this.drawPickingColors?this.pickLayersPass:this.drawLayersPass;t.layerFilter=t.layerFilter||this.layerFilter,t.effects=t.effects||[],t.target=t.target||Hc.getDefaultFramebuffer(this.gl),this._preRender(t.effects,t);const i=this.lastPostProcessEffect?this.renderBuffers[0]:t.target,n=e.render({...t,target:i});this._postRender(t.effects,t),this.renderCount++,Oa("deckRenderer.renderLayers",this,n,t)}needsRedraw(t={clearRedrawFlags:!1}){const e=this._needsRedraw;return t.clearRedrawFlags&&(this._needsRedraw=!1),e}finalize(){const{renderBuffers:t}=this;for(const e of t)e.delete();t.length=0}_preRender(t,e){let i=null;for(const n of t)n.preRender(this.gl,e),n.postRender&&(i=n);i&&this._resizeRenderBuffers(),this.lastPostProcessEffect=i}_resizeRenderBuffers(){const{renderBuffers:t}=this;0===t.length&&t.push(new Hc(this.gl),new Hc(this.gl));for(const e of t)e.resize()}_postRender(t,e){const{renderBuffers:i}=this,n={inputBuffer:i[0],swapBuffer:i[1],target:null};for(const r of t)if(r.postRender){if(r===this.lastPostProcessEffect){n.target=e.target,r.postRender(this.gl,n);break}const t=r.postRender(this.gl,n);n.inputBuffer=t,n.swapBuffer=t===i[0]?i[1]:i[0]}}}const Tf={pickedColor:null,pickedLayer:null,pickedObjectIndex:-1};function If({pickedColors:t,decodePickingColor:e,deviceX:i,deviceY:n,deviceRadius:r,deviceRect:s}){if(t){const{x:o,y:a,width:l,height:h}=s;let u=r*r,c=-1,d=0;for(let e=0;e<h;e++){const r=e+a-n,s=r*r;if(s>u)d+=4*l;else for(let e=0;e<l;e++){if(t[d+3]-1>=0){const t=e+o-i,n=t*t+s;n<=u&&(u=n,c=d)}d+=4}}if(c>=0){const i=t.slice(c,c+4),n=e(i);if(n){const t=Math.floor(c/4/l),e=c/4-t*l;return{...n,pickedColor:i,pickedX:o+e,pickedY:a+t}}Ta.error("Picked non-existent layer. Is picking buffer corrupt?")()}}return Tf}function Of({pickInfo:t,viewports:e,pixelRatio:i,x:n,y:r,z:s}){let o=e[0];e.length>1&&(o=function(t,e){for(let i=t.length-1;i>=0;i--){const n=t[i];if(n.containsPixel(e))return n}return t[0]}((null==t?void 0:t.pickedViewports)||e,{x:n,y:r}));const a=o&&o.unproject([n-o.x,r-o.y,s]);return{color:null,layer:null,viewport:o,index:-1,picked:!1,x:n,y:r,pixel:[n,r],coordinate:a,devicePixel:t&&"pickedX"in t?[t.pickedX,t.pickedY]:null,pixelRatio:i}}function _f(t){const{pickInfo:e,lastPickedInfo:i,mode:n,layers:r}=t,{pickedColor:s,pickedLayer:o,pickedObjectIndex:a}=e,l=o?[o]:[];if("hover"===n){const t=i.index,e=i.layerId,n=o&&o.props.id;if(n!==e||a!==t){if(n!==e){const t=r.find(t=>t.props.id===e);t&&l.unshift(t)}i.layerId=n,i.index=a,i.info=null}}const h=Of(t),u=new Map;return u.set(null,h),l.forEach(t=>{let e={...h};t===o&&(e.color=s,e.index=a,e.picked=!0),e=Lf({layer:t,info:e,mode:n}),t===o&&"hover"===n&&(i.info=e),u.set(e.layer.id,e),"hover"===n&&e.layer.updateAutoHighlight(e)}),u}function Lf({layer:t,info:e,mode:i}){for(;t&&e;){const n=e.layer||null;e.sourceLayer=n,e.layer=t,e=t.getPickingInfo({info:e,mode:i,sourceLayer:n}),t=t.parent}return e}class Rf{constructor(t){this.gl=t,this.pickingFBO=null,this.pickLayersPass=new Ef(t),this.layerFilter=null,this.lastPickedInfo={index:-1,layerId:null,info:null}}setProps(t){"layerFilter"in t&&(this.layerFilter=t.layerFilter),"_pickable"in t&&(this._pickable=t._pickable)}finalize(){this.pickingFBO&&this.pickingFBO.delete(),this.depthFBO&&(this.depthFBO.color.delete(),this.depthFBO.delete())}pickObject(t){return this._pickClosestObject(t)}pickObjects(t){return this._pickVisibleObjects(t)}getLastPickedObject({x:t,y:e,layers:i,viewports:n},r=this.lastPickedInfo.info){const s=r&&r.layer&&r.layer.id,o=r&&r.viewport&&r.viewport.id,a=s?i.find(t=>t.id===s):null,l=o&&n.find(t=>t.id===o)||n[0],h=l&&l.unproject([t-l.x,e-l.y]),u={x:t,y:e,viewport:l,coordinate:h,layer:a};return{...r,...u}}_resizeBuffer(){const{gl:t}=this;return this.pickingFBO||(this.pickingFBO=new Hc(t),Hc.isSupported(t,{colorBufferFloat:!0})&&(this.depthFBO=new Hc(t),this.depthFBO.attach({36064:new Ac(t,{format:Object(Du.e)(t)?34836:6408,type:5126})}))),this.pickingFBO.resize({width:t.canvas.width,height:t.canvas.height}),this.depthFBO&&this.depthFBO.resize({width:t.canvas.width,height:t.canvas.height}),this.pickingFBO}_getPickable(t){if(!1===this._pickable)return null;const e=t.filter(t=>t.isPickable()&&!t.isComposite);return e.length?e:null}_pickClosestObject({layers:t,views:e,viewports:i,x:n,y:r,radius:s=0,depth:o=1,mode:a="query",unproject3D:l,onViewportActive:h,effects:u}){if(!(t=this._getPickable(t)))return{result:[],emptyInfo:Of({viewports:i,x:n,y:r})};this._resizeBuffer();const c=zu(this.gl),d=ju(this.gl,[n,r],!0),g=[d.x+Math.floor(d.width/2),d.y+Math.floor(d.height/2)],f=Math.round(s*c),{width:p,height:m}=this.pickingFBO,y=this._getPickingRect({deviceX:g[0],deviceY:g[1],deviceRadius:f,deviceWidth:p,deviceHeight:m});let b;const P=[],v=new Set;for(let s=0;s<o;s++){const d=If({...y&&this._drawAndSample({layers:t,views:e,viewports:i,onViewportActive:h,deviceRect:y,effects:u,pass:"picking:".concat(a),redrawReason:a}),deviceX:g[0],deviceY:g[1],deviceRadius:f,deviceRect:y});let p;if(d.pickedLayer&&l&&this.depthFBO){p=this._drawAndSample({layers:[d.pickedLayer],views:e,viewports:i,onViewportActive:h,deviceRect:{x:d.pickedX,y:d.pickedY,width:1,height:1},effects:u,pass:"picking:".concat(a),redrawReason:"pick-z",pickZ:!0}).pickedColors[0]}d.pickedLayer&&s+1<o&&(v.add(d.pickedLayer),d.pickedLayer.disablePickingIndex(d.pickedObjectIndex)),b=_f({pickInfo:d,lastPickedInfo:this.lastPickedInfo,mode:a,layers:t,viewports:i,x:n,y:r,z:p,pixelRatio:c});for(const t of b.values())t.layer&&P.push(t);if(!d.pickedColor)break}for(const t of v)t.restorePickingColors();return{result:P,emptyInfo:b&&b.get(null)}}_pickVisibleObjects({layers:t,views:e,viewports:i,x:n,y:r,width:s=1,height:o=1,mode:a="query",maxObjects:l=null,onViewportActive:h,effects:u}){if(!(t=this._getPickable(t)))return[];this._resizeBuffer();const c=zu(this.gl),d=ju(this.gl,[n,r],!0),g=d.x,f=d.y+d.height,p=ju(this.gl,[n+s,r+o],!0),m=p.x+p.width,y=p.y,b={x:g,y:y,width:m-g,height:f-y},P=function({pickedColors:t,decodePickingColor:e}){const i=new Map;if(t)for(let n=0;n<t.length;n+=4){if(t[n+3]-1>=0){const r=t.slice(n,n+4),s=r.join(",");if(!i.has(s)){const t=e(r);t?i.set(s,{...t,pickedColor:r}):Ta.error("Picked non-existent layer. Is picking buffer corrupt?")()}}}return Array.from(i.values())}(this._drawAndSample({layers:t,views:e,viewports:i,onViewportActive:h,deviceRect:b,effects:u,pass:"picking:".concat(a),redrawReason:a})),v=new Map,S=Number.isFinite(l);for(let t=0;t<P.length&&!(S&&v.size>=l);t++){const e=P[t];let i={color:e.pickedColor,layer:null,index:e.pickedObjectIndex,picked:!0,x:n,y:r,width:s,height:o,pixelRatio:c};i=Lf({layer:e.pickedLayer,info:i,mode:a}),v.has(i.object)||v.set(i.object,i)}return Array.from(v.values())}_drawAndSample({layers:t,views:e,viewports:i,onViewportActive:n,deviceRect:r,effects:s,pass:o,redrawReason:a,pickZ:l}){const h=l?this.depthFBO:this.pickingFBO,{decodePickingColor:u}=this.pickLayersPass.render({layers:t,layerFilter:this.layerFilter,views:e,viewports:i,onViewportActive:n,pickingFBO:h,deviceRect:r,effects:s,pass:o,redrawReason:a,pickZ:l}),{x:c,y:d,width:g,height:f}=r,p=new(l?Float32Array:Uint8Array)(g*f*4);return Nc(h,{sourceX:c,sourceY:d,sourceWidth:g,sourceHeight:f,target:p}),{pickedColors:p,decodePickingColor:u}}_getPickingRect({deviceX:t,deviceY:e,deviceRadius:i,deviceWidth:n,deviceHeight:r}){const s=Math.max(0,t-i),o=Math.max(0,e-i),a=Math.min(n,t+i+1)-s,l=Math.min(r,e+i+1)-o;return a<=0||l<=0?null:{x:s,y:o,width:a,height:l}}}const Bf={zIndex:1,position:"absolute",pointerEvents:"none",color:"#a0a7b4",backgroundColor:"#29323c",padding:"10px",top:0,left:0,display:"none"};class Mf{constructor(t){const e=t.parentElement;e&&(this.el=document.createElement("div"),this.el.className="deck-tooltip",Object.assign(this.el.style,Bf),e.appendChild(this.el)),this.isVisible=!1}setTooltip(t,e,i){const n=this.el;if("string"==typeof t)n.innerText=t;else{if(!t)return this.isVisible=!1,void(n.style.display="none");"text"in t&&(n.innerText=t.text),"html"in t&&(n.innerHTML=t.html),"className"in t&&(n.className=t.className),Object.assign(n.style,t.style)}this.isVisible=!0,n.style.display="block",n.style.transform="translate(".concat(e,"px, ").concat(i,"px)")}remove(){this.el&&this.el.remove()}}const{_parseImageNode:Ff}=globalThis,Df="undefined"!=typeof Image,Nf="undefined"!=typeof ImageBitmap,kf=Boolean(Ff),Vf=!!Fl.a||kf;function Gf(t){const e=jf(t);if(!e)throw new Error("Not an image");return e}function zf(t){switch(Gf(t)){case"data":return t;case"image":case"imagebitmap":const e=document.createElement("canvas"),i=e.getContext("2d");if(!i)throw new Error("getImageData");return e.width=t.width,e.height=t.height,i.drawImage(t,0,0),i.getImageData(0,0,t.width,t.height);default:throw new Error("getImageData")}}function jf(t){return"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?"imagebitmap":"undefined"!=typeof Image&&t instanceof Image?"image":t&&"object"==typeof t&&t.data&&t.width&&t.height?"data":null}const Uf=/^data:image\/svg\+xml/,Wf=/\.svg((\?|#).*)?$/;function Hf(t){return t&&(Uf.test(t)||Wf.test(t))}function qf(t,e){if(Hf(e))throw new Error("SVG cannot be parsed directly to imagebitmap");return new Blob([new Uint8Array(t)])}async function Xf(t,e,i){const n=function(t,e){if(Hf(e)){let e=(new TextDecoder).decode(t);try{"function"==typeof unescape&&"function"==typeof encodeURIComponent&&(e=unescape(encodeURIComponent(e)))}catch(t){throw new Error(t.message)}return"data:image/svg+xml;base64,".concat(btoa(e))}return qf(t,e)}(t,i),r=self.URL||self.webkitURL,s="string"!=typeof n&&r.createObjectURL(n);try{return await async function(t,e){const i=new Image;if(i.src=t,e.image&&e.image.decode&&i.decode)return await i.decode(),i;return await new Promise((e,n)=>{try{i.onload=()=>e(i),i.onerror=e=>n(new Error("Could not load image ".concat(t,": ").concat(e)))}catch(t){n(t)}})}(s||n,e)}finally{s&&r.revokeObjectURL(s)}}const Yf={};let Qf=!0;async function Zf(t,e,i){let n;if(Hf(i)){n=await Xf(t,e,i)}else n=qf(t,i);const r=e&&e.imagebitmap;return await async function(t,e=null){!function(t){for(const e in t||Yf)return!1;return!0}(e)&&Qf||(e=null);if(e)try{return await createImageBitmap(t,e)}catch(t){console.warn(t),Qf=!1}return await createImageBitmap(t)}(n,r)}function Kf(t){const e=$f(t);return function(t){const e=$f(t);if(!(e.byteLength>=24&&2303741511===e.getUint32(0,!1)))return null;return{mimeType:"image/png",width:e.getUint32(16,!1),height:e.getUint32(20,!1)}}(e)||function(t){const e=$f(t);if(!(e.byteLength>=3&&65496===e.getUint16(0,!1)&&255===e.getUint8(2)))return null;const{tableMarkers:i,sofMarkers:n}=function(){const t=new Set([65499,65476,65484,65501,65534]);for(let e=65504;e<65520;++e)t.add(e);const e=new Set([65472,65473,65474,65475,65477,65478,65479,65481,65482,65483,65485,65486,65487,65502]);return{tableMarkers:t,sofMarkers:e}}();let r=2;for(;r+9<e.byteLength;){const t=e.getUint16(r,!1);if(n.has(t))return{mimeType:"image/jpeg",height:e.getUint16(r+5,!1),width:e.getUint16(r+7,!1)};if(!i.has(t))return null;r+=2,r+=e.getUint16(r,!1)}return null}(e)||function(t){const e=$f(t);if(!(e.byteLength>=10&&1195984440===e.getUint32(0,!1)))return null;return{mimeType:"image/gif",width:e.getUint16(6,!0),height:e.getUint16(8,!0)}}(e)||function(t){const e=$f(t);if(!(e.byteLength>=14&&16973===e.getUint16(0,!1)&&e.getUint32(2,!0)===e.byteLength))return null;return{mimeType:"image/bmp",width:e.getUint32(18,!0),height:e.getUint32(22,!0)}}(e)}function $f(t){if(t instanceof DataView)return t;if(ArrayBuffer.isView(t))return new DataView(t.buffer);if(t instanceof ArrayBuffer)return new DataView(t);throw new Error("toDataView")}const Jf={id:"image",module:"images",name:"Images",version:"3.1.8",mimeTypes:["image/png","image/jpeg","image/gif","image/webp","image/bmp","image/vnd.microsoft.icon","image/svg+xml"],extensions:["png","jpg","jpeg","gif","webp","bmp","ico","svg"],parse:async function(t,e,i){const n=((e=e||{}).image||{}).type||"auto",{url:r}=i||{};let s;switch(function(t){switch(t){case"auto":case"data":return function(){if(Nf)return"imagebitmap";if(Df)return"image";if(Vf)return"data";throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js")}();default:return function(t){switch(t){case"auto":return Nf||Df||Vf;case"imagebitmap":return Nf;case"image":return Df;case"data":return Vf;default:throw new Error("@loaders.gl/images: image ".concat(t," not supported in this environment"))}}(t),t}}(n)){case"imagebitmap":s=await Zf(t,e,r);break;case"image":s=await Xf(t,e,r);break;case"data":s=await async function(t,e){const{mimeType:i}=Kf(t)||{},n=globalThis._parseImageNode;return Wa(n),await n(t,i)}(t);break;default:Wa(!1)}return"data"===n&&(s=zf(s)),s},tests:[t=>Boolean(Kf(new DataView(t)))],options:{image:{type:"auto",decode:!0}}};var tp={name:"JSON",extensions:["json","geojson"],mimeTypes:["application/json","application/geo+json"],testText:function(t){const e=t[0],i=t[t.length-1];return"{"===e&&"}"===i||"["===e&&"]"===i},parseTextSync:JSON.parse};const ep=globalThis.deck&&globalThis.deck.VERSION;if(ep&&"8.7.2"!==ep)throw new Error("deck.gl - multiple versions detected: ".concat(ep," vs ").concat("8.7.2"));ep||(Ta.log(1,"deck.gl ".concat("8.7.2"))(),globalThis.deck={...globalThis.deck,VERSION:"8.7.2",version:"8.7.2",log:Ta,_registerLoggers:function(t){Ia=t}},function(t){const e=Wl();t=Array.isArray(t)?t:[t];for(const i of t){const t=qa(i);e.find(e=>t===e)||e.unshift(t)}}([tp,[Jf,{imagebitmap:{premultiplyAlpha:"none"}}]]));var ip=globalThis.deck,np=i(51);class rp extends ac{static isSupported(t,e=[]){const i=Object(Du.e)(t),n=Uc(t,Gc);let r=i||n;for(const t of e)switch(t){case"queries":r=r&&i;break;case"timers":r=r&&n;break;default:$u(!1)}return r}constructor(t,e={}){super(t,e),this.target=null,this._queryPending=!1,this._pollingPromise=null,Object.seal(this)}beginTimeElapsedQuery(){return this.begin(35007)}beginOcclusionQuery({conservative:t=!1}={}){return this.begin(t?36202:35887)}beginTransformFeedbackQuery(){return this.begin(35976)}begin(t){return this._queryPending||(this.target=t,this.gl2.beginQuery(this.target,this.handle)),this}end(){return this._queryPending||this.target&&(this.gl2.endQuery(this.target),this.target=null,this._queryPending=!0),this}isResultAvailable(){if(!this._queryPending)return!1;const t=this.gl2.getQueryParameter(this.handle,34919);return t&&(this._queryPending=!1),t}isTimerDisjoint(){return this.gl2.getParameter(36795)}getResult(){return this.gl2.getQueryParameter(this.handle,34918)}getTimerMilliseconds(){return this.getResult()/1e6}createPoll(t=Number.POSITIVE_INFINITY){if(this._pollingPromise)return this._pollingPromise;let e=0;return this._pollingPromise=new Promise((i,n)=>{const r=()=>{this.isResultAvailable()?(i(this.getResult()),this._pollingPromise=null):e++>t?(n("Timed out"),this._pollingPromise=null):requestAnimationFrame(r)};requestAnimationFrame(r)}),this._pollingPromise}_createHandle(){return rp.isSupported(this.gl)?this.gl2.createQuery():null}_deleteHandle(){this.gl2.deleteQuery(this.handle)}}const sp=Object(Vu.isBrowser)()&&"undefined"!=typeof document;let op=0;class ap{constructor(t={}){const{onCreateContext:e=(t=>Yu(t)),onAddHTML:i=null,onInitialize:n=(()=>{}),onRender:r=(()=>{}),onFinalize:s=(()=>{}),onError:o,gl:a=null,glOptions:l={},debug:h=!1,createFramebuffer:u=!1,autoResizeViewport:c=!0,autoResizeDrawingBuffer:d=!0,stats:g=Ku.get("animation-loop-"+op++)}=t;let{useDevicePixels:f=!0}=t;"useDevicePixelRatio"in t&&(Fu.deprecated("useDevicePixelRatio","useDevicePixels")(),f=t.useDevicePixelRatio),this.props={onCreateContext:e,onAddHTML:i,onInitialize:n,onRender:r,onFinalize:s,onError:o,gl:a,glOptions:l,debug:h,createFramebuffer:u},this.gl=a,this.needsRedraw=null,this.timeline=null,this.stats=g,this.cpuTime=this.stats.get("CPU Time"),this.gpuTime=this.stats.get("GPU Time"),this.frameRate=this.stats.get("Frame Rate"),this._initialized=!1,this._running=!1,this._animationFrameId=null,this._nextFramePromise=null,this._resolveNextFrame=null,this._cpuStartTime=0,this.setProps({autoResizeViewport:c,autoResizeDrawingBuffer:d,useDevicePixels:f}),this.start=this.start.bind(this),this.stop=this.stop.bind(this),this._pageLoadPromise=null,this._onMousemove=this._onMousemove.bind(this),this._onMouseleave=this._onMouseleave.bind(this)}delete(){this.stop(),this._setDisplay(null)}setNeedsRedraw(t){return $u("string"==typeof t),this.needsRedraw=this.needsRedraw||t,this}setProps(t){return"autoResizeViewport"in t&&(this.autoResizeViewport=t.autoResizeViewport),"autoResizeDrawingBuffer"in t&&(this.autoResizeDrawingBuffer=t.autoResizeDrawingBuffer),"useDevicePixels"in t&&(this.useDevicePixels=t.useDevicePixels),this}start(t={}){if(this._running)return this;this._running=!0;const e=this._getPageLoadPromise().then(()=>!this._running||this._initialized?null:(this._createWebGLContext(t),this._createFramebuffer(),this._startEventHandling(),this._initializeCallbackData(),this._updateCallbackData(),this._resizeCanvasDrawingBuffer(),this._resizeViewport(),this._gpuTimeQuery=rp.isSupported(this.gl,["timers"])?new rp(this.gl):null,this._initialized=!0,this.onInitialize(this.animationProps))).then(t=>{this._running&&(this._addCallbackData(t||{}),!1!==t&&this._startLoop())});return this.props.onError&&e.catch(this.props.onError),this}redraw(){return this.isContextLost()||(this._beginTimers(),this._setupFrame(),this._updateCallbackData(),this._renderFrame(this.animationProps),this._clearNeedsRedraw(),this.offScreen&&this.gl.commit&&this.gl.commit(),this._resolveNextFrame&&(this._resolveNextFrame(this),this._nextFramePromise=null,this._resolveNextFrame=null),this._endTimers()),this}stop(){return this._running&&(this._finalizeCallbackData(),this._cancelAnimationFrame(this._animationFrameId),this._nextFramePromise=null,this._resolveNextFrame=null,this._animationFrameId=null,this._running=!1),this}attachTimeline(t){return this.timeline=t,this.timeline}detachTimeline(){this.timeline=null}waitForRender(){return this.setNeedsRedraw("waitForRender"),this._nextFramePromise||(this._nextFramePromise=new Promise(t=>{this._resolveNextFrame=t})),this._nextFramePromise}async toDataURL(){return this.setNeedsRedraw("toDataURL"),await this.waitForRender(),this.gl.canvas.toDataURL()}isContextLost(){return this.gl.isContextLost()}onCreateContext(...t){return this.props.onCreateContext(...t)}onInitialize(...t){return this.props.onInitialize(...t)}onRender(...t){return this.props.onRender(...t)}onFinalize(...t){return this.props.onFinalize(...t)}getHTMLControlValue(t,e=1){const i=document.getElementById(t);return i?Number(i.value):e}setViewParameters(){return Fu.removed("AnimationLoop.setViewParameters","AnimationLoop.setProps")(),this}_startLoop(){const t=()=>{this._running&&(this.redraw(),this._animationFrameId=this._requestAnimationFrame(t))};this._cancelAnimationFrame(this._animationFrameId),this._animationFrameId=this._requestAnimationFrame(t)}_getPageLoadPromise(){return this._pageLoadPromise||(this._pageLoadPromise=sp?new Promise((t,e)=>{sp&&"complete"===document.readyState?t(document):window.addEventListener("load",()=>{t(document)})}):Promise.resolve({})),this._pageLoadPromise}_setDisplay(t){this.display&&(this.display.delete(),this.display.animationLoop=null),t&&(t.animationLoop=this),this.display=t}_cancelAnimationFrame(t){return this.display&&this.display.cancelAnimationFrame?this.display.cancelAnimationFrame(t):(e=t,"undefined"!=typeof window&&window.cancelAnimationFrame?window.cancelAnimationFrame(e):clearTimeout(e));var e}_requestAnimationFrame(t){if(this._running)return this.display&&this.display.requestAnimationFrame?this.display.requestAnimationFrame(t):(e=t,"undefined"!=typeof window&&window.requestAnimationFrame?window.requestAnimationFrame(e):setTimeout(e,1e3/60));var e}_renderFrame(...t){this.display?this.display._renderFrame(...t):this.onRender(...t)}_clearNeedsRedraw(){this.needsRedraw=null}_setupFrame(){this._resizeCanvasDrawingBuffer(),this._resizeViewport(),this._resizeFramebuffer()}_initializeCallbackData(){this.animationProps={gl:this.gl,stop:this.stop,canvas:this.gl.canvas,framebuffer:this.framebuffer,useDevicePixels:this.useDevicePixels,needsRedraw:null,startTime:Date.now(),engineTime:0,tick:0,tock:0,time:0,_timeline:this.timeline,_loop:this,_animationLoop:this,_mousePosition:null}}_updateCallbackData(){const{width:t,height:e,aspect:i}=this._getSizeAndAspect();t===this.animationProps.width&&e===this.animationProps.height||this.setNeedsRedraw("drawing buffer resized"),i!==this.animationProps.aspect&&this.setNeedsRedraw("drawing buffer aspect changed"),this.animationProps.width=t,this.animationProps.height=e,this.animationProps.aspect=i,this.animationProps.needsRedraw=this.needsRedraw,this.animationProps.engineTime=Date.now()-this.animationProps.startTime,this.timeline&&this.timeline.update(this.animationProps.engineTime),this.animationProps.tick=Math.floor(this.animationProps.time/1e3*60),this.animationProps.tock++,this.animationProps.time=this.timeline?this.timeline.getTime():this.animationProps.engineTime,this.animationProps._offScreen=this.offScreen}_finalizeCallbackData(){this.onFinalize(this.animationProps)}_addCallbackData(t){"object"==typeof t&&null!==t&&(this.animationProps=Object.assign({},this.animationProps,t))}_createWebGLContext(t){if(this.offScreen=t.canvas&&"undefined"!=typeof OffscreenCanvas&&t.canvas instanceof OffscreenCanvas,t=Object.assign({},t,this.props.glOptions),this.gl=this.props.gl?Qu(this.props.gl,t):this.onCreateContext(t),!Object(Du.d)(this.gl))throw new Error("AnimationLoop.onCreateContext - illegal context returned");Object(Nu.b)(this.gl),this._createInfoDiv()}_createInfoDiv(){if(this.gl.canvas&&this.props.onAddHTML){const t=document.createElement("div");document.body.appendChild(t),t.style.position="relative";const e=document.createElement("div");e.style.position="absolute",e.style.left="10px",e.style.bottom="10px",e.style.width="300px",e.style.background="white",t.appendChild(this.gl.canvas),t.appendChild(e);const i=this.props.onAddHTML(e);i&&(e.innerHTML=i)}}_getSizeAndAspect(){const t=this.gl.drawingBufferWidth,e=this.gl.drawingBufferHeight;let i=1;const{canvas:n}=this.gl;return n&&n.clientHeight?i=n.clientWidth/n.clientHeight:t>0&&e>0&&(i=t/e),{width:t,height:e,aspect:i}}_resizeViewport(){this.autoResizeViewport&&this.gl.viewport(0,0,this.gl.drawingBufferWidth,this.gl.drawingBufferHeight)}_resizeCanvasDrawingBuffer(){this.autoResizeDrawingBuffer&&Zu(this.gl,{useDevicePixels:this.useDevicePixels})}_createFramebuffer(){this.props.createFramebuffer&&(this.framebuffer=new Hc(this.gl))}_resizeFramebuffer(){this.framebuffer&&this.framebuffer.resize({width:this.gl.drawingBufferWidth,height:this.gl.drawingBufferHeight})}_beginTimers(){this.frameRate.timeEnd(),this.frameRate.timeStart(),this._gpuTimeQuery&&this._gpuTimeQuery.isResultAvailable()&&!this._gpuTimeQuery.isTimerDisjoint()&&this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds()),this._gpuTimeQuery&&this._gpuTimeQuery.beginTimeElapsedQuery(),this.cpuTime.timeStart()}_endTimers(){this.cpuTime.timeEnd(),this._gpuTimeQuery&&this._gpuTimeQuery.end()}_startEventHandling(){const{canvas:t}=this.gl;t&&(t.addEventListener("mousemove",this._onMousemove),t.addEventListener("mouseleave",this._onMouseleave))}_onMousemove(t){this.animationProps._mousePosition=[t.offsetX,t.offsetY]}_onMouseleave(t){this.animationProps._mousePosition=null}}var lp=i(37),hp=i.n(lp);const up={mousedown:1,mousemove:2,mouseup:4};!function(t){const e=t.prototype.handler;t.prototype.handler=function(t){const i=this.store;t.button>0&&"pointerdown"===t.type&&(function(t,e){for(let i=0;i<t.length;i++)if(e(t[i]))return!0;return!1}(i,e=>e.pointerId===t.pointerId)||i.push(t)),e.call(this,t)}}(hp.a.PointerEventInput),hp.a.MouseInput.prototype.handler=function(t){let e=up[t.type];1&e&&t.button>=0&&(this.pressed=!0),2&e&&0===t.which&&(e=4),this.pressed&&(4&e&&(this.pressed=!1),this.callback(this.manager,e,{pointers:[t],changedPointers:[t],pointerType:"mouse",srcEvent:t}))};const cp=hp.a.Manager;var dp=hp.a;const gp=dp?[[dp.Pan,{event:"tripan",pointers:3,threshold:0,enable:!1}],[dp.Rotate,{enable:!1}],[dp.Pinch,{enable:!1}],[dp.Swipe,{enable:!1}],[dp.Pan,{threshold:0,enable:!1}],[dp.Press,{enable:!1}],[dp.Tap,{event:"doubletap",taps:2,enable:!1}],[dp.Tap,{event:"anytap",enable:!1}],[dp.Tap,{enable:!1}]]:null,fp={tripan:["rotate","pinch","pan"],rotate:["pinch"],pinch:["pan"],pan:["press","doubletap","anytap","tap"],doubletap:["anytap"],anytap:["tap"]},pp={doubletap:["tap"]},mp={pointerdown:"pointerdown",pointermove:"pointermove",pointerup:"pointerup",touchstart:"pointerdown",touchmove:"pointermove",touchend:"pointerup",mousedown:"pointerdown",mousemove:"pointermove",mouseup:"pointerup"},yp={KEY_EVENTS:["keydown","keyup"],MOUSE_EVENTS:["mousedown","mousemove","mouseup","mouseover","mouseout","mouseleave"],WHEEL_EVENTS:["wheel","mousewheel"]},bp={tap:"tap",anytap:"anytap",doubletap:"doubletap",press:"press",pinch:"pinch",pinchin:"pinch",pinchout:"pinch",pinchstart:"pinch",pinchmove:"pinch",pinchend:"pinch",pinchcancel:"pinch",rotate:"rotate",rotatestart:"rotate",rotatemove:"rotate",rotateend:"rotate",rotatecancel:"rotate",tripan:"tripan",tripanstart:"tripan",tripanmove:"tripan",tripanup:"tripan",tripandown:"tripan",tripanleft:"tripan",tripanright:"tripan",tripanend:"tripan",tripancancel:"tripan",pan:"pan",panstart:"pan",panmove:"pan",panup:"pan",pandown:"pan",panleft:"pan",panright:"pan",panend:"pan",pancancel:"pan",swipe:"swipe",swipeleft:"swipe",swiperight:"swipe",swipeup:"swipe",swipedown:"swipe"},Pp={click:"tap",anyclick:"anytap",dblclick:"doubletap",mousedown:"pointerdown",mousemove:"pointermove",mouseup:"pointerup",mouseover:"pointerover",mouseout:"pointerout",mouseleave:"pointerleave"};var vp=i(27);const Sp=-1!==vp.b.indexOf("firefox"),{WHEEL_EVENTS:Cp}=yp;class wp{constructor(t,e,i={}){this.element=t,this.callback=e,this.options=Object.assign({enable:!0},i),this.events=Cp.concat(i.events||[]),this.handleEvent=this.handleEvent.bind(this),this.events.forEach(e=>t.addEventListener(e,this.handleEvent,!!vp.a&&{passive:!1}))}destroy(){this.events.forEach(t=>this.element.removeEventListener(t,this.handleEvent))}enableEventType(t,e){"wheel"===t&&(this.options.enable=e)}handleEvent(t){if(!this.options.enable)return;let e=t.deltaY;vp.c.WheelEvent&&(Sp&&t.deltaMode===vp.c.WheelEvent.DOM_DELTA_PIXEL&&(e/=vp.c.devicePixelRatio),t.deltaMode===vp.c.WheelEvent.DOM_DELTA_LINE&&(e*=40));const i={x:t.clientX,y:t.clientY};0!==e&&e%4.000244140625==0&&(e=Math.floor(e/4.000244140625)),t.shiftKey&&e&&(e*=.25),this._onWheel(t,-e,i)}_onWheel(t,e,i){this.callback({type:"wheel",center:i,delta:e,srcEvent:t,pointerType:"mouse",target:t.target})}}const{MOUSE_EVENTS:Ep}=yp;class xp{constructor(t,e,i={}){this.element=t,this.callback=e,this.pressed=!1,this.options=Object.assign({enable:!0},i),this.enableMoveEvent=this.options.enable,this.enableLeaveEvent=this.options.enable,this.enableOutEvent=this.options.enable,this.enableOverEvent=this.options.enable,this.events=Ep.concat(i.events||[]),this.handleEvent=this.handleEvent.bind(this),this.events.forEach(e=>t.addEventListener(e,this.handleEvent))}destroy(){this.events.forEach(t=>this.element.removeEventListener(t,this.handleEvent))}enableEventType(t,e){"pointermove"===t&&(this.enableMoveEvent=e),"pointerover"===t&&(this.enableOverEvent=e),"pointerout"===t&&(this.enableOutEvent=e),"pointerleave"===t&&(this.enableLeaveEvent=e)}handleEvent(t){this.handleOverEvent(t),this.handleOutEvent(t),this.handleLeaveEvent(t),this.handleMoveEvent(t)}handleOverEvent(t){this.enableOverEvent&&"mouseover"===t.type&&this.callback({type:"pointerover",srcEvent:t,pointerType:"mouse",target:t.target})}handleOutEvent(t){this.enableOutEvent&&"mouseout"===t.type&&this.callback({type:"pointerout",srcEvent:t,pointerType:"mouse",target:t.target})}handleLeaveEvent(t){this.enableLeaveEvent&&"mouseleave"===t.type&&this.callback({type:"pointerleave",srcEvent:t,pointerType:"mouse",target:t.target})}handleMoveEvent(t){if(this.enableMoveEvent)switch(t.type){case"mousedown":t.button>=0&&(this.pressed=!0);break;case"mousemove":0===t.which&&(this.pressed=!1),this.pressed||this.callback({type:"pointermove",srcEvent:t,pointerType:"mouse",target:t.target});break;case"mouseup":this.pressed=!1}}}const{KEY_EVENTS:Ap}=yp;class Tp{constructor(t,e,i={}){this.element=t,this.callback=e,this.options=Object.assign({enable:!0},i),this.enableDownEvent=this.options.enable,this.enableUpEvent=this.options.enable,this.events=Ap.concat(i.events||[]),this.handleEvent=this.handleEvent.bind(this),t.tabIndex=i.tabIndex||0,t.style.outline="none",this.events.forEach(e=>t.addEventListener(e,this.handleEvent))}destroy(){this.events.forEach(t=>this.element.removeEventListener(t,this.handleEvent))}enableEventType(t,e){"keydown"===t&&(this.enableDownEvent=e),"keyup"===t&&(this.enableUpEvent=e)}handleEvent(t){const e=t.target||t.srcElement;"INPUT"===e.tagName&&"text"===e.type||"TEXTAREA"===e.tagName||(this.enableDownEvent&&"keydown"===t.type&&this.callback({type:"keydown",srcEvent:t,key:t.key,target:t.target}),this.enableUpEvent&&"keyup"===t.type&&this.callback({type:"keyup",srcEvent:t,key:t.key,target:t.target}))}}class Ip{constructor(t,e,i={}){this.element=t,this.callback=e,this.options=Object.assign({enable:!0},i),this.handleEvent=this.handleEvent.bind(this),t.addEventListener("contextmenu",this.handleEvent)}destroy(){this.element.removeEventListener("contextmenu",this.handleEvent)}enableEventType(t,e){"contextmenu"===t&&(this.options.enable=e)}handleEvent(t){this.options.enable&&this.callback({type:"contextmenu",center:{x:t.clientX,y:t.clientY},srcEvent:t,pointerType:"mouse",target:t.target})}}const Op={pointerdown:1,pointermove:2,pointerup:4,mousedown:1,mousemove:2,mouseup:4};const _p={srcElement:"root",priority:0};class Lp{constructor(t){this.eventManager=t,this.handlers=[],this.handlersByElement=new Map,this.handleEvent=this.handleEvent.bind(this),this._active=!1}isEmpty(){return!this._active}add(t,e,i,n=!1,r=!1){const{handlers:s,handlersByElement:o}=this;i&&("object"!=typeof i||i.addEventListener)&&(i={srcElement:i}),i=i?Object.assign({},_p,i):_p;let a=o.get(i.srcElement);a||(a=[],o.set(i.srcElement,a));const l={type:t,handler:e,srcElement:i.srcElement,priority:i.priority};n&&(l.once=!0),r&&(l.passive=!0),s.push(l),this._active=this._active||!l.passive;let h=a.length-1;for(;h>=0&&!(a[h].priority>=l.priority);)h--;a.splice(h+1,0,l)}remove(t,e){const{handlers:i,handlersByElement:n}=this;for(let r=i.length-1;r>=0;r--){const s=i[r];if(s.type===t&&s.handler===e){i.splice(r,1);const t=n.get(s.srcElement);t.splice(t.indexOf(s),1),0===t.length&&n.delete(s.srcElement)}}this._active=i.some(t=>!t.passive)}handleEvent(t){if(this.isEmpty())return;const e=this._normalizeEvent(t);let i=t.srcEvent.target;for(;i&&i!==e.rootElement;){if(this._emit(e,i),e.handled)return;i=i.parentNode}this._emit(e,"root")}_emit(t,e){const i=this.handlersByElement.get(e);if(i){let e=!1;const n=()=>{t.handled=!0},r=()=>{t.handled=!0,e=!0},s=[];for(let o=0;o<i.length;o++){const{type:a,handler:l,once:h}=i[o];if(l(Object.assign({},t,{type:a,stopPropagation:n,stopImmediatePropagation:r})),h&&s.push(i[o]),e)break}for(let t=0;t<s.length;t++){const{type:e,handler:i}=s[t];this.remove(e,i)}}}_normalizeEvent(t){const e=this.eventManager.element;return Object.assign({},t,function(t){const e=Op[t.srcEvent.type];if(!e)return null;const{buttons:i,button:n,which:r}=t.srcEvent;let s=!1,o=!1,a=!1;return 4===e||2===e&&!Number.isFinite(i)?(s=1===r,o=2===r,a=3===r):2===e?(s=Boolean(1&i),o=Boolean(4&i),a=Boolean(2&i)):1===e&&(s=0===n,o=1===n,a=2===n),{leftButton:s,middleButton:o,rightButton:a}}(t),function(t,e){const{srcEvent:i}=t;if(!t.center&&!Number.isFinite(i.clientX))return null;const n=t.center||{x:i.clientX,y:i.clientY},r=e.getBoundingClientRect(),s=r.width/e.offsetWidth||1,o=r.height/e.offsetHeight||1;return{center:n,offsetCenter:{x:(n.x-r.left-e.clientLeft)/s,y:(n.y-r.top-e.clientTop)/o}}}(t,e),{handled:!1,rootElement:e})}}const Rp={events:null,recognizers:null,recognizerOptions:{},Manager:cp,touchAction:"none",tabIndex:0};class Bp{constructor(t=null,e={}){this.options=Object.assign({},Rp,e),this.events=new Map,this._onBasicInput=this._onBasicInput.bind(this),this._onOtherEvent=this._onOtherEvent.bind(this),this.setElement(t);const{events:i}=e;i&&this.on(i)}setElement(t){if(this.element&&this.destroy(),this.element=t,!t)return;const{options:e}=this,i=e.Manager;this.manager=new i(t,{touchAction:e.touchAction,recognizers:e.recognizers||gp}).on("hammer.input",this._onBasicInput),e.recognizers||Object.keys(fp).forEach(t=>{const e=this.manager.get(t);e&&fp[t].forEach(t=>{e.recognizeWith(t)})});for(const t in e.recognizerOptions){const i=this.manager.get(t);if(i){const n=e.recognizerOptions[t];delete n.enable,i.set(n)}}this.wheelInput=new wp(t,this._onOtherEvent,{enable:!1}),this.moveInput=new xp(t,this._onOtherEvent,{enable:!1}),this.keyInput=new Tp(t,this._onOtherEvent,{enable:!1,tabIndex:e.tabIndex}),this.contextmenuInput=new Ip(t,this._onOtherEvent,{enable:!1});for(const[t,e]of this.events)e.isEmpty()||(this._toggleRecognizer(e.recognizerName,!0),this.manager.on(t,e.handleEvent))}destroy(){this.element&&(this.wheelInput.destroy(),this.moveInput.destroy(),this.keyInput.destroy(),this.contextmenuInput.destroy(),this.manager.destroy(),this.wheelInput=null,this.moveInput=null,this.keyInput=null,this.contextmenuInput=null,this.manager=null,this.element=null)}on(t,e,i){this._addEventHandler(t,e,i,!1)}once(t,e,i){this._addEventHandler(t,e,i,!0)}watch(t,e,i){this._addEventHandler(t,e,i,!1,!0)}off(t,e){this._removeEventHandler(t,e)}_toggleRecognizer(t,e){const{manager:i}=this;if(!i)return;const n=i.get(t);if(n&&n.options.enable!==e){n.set({enable:e});const r=pp[t];r&&!this.options.recognizers&&r.forEach(r=>{const s=i.get(r);e?(s.requireFailure(t),n.dropRequireFailure(r)):s.dropRequireFailure(t)})}this.wheelInput.enableEventType(t,e),this.moveInput.enableEventType(t,e),this.keyInput.enableEventType(t,e),this.contextmenuInput.enableEventType(t,e)}_addEventHandler(t,e,i,n,r){if("string"!=typeof t){i=e;for(const e in t)this._addEventHandler(e,t[e],i,n,r);return}const{manager:s,events:o}=this,a=Pp[t]||t;let l=o.get(a);l||(l=new Lp(this),o.set(a,l),l.recognizerName=bp[a]||a,s&&s.on(a,l.handleEvent)),l.add(t,e,i,n,r),l.isEmpty()||this._toggleRecognizer(l.recognizerName,!0)}_removeEventHandler(t,e){if("string"!=typeof t){for(const e in t)this._removeEventHandler(e,t[e]);return}const{events:i}=this,n=Pp[t]||t,r=i.get(n);if(r&&(r.remove(t,e),r.isEmpty())){const{recognizerName:t}=r;let e=!1;for(const n of i.values())if(n.recognizerName===t&&!n.isEmpty()){e=!0;break}e||this._toggleRecognizer(t,!1)}}_onBasicInput(t){const{srcEvent:e}=t,i=mp[e.type];i&&this.manager.emit(i,t)}_onOtherEvent(t){this.manager.emit(t.type,t)}}function Mp(){}const Fp={id:"",width:"100%",height:"100%",pickingRadius:0,layerFilter:null,glOptions:{},gl:null,layers:[],effects:[],views:null,controller:null,useDevicePixels:!0,touchAction:"none",eventRecognizerOptions:{},_framebuffer:null,_animate:!1,_pickable:!0,_typedArrayManagerProps:{},onWebGLInitialized:Mp,onResize:Mp,onViewStateChange:Mp,onInteractionStateChange:Mp,onBeforeRender:Mp,onAfterRender:Mp,onLoad:Mp,onError:(t,e)=>Ta.error(t)(),_onMetrics:null,getCursor:({isDragging:t})=>t?"grabbing":"grab",debug:!1,drawPickingColors:!1};class Dp{constructor(t){t={...Fp,...t},this.props={},this.width=0,this.height=0,this.viewManager=null,this.layerManager=null,this.effectManager=null,this.deckRenderer=null,this.deckPicker=null,this._needsRedraw=!0,this._pickRequest={},this._lastPointerDownInfo=null,this.viewState=null,this.interactiveState={isHovering:!1,isDragging:!1},this._onEvent=this._onEvent.bind(this),this._onPointerDown=this._onPointerDown.bind(this),this._onPointerMove=this._onPointerMove.bind(this),t.viewState&&t.initialViewState&&Ta.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(),"IE"===Object(np.a)()&&Ta.warn("IE 11 support will be deprecated in v8.0")(),t.gl||"undefined"!=typeof document&&(this.canvas=this._createCanvas(t)),this.animationLoop=this._createAnimationLoop(t),this.stats=new Ma({id:"deck.gl"}),this.metrics={fps:0,setPropsTime:0,updateAttributesTime:0,framesRedrawn:0,pickTime:0,pickCount:0,gpuTime:0,gpuTimePerFrame:0,cpuTime:0,cpuTimePerFrame:0,bufferMemory:0,textureMemory:0,renderbufferMemory:0,gpuMemory:0},this._metricsCounter=0,this.setProps(t),t._typedArrayManagerProps&&rh.setProps(t._typedArrayManagerProps),this.animationLoop.start()}finalize(){this.animationLoop.stop(),this.animationLoop=null,this._lastPointerDownInfo=null,this.layerManager&&(this.layerManager.finalize(),this.layerManager=null,this.viewManager.finalize(),this.viewManager=null,this.effectManager.finalize(),this.effectManager=null,this.deckRenderer.finalize(),this.deckRenderer=null,this.deckPicker.finalize(),this.deckPicker=null,this.eventManager.destroy(),this.eventManager=null,this.tooltip.remove(),this.tooltip=null),this.props.canvas||this.props.gl||!this.canvas||(this.canvas.parentElement.removeChild(this.canvas),this.canvas=null)}setProps(t){this.stats.get("setProps Time").timeStart(),"onLayerHover"in t&&Ta.removed("onLayerHover","onHover")(),"onLayerClick"in t&&Ta.removed("onLayerClick","onClick")(),t.initialViewState&&!Zd(this.props.initialViewState,t.initialViewState)&&(this.viewState=t.initialViewState),Object.assign(this.props,t),this._setCanvasSize(this.props);const e=Object.create(this.props);Object.assign(e,{views:this._getViews(),width:this.width,height:this.height,viewState:this._getViewState()}),this.animationLoop.setProps(e),this.layerManager&&(this.viewManager.setProps(e),this.layerManager.activateViewport(this.getViewports()[0]),this.layerManager.setProps(e),this.effectManager.setProps(e),this.deckRenderer.setProps(e),this.deckPicker.setProps(e)),this.stats.get("setProps Time").timeEnd()}needsRedraw(t={clearRedrawFlags:!1}){if(this.props._animate)return"Deck._animate";let e=this._needsRedraw;t.clearRedrawFlags&&(this._needsRedraw=!1);const i=this.viewManager.needsRedraw(t),n=this.layerManager.needsRedraw(t),r=this.effectManager.needsRedraw(t),s=this.deckRenderer.needsRedraw(t);return e=e||i||n||r||s,e}redraw(t){if(!this.layerManager)return;const e=t||this.needsRedraw({clearRedrawFlags:!0});e&&(this.stats.get("Redraw Count").incrementCount(),this.props._customRender?this.props._customRender(e):this._drawLayers(e))}getViews(){return this.viewManager.views}getViewports(t){return this.viewManager.getViewports(t)}pickObject(t){const e=this._pick("pickObject","pickObject Time",t).result;return e.length?e[0]:null}pickMultipleObjects(t){return t.depth=t.depth||10,this._pick("pickObject","pickMultipleObjects Time",t).result}pickObjects(t){return this._pick("pickObjects","pickObjects Time",t)}_addResources(t,e=!1){for(const i in t)this.layerManager.resourceManager.add({resourceId:i,data:t[i],forceUpdate:e})}_removeResources(t){for(const e of t)this.layerManager.resourceManager.remove(e)}_pick(t,e,i){const{stats:n}=this;n.get("Pick Count").incrementCount(),n.get(e).timeStart();const r=this.deckPicker[t]({layers:this.layerManager.getLayers(i),views:this.viewManager.getViews(),viewports:this.getViewports(i),onViewportActive:this.layerManager.activateViewport,effects:this.effectManager.getEffects(),...i});return n.get(e).timeEnd(),r}_createCanvas(t){let e=t.canvas;if("string"==typeof e&&(e=document.getElementById(e),eg(e)),!e){e=document.createElement("canvas"),e.id=t.id||"deckgl-overlay";(t.parent||document.body).appendChild(e)}return Object.assign(e.style,t.style),e}_setCanvasSize(t){if(!this.canvas)return;let{width:e,height:i}=t;(e||0===e)&&(e=Number.isFinite(e)?"".concat(e,"px"):e,this.canvas.style.width=e),(i||0===i)&&(i=Number.isFinite(i)?"".concat(i,"px"):i,this.canvas.style.position="absolute",this.canvas.style.height=i)}_updateCanvasSize(){if(this._checkForCanvasSizeChange()){const{width:t,height:e}=this;this.viewManager.setProps({width:t,height:e}),this.props.onResize({width:this.width,height:this.height})}}_checkForCanvasSizeChange(){const{canvas:t}=this;if(!t)return!1;const e=t.clientWidth||t.width,i=t.clientHeight||t.height;return(e!==this.width||i!==this.height)&&(this.width=e,this.height=i,!0)}_createAnimationLoop(t){const{width:e,height:i,gl:n,glOptions:r,debug:s,onError:o,onBeforeRender:a,onAfterRender:l,useDevicePixels:h,autoResizeDrawingBuffer:u}=t;return new ap({width:e,height:i,useDevicePixels:h,autoResizeDrawingBuffer:u,autoResizeViewport:!1,gl:n,onCreateContext:t=>Yu({...r,...t,canvas:this.canvas,debug:s,onContextLost:()=>this._onContextLost()}),onInitialize:t=>this._setGLContext(t.gl),onRender:this._onRenderFrame.bind(this),onBeforeRender:a,onAfterRender:l,onError:o})}_getViewState(){return this.props.viewState||this.viewState}_getViews(){let t=this.props.views||[new Mg({id:"default-view"})];return t=Array.isArray(t)?t:[t],t.length&&this.props.controller&&(t[0].props.controller=this.props.controller),t}_onContextLost(){const{onError:t}=this.props;this.animationLoop&&t&&t(new Error("WebGL context is lost"))}_onPointerMove(t){const{_pickRequest:e}=this;if("pointerleave"===t.type)e.x=-1,e.y=-1,e.radius=0;else{if(t.leftButton||t.rightButton)return;{const i=t.offsetCenter;if(!i)return;e.x=i.x,e.y=i.y,e.radius=this.props.pickingRadius}}this.layerManager&&(this.layerManager.context.mousePosition={x:e.x,y:e.y}),e.event=t,e.mode="hover"}_pickAndCallback(){const{_pickRequest:t}=this;if(t.event){const{result:e,emptyInfo:i}=this._pick("pickObject","pickObject Time",t);this.interactiveState.isHovering=e.length>0;let n=i,r=!1;for(const i of e)n=i,r=i.layer.onHover(i,t.event);if(!r&&this.props.onHover&&this.props.onHover(n,t.event),this.props.getTooltip){const t=this.props.getTooltip(n);this.tooltip.setTooltip(t,n.x,n.y)}t.event=null}}_updateCursor(){const t=this.props.parent||this.canvas;t&&(t.style.cursor=this.props.getCursor(this.interactiveState))}_setGLContext(t){if(this.layerManager)return;this.canvas||(this.canvas=t.canvas,Qu(t,{enable:!0,copyState:!0})),this.tooltip=new Mf(this.canvas),Object(Nu.c)(t,{blend:!0,blendFunc:[770,771,1,771],polygonOffsetFill:!0,depthTest:!0,depthFunc:515}),this.props.onWebGLInitialized(t);const e=new Ko;e.play(),this.animationLoop.attachTimeline(e),this.eventManager=new Bp(this.props.parent||t.canvas,{touchAction:this.props.touchAction,recognizerOptions:this.props.eventRecognizerOptions,events:{pointerdown:this._onPointerDown,pointermove:this._onPointerMove,pointerleave:this._onPointerMove}});for(const t in Xh)this.eventManager.on(t,this._onEvent);this.viewManager=new Kd({timeline:e,eventManager:this.eventManager,onViewStateChange:this._onViewStateChange.bind(this),onInteractionStateChange:this._onInteractionStateChange.bind(this),views:this._getViews(),viewState:this._getViewState(),width:this.width,height:this.height});const i=this.viewManager.getViewports()[0];this.layerManager=new Qd(t,{deck:this,stats:this.stats,viewport:i,timeline:e}),this.effectManager=new Sf,this.deckRenderer=new Af(t),this.deckPicker=new Rf(t),this.setProps(this.props),this._updateCanvasSize(),this.props.onLoad()}_drawLayers(t,e){const{gl:i}=this.layerManager.context;Object(Nu.c)(i,this.props.parameters),this.props.onBeforeRender({gl:i}),this.deckRenderer.renderLayers({target:this.props._framebuffer,layers:this.layerManager.getLayers(),viewports:this.viewManager.getViewports(),onViewportActive:this.layerManager.activateViewport,views:this.viewManager.getViews(),pass:"screen",redrawReason:t,effects:this.effectManager.getEffects(),...e}),this.props.onAfterRender({gl:i})}_onRenderFrame(t){this._getFrameStats(),this._metricsCounter++%60==0&&(this._getMetrics(),this.stats.reset(),Ta.table(4,this.metrics)(),this.props._onMetrics&&this.props._onMetrics(this.metrics)),this._updateCanvasSize(),this._updateCursor(),this.tooltip.isVisible&&this.viewManager.needsRedraw()&&this.tooltip.setTooltip(null),this.layerManager.updateLayers(),this._pickAndCallback(),this.redraw(!1),this.viewManager&&this.viewManager.updateViewStates()}_onViewStateChange(t){const e=this.props.onViewStateChange(t)||t.viewState;this.viewState&&(this.viewState={...this.viewState,[t.viewId]:e},this.props.viewState||this.viewManager&&this.viewManager.setProps({viewState:this.viewState}))}_onInteractionStateChange(t){this.interactiveState.isDragging=t.isDragging,this.props.onInteractionStateChange(t)}_onEvent(t){const e=Xh[t.type],i=t.offsetCenter;if(!e||!i)return;const n=this.layerManager.getLayers(),r=this.deckPicker.getLastPickedObject({x:i.x,y:i.y,layers:n,viewports:this.getViewports(i)},this._lastPointerDownInfo),{layer:s}=r,o=s&&(s[e.handler]||s.props[e.handler]),a=this.props[e.handler];let l=!1;o&&(l=o.call(s,r,t)),!l&&a&&a(r,t)}_onPointerDown(t){const e=t.offsetCenter,i=this._pick("pickObject","pickObject Time",{x:e.x,y:e.y,radius:this.props.pickingRadius});this._lastPointerDownInfo=i.result[0]||i.emptyInfo}_getFrameStats(){const{stats:t}=this;t.get("frameRate").timeEnd(),t.get("frameRate").timeStart();const e=this.animationLoop.stats;t.get("GPU Time").addTime(e.get("GPU Time").lastTiming),t.get("CPU Time").addTime(e.get("CPU Time").lastTiming)}_getMetrics(){const{metrics:t,stats:e}=this;t.fps=e.get("frameRate").getHz(),t.setPropsTime=e.get("setProps Time").time,t.updateAttributesTime=e.get("Update Attributes").time,t.framesRedrawn=e.get("Redraw Count").count,t.pickTime=e.get("pickObject Time").time+e.get("pickMultipleObjects Time").time+e.get("pickObjects Time").time,t.pickCount=e.get("Pick Count").count,t.gpuTime=e.get("GPU Time").time,t.cpuTime=e.get("CPU Time").time,t.gpuTimePerFrame=e.get("GPU Time").getAverageTime(),t.cpuTimePerFrame=e.get("CPU Time").getAverageTime();const i=Ku.get("Memory Usage");t.bufferMemory=i.get("Buffer Memory").count,t.textureMemory=i.get("Texture Memory").count,t.renderbufferMemory=i.get("Renderbuffer Memory").count,t.gpuMemory=i.get("GPU Memory").count}}Dp.getPropTypes=function(t){return{id:t.string,width:t.oneOfType([t.number,t.string]),height:t.oneOfType([t.number,t.string]),layers:t.oneOfType([t.object,t.array]),layerFilter:t.func,views:t.oneOfType([t.object,t.array]),viewState:t.object,effects:t.arrayOf(t.instanceOf(Wg)),controller:t.oneOfType([t.func,t.bool,t.object]),gl:t.object,glOptions:t.object,parameters:t.object,pickingRadius:t.number,useDevicePixels:t.oneOfType([t.bool,t.number]),touchAction:t.string,eventRecognizerOptions:t.object,onWebGLInitialized:t.func,onResize:t.func,onViewStateChange:t.func,onInteractionStateChange:t.func,onBeforeRender:t.func,onAfterRender:t.func,onLoad:t.func,onError:t.func,debug:t.bool,drawPickingColors:t.bool,_framebuffer:t.object,_animate:t.bool,_pickable:t.bool,_typedArrayManagerProps:t.object}},Dp.defaultProps=Fp,Dp.VERSION=ip.VERSION;class Np{constructor(t,e){this.opts=e,this.source=t}get value(){return this.source.value}getValue(){const t=this.source.getBuffer(),e=this.getAccessor();if(t)return[t,e];const{value:i}=this.source,{size:n}=e;let r=i;if(i&&i.length!==n){r=new Float32Array(n);const t=e.elementOffset||0;for(let e=0;e<n;++e)r[e]=i[t+e]}return r}getAccessor(){return{...this.source.getAccessor(),...this.opts}}}function kp(t){return t.stride||t.size*t.bytesPerElement}function Vp(t,e){e.offset&&Ta.removed("shaderAttribute.offset","vertexOffset, elementOffset")();const i=kp(t),n=("vertexOffset"in e?e.vertexOffset:t.vertexOffset||0)*i+(e.elementOffset||0)*t.bytesPerElement+(t.offset||0);return{...e,offset:n,stride:i}}const Gp=[],zp=[];function jp(t,e=0,i=1/0){let n=Gp;const r={index:-1,data:t,target:[]};return t?"function"==typeof t[Symbol.iterator]?n=t:t.length>0&&(zp.length=t.length,n=zp):n=Gp,(e>0||Number.isFinite(i))&&(n=(Array.isArray(n)?n:Array.from(n)).slice(e,i),r.index=e-1),{iterable:n,objectInfo:r}}function Up(t){return t&&t[Symbol.asyncIterator]}function Wp(t,e){const{size:i,stride:n,offset:r,startIndices:s,nested:o}=e,a=t.BYTES_PER_ELEMENT,l=n?n/a:i,h=r?r/a:0,u=Math.floor((t.length-h)/l);return(e,{index:n,target:r})=>{if(!s){const e=n*l+h;for(let n=0;n<i;n++)r[n]=t[e+n];return r}const a=s[n],c=s[n+1]||u;let d;if(o){d=new Array(c-a);for(let e=a;e<c;e++){const n=e*l+h;r=new Array(i);for(let e=0;e<i;e++)r[e]=t[n+e];d[e-a]=r}}else if(l===i)d=t.subarray(a*i+h,c*i+h);else{d=new t.constructor((c-a)*i);let e=0;for(let n=a;n<c;n++){const r=n*l+h;for(let n=0;n<i;n++)d[e++]=t[r+n]}}return d}}const Hp=[],qp=[[0,1/0]];function Xp(t){const{source:e,target:i,start:n=0,size:r,getData:s}=t,o=t.end||i.length,a=e.length,l=o-n;if(a>l)return void i.set(e.subarray(0,l),n);if(i.set(e,n),!s)return;let h=a;for(;h<l;){const t=s(h,e);for(let e=0;e<r;e++)i[n+h]=t[e]||0,h++}}const Yp={interpolation:{duration:0,easing:t=>t},spring:{stiffness:.05,damping:.5}};function Qp(t,e){return t?(Number.isFinite(t)&&(t={duration:t}),t.type=t.type||"interpolation",{...Yp[t.type],...e,...t}):null}function Zp(t,e){return e.getBuffer()?[e.getBuffer(),{divisor:0,size:e.size,normalized:e.settings.normalized}]:e.value}function Kp(t){switch(t){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";default:throw new Error('No defined attribute type for size "'.concat(t,'"'))}}function $p(t){t.push(t.shift())}function Jp(t,e){const{doublePrecision:i,settings:n,value:r,size:s}=t,o=i&&r instanceof Float64Array?2:1;return(n.noAlloc?r.length:e*s)*o}function tm({buffer:t,numInstances:e,attribute:i,fromLength:n,fromStartIndices:r,getData:s=(t=>t)}){const o=i.doublePrecision&&i.value instanceof Float64Array?2:1,a=i.size*o,l=i.byteOffset,h=i.startIndices,u=r&&h,c=Jp(i,e),d=i.state.constant;if(!u&&n>=c)return;const g=d?i.value:i.getBuffer().getData({srcByteOffset:l});if(i.settings.normalized&&!d){const t=s;s=(e,n)=>i._normalizeConstant(t(e,n))}const f=d?(t,e)=>s(g,e):(t,e)=>s(g.subarray(t,t+a),e),p=t.getData({length:n}),m=new Float32Array(c);!function({source:t,target:e,size:i,getData:n,sourceStartIndices:r,targetStartIndices:s}){if(!Array.isArray(s))return Xp({source:t,target:e,size:i,getData:n}),e;let o=0,a=0;const l=n&&((t,e)=>n(t+a,e)),h=Math.min(r.length,s.length);for(let n=1;n<h;n++){const h=r[n]*i,u=s[n]*i;Xp({source:t.subarray(o,h),target:e,start:a,end:u,size:i,getData:l}),o=h,a=u}a<e.length&&Xp({source:[],target:e,start:a,size:i,getData:l})}({source:p,target:m,sourceStartIndices:r,targetStartIndices:h,size:a,getData:f}),t.byteLength<m.byteLength+l&&t.reallocate(m.byteLength+l),t.subData({data:m,offset:l})}class em extends class{constructor(t,e){this.gl=t,this.id=e.id,this.size=e.size;const i=e.logicalType||e.type,n=5130===i;let{defaultValue:r}=e;r=Number.isFinite(r)?[r]:r||new Array(this.size).fill(0),e.defaultValue=r;let s=i;n?s=5126:!s&&e.isIndexed?s=t&&function(t,e){return Uc(t,e)}(t,zc)?5125:5123:s||(s=5126),e.logicalType=i,e.type=s;let o=function(t){switch(t){case 5126:return Float32Array;case 5130:return Float64Array;case 5123:case 33635:case 32819:case 32820:return Uint16Array;case 5125:return Uint32Array;case 5121:return Uint8ClampedArray;case 5120:return Int8Array;case 5122:return Int16Array;case 5124:return Int32Array;default:throw new Error("Unknown GL type")}}(i||s||5126);this.shaderAttributes={},this.doublePrecision=n,n&&!1===e.fp64&&(o=Float32Array),e.bytesPerElement=o.BYTES_PER_ELEMENT,this.defaultType=o,this.value=null,this.settings=e,this.state={externalBuffer:null,bufferAccessor:e,allocatedValue:null,numInstances:0,bounds:null,constant:!1},this._buffer=null,this.setData(e)}get buffer(){if(!this._buffer){const{isIndexed:t,type:e}=this.settings;this._buffer=new bc(this.gl,{id:this.id,target:t?34963:34962,accessor:{type:e}})}return this._buffer}get byteOffset(){const t=this.getAccessor();return t.vertexOffset?t.vertexOffset*kp(t):0}get numInstances(){return this.state.numInstances}set numInstances(t){this.state.numInstances=t}delete(){this._buffer&&(this._buffer.delete(),this._buffer=null),rh.release(this.state.allocatedValue)}getShaderAttributes(t,e){if(this.doublePrecision){const i={},n=this.value instanceof Float64Array,r=function(t,e){const i=Vp(t,e);return{high:i,low:{...i,offset:i.offset+4*t.size}}}(this.getAccessor(),e||{});return i[t]=new Np(this,r.high),i["".concat(t,"64Low")]=n?new Np(this,r.low):new Float32Array(this.size),i}if(e){const i=Vp(this.getAccessor(),e);return{[t]:new Np(this,i)}}return{[t]:this}}getBuffer(){return this.state.constant?null:this.state.externalBuffer||this._buffer}getValue(){return this.state.constant?this.value:[this.getBuffer(),this.getAccessor()]}getAccessor(){return this.state.bufferAccessor}getBounds(){if(this.state.bounds)return this.state.bounds;let t=null;if(this.state.constant){const e=this.value.slice();t=[e,e]}else{const{value:e,numInstances:i,size:n}=this,r=i*n;if(e&&r&&e.length>=r){const i=new Array(n).fill(1/0),s=new Array(n).fill(-1/0);for(let t=0;t<r;)for(let r=0;r<n;r++){const n=e[t++];n<i[r]&&(i[r]=n),n>s[r]&&(s[r]=n)}t=[i,s]}}return this.state.bounds=t,t}setData(t){const{state:e}=this;ArrayBuffer.isView(t)?t={value:t}:t instanceof bc&&(t={buffer:t});const i={...this.settings,...t};if(e.bufferAccessor=i,e.bounds=null,t.constant){let i=t.value;i=this._normalizeValue(i,[],0),this.settings.normalized&&(i=this._normalizeConstant(i));if(!(!e.constant||!this._areValuesEqual(i,this.value)))return!1;e.externalBuffer=null,e.constant=!0,this.value=i}else if(t.buffer){const n=t.buffer;e.externalBuffer=n,e.constant=!1,this.value=t.value;const r=t.value instanceof Float64Array;i.type=t.type||n.accessor.type,i.bytesPerElement=n.accessor.BYTES_PER_ELEMENT*(r?2:1),i.stride=kp(i)}else if(t.value){this._checkExternalBuffer(t);let n=t.value;e.externalBuffer=null,e.constant=!1,this.value=n,i.bytesPerElement=n.BYTES_PER_ELEMENT,i.stride=kp(i);const{buffer:r,byteOffset:s}=this;this.doublePrecision&&n instanceof Float64Array&&(n=hh(n,i));const o=n.byteLength+s+2*i.stride;r.byteLength<o&&r.reallocate(o),r.setAccessor(null),r.subData({data:n,offset:s}),i.type=t.type||r.accessor.type}return!0}updateSubBuffer(t={}){this.state.bounds=null;const{value:e}=this,{startOffset:i=0,endOffset:n}=t;this.buffer.subData({data:this.doublePrecision&&e instanceof Float64Array?hh(e,{size:this.size,startIndex:i,endIndex:n}):e.subarray(i,n),offset:i*e.BYTES_PER_ELEMENT+this.byteOffset})}allocate({numInstances:t,copy:e=!1}){const{state:i}=this,n=i.allocatedValue,r=rh.allocate(n,t+1,{size:this.size,type:this.defaultType,copy:e});this.value=r;const{buffer:s,byteOffset:o}=this;return s.byteLength<r.byteLength+o&&(s.reallocate(r.byteLength+o),e&&n&&s.subData({data:n instanceof Float64Array?hh(n,this):n,offset:o})),i.allocatedValue=r,i.constant=!1,i.externalBuffer=null,i.bufferAccessor=this.settings,!0}_checkExternalBuffer(t){const{value:e}=t;if(!t.constant&&e){const i=this.defaultType;let n=!1;if(this.doublePrecision&&(n=e.BYTES_PER_ELEMENT<4),n)throw new Error("Attribute ".concat(this.id," does not support ").concat(e.constructor.name));e instanceof i||!this.settings.normalized||"normalized"in t||Ta.warn("Attribute ".concat(this.id," is normalized"))()}}_normalizeConstant(t){switch(this.settings.type){case 5120:return new Float32Array(t).map(t=>(t+128)/255*2-1);case 5122:return new Float32Array(t).map(t=>(t+32768)/65535*2-1);case 5121:return new Float32Array(t).map(t=>t/255);case 5123:return new Float32Array(t).map(t=>t/65535);default:return t}}_normalizeValue(t,e,i){const{defaultValue:n,size:r}=this.settings;if(Number.isFinite(t))return e[i]=t,e;if(!t)return e[i]=n[0],e;switch(r){case 4:e[i+3]=Number.isFinite(t[3])?t[3]:n[3];case 3:e[i+2]=Number.isFinite(t[2])?t[2]:n[2];case 2:e[i+1]=Number.isFinite(t[1])?t[1]:n[1];case 1:e[i+0]=Number.isFinite(t[0])?t[0]:n[0];break;default:let s=r;for(;--s>=0;)e[i+s]=Number.isFinite(t[s])?t[s]:n[s]}return e}_areValuesEqual(t,e){if(!t||!e)return!1;const{size:i}=this;for(let n=0;n<i;n++)if(t[n]!==e[n])return!1;return!0}}{constructor(t,e={}){super(t,e);const{transition:i=!1,noAlloc:n=!1,update:r=null,accessor:s=null,transform:o=null,startIndices:a=null}=e;Object.assign(this.settings,{transition:i,noAlloc:n,update:r||s&&this._autoUpdater,accessor:s,transform:o}),Object.assign(this.state,{lastExternalBuffer:null,binaryValue:null,binaryAccessor:null,needsUpdate:!0,needsRedraw:!1,updateRanges:qp,startIndices:a}),Object.seal(this.settings),Object.seal(this.state),this._validateAttributeUpdaters()}get startIndices(){return this.state.startIndices}set startIndices(t){this.state.startIndices=t}needsUpdate(){return this.state.needsUpdate}needsRedraw({clearChangedFlags:t=!1}={}){const e=this.state.needsRedraw;return this.state.needsRedraw=e&&!t,e}getUpdateTriggers(){const{accessor:t}=this.settings;return[this.id].concat("function"!=typeof t&&t||[])}supportsTransition(){return Boolean(this.settings.transition)}getTransitionSetting(t){if(!t||!this.supportsTransition())return null;const{accessor:e}=this.settings,i=this.settings.transition;return Qp(Array.isArray(e)?t[e.find(e=>t[e])]:t[e],i)}setNeedsUpdate(t=this.id,e){if(this.state.needsUpdate=this.state.needsUpdate||t,this.setNeedsRedraw(t),e){const{startRow:t=0,endRow:i=1/0}=e;this.state.updateRanges=function(t,e){if(t===qp)return t;if(e[0]<0&&(e[0]=0),e[0]>=e[1])return t;const i=[],n=t.length;let r=0;for(let s=0;s<n;s++){const n=t[s];n[1]<e[0]?(i.push(n),r=s+1):n[0]>e[1]?i.push(n):e=[Math.min(n[0],e[0]),Math.max(n[1],e[1])]}return i.splice(r,0,e),i}(this.state.updateRanges,[t,i])}else this.state.updateRanges=qp}clearNeedsUpdate(){this.state.needsUpdate=!1,this.state.updateRanges=Hp}setNeedsRedraw(t=this.id){this.state.needsRedraw=this.state.needsRedraw||t}update(t){this.setData(t)}allocate(t){const{state:e,settings:i}=this;return!i.noAlloc&&(!!i.update&&(super.allocate({numInstances:t,copy:e.updateRanges!==qp}),!0))}updateBuffer({numInstances:t,data:e,props:i,context:n}){if(!this.needsUpdate())return!1;const{state:{updateRanges:r},settings:{update:s,noAlloc:o}}=this;let a=!0;if(s){for(const[o,a]of r)s.call(n,this,{data:e,startRow:o,endRow:a,props:i,numInstances:t});if(this.value)if(this.constant||this.buffer.byteLength<this.value.byteLength+this.byteOffset)this.setData({value:this.value,constant:this.constant}),this.constant=!1;else for(const[e,i]of r){const n=Number.isFinite(e)?this.getVertexOffset(e):0,r=Number.isFinite(i)?this.getVertexOffset(i):o||!Number.isFinite(t)?this.value.length:t*this.size;super.updateSubBuffer({startOffset:n,endOffset:r})}else;this._checkAttributeArray()}else a=!1;return this.clearNeedsUpdate(),this.setNeedsRedraw(),a}setConstantValue(t){if(void 0===t||"function"==typeof t)return!1;return this.setData({constant:!0,value:t})&&this.setNeedsRedraw(),this.clearNeedsUpdate(),!0}setExternalBuffer(t){const{state:e}=this;return t?(this.clearNeedsUpdate(),e.lastExternalBuffer===t||(e.lastExternalBuffer=t,this.setNeedsRedraw(),this.setData(t)),!0):(e.lastExternalBuffer=null,!1)}setBinaryValue(t,e=null){const{state:i,settings:n}=this;if(!t)return i.binaryValue=null,i.binaryAccessor=null,!1;if(n.noAlloc)return!1;if(i.binaryValue===t)return this.clearNeedsUpdate(),!0;i.binaryValue=t,this.setNeedsRedraw(),ArrayBuffer.isView(t)&&(t={value:t});if(n.transform||e!==this.startIndices){eg(ArrayBuffer.isView(t.value),"invalid ".concat(n.accessor));const r=t.size&&t.size!==this.size;return i.binaryAccessor=Wp(t.value,{size:t.size||this.size,stride:t.stride,offset:t.offset,startIndices:e,nested:r}),!1}return this.clearNeedsUpdate(),this.setData(t),!0}getVertexOffset(t){const{startIndices:e}=this;return(e?e[t]:t)*this.size}getShaderAttributes(){const t=this.settings.shaderAttributes||{[this.id]:null},e={};for(const i in t)Object.assign(e,super.getShaderAttributes(i,t[i]));return e}_autoUpdater(t,{data:e,startRow:i,endRow:n,props:r,numInstances:s}){if(t.constant)return;const{settings:o,state:a,value:l,size:h,startIndices:u}=t,{accessor:c,transform:d}=o,g=a.binaryAccessor||("function"==typeof c?c:r[c]);eg("function"==typeof g,'accessor "'.concat(c,'" is not a function'));let f=t.getVertexOffset(i);const{iterable:p,objectInfo:m}=jp(e,i,n);for(const e of p){m.index++;let i=g(e,m);if(d&&(i=d.call(this,i)),u){const e=(m.index<u.length-1?u[m.index+1]:s)-u[m.index];if(i&&Array.isArray(i[0])){let e=f;for(const n of i)t._normalizeValue(n,l,e),e+=h}else i&&i.length>h?l.set(i,f):(t._normalizeValue(i,m.target,0),La({target:l,source:m.target,start:f,count:e}));f+=e*h}else t._normalizeValue(i,l,f),f+=h}}_validateAttributeUpdaters(){const{settings:t}=this;if(!(t.noAlloc||"function"==typeof t.update))throw new Error("Attribute ".concat(this.id," missing update or accessor"))}_checkAttributeArray(){const{value:t}=this,e=Math.min(4,this.size);if(t&&t.length>=e){let i=!0;switch(e){case 4:i=i&&Number.isFinite(t[3]);case 3:i=i&&Number.isFinite(t[2]);case 2:i=i&&Number.isFinite(t[1]);case 1:i=i&&Number.isFinite(t[0]);break;default:i=!1}if(!i)throw new Error("Illegal attribute generated for ".concat(this.id))}}}const im="out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";function nm(t,e){e=Array.isArray(e)?e:[e];const i=t.replace(/^\s+/,"").split(/\s+/),[n,r,s]=i;if(!e.includes(n)||!r||!s)return null;return{qualifier:n,type:r,name:s.split(";")[0]}}function rm(t={}){const{version:e=100,input:i,inputType:n,output:r}=t;if(!i)return 300===e?"#version 300 es\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}":e>300?`#version ${e}\n${im}`:"void main() {gl_FragColor = vec4(0);}";const s=function(t,e){switch(e){case"float":return`vec4(${t}, 0.0, 0.0, 1.0)`;case"vec2":return`vec4(${t}, 0.0, 1.0)`;case"vec3":return`vec4(${t}, 1.0)`;case"vec4":return t;default:return eu(!1),null}}(i,n);return e>=300?`#version ${e} ${300===e?"es":""}\nin ${n} ${i};\nout vec4 ${r};\nvoid main() {\n  ${r} = ${s};\n}`:`varying ${n} ${i};\nvoid main() {\n  gl_FragColor = ${s};\n}`}class sm extends ac{static isSupported(t){return Object(Du.e)(t)}constructor(t,e={}){Object(Du.a)(t),super(t,e),this.initialize(e),this.stubRemovedMethods("TransformFeedback","v6.0",["pause","resume"]),Object.seal(this)}initialize(t={}){return this.buffers={},this.unused={},this.configuration=null,this.bindOnUse=!0,rc(this.buffers)||this.bind(()=>this._unbindBuffers()),this.setProps(t),this}setProps(t){"program"in t&&(this.configuration=t.program&&t.program.configuration),"configuration"in t&&(this.configuration=t.configuration),"bindOnUse"in t&&(t=t.bindOnUse),"buffers"in t&&this.setBuffers(t.buffers)}setBuffers(t={}){return this.bind(()=>{for(const e in t)this.setBuffer(e,t[e])}),this}setBuffer(t,e){const i=this._getVaryingIndex(t),{buffer:n,byteSize:r,byteOffset:s}=this._getBufferParams(e);return i<0?(this.unused[t]=n,Fu.warn(()=>`${this.id} unused varying buffer ${t}`)(),this):(this.buffers[i]=e,this.bindOnUse||this._bindBuffer(i,n,s,r),this)}begin(t=0){return this.gl.bindTransformFeedback(36386,this.handle),this._bindBuffers(),this.gl.beginTransformFeedback(t),this}end(){return this.gl.endTransformFeedback(),this._unbindBuffers(),this.gl.bindTransformFeedback(36386,null),this}_getBufferParams(t){let e,i,n;return t instanceof bc==!1?(n=t.buffer,i=t.byteSize,e=t.byteOffset):n=t,void 0===e&&void 0===i||(e=e||0,i=i||n.byteLength-e),{buffer:n,byteOffset:e,byteSize:i}}_getVaryingInfo(t){return this.configuration&&this.configuration.getVaryingInfo(t)}_getVaryingIndex(t){if(this.configuration)return this.configuration.getVaryingInfo(t).location;const e=Number(t);return Number.isFinite(e)?e:-1}_bindBuffers(){if(this.bindOnUse)for(const t in this.buffers){const{buffer:e,byteSize:i,byteOffset:n}=this._getBufferParams(this.buffers[t]);this._bindBuffer(t,e,n,i)}}_unbindBuffers(){if(this.bindOnUse)for(const t in this.buffers)this._bindBuffer(t,null)}_bindBuffer(t,e,i=0,n){const r=e&&e.handle;return r&&void 0!==n?this.gl.bindBufferRange(35982,t,r,i,n):this.gl.bindBufferBase(35982,t,r),this}_createHandle(){return this.gl.createTransformFeedback()}_deleteHandle(){this.gl.deleteTransformFeedback(this.handle)}_bindHandle(t){this.gl.bindTransformFeedback(36386,this.handle)}}class om{constructor(t,e={}){this.gl=t,this.currentIndex=0,this.feedbackMap={},this.varyings=null,this.bindings=[],this.resources={},this._initialize(e),Object.seal(this)}setupResources(t){for(const e of this.bindings)this._setupTransformFeedback(e,t)}updateModelProps(t={}){const{varyings:e}=this;return e.length>0&&(t=Object.assign({},t,{varyings:e})),t}getDrawOptions(t={}){const e=this.bindings[this.currentIndex],{sourceBuffers:i,transformFeedback:n}=e;return{attributes:Object.assign({},i,t.attributes),transformFeedback:n}}swap(){return!!this.feedbackMap&&(this.currentIndex=this._getNextIndex(),!0)}update(t={}){this._setupBuffers(t)}getBuffer(t){const{feedbackBuffers:e}=this.bindings[this.currentIndex],i=t?e[t]:null;return i?i instanceof bc?i:i.buffer:null}getData(t={}){const{varyingName:e}=t,i=this.getBuffer(e);return i?i.getData():null}delete(){for(const t in this.resources)this.resources[t].delete()}_initialize(t={}){this._setupBuffers(t),this.varyings=t.varyings||Object.keys(this.bindings[this.currentIndex].feedbackBuffers),this.varyings.length>0&&$u(Object(Du.e)(this.gl))}_getFeedbackBuffers(t){const{sourceBuffers:e={}}=t,i={};if(this.bindings[this.currentIndex]&&Object.assign(i,this.bindings[this.currentIndex].feedbackBuffers),this.feedbackMap)for(const t in this.feedbackMap){const n=this.feedbackMap[t];t in e&&(i[n]=t)}Object.assign(i,t.feedbackBuffers);for(const t in i){const n=i[t];if("string"==typeof n){const r=e[n],{byteLength:s,usage:o,accessor:a}=r;i[t]=this._createNewBuffer(t,{byteLength:s,usage:o,accessor:a})}}return i}_setupBuffers(t={}){const{sourceBuffers:e=null}=t;Object.assign(this.feedbackMap,t.feedbackMap);const i=this._getFeedbackBuffers(t);this._updateBindings({sourceBuffers:e,feedbackBuffers:i})}_setupTransformFeedback(t,{model:e}){const{program:i}=e;t.transformFeedback=new sm(this.gl,{program:i,buffers:t.feedbackBuffers})}_updateBindings(t){if(this.bindings[this.currentIndex]=this._updateBinding(this.bindings[this.currentIndex],t),this.feedbackMap){const{sourceBuffers:t,feedbackBuffers:e}=this._swapBuffers(this.bindings[this.currentIndex]),i=this._getNextIndex();this.bindings[i]=this._updateBinding(this.bindings[i],{sourceBuffers:t,feedbackBuffers:e})}}_updateBinding(t,e){return t?(Object.assign(t.sourceBuffers,e.sourceBuffers),Object.assign(t.feedbackBuffers,e.feedbackBuffers),t.transformFeedback&&t.transformFeedback.setBuffers(t.feedbackBuffers),t):{sourceBuffers:Object.assign({},e.sourceBuffers),feedbackBuffers:Object.assign({},e.feedbackBuffers)}}_swapBuffers(t){if(!this.feedbackMap)return null;const e=Object.assign({},t.sourceBuffers),i=Object.assign({},t.feedbackBuffers);for(const n in this.feedbackMap){const r=this.feedbackMap[n];e[n]=t.feedbackBuffers[r],i[r]=t.sourceBuffers[n],$u(i[r]instanceof bc)}return{sourceBuffers:e,feedbackBuffers:i}}_createNewBuffer(t,e){const i=new bc(this.gl,e);return this.resources[t]&&this.resources[t].delete(),this.resources[t]=i,i}_getNextIndex(){return(this.currentIndex+1)%2}}function am(t){let e=100;const i=t.match(/[^\s]+/g);if(i.length>=2&&"#version"===i[0]){const t=parseInt(i[1],10);Number.isFinite(t)&&(e=t)}return e}const lm={name:"transform",vs:"attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n",fs:null};function hm({vs:t,sourceTextureMap:e,targetTextureVarying:i,targetTexture:n}){let r=Object.keys(e).length,s=null;const o={};let a=t,l={};if(r>0||i){const t=a.split("\n"),h=t.slice();if(t.forEach((t,n,a)=>{if(r>0){const i=function(t,e){const i={},n=function(t){return nm(t,["attribute","in"])}(t);if(!n)return null;const{type:r,name:s}=n;if(s&&e[s]){const e=`// ${t} => Replaced by Transform with a sampler`,{samplerName:n,sizeName:o,uniformDeclerations:a}=function(t){const e="transform_uSampler_"+t,i="transform_uSize_"+t;return{samplerName:e,sizeName:i,uniformDeclerations:`  uniform sampler2D ${e};\n  uniform vec2 ${i};`}}(s),l=function(t){switch(t){case"float":return"x";case"vec2":return"xy";case"vec3":return"xyz";case"vec4":return"xyzw";default:return eu(!1),null}}(r),h=`  ${r} ${s} = transform_getInput(${n}, ${o}).${l};\n`;i[n]=s;return{updatedLine:e,inject:{"vs:#decl":a,"vs:#main-start":h},samplerTextureMap:i}}return null}(t,e);if(i){const{updatedLine:t,inject:e}=i;h[n]=t,l=vu([l,e]),Object.assign(o,i.samplerTextureMap),r--}}i&&!s&&(s=function(t,e){const i=nm(t,["varying","out"]);if(!i)return null;return i.name===e?i.type:null}(t,i))}),i){$u(n);const t="transform_uSize_"+i;l=vu([l,{"vs:#decl":`uniform vec2 ${t};\n`,"vs:#main-start":`     vec2 transform_position = transform_getPos(${t});\n     gl_Position = vec4(transform_position, 0, 1.);\n`}])}a=h.join("\n")}return{vs:a,targetTextureType:s,inject:l,samplerTextureMap:o}}const um={10241:9728,10240:9728,10242:33071,10243:33071};class cm{constructor(t,e={}){this.gl=t,this.id=this.currentIndex=0,this._swapTexture=null,this.targetTextureVarying=null,this.targetTextureType=null,this.samplerTextureMap=null,this.bindings=[],this.resources={},this._initialize(e),Object.seal(this)}updateModelProps(t={}){const e=this._processVertexShader(t);return Object.assign({},t,e)}getDrawOptions(t={}){const{sourceBuffers:e,sourceTextures:i,framebuffer:n,targetTexture:r}=this.bindings[this.currentIndex],s=Object.assign({},e,t.attributes),o=Object.assign({},t.uniforms),a=Object.assign({},t.parameters);let l=t.discard;if(this.hasSourceTextures||this.hasTargetTexture){s.transform_elementID=this.elementIDBuffer;for(const t in this.samplerTextureMap){const e=this.samplerTextureMap[t];o[t]=i[e]}this._setSourceTextureParameters();const t=function({sourceTextureMap:t,targetTextureVarying:e,targetTexture:i}){const n={};let r,s;e&&(({width:r,height:s}=i),n["transform_uSize_"+e]=[r,s]);for(const e in t)({width:r,height:s}=t[e]),n["transform_uSize_"+e]=[r,s];return n}({sourceTextureMap:i,targetTextureVarying:this.targetTextureVarying,targetTexture:r});Object.assign(o,t)}return this.hasTargetTexture&&(l=!1,a.viewport=[0,0,n.width,n.height]),{attributes:s,framebuffer:n,uniforms:o,discard:l,parameters:a}}swap(){return!!this._swapTexture&&(this.currentIndex=this._getNextIndex(),!0)}update(t={}){this._setupTextures(t)}getTargetTexture(){const{targetTexture:t}=this.bindings[this.currentIndex];return t}getData({packed:t=!1}={}){const{framebuffer:e}=this.bindings[this.currentIndex],i=Nc(e);if(!t)return i;const n=i.constructor,r=function(t){switch(t){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4;default:return eu(!1),null}}(this.targetTextureType),s=new n(i.length*r/4);let o=0;for(let t=0;t<i.length;t+=4)for(let e=0;e<r;e++)s[o++]=i[t+e];return s}getFramebuffer(){return this.bindings[this.currentIndex].framebuffer}delete(){this.ownTexture&&this.ownTexture.delete(),this.elementIDBuffer&&this.elementIDBuffer.delete()}_initialize(t={}){const{_targetTextureVarying:e,_swapTexture:i}=t;this._swapTexture=i,this.targetTextureVarying=e,this.hasTargetTexture=e,this._setupTextures(t)}_createTargetTexture(t){const{sourceTextures:e,textureOrReference:i}=t;if(i instanceof Ac)return i;const n=e[i];return n?(this._targetRefTexName=i,this._createNewTexture(n)):null}_setupTextures(t={}){const{sourceBuffers:e,_sourceTextures:i={},_targetTexture:n}=t,r=this._createTargetTexture({sourceTextures:i,textureOrReference:n});this.hasSourceTextures=this.hasSourceTextures||i&&Object.keys(i).length>0,this._updateBindings({sourceBuffers:e,sourceTextures:i,targetTexture:r}),"elementCount"in t&&this._updateElementIDBuffer(t.elementCount)}_updateElementIDBuffer(t){if("number"!=typeof t||this.elementCount>=t)return;const e=new Float32Array(t);e.forEach((t,e,i)=>{i[e]=e}),this.elementIDBuffer?this.elementIDBuffer.setData({data:e}):this.elementIDBuffer=new bc(this.gl,{data:e,accessor:{size:1}}),this.elementCount=t}_updateBindings(t){if(this.bindings[this.currentIndex]=this._updateBinding(this.bindings[this.currentIndex],t),this._swapTexture){const{sourceTextures:t,targetTexture:e}=this._swapTextures(this.bindings[this.currentIndex]),i=this._getNextIndex();this.bindings[i]=this._updateBinding(this.bindings[i],{sourceTextures:t,targetTexture:e})}}_updateBinding(t,e){const{sourceBuffers:i,sourceTextures:n,targetTexture:r}=e;if(t||(t={sourceBuffers:{},sourceTextures:{},targetTexture:null}),Object.assign(t.sourceTextures,n),Object.assign(t.sourceBuffers,i),r){t.targetTexture=r;const{width:e,height:i}=r,{framebuffer:n}=t;n?(n.update({attachments:{36064:r},resizeAttachments:!1}),n.resize({width:e,height:i})):t.framebuffer=new Hc(this.gl,{id:"transform-framebuffer",width:e,height:i,attachments:{36064:r}})}return t}_setSourceTextureParameters(){const t=this.currentIndex,{sourceTextures:e}=this.bindings[t];for(const t in e)e[t].setParameters(um)}_swapTextures(t){if(!this._swapTexture)return null;const e=Object.assign({},t.sourceTextures);e[this._swapTexture]=t.targetTexture;return{sourceTextures:e,targetTexture:t.sourceTextures[this._swapTexture]}}_createNewTexture(t){const e=Fc(t,{parameters:{10241:9728,10240:9728,10242:33071,10243:33071},pixelStore:{37440:!1}});return this.ownTexture&&this.ownTexture.delete(),this.ownTexture=e,e}_getNextIndex(){return(this.currentIndex+1)%2}_processVertexShader(t={}){const{sourceTextures:e,targetTexture:i}=this.bindings[this.currentIndex],{vs:n,uniforms:r,targetTextureType:s,inject:o,samplerTextureMap:a}=hm({vs:t.vs,sourceTextureMap:e,targetTextureVarying:this.targetTextureVarying,targetTexture:i}),l=vu([t.inject||{},o]);this.targetTextureType=s,this.samplerTextureMap=a;return{vs:n,fs:t._fs||rm({version:am(n),input:this.targetTextureVarying,inputType:s,output:"transform_output"}),modules:this.hasSourceTextures||this.targetTextureVarying?[lm].concat(t.modules||[]):t.modules,uniforms:r,inject:l}}}let dm=null;function gm(t,e){var i;return new t((i=t.BYTES_PER_ELEMENT*e,(!dm||dm.byteLength<i)&&(dm=new ArrayBuffer(i)),dm),0,e)}class fm extends ac{static isSupported(t,e={}){return!e.constantAttributeZero||(Object(Du.e)(t)||"Chrome"===Object(np.a)())}static getDefaultArray(t){return t.luma=t.luma||{},t.luma.defaultVertexArray||(t.luma.defaultVertexArray=new fm(t,{handle:null,isDefaultArray:!0})),t.luma.defaultVertexArray}static getMaxAttributes(t){return fm.MAX_ATTRIBUTES=fm.MAX_ATTRIBUTES||t.getParameter(34921),fm.MAX_ATTRIBUTES}static setConstant(t,e,i){switch(i.constructor){case Float32Array:fm._setConstantFloatArray(t,e,i);break;case Int32Array:fm._setConstantIntArray(t,e,i);break;case Uint32Array:fm._setConstantUintArray(t,e,i);break;default:$u(!1)}}constructor(t,e={}){const i=e.id||e.program&&e.program.id;super(t,Object.assign({},e,{id:i})),this.buffer=null,this.bufferValue=null,this.isDefaultArray=e.isDefaultArray||!1,this.gl2=t,this.initialize(e),Object.seal(this)}delete(){return super.delete(),this.buffer&&this.buffer.delete(),this}get MAX_ATTRIBUTES(){return fm.getMaxAttributes(this.gl)}initialize(t={}){return this.setProps(t)}setProps(t){return this}setElementBuffer(t=null,e={}){return $u(!t||34963===t.target,"elements must be GL.ELEMENT_ARRAY_BUFFER"),this.bind(()=>{this.gl.bindBuffer(34963,t?t.handle:null)}),this}setBuffer(t,e,i){if(34963===e.target)return this.setElementBuffer(e,i);const{size:n,type:r,stride:s,offset:o,normalized:a,integer:l,divisor:h}=i,{gl:u,gl2:c}=this;return t=Number(t),this.bind(()=>{u.bindBuffer(34962,e.handle),l?($u(Object(Du.e)(u)),c.vertexAttribIPointer(t,n,r,s,o)):u.vertexAttribPointer(t,n,r,a,s,o),u.enableVertexAttribArray(t),c.vertexAttribDivisor(t,h||0)}),this}enable(t,e=!0){return!e&&0===t&&!fm.isSupported(this.gl,{constantAttributeZero:!0})||(t=Number(t),this.bind(()=>e?this.gl.enableVertexAttribArray(t):this.gl.disableVertexAttribArray(t))),this}getConstantBuffer(t,e){const i=this._normalizeConstantArrayValue(e),n=i.byteLength*t,r=i.length*t;let s=!this.buffer;if(this.buffer=this.buffer||new bc(this.gl,n),s=s||this.buffer.reallocate(n),s=s||!this._compareConstantArrayValues(i,this.bufferValue),s){const t=gm(e.constructor,r);!function({target:t,source:e,start:i=0,count:n=1}){const r=e.length,s=n*r;let o=0;for(let n=i;o<r;o++)t[n++]=e[o];for(;o<s;)o<s-o?(t.copyWithin(i+o,i,i+o),o*=2):(t.copyWithin(i+o,i,i+s-o),o=s)}({target:t,source:i,start:0,count:r}),this.buffer.subData(t),this.bufferValue=e}return this.buffer}_normalizeConstantArrayValue(t){return Array.isArray(t)?new Float32Array(t):t}_compareConstantArrayValues(t,e){if(!t||!e||t.length!==e.length||t.constructor!==e.constructor)return!1;for(let i=0;i<t.length;++i)if(t[i]!==e[i])return!1;return!0}static _setConstantFloatArray(t,e,i){switch(i.length){case 1:t.vertexAttrib1fv(e,i);break;case 2:t.vertexAttrib2fv(e,i);break;case 3:t.vertexAttrib3fv(e,i);break;case 4:t.vertexAttrib4fv(e,i);break;default:$u(!1)}}static _setConstantIntArray(t,e,i){switch($u(Object(Du.e)(t)),i.length){case 1:t.vertexAttribI1iv(e,i);break;case 2:t.vertexAttribI2iv(e,i);break;case 3:t.vertexAttribI3iv(e,i);break;case 4:t.vertexAttribI4iv(e,i);break;default:$u(!1)}}static _setConstantUintArray(t,e,i){switch($u(Object(Du.e)(t)),i.length){case 1:t.vertexAttribI1uiv(e,i);break;case 2:t.vertexAttribI2uiv(e,i);break;case 3:t.vertexAttribI3uiv(e,i);break;case 4:t.vertexAttribI4uiv(e,i);break;default:$u(!1)}}_createHandle(){return this.gl.createVertexArray()}_deleteHandle(t){return this.gl2.deleteVertexArray(t),[this.elements]}_bindHandle(t){this.gl2.bindVertexArray(t)}_getParameter(t,{location:e}){return $u(Number.isFinite(e)),this.bind(()=>{switch(t){case 34373:return this.gl.getVertexAttribOffset(e,t);default:return this.gl.getVertexAttrib(e,t)}})}}const pm=/^(.+)__LOCATION_([0-9]+)$/,mm=["setBuffers","setGeneric","clearBindings","setLocations","setGenericValues","setDivisor","enable","disable"];class ym{constructor(t,e={}){const i=e.id||e.program&&e.program.id;this.id=i,this.gl=t,this.configuration=null,this.elements=null,this.elementsAccessor=null,this.values=null,this.accessors=null,this.unused=null,this.drawParams=null,this.buffer=null,this.attributes={},this.vertexArrayObject=new fm(t),sc(this,"VertexArray","v6.0",mm),this.initialize(e),Object.seal(this)}delete(){this.buffer&&this.buffer.delete(),this.vertexArrayObject.delete()}initialize(t={}){return this.reset(),this.configuration=null,this.bindOnUse=!1,this.setProps(t)}reset(){this.elements=null,this.elementsAccessor=null;const{MAX_ATTRIBUTES:t}=this.vertexArrayObject;return this.values=new Array(t).fill(null),this.accessors=new Array(t).fill(null),this.unused={},this.drawParams=null,this}setProps(t){return"program"in t&&(this.configuration=t.program&&t.program.configuration),"configuration"in t&&(this.configuration=t.configuration),"attributes"in t&&this.setAttributes(t.attributes),"elements"in t&&this.setElementBuffer(t.elements),"bindOnUse"in t&&(t=t.bindOnUse),this}clearDrawParams(){this.drawParams=null}getDrawParams(){return this.drawParams=this.drawParams||this._updateDrawParams(),this.drawParams}setAttributes(t){return Object.assign(this.attributes,t),this.vertexArrayObject.bind(()=>{for(const e in t){const i=t[e];this._setAttribute(e,i)}this.gl.bindBuffer(34962,null)}),this}setElementBuffer(t=null,e={}){return this.elements=t,this.elementsAccessor=e,this.clearDrawParams(),this.vertexArrayObject.setElementBuffer(t,e),this}setBuffer(t,e,i={}){if(34963===e.target)return this.setElementBuffer(e,i);const{location:n,accessor:r}=this._resolveLocationAndAccessor(t,e,e.accessor,i);return n>=0&&(this.values[n]=e,this.accessors[n]=r,this.clearDrawParams(),this.vertexArrayObject.setBuffer(n,e,r)),this}setConstant(t,e,i={}){const{location:n,accessor:r}=this._resolveLocationAndAccessor(t,e,Object.assign({size:e.length},i));return n>=0&&(e=this.vertexArrayObject._normalizeConstantArrayValue(e),this.values[n]=e,this.accessors[n]=r,this.clearDrawParams(),this.vertexArrayObject.enable(n,!1)),this}unbindBuffers(){return this.vertexArrayObject.bind(()=>{this.elements&&this.vertexArrayObject.setElementBuffer(null),this.buffer=this.buffer||new bc(this.gl,{accessor:{size:4}});for(let t=0;t<this.vertexArrayObject.MAX_ATTRIBUTES;t++)this.values[t]instanceof bc&&(this.gl.disableVertexAttribArray(t),this.gl.bindBuffer(34962,this.buffer.handle),this.gl.vertexAttribPointer(t,1,5126,!1,0,0))}),this}bindBuffers(){return this.vertexArrayObject.bind(()=>{this.elements&&this.setElementBuffer(this.elements);for(let t=0;t<this.vertexArrayObject.MAX_ATTRIBUTES;t++){const e=this.values[t];e instanceof bc&&this.setBuffer(t,e)}}),this}bindForDraw(t,e,i){let n;return this.vertexArrayObject.bind(()=>{this._setConstantAttributes(t,e),n=i()}),n}_resolveLocationAndAccessor(t,e,i,n){const r={location:-1,accessor:null},{location:s,name:o}=this._getAttributeIndex(t);if(!Number.isFinite(s)||s<0)return this.unused[t]=e,Fu.once(3,()=>`unused value ${t} in ${this.id}`)(),r;const a=this._getAttributeInfo(o||s);if(!a)return r;const l=this.accessors[s]||{},h=fc.resolve(a.accessor,l,i,n),{size:u,type:c}=h;return $u(Number.isFinite(u)&&Number.isFinite(c)),{location:s,accessor:h}}_getAttributeInfo(t){return this.configuration&&this.configuration.getAttributeInfo(t)}_getAttributeIndex(t){const e=Number(t);if(Number.isFinite(e))return{location:e};const i=pm.exec(t),n=i?i[1]:t,r=i?Number(i[2]):0;return this.configuration?{location:this.configuration.getAttributeLocation(n)+r,name:n}:{location:-1}}_setAttribute(t,e){if(e instanceof bc)this.setBuffer(t,e);else if(Array.isArray(e)&&e.length&&e[0]instanceof bc){const i=e[0],n=e[1];this.setBuffer(t,i,n)}else if(ArrayBuffer.isView(e)||Array.isArray(e)){const i=e;this.setConstant(t,i)}else{if(!(e.buffer instanceof bc))throw new Error("VertexArray: attributes must be Buffers or constants (i.e. typed array)");{const i=e;this.setBuffer(t,i.buffer,i)}}}_setConstantAttributes(t,e){const i=Math.max(0|t,0|e);let n=this.values[0];ArrayBuffer.isView(n)&&this._setConstantAttributeZero(n,i);for(let t=1;t<this.vertexArrayObject.MAX_ATTRIBUTES;t++)n=this.values[t],ArrayBuffer.isView(n)&&this._setConstantAttribute(t,n)}_setConstantAttributeZero(t,e){if(fm.isSupported(this.gl,{constantAttributeZero:!0}))return void this._setConstantAttribute(0,t);const i=this.vertexArrayObject.getConstantBuffer(e,t);this.vertexArrayObject.setBuffer(0,i,this.accessors[0])}_setConstantAttribute(t,e){fm.setConstant(this.gl,t,e)}_updateDrawParams(){const t={isIndexed:!1,isInstanced:!1,indexCount:1/0,vertexCount:1/0,instanceCount:1/0};for(let e=0;e<this.vertexArrayObject.MAX_ATTRIBUTES;e++)this._updateDrawParamsForLocation(t,e);return this.elements&&(t.elementCount=this.elements.getElementCount(this.elements.accessor),t.isIndexed=!0,t.indexType=this.elementsAccessor.type||this.elements.accessor.type,t.indexOffset=this.elementsAccessor.offset||0),t.indexCount===1/0&&(t.indexCount=0),t.vertexCount===1/0&&(t.vertexCount=0),t.instanceCount===1/0&&(t.instanceCount=0),t}_updateDrawParamsForLocation(t,e){const i=this.values[e],n=this.accessors[e];if(!i)return;const{divisor:r}=n,s=r>0;if(t.isInstanced=t.isInstanced||s,i instanceof bc){const e=i;if(s){const i=e.getVertexCount(n);t.instanceCount=Math.min(t.instanceCount,i)}else{const i=e.getVertexCount(n);t.vertexCount=Math.min(t.vertexCount,i)}}}setElements(t=null,e={}){return Fu.deprecated("setElements","setElementBuffer")(),this.setElementBuffer(t,e)}}function bm(t,e={}){const{isInteger:i=!1}=e;if(Array.isArray(t)||ArrayBuffer.isView(t))return function(t,e){const{maxElts:i=16,size:n=1}=e;let r="[";for(let s=0;s<t.length&&s<i;++s)s>0&&(r+=","+(s%n==0?" ":"")),r+=bm(t[s],e);return`${r}${t.length>i?"...":"]"}`}(t,e);if(!Number.isFinite(t))return String(t);if(Math.abs(t)<1e-16)return i?"0":"0.";if(i)return t.toFixed(0);if(Math.abs(t)>100&&Math.abs(t)<1e4)return t.toFixed(0);const n=t.toPrecision(2);return n.indexOf(".0")===n.length-2?n.slice(0,-1):n}function Pm(t,e,i,n){const{gl:r}=t;if(!e)return{[n]:"null","Format ":"N/A"};let s,o,a,l="NOT PROVIDED",h=1,u=0,c=0;if(i&&(l=i.type,h=i.size,l=String(l).replace("Array",""),s=-1!==l.indexOf("nt")),e instanceof bc){const t=e,{data:d,changed:g}=t.getDebugData();let f;if(o=g?"*":"",a=d,c=t.byteLength,u=c/d.BYTES_PER_ELEMENT/h,i){f=`${i.divisor>0?"I ":"P "} ${u} (x${h}=${c} bytes ${tc(r,l)})`}else s=!0,f=c+" bytes";return{[n]:`${o}${bm(a,{size:h,isInteger:s})}`,"Format ":f}}return a=e,h=e.length,l=String(e.constructor.name).replace("Array",""),s=-1!==l.indexOf("nt"),{[n]:bm(a,{size:h,isInteger:s})+" (constant)","Format ":`${h}x${l} (constant)`}}function vm(t,e){const{type:i,size:n}=e,r=Pd(i,n);return r?`${t} (${r.name})`:t}function Sm({header:t="Uniforms",program:e,uniforms:i,undefinedOnly:n=!1}){$u(e);const r=e._uniformSetters,s={},o=Object.keys(r).sort();let a=0;for(const e of o)e.match(".*_.*")||e.match(".*Matrix")||Cm({table:s,header:t,uniforms:i,uniformName:e,undefinedOnly:n})&&a++;for(const e of o)e.match(".*Matrix")&&Cm({table:s,header:t,uniforms:i,uniformName:e,undefinedOnly:n})&&a++;for(const e of o)s[e]||Cm({table:s,header:t,uniforms:i,uniformName:e,undefinedOnly:n})&&a++;let l=0;const h={};if(!n)for(const e in i){const n=i[e];s[e]||(l++,h[e]={Type:"NOT USED: "+n,[t]:bm(n)})}return{table:s,count:a,unusedTable:h,unusedCount:l}}function Cm({table:t,header:e,uniforms:i,uniformName:n,undefinedOnly:r}){const s=i[n],o=function(t){return null!=t}(s);return(!r||!o)&&(t[n]={[e]:o?bm(s):"N/A","Uniform Type":o?s:"NOT PROVIDED"},!0)}function wm(t){const{type:e,size:i}=t.accessor,n=Pd(e,i);return n?`${n.name} ${t.name}`:t.name}const Em={POSITION:"positions",NORMAL:"normals",COLOR_0:"colors",TEXCOORD_0:"texCoords",TEXCOORD_1:"texCoords1",TEXCOORD_2:"texCoords2"};function xm(t,e){const{attributeMap:i=Em}=e||{};return i&&i[t]||t}function Am(t,e){let i;switch(t){case"texCoords":case"texCoord1":case"texCoord2":case"texCoord3":i="uvs";break;case"vertices":case"positions":case"normals":case"pickingColors":i="vectors"}switch(i){case"vectors":e.size=e.size||3;break;case"uvs":e.size=e.size||2}$u(Number.isFinite(e.size),`attribute ${t} needs size`)}const Tm=()=>{},Im={};class Om{constructor(t,e={}){const{id:i=ic("model")}=e;$u(Object(Du.d)(t)),this.id=i,this.gl=t,this.id=e.id||ic("Model"),this.lastLogTime=0,this.animated=!1,this.initialize(e)}initialize(t){this.props={},this.programManager=t.programManager||Ed.getDefaultProgramManager(this.gl),this._programManagerState=-1,this._managedProgram=!1;const{program:e=null,vs:i,fs:n,modules:r,defines:s,inject:o,varyings:a,bufferMode:l,transpileToGLSL100:h}=t;this.programProps={program:e,vs:i,fs:n,modules:r,defines:s,inject:o,varyings:a,bufferMode:l,transpileToGLSL100:h},this.program=null,this.vertexArray=null,this._programDirty=!0,this.userData={},this.needsRedraw=!0,this._attributes={},this.attributes={},this.uniforms={},this.pickable=!0,this._checkProgram(),this.setUniforms(Object.assign({},this.getModuleUniforms(t.moduleSettings))),this.drawMode=void 0!==t.drawMode?t.drawMode:4,this.vertexCount=t.vertexCount||0,this.geometryBuffers={},this.isInstanced=t.isInstanced||t.instanced||t.instanceCount>0,this._setModelProps(t),this.geometry={},$u(void 0!==this.drawMode&&Number.isFinite(this.vertexCount),"Model needs drawMode and vertexCount")}setProps(t){this._setModelProps(t)}delete(){for(const t in this._attributes)this._attributes[t]!==this.attributes[t]&&this._attributes[t].delete();this._managedProgram&&(this.programManager.release(this.program),this._managedProgram=!1),this.vertexArray.delete(),this._deleteGeometryBuffers()}getDrawMode(){return this.drawMode}getVertexCount(){return this.vertexCount}getInstanceCount(){return this.instanceCount}getAttributes(){return this.attributes}getProgram(){return this.program}setProgram(t){const{program:e,vs:i,fs:n,modules:r,defines:s,inject:o,varyings:a,bufferMode:l,transpileToGLSL100:h}=t;this.programProps={program:e,vs:i,fs:n,modules:r,defines:s,inject:o,varyings:a,bufferMode:l,transpileToGLSL100:h},this._programDirty=!0}getUniforms(){return this.uniforms}setDrawMode(t){return this.drawMode=t,this}setVertexCount(t){return $u(Number.isFinite(t)),this.vertexCount=t,this}setInstanceCount(t){return $u(Number.isFinite(t)),this.instanceCount=t,this}setGeometry(t){return this.drawMode=t.drawMode,this.vertexCount=t.getVertexCount(),this._deleteGeometryBuffers(),this.geometryBuffers=function(t,e,i){const n={};let r=e.indices;for(const s in e.attributes){const o=e.attributes[s],a=xm(s,i);if("indices"===s)r=o;else if(o.constant)n[a]=o.value;else{const e=o.value,i={...o};delete i.value,n[a]=[new bc(t,e),i],Am(s,i)}}if(r){const e=r.value||r;$u(e instanceof Uint16Array||e instanceof Uint32Array,'attribute array for "indices" must be of integer type');const i={size:1,isIndexed:void 0===r.isIndexed||r.isIndexed};n.indices=[new bc(t,{data:e,target:34963}),i]}return n}(this.gl,t),this.vertexArray.setAttributes(this.geometryBuffers),this}setAttributes(t={}){if(rc(t))return this;const e={};for(const i in t){const n=t[i];e[i]=n.getValue?n.getValue():n}return this.vertexArray.setAttributes(e),this}setUniforms(t={}){return Object.assign(this.uniforms,t),this}getModuleUniforms(t){this._checkProgram();const e=this.programManager.getUniforms(this.program);return e?e(t):{}}updateModuleSettings(t){const e=this.getModuleUniforms(t||{});return this.setUniforms(e)}clear(t){return _c(this.program.gl,t),this}draw(t={}){this._checkProgram();const{moduleSettings:e=null,framebuffer:i,uniforms:n={},attributes:r={},transformFeedback:s=this.transformFeedback,parameters:o={},vertexArray:a=this.vertexArray}=t;let l;this.setAttributes(r),this.updateModuleSettings(e),this.setUniforms(n),Fu.priority>=2&&(l=this._logDrawCallStart(2));const h=this.vertexArray.getDrawParams(),{isIndexed:u=h.isIndexed,indexType:c=h.indexType,indexOffset:d=h.indexOffset,vertexArrayInstanced:g=h.isInstanced}=this.props;g&&!this.isInstanced&&Fu.warn("Found instanced attributes on non-instanced model",this.id)();const{isInstanced:f,instanceCount:p}=this,{onBeforeRender:m=Tm,onAfterRender:y=Tm}=this.props;m(),this.program.setUniforms(this.uniforms);const b=this.program.draw(Object.assign(Im,t,{logPriority:l,uniforms:null,framebuffer:i,parameters:o,drawMode:this.getDrawMode(),vertexCount:this.getVertexCount(),vertexArray:a,transformFeedback:s,isIndexed:u,indexType:c,isInstanced:f,instanceCount:p,offset:u?d:0}));return y(),Fu.priority>=2&&this._logDrawCallEnd(l,a,i),b}transform(t={}){const{discard:e=!0,feedbackBuffers:i,unbindModels:n=[]}=t;let{parameters:r}=t;i&&this._setFeedbackBuffers(i),e&&(r=Object.assign({},r,{35977:e})),n.forEach(t=>t.vertexArray.unbindBuffers());try{this.draw(Object.assign({},t,{parameters:r}))}finally{n.forEach(t=>t.vertexArray.bindBuffers())}return this}render(t={}){return Fu.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")(),this.setUniforms(t).draw()}_setModelProps(t){Object.assign(this.props,t),"uniforms"in t&&this.setUniforms(t.uniforms),"pickable"in t&&(this.pickable=t.pickable),"instanceCount"in t&&(this.instanceCount=t.instanceCount),"geometry"in t&&this.setGeometry(t.geometry),"attributes"in t&&this.setAttributes(t.attributes),"_feedbackBuffers"in t&&this._setFeedbackBuffers(t._feedbackBuffers)}_checkProgram(){if(!(this._programDirty||this.programManager.stateHash!==this._programManagerState))return;let{program:t}=this.programProps;if(t)this._managedProgram=!1;else{const{vs:e,fs:i,modules:n,inject:r,defines:s,varyings:o,bufferMode:a,transpileToGLSL100:l}=this.programProps;t=this.programManager.get({vs:e,fs:i,modules:n,inject:r,defines:s,varyings:o,bufferMode:a,transpileToGLSL100:l}),this.program&&this._managedProgram&&this.programManager.release(this.program),this._programManagerState=this.programManager.stateHash,this._managedProgram=!0}$u(t instanceof wd,"Model needs a program"),this._programDirty=!1,t!==this.program&&(this.program=t,this.vertexArray?this.vertexArray.setProps({program:this.program,attributes:this.vertexArray.attributes}):this.vertexArray=new ym(this.gl,{program:this.program}),this.setUniforms(Object.assign({},this.getModuleUniforms())))}_deleteGeometryBuffers(){for(const t in this.geometryBuffers){const e=this.geometryBuffers[t][0]||this.geometryBuffers[t];e instanceof bc&&e.delete()}}_setAnimationProps(t){this.animated&&$u(t,"Model.draw(): animated uniforms but no animationProps")}_setFeedbackBuffers(t={}){if(rc(t))return this;const{gl:e}=this.program;return this.transformFeedback=this.transformFeedback||new sm(e,{program:this.program}),this.transformFeedback.setBuffers(t),this}_logDrawCallStart(t){const e=t>3?0:1e4;if(!(Date.now()-this.lastLogTime<e))return this.lastLogTime=Date.now(),Fu.group(2,">>> DRAWING MODEL "+this.id,{collapsed:Fu.level<=2})(),t}_logDrawCallEnd(t,e,i,n){if(void 0===t)return;const r=function({vertexArray:t,header:e="Attributes"}){if(!t.configuration)return{};const i={};t.elements&&(i.ELEMENT_ARRAY_BUFFER=Pm(t,t.elements,null,e));const n=t.values;for(const r in n){const s=t._getAttributeInfo(r);if(s){let o=`${r}: ${s.name}`;const a=t.accessors[s.location];a&&(o=`${r}: ${vm(s.name,a)}`),i[o]=Pm(t,n[r],a,e)}}return i}({vertexArray:e,header:this.id+" attributes",attributes:this._attributes}),{table:s,unusedTable:o,unusedCount:a}=Sm({header:this.id+" uniforms",program:this.program,uniforms:Object.assign({},this.program.uniforms,i)}),{table:l,count:h}=Sm({header:this.id+" uniforms",program:this.program,uniforms:Object.assign({},this.program.uniforms,i),undefinedOnly:!0});h>0&&Fu.log("MISSING UNIFORMS",Object.keys(l))(),a>0&&Fu.log("UNUSED UNIFORMS",Object.keys(o))();const u=function(t){const e={},i="Accessors for "+t.id;for(const n of t.attributeInfos)if(n){e["in "+wm(n)]={[i]:JSON.stringify(n.accessor)}}for(const n of t.varyingInfos)if(n){e["out "+wm(n)]={[i]:JSON.stringify(n.accessor)}}return e}(this.vertexArray.configuration);Fu.table(t,r)(),Fu.table(t,s)(),Fu.table(t+1,u)(),n&&n.log({logLevel:2,message:"Rendered to "+n.id}),Fu.groupEnd(2,">>> DRAWING MODEL "+this.id)()}}class _m{static isSupported(t){return Object(Du.e)(t)}constructor(t,e={}){this.gl=t,this.model=null,this.elementCount=0,this.bufferTransform=null,this.textureTransform=null,this.elementIDBuffer=null,this._initialize(e),Object.seal(this)}delete(){const{model:t,bufferTransform:e,textureTransform:i}=this;t&&t.delete(),e&&e.delete(),i&&i.delete()}run(t={}){const{clearRenderTarget:e=!0}=t,i=this._updateDrawOptions(t);e&&i.framebuffer&&i.framebuffer.clear({color:!0}),this.model.transform(i)}swap(){let t=!1;const e=[this.bufferTransform,this.textureTransform].filter(Boolean);for(const i of e)t=t||i.swap();$u(t,"Nothing to swap")}getBuffer(t=null){return this.bufferTransform&&this.bufferTransform.getBuffer(t)}getData(t={}){const e=[this.bufferTransform,this.textureTransform].filter(Boolean);for(const i of e){const e=i.getData(t);if(e)return e}return null}getFramebuffer(){return this.textureTransform&&this.textureTransform.getFramebuffer()}update(t={}){"elementCount"in t&&this.model.setVertexCount(t.elementCount);const e=[this.bufferTransform,this.textureTransform].filter(Boolean);for(const i of e)i.update(t)}_initialize(t={}){const{gl:e}=this;this._buildResourceTransforms(e,t),t=this._updateModelProps(t),this.model=new Om(e,Object.assign({},t,{fs:t.fs||rm({version:am(t.vs)}),id:t.id||"transform-model",drawMode:t.drawMode||0,vertexCount:t.elementCount})),this.bufferTransform&&this.bufferTransform.setupResources({model:this.model})}_updateModelProps(t){let e=Object.assign({},t);const i=[this.bufferTransform,this.textureTransform].filter(Boolean);for(const t of i)e=t.updateModelProps(e);return e}_buildResourceTransforms(t,e){(function(t){if(!rc(t.feedbackBuffers)||!rc(t.feedbackMap)||t.varyings&&t.varyings.length>0)return!0;return!1})(e)&&(this.bufferTransform=new om(t,e)),function(t){if(!rc(t._sourceTextures)||t._targetTexture||t._targetTextureVarying)return!0;return!1}(e)&&(this.textureTransform=new cm(t,e)),$u(this.bufferTransform||this.textureTransform,"must provide source/feedback buffers or source/target textures")}_updateDrawOptions(t){let e=Object.assign({},t);const i=[this.bufferTransform,this.textureTransform].filter(Boolean);for(const t of i)e=Object.assign(e,t.getDrawOptions(e));return e}}const Lm={interpolation:class{constructor({gl:t,attribute:e,timeline:i}){this.gl=t,this.type="interpolation",this.transition=new ug(i),this.attribute=e,this.attributeInTransition=new em(t,e.settings),this.currentStartIndices=e.startIndices,this.currentLength=0,this.transform=function(t,e){const i=Kp(e.size);return new _m(t,{vs:"\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n",defines:{ATTRIBUTE_TYPE:i},varyings:["vCurrent"]})}(t,e);const n={byteLength:0,usage:35050};this.buffers=[new bc(t,n),new bc(t,n)]}get inProgress(){return this.transition.inProgress}start(t,e){if(t.duration<=0)return void this.transition.cancel();const{gl:i,buffers:n,attribute:r}=this;$p(n);const s={numInstances:e,attribute:r,fromLength:this.currentLength,fromStartIndices:this.currentStartIndices,getData:t.enter};for(const t of n)tm({buffer:t,...s});this.currentStartIndices=r.startIndices,this.currentLength=Jp(r,e),this.attributeInTransition.update({buffer:n[1],value:r.value}),this.transition.start(t),this.transform.update({elementCount:Math.floor(this.currentLength/r.size),sourceBuffers:{aFrom:n[0],aTo:Zp(0,r)},feedbackBuffers:{vCurrent:n[1]}})}update(){const t=this.transition.update();if(t){const{time:t,settings:{duration:e,easing:i}}=this.transition,n=i(t/e);this.transform.run({uniforms:{time:n}})}return t}cancel(){for(this.transition.cancel(),this.transform.delete();this.buffers.length;)this.buffers.pop().delete()}},spring:class{constructor({gl:t,attribute:e,timeline:i}){this.gl=t,this.type="spring",this.transition=new ug(i),this.attribute=e,this.attributeInTransition=new em(t,{...e.settings,normalized:!1}),this.currentStartIndices=e.startIndices,this.currentLength=0,this.texture=function(t){return new Ac(t,{data:new Uint8Array(4),format:6408,type:5121,border:0,mipmaps:!1,dataFormat:6408,width:1,height:1})}(t),this.framebuffer=function(t,e){return new Hc(t,{id:"spring-transition-is-transitioning-framebuffer",width:1,height:1,attachments:{36064:e}})}(t,this.texture),this.transform=function(t,e,i){const n=Kp(e.size);return new _m(t,{framebuffer:i,vs:"\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",fs:"\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",defines:{ATTRIBUTE_TYPE:n},varyings:["vNext"]})}(t,e,this.framebuffer);const n={byteLength:0,usage:35050};this.buffers=[new bc(t,n),new bc(t,n),new bc(t,n)]}get inProgress(){return this.transition.inProgress}start(t,e){const{gl:i,buffers:n,attribute:r}=this,s={numInstances:e,attribute:r,fromLength:this.currentLength,fromStartIndices:this.currentStartIndices,getData:t.enter};for(const t of n)tm({buffer:t,...s});this.currentStartIndices=r.startIndices,this.currentLength=Jp(r,e),this.attributeInTransition.update({buffer:n[1],value:r.value}),this.transition.start(t),this.transform.update({elementCount:Math.floor(this.currentLength/r.size),sourceBuffers:{aTo:Zp(0,r)}})}update(){const{buffers:t,transform:e,framebuffer:i,transition:n}=this;if(!n.update())return!1;e.update({sourceBuffers:{aPrev:t[0],aCur:t[1]},feedbackBuffers:{vNext:t[2]}}),e.run({framebuffer:i,discard:!1,clearRenderTarget:!0,uniforms:{stiffness:n.settings.stiffness,damping:n.settings.damping},parameters:{depthTest:!1,blend:!0,viewport:[0,0,1,1],blendFunc:[1,1],blendEquation:[32776,32776]}}),$p(t),this.attributeInTransition.update({buffer:t[1],value:this.attribute.value});return Nc(i)[0]>0||n.end(),!0}cancel(){for(this.transition.cancel(),this.transform.delete();this.buffers.length;)this.buffers.pop().delete();this.texture.delete(),this.texture=null,this.framebuffer.delete(),this.framebuffer=null}}};class Rm{constructor(t,{id:e,timeline:i}){this.id=e,this.gl=t,this.timeline=i,this.transitions={},this.needsRedraw=!1,this.numInstances=1,this.isSupported=_m.isSupported(t)}finalize(){for(const t in this.transitions)this._removeTransition(t)}update({attributes:t,transitions:e,numInstances:i}){this.numInstances=i||1;for(const i in t){const n=t[i],r=n.getTransitionSetting(e);r&&this._updateAttribute(i,n,r)}for(const i in this.transitions){const n=t[i];n&&n.getTransitionSetting(e)||this._removeTransition(i)}}hasAttribute(t){const e=this.transitions[t];return e&&e.inProgress}getAttributes(){const t={};for(const e in this.transitions){const i=this.transitions[e];i.inProgress&&(t[e]=i.attributeInTransition)}return t}run(){if(!this.isSupported||0===this.numInstances)return!1;for(const t in this.transitions){this.transitions[t].update()&&(this.needsRedraw=!0)}const t=this.needsRedraw;return this.needsRedraw=!1,t}_removeTransition(t){this.transitions[t].cancel(),delete this.transitions[t]}_updateAttribute(t,e,i){const n=this.transitions[t];let r=!n||n.type!==i.type;if(r){if(!this.isSupported)return void Ta.warn("WebGL2 not supported by this browser. Transition for ".concat(t," is disabled."))();n&&this._removeTransition(t);const s=Lm[i.type];s?this.transitions[t]=new s({attribute:e,timeline:this.timeline,gl:this.gl}):(Ta.error("unsupported transition type '".concat(i.type,"'"))(),r=!1)}(r||e.needsRedraw())&&(this.needsRedraw=!0,this.transitions[t].start(i,this.numInstances))}}class Bm{constructor(t,{id:e="attribute-manager",stats:i,timeline:n}={}){this.id=e,this.gl=t,this.attributes={},this.updateTriggers={},this.accessors={},this.needsRedraw=!0,this.userData={},this.stats=i,this.attributeTransitionManager=new Rm(t,{id:"".concat(e,"-transitions"),timeline:n}),Object.seal(this)}finalize(){for(const t in this.attributes)this.attributes[t].delete();this.attributeTransitionManager.finalize()}getNeedsRedraw(t={clearRedrawFlags:!1}){const e=this.needsRedraw;return this.needsRedraw=this.needsRedraw&&!t.clearRedrawFlags,e&&this.id}setNeedsRedraw(t=!0){return this.needsRedraw=!0,this}add(t,e){this._add(t,e)}addInstanced(t,e){this._add(t,e,{instanced:1})}remove(t){for(let e=0;e<t.length;e++){const i=t[e];void 0!==this.attributes[i]&&(this.attributes[i].delete(),delete this.attributes[i])}}invalidate(t,e){Oa("attributeManager.invalidate",this,t,this._invalidateTrigger(t,e))}invalidateAll(t){for(const e in this.attributes)this.attributes[e].setNeedsUpdate(e,t);Oa("attributeManager.invalidate",this,"all")}update({data:t,numInstances:e,startIndices:i=null,transitions:n,props:r={},buffers:s={},context:o={}}={}){let a=!1;Oa("attributeManager.updateStart",this),this.stats&&this.stats.get("Update Attributes").timeStart();for(const n in this.attributes){const l=this.attributes[n],h=l.settings.accessor;l.startIndices=i,l.numInstances=e,r[n]&&Ta.removed("props.".concat(n),"data.attributes.".concat(n))(),l.setExternalBuffer(s[n])||l.setBinaryValue(s[h],t.startIndices)||!s[h]&&l.setConstantValue(r[h])||l.needsUpdate()&&(a=!0,this._updateAttribute({attribute:l,numInstances:e,data:t,props:r,context:o})),this.needsRedraw|=l.needsRedraw()}a&&Oa("attributeManager.updateEnd",this,e),this.stats&&this.stats.get("Update Attributes").timeEnd(),this.attributeTransitionManager.update({attributes:this.attributes,numInstances:e,transitions:n})}updateTransition(){const{attributeTransitionManager:t}=this,e=t.run();return this.needsRedraw=this.needsRedraw||e,e}getAttributes(){return this.attributes}getChangedAttributes(t={clearChangedFlags:!1}){const{attributes:e,attributeTransitionManager:i}=this,n={...i.getAttributes()};for(const r in e){const s=e[r];s.needsRedraw(t)&&!i.hasAttribute(r)&&(n[r]=s)}return n}getShaderAttributes(t,e={}){t||(t=this.getAttributes());const i={};for(const n in t)e[n]||Object.assign(i,t[n].getShaderAttributes());return i}getAccessors(){return this.updateTriggers}_add(t,e,i={}){e&&Ta.warn("AttributeManager.add({updaters}) - updater map no longer supported")();for(const e in t){const n=t[e];this.attributes[e]=this._createAttribute(e,n,i)}this._mapUpdateTriggersToAttributes()}_createAttribute(t,e,i){const n={...e,id:t,isIndexed:e.isIndexed||e.elements||!1,constant:e.constant||!1,size:(e.elements?1:e.size)||1,value:e.value||null,divisor:e.instanced||i.instanced?1:e.divisor||0};return new em(this.gl,n)}_mapUpdateTriggersToAttributes(){const t={};for(const e in this.attributes){this.attributes[e].getUpdateTriggers().forEach(i=>{t[i]||(t[i]=[]),t[i].push(e)})}this.updateTriggers=t}_invalidateTrigger(t,e){const{attributes:i,updateTriggers:n}=this,r=n[t];return r&&r.forEach(t=>{const n=i[t];n&&n.setNeedsUpdate(n.id,e)}),r}_updateAttribute(t){const{attribute:e,numInstances:i}=t;if(Oa("attribute.updateStart",e),e.constant)return void e.setConstantValue(e.value);e.allocate(i)&&Oa("attribute.allocate",e,i);e.updateBuffer(t)&&(this.needsRedraw=!0,Oa("attribute.updateEnd",e,i))}}function Mm(t,e,i,n,r){const s=e-t;return(i-e)*r+-s*n+s+e}function Fm(t,e){if(Array.isArray(t)){let i=0;for(let n=0;n<t.length;n++){const r=t[n]-e[n];i+=r*r}return Math.sqrt(i)}return Math.abs(t-e)}const Dm={interpolation:class extends ug{get value(){return this._value}_onUpdate(){const{time:t,settings:{fromValue:e,toValue:i,duration:n,easing:r}}=this,s=r(t/n);this._value=Object(uh.f)(e,i,s)}},spring:class extends ug{get value(){return this._currValue}_onUpdate(){const{fromValue:t,toValue:e,damping:i,stiffness:n}=this.settings,{_prevValue:r=t,_currValue:s=t}=this;let o=function(t,e,i,n,r){if(Array.isArray(i)){const s=[];for(let o=0;o<i.length;o++)s[o]=Mm(t[o],e[o],i[o],n,r);return s}return Mm(t,e,i,n,r)}(r,s,e,i,n);const a=Fm(o,e),l=Fm(o,s);a<1e-5&&l<1e-5&&(o=e,this.end()),this._prevValue=s,this._currValue=o}}};class Nm{constructor(t){this.transitions=new Map,this.timeline=t}get active(){return this.transitions.size>0}add(t,e,i,n){const{transitions:r}=this;if(r.has(t)){const i=r.get(t),{value:n=i.settings.fromValue}=i;e=n,this.remove(t)}if(!(n=Qp(n)))return;const s=Dm[n.type];if(!s)return void Ta.error("unsupported transition type '".concat(n.type,"'"))();const o=new s(this.timeline);o.start({...n,fromValue:e,toValue:i}),r.set(t,o)}remove(t){const{transitions:e}=this;e.has(t)&&(e.get(t).cancel(),e.delete(t))}update(){const t={};for(const[e,i]of this.transitions)i.update(),t[e]=i.value,i.inProgress||this.remove(e);return t}clear(){for(const t of this.transitions.keys())this.remove(t)}}function km(t,e){const i=Gm({newProps:t,oldProps:e,propTypes:Wm(t),ignoreProps:{data:null,updateTriggers:null,extensions:null,transitions:null}}),n=function(t,e){if(null===e)return"oldProps is null, initial diff";let i=null;const{dataComparator:n,_dataDiff:r}=t;n?n(t.data,e.data)||(i="Data comparator detected a change"):t.data!==e.data&&(i="A new data container was supplied");i&&r&&(i=r(t.data,e.data)||i);return i}(t,e);let r=!1;return n||(r=function(t,e){if(null===e)return"oldProps is null, initial diff";if("all"in t.updateTriggers){if(Um(t,e,"all"))return{all:!0}}const i={};let n=!1;for(const r in t.updateTriggers)if("all"!==r){Um(t,e,r)&&(i[r]=!0,n=i)}return n}(t,e)),{dataChanged:n,propsChanged:i,updateTriggersChanged:r,extensionsChanged:jm(t,e),transitionsChanged:Vm(t,e)}}function Vm(t,e){if(!t.transitions)return null;const i={},n=Wm(t);for(const r in t.transitions){const s=n[r],o=s&&s.type;("number"===o||"color"===o||"array"===o)&&zm(t[r],e[r],s)&&(i[r]=!0)}return i}function Gm({newProps:t,oldProps:e,ignoreProps:i={},propTypes:n={},triggerName:r="props"}){if(e===t)return null;if("object"!=typeof t||null===t)return"".concat(r," changed shallowly");if("object"!=typeof e||null===e)return"".concat(r," changed shallowly");for(const s of Object.keys(t))if(!(s in i)){if(!(s in e))return"".concat(r,".").concat(s," added");const i=zm(t[s],e[s],n[s]);if(i)return"".concat(r,".").concat(s," ").concat(i)}for(const s of Object.keys(e))if(!(s in i)){if(!(s in t))return"".concat(r,".").concat(s," dropped");if(!Object.hasOwnProperty.call(t,s)){const i=zm(t[s],e[s],n[s]);if(i)return"".concat(r,".").concat(s," ").concat(i)}}return null}function zm(t,e,i){let n=i&&i.equal;return n&&!n(t,e,i)?"changed deeply":n||(n=t&&e&&t.equals,!n||n.call(t,e))?n||e===t?null:"changed shallowly":"changed deeply"}function jm(t,e){if(null===e)return!0;const i=e.extensions,{extensions:n}=t;if(n===i)return!1;if(!i||!n)return!0;if(n.length!==i.length)return!0;for(let t=0;t<n.length;t++)if(!n[t].equals(i[t]))return!0;return!1}function Um(t,e,i){let n=t.updateTriggers[i];n=null==n?{}:n;let r=e.updateTriggers[i];r=null==r?{}:r;return Gm({oldProps:r,newProps:n,triggerName:i})}function Wm(t){const e=t[ra],i=e&&e.constructor;return i?i._propTypes:{}}function Hm(t){if(null===(e=t)||"object"!=typeof e)throw new Error("count(): argument not an object");var e;if("function"==typeof t.count)return t.count();if(Number.isFinite(t.size))return t.size;if(Number.isFinite(t.length))return t.length;if(function(t){return null!==t&&"object"==typeof t&&t.constructor===Object}(t))return Object.keys(t).length;throw new Error("count(): argument not a container")}function qm(t,e){if(!e)return t;const i={...t,...e};if("defines"in e&&(i.defines={...t.defines,...e.defines}),"modules"in e&&(i.modules=(t.modules||[]).concat(e.modules),e.modules.some(t=>"project64"===t.name))){const t=i.modules.findIndex(t=>"project32"===t.name);t>=0&&i.modules.splice(t,1)}if("inject"in e)if(t.inject){const n={...t.inject};for(const t in e.inject)n[t]=(n[t]||"")+e.inject[t];i.inject=n}else i.inject=e.inject;return i}var Xm=function(t,e,i){return t[0]=e[0]-i[0],t[1]=e[1]-i[1],t[2]=e[2]-i[2],t};!function(){var t=function(){var t=new gh(3);return gh!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}()}();function Ym(t,e,i=!1){const n=e.projectPosition(t);if(i&&e instanceof ag){const[i,r,s=0]=t,o=e.getDistanceScales([i,r]);n[2]=s*o.unitsPerMeter[2]}return n}function Qm(t,{viewport:e,modelMatrix:i,coordinateSystem:n,coordinateOrigin:r,offsetMode:s}){let[o,a,l=0]=t;switch(i&&([o,a,l]=Ld([],[o,a,l,1],i)),n){case Wh.LNGLAT:return Ym([o,a,l],e,s);case Wh.LNGLAT_OFFSETS:return Ym([o+r[0],a+r[1],l+(r[2]||0)],e,s);case Wh.METER_OFFSETS:return Ym(Bh(r,[o,a,l]),e,s);case Wh.CARTESIAN:default:return e.isGeospatial?[o+r[0],a+r[1],l+r[2]]:e.projectPosition([o,a,l])}}function Zm(t,e){const{viewport:i,coordinateSystem:n,coordinateOrigin:r,modelMatrix:s,fromCoordinateSystem:o,fromCoordinateOrigin:a}=function(t){const e={...t};let{coordinateSystem:i}=t;const{viewport:n,coordinateOrigin:r,fromCoordinateSystem:s,fromCoordinateOrigin:o}=t;return i===Wh.DEFAULT&&(i=n.isGeospatial?Wh.LNGLAT:Wh.CARTESIAN),void 0===s&&(e.fromCoordinateSystem=i),void 0===o&&(e.fromCoordinateOrigin=r),e.coordinateSystem=i,e}(e),{geospatialOrigin:l,shaderCoordinateOrigin:h,offsetMode:u}=jd(i,n,r),c=Qm(t,{viewport:i,modelMatrix:s,coordinateSystem:o,coordinateOrigin:a,offsetMode:u});if(u){const t=i.projectPosition(l||h);Xm(c,c,t)}return c}const Km={10241:9987,10240:9729,10242:33071,10243:33071},$m={};const Jm={boolean:{validate:(t,e)=>!0,equal:(t,e,i)=>Boolean(t)===Boolean(e)},number:{validate:(t,e)=>Number.isFinite(t)&&(!("max"in e)||t<=e.max)&&(!("min"in e)||t>=e.min)},color:{validate:(t,e)=>e.optional&&!t||ny(t)&&(3===t.length||4===t.length),equal:(t,e,i)=>ty(t,e)},accessor:{validate(t,e){const i=ry(t);return"function"===i||i===ry(e.value)},equal:(t,e,i)=>"function"==typeof e||ty(t,e)},array:{validate:(t,e)=>e.optional&&!t||ny(t),equal:(t,e,i)=>i.compare?ty(t,e):t===e},function:{validate:(t,e)=>e.optional&&!t||"function"==typeof t,equal:(t,e,i)=>!i.compare||t===e},data:{transform:(t,e,i)=>{const{dataTransform:n}=i.props;return n&&t?n(t):t}},image:{transform:(t,e,i)=>function(t,e){const i=t.context&&t.context.gl;if(!i||!e)return null;if(e instanceof Ac)return e;e.constructor&&"Object"!==e.constructor.name&&(e={data:e});let n=null;e.compressed&&(n={10241:e.data.length>1?9985:9729});const r=new Ac(i,{...e,parameters:{...Km,...n,...t.props.textureParameters}});return $m[r.id]=!0,r}(i,t),release:t=>{var e;(e=t)&&e instanceof Ac&&$m[e.id]&&(e.delete(),delete $m[e.id])}}};function ty(t,e){if(t===e)return!0;if(!ny(t)||!ny(e))return!1;const i=t.length;if(i!==e.length)return!1;for(let n=0;n<i;n++)if(t[n]!==e[n])return!1;return!0}function ey(t,e){switch(ry(e)){case"object":return iy(t,e);case"array":return iy(t,{type:"array",value:e,compare:!1});case"boolean":return iy(t,{type:"boolean",value:e});case"number":return iy(t,{type:"number",value:e});case"function":return iy(t,{type:"function",value:e,compare:!0});default:return{name:t,type:"unknown",value:e}}}function iy(t,e){return"type"in e?{name:t,...Jm[e.type],...e}:"value"in e?{name:t,type:ry(e.value),...e}:{name:t,type:"object",value:e}}function ny(t){return Array.isArray(t)||ArrayBuffer.isView(t)}function ry(t){return ny(t)?"array":null===t?"null":typeof t}function sy(t){const e=ly(t,"_mergedDefaultProps");return e||(function(t){if(!t.prototype)return;const e=Object.getPrototypeOf(t),i=sy(e),n=function(t){const e={},i={},n={};for(const[r,s]of Object.entries(t)){const t=null==s?void 0:s.deprecatedFor;if(t)n[r]=Array.isArray(t)?t:[t];else{const t=ey(r,s);e[r]=t,i[r]=t.value}}return{propTypes:e,defaultProps:i,deprecatedProps:n}}(ly(t,"defaultProps")||{}),r=function(t,e,i){const n=Object.create(null);Object.assign(n,e,t);const r=function(t){const e=ly(t,"layerName")||ly(t,"componentName");e||Ta.once(0,"".concat(t.name,".componentName not specified"))();return e||t.name}(i);return delete t.id,Object.defineProperties(n,{id:{writable:!0,value:r}}),n}(n.defaultProps,i,t),s={...e._propTypes,...n.propTypes};!function(t,e){const i={},n={};for(const t in e){const r=e[t],{name:s,value:o}=r;r.async&&(i[s]=o,n[s]=oy(s))}t[sa]=i,t[oa]={},Object.defineProperties(t,n)}(r,s);const o={...e._deprecatedProps,...n.deprecatedProps};(function(t,e){for(const i in e)Object.defineProperty(t,i,{enumerable:!1,set(t){const n="".concat(this.id,": ").concat(i);for(const n of e[i])ay(this,n)||(this[n]=t);Ta.deprecated(n,e[i].join("/"))()}})})(r,o),t._mergedDefaultProps=r,t._propTypes=s,t._deprecatedProps=o}(t),t._mergedDefaultProps)}function oy(t){return{enumerable:!0,set(e){"string"==typeof e||e instanceof Promise||Up(e)?this[oa][t]=e:this[aa][t]=e},get(){if(this[aa]){if(t in this[aa]){return this[aa][t]||this[sa][t]}if(t in this[oa]){const e=this[ra]&&this[ra].internalState;if(e&&e.hasAsyncProp(t))return e.getAsyncProp(t)||this[sa][t]}}return this[sa][t]}}}function ay(t,e){return Object.prototype.hasOwnProperty.call(t,e)}function ly(t,e){return ay(t,e)&&t[e]}const hy=Object.freeze({});class uy{constructor(t){la(this,"component",void 0),la(this,"onAsyncPropUpdated",void 0),la(this,"asyncProps",void 0),la(this,"oldProps",void 0),la(this,"oldAsyncProps",void 0),this.component=t,this.asyncProps={},this.onAsyncPropUpdated=()=>{},this.oldProps=null,this.oldAsyncProps=null}finalize(){for(const t in this.asyncProps){const e=this.asyncProps[t];e&&e.type&&e.type.release&&e.type.release(e.resolvedValue,e.type,this.component)}}getOldProps(){return this.oldAsyncProps||this.oldProps||hy}resetOldProps(){this.oldAsyncProps=null,this.oldProps=this.component.props}hasAsyncProp(t){return t in this.asyncProps}getAsyncProp(t){const e=this.asyncProps[t];return e&&e.resolvedValue}isAsyncPropLoading(t){if(t){const e=this.asyncProps[t];return Boolean(e&&e.pendingLoadCount>0&&e.pendingLoadCount!==e.resolvedLoadCount)}for(const t in this.asyncProps)if(this.isAsyncPropLoading(t))return!0;return!1}reloadAsyncProp(t,e){this._watchPromise(t,Promise.resolve(e))}setAsyncProps(t){const e=t[aa]||{},i=t[oa]||t,n=t[sa]||{};for(const t in e){const i=e[t];this._createAsyncPropData(t,n[t]),this._updateAsyncProp(t,i),e[t]=this.getAsyncProp(t)}for(const t in i){const e=i[t];this._createAsyncPropData(t,n[t]),this._updateAsyncProp(t,e)}}_fetch(t,e){return e}_onResolve(t,e){}_onError(t,e){}_updateAsyncProp(t,e){this._didAsyncInputValueChange(t,e)&&("string"==typeof e&&(e=this._fetch(t,e)),e instanceof Promise?this._watchPromise(t,e):Up(e)?this._resolveAsyncIterable(t,e):this._setPropValue(t,e))}_freezeAsyncOldProps(){if(!this.oldAsyncProps&&this.oldProps){this.oldAsyncProps=Object.create(this.oldProps);for(const t in this.asyncProps)Object.defineProperty(this.oldAsyncProps,t,{enumerable:!0,value:this.oldProps[t]})}}_didAsyncInputValueChange(t,e){const i=this.asyncProps[t];return e!==i.resolvedValue&&e!==i.lastValue&&(i.lastValue=e,!0)}_setPropValue(t,e){this._freezeAsyncOldProps();const i=this.asyncProps[t];i&&(e=this._postProcessValue(i,e),i.resolvedValue=e,i.pendingLoadCount++,i.resolvedLoadCount=i.pendingLoadCount)}_setAsyncPropValue(t,e,i){const n=this.asyncProps[t];n&&i>=n.resolvedLoadCount&&void 0!==e&&(this._freezeAsyncOldProps(),n.resolvedValue=e,n.resolvedLoadCount=i,this.onAsyncPropUpdated(t,e))}_watchPromise(t,e){const i=this.asyncProps[t];if(i){i.pendingLoadCount++;const n=i.pendingLoadCount;e.then(e=>{e=this._postProcessValue(i,e),this._setAsyncPropValue(t,e,n),this._onResolve(t,e)}).catch(e=>{this._onError(t,e)})}}async _resolveAsyncIterable(t,e){if("data"!==t)return void this._setPropValue(t,e);const i=this.asyncProps[t];if(!i)return;i.pendingLoadCount++;const n=i.pendingLoadCount;let r=[],s=0;for await(const i of e){const{dataTransform:e}=this.component.props;r=e?e(i,r):r.concat(i),Object.defineProperty(r,"__diff",{enumerable:!1,value:[{startRow:s,endRow:r.length}]}),s=r.length,this._setAsyncPropValue(t,r,n)}this._onResolve(t,r)}_postProcessValue(t,e){const i=t.type;return i&&(i.release&&i.release(t.resolvedValue,i,this.component),i.transform)?i.transform(e,i,this.component):e}_createAsyncPropData(t,e){if(!this.asyncProps[t]){const i=this.component&&this.component.constructor._propTypes;this.asyncProps[t]={type:i&&i[t],lastValue:null,resolvedValue:e,pendingLoadCount:0,resolvedLoadCount:0}}}}let cy=0;class dy{constructor(...t){la(this,"id",void 0),la(this,"props",void 0),la(this,"count",void 0),la(this,"lifecycle",void 0),la(this,"parent",void 0),la(this,"context",void 0),la(this,"state",void 0),la(this,"internalState",void 0),this.props=function(t,e){const i=sy(t.constructor),n=Object.create(i);n[ra]=t,n[oa]={},n[aa]={};for(let t=0;t<e.length;++t){const i=e[t];for(const t in i)n[t]=i[t]}return Object.freeze(n),n}(this,t),this.id=this.props.id,this.count=cy++,this.lifecycle=$o,this.parent=null,this.context=null,this.state=null,this.internalState=null,Object.seal(this)}get root(){let t=this;for(;t.parent;)t=t.parent;return t}clone(t){const{props:e}=this,i={};for(const t in e[sa])t in e[aa]?i[t]=e[aa][t]:t in e[oa]&&(i[t]=e[oa][t]);return new this.constructor({...e,...i,...t})}_initState(){this.internalState=new uy(this)}}la(dy,"componentName","Component"),la(dy,"defaultProps",{});class gy extends uy{constructor({attributeManager:t,layer:e}){super(e),la(this,"attributeManager",void 0),la(this,"needsRedraw",void 0),la(this,"subLayers",void 0),la(this,"usesPickingColorCache",void 0),this.attributeManager=t,this.needsRedraw=!0,this.subLayers=null,this.usesPickingColorCache=!1}get layer(){return this.component}set layer(t){this.component=t}_fetch(t,e){const i=this.component.props.fetch;return i?i(e,{propName:t,layer:this.layer}):super._fetch(t,e)}_onResolve(t,e){const i=this.component.props.onDataLoad;"data"===t&&i&&i(e,{propName:t,layer:this.layer})}_onError(t,e){this.layer.raiseError(e,"loading ".concat(t," of ").concat(this.layer))}}const fy=Object.freeze([]),py=Fd(({oldViewport:t,viewport:e})=>t.equals(e));let my=new Uint8ClampedArray(0);const yy={data:{type:"data",value:fy,async:!0},dataComparator:{type:"function",value:null,compare:!1,optional:!0},_dataDiff:{type:"function",value:t=>t&&t.__diff,compare:!1,optional:!0},dataTransform:{type:"function",value:null,compare:!1,optional:!0},onDataLoad:{type:"function",value:null,compare:!1,optional:!0},onError:{type:"function",value:null,compare:!1,optional:!0},fetch:{type:"function",value:(t,{propName:e,layer:i,loaders:n,loadOptions:r,signal:s})=>{const{resourceManager:o}=i.context;var a;(r=r||i.getLoadOptions(),n=n||i.props.loaders,s)&&(r={...r,fetch:{...null===(a=r)||void 0===a?void 0:a.fetch,signal:s}});let l=o.contains(t);return l||r||(o.add({resourceId:t,data:eh(t,n),persistent:!1}),l=!0),l?o.subscribe({resourceId:t,onChange:t=>i.internalState.reloadAsyncProp(e,t),consumerId:i.id,requestId:e}):eh(t,n,r)},compare:!1},updateTriggers:{},visible:!0,pickable:!1,opacity:{type:"number",min:0,max:1,value:1},operation:Yh,onHover:{type:"function",value:null,compare:!1,optional:!0},onClick:{type:"function",value:null,compare:!1,optional:!0},onDragStart:{type:"function",value:null,compare:!1,optional:!0},onDrag:{type:"function",value:null,compare:!1,optional:!0},onDragEnd:{type:"function",value:null,compare:!1,optional:!0},coordinateSystem:Wh.DEFAULT,coordinateOrigin:{type:"array",value:[0,0,0],compare:!0},modelMatrix:{type:"array",value:null,compare:!0,optional:!0},wrapLongitude:!1,positionFormat:"XYZ",colorFormat:"RGBA",parameters:{},transitions:null,extensions:[],loaders:{type:"array",value:[],optional:!0,compare:!0},getPolygonOffset:{type:"function",value:({layerIndex:t})=>[0,100*-t],compare:!1},highlightedObjectIndex:null,autoHighlight:!1,highlightColor:{type:"accessor",value:[0,0,128,128]}};class by extends dy{toString(){const t=this.constructor.layerName||this.constructor.name;return"".concat(t,"({id: '").concat(this.props.id,"'})")}raiseError(t,e){var i,n,r,s;(e&&(t.message="".concat(e,": ").concat(t.message)),null!==(i=(n=this.props).onError)&&void 0!==i&&i.call(n,t))||(null===(r=this.context)||void 0===r||null===(s=r.onError)||void 0===s||s.call(r,t,this))}setState(t){this.setChangeFlags({stateChanged:!0}),Object.assign(this.state,t),this.setNeedsRedraw()}setNeedsRedraw(t=!0){this.internalState&&(this.internalState.needsRedraw=t)}setNeedsUpdate(){this.context.layerManager.setNeedsUpdate(String(this)),this.internalState.needsUpdate=!0}getNeedsRedraw(t={clearRedrawFlags:!1}){return this._getNeedsRedraw(t)}needsUpdate(){return this.internalState.needsUpdate||this.hasUniformTransition()||this.shouldUpdateState(this._getUpdateParams())}hasUniformTransition(){return this.internalState.uniformTransitions.active}get isLoaded(){return this.internalState&&!this.internalState.isAsyncPropLoading()}get wrapLongitude(){return this.props.wrapLongitude}isPickable(){return this.props.pickable&&this.props.visible}getModels(){return this.state&&(this.state.models||(this.state.model?[this.state.model]:[]))}getAttributeManager(){return this.internalState&&this.internalState.attributeManager}getCurrentLayer(){return this.internalState&&this.internalState.layer}getLoadOptions(){return this.props.loadOptions}project(t){const{viewport:e}=this.context,i=Qm(t,{viewport:e,modelMatrix:this.props.modelMatrix,coordinateOrigin:this.props.coordinateOrigin,coordinateSystem:this.props.coordinateSystem}),[n,r,s]=kh(i,e.pixelProjectionMatrix);return 2===t.length?[n,r]:[n,r,s]}unproject(t){const{viewport:e}=this.context;return e.unproject(t)}projectPosition(t,e){return Zm(t,{viewport:this.context.viewport,modelMatrix:this.props.modelMatrix,coordinateOrigin:this.props.coordinateOrigin,coordinateSystem:this.props.coordinateSystem,...e})}use64bitPositions(){const{coordinateSystem:t}=this.props;return t===Wh.DEFAULT||t===Wh.LNGLAT||t===Wh.CARTESIAN}onHover(t,e){return!!this.props.onHover&&this.props.onHover(t,e)}onClick(t,e){return!!this.props.onClick&&this.props.onClick(t,e)}nullPickingColor(){return[0,0,0]}encodePickingColor(t,e=[]){return e[0]=t+1&255,e[1]=t+1>>8&255,e[2]=t+1>>8>>8&255,e}decodePickingColor(t){eg(t instanceof Uint8Array);const[e,i,n]=t;return e+256*i+65536*n-1}initializeState(){throw new Error("Layer ".concat(this," has not defined initializeState"))}getShaders(t){for(const e of this.props.extensions)t=qm(t,e.getShaders.call(this,e));return t}getBounds(){var t;const e=this.getAttributeManager();if(!e)return null;const{positions:i,instancePositions:n}=e.attributes;return null===(t=i||n)||void 0===t?void 0:t.getBounds()}shouldUpdateState({oldProps:t,props:e,context:i,changeFlags:n}){return n.propsOrDataChanged}updateState({oldProps:t,props:e,context:i,changeFlags:n}){const r=this.getAttributeManager();if(n.dataChanged&&r){const{dataChanged:t}=n;if(Array.isArray(t))for(const e of t)r.invalidateAll(e);else r.invalidateAll()}const s=Number.isInteger(t.highlightedObjectIndex)||t.pickable,o=Number.isInteger(e.highlightedObjectIndex)||e.pickable;if(s!==o&&r){const{pickingColors:t,instancePickingColors:e}=r.attributes,i=t||e;i&&(o&&i.constant&&(i.constant=!1,r.invalidate(i.id)),i.value||o||(i.constant=!0,i.value=[0,0,0]))}}finalizeState(){for(const t of this.getModels())t.delete();const t=this.getAttributeManager();t&&t.finalize(),this.context.resourceManager.unsubscribe({consumerId:this.id}),this.internalState.uniformTransitions.clear(),this.internalState.finalize()}draw(t){for(const e of this.getModels())e.draw(t)}getPickingInfo({info:t,mode:e}){const{index:i}=t;return i>=0&&Array.isArray(this.props.data)&&(t.object=this.props.data[i]),t}activateViewport(t){const e=this.internalState.viewport;this.internalState.viewport=t,e&&py({oldViewport:e,viewport:t})||(this.setChangeFlags({viewportChanged:!0}),this.isComposite?this.needsUpdate()&&this.setNeedsUpdate():this._update())}invalidateAttribute(t="all",e=""){const i=this.getAttributeManager();i&&("all"===t?i.invalidateAll():i.invalidate(t))}updateAttributes(t){for(const e of this.getModels())this._setModelAttributes(e,t)}_updateAttributes(t){const e=this.getAttributeManager();if(!e)return;const i=this.getNumInstances(t),n=this.getStartIndices(t);e.update({data:t.data,numInstances:i,startIndices:n,props:t,transitions:t.transitions,buffers:t.data.attributes,context:this,ignoreUnknownAttributes:!0});const r=e.getChangedAttributes({clearChangedFlags:!0});this.updateAttributes(r)}_updateAttributeTransition(){const t=this.getAttributeManager();t&&t.updateTransition()}_updateUniformTransition(){const{uniformTransitions:t}=this.internalState;if(t.active){const e=t.update(),i=Object.create(this.props);for(const t in e)Object.defineProperty(i,t,{value:e[t]});return i}return this.props}calculateInstancePickingColors(t,{numInstances:e}){if(t.constant)return;const i=Math.floor(my.length/3);if(this.internalState.usesPickingColorCache=!0,i<e){e>2**24-1&&Ta.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(),my=rh.allocate(my,e,{size:3,copy:!0,maxCount:Math.max(e,2**24-1)});const t=Math.floor(my.length/3),n=[];for(let e=i;e<t;e++)this.encodePickingColor(e,n),my[3*e+0]=n[0],my[3*e+1]=n[1],my[3*e+2]=n[2]}t.value=my.subarray(0,3*e)}_setModelAttributes(t,e){const i=this.getAttributeManager(),n=t.userData.excludeAttributes||{},r=i.getShaderAttributes(e,n);t.setAttributes(r)}disablePickingIndex(t){this._disablePickingIndex(t)}_disablePickingIndex(t){const{pickingColors:e,instancePickingColors:i}=this.getAttributeManager().attributes,n=e||i,r=n.getVertexOffset(t),s=n.getVertexOffset(t+1);n.buffer.subData({data:new Uint8Array(s-r),offset:r})}restorePickingColors(){const{pickingColors:t,instancePickingColors:e}=this.getAttributeManager().attributes,i=t||e;this.internalState.usesPickingColorCache&&i.value.buffer!==my.buffer&&(i.value=my.subarray(0,i.value.length)),i.updateSubBuffer({startOffset:0})}getNumInstances(t){return void 0!==(t=t||this.props).numInstances?t.numInstances:this.state&&void 0!==this.state.numInstances?this.state.numInstances:Hm(t.data)}getStartIndices(t){return void 0!==(t=t||this.props).startIndices?t.startIndices:this.state&&this.state.startIndices?this.state.startIndices:null}_initialize(){Oa("layer.initialize",this),this._initState(),this.initializeState(this.context);for(const t of this.props.extensions)t.initializeState.call(this,this.context,t);this.setChangeFlags({dataChanged:!0,propsChanged:!0,viewportChanged:!0,extensionsChanged:!0}),this._updateState()}_update(){const t=this.needsUpdate();Oa("layer.update",this,t),t&&this._updateState()}_updateState(){const t=this.props,e=this.context.viewport,i=this._updateUniformTransition();this.internalState.propsInTransition=i,this.context.viewport=this.internalState.viewport||e,this.props=i;try{const i=this._getUpdateParams(),n=this.getModels();if(this.context.gl)this.updateState(i);else try{this.updateState(i)}catch(t){}for(const t of this.props.extensions)t.updateState.call(this,i,t);const r=this.getModels()[0]!==n[0];this._updateModules(i,r),this.isComposite?this._renderLayers(i):(this.setNeedsRedraw(),this._updateAttributes(this.props),this.state.model&&this.state.model.setInstanceCount(this.getNumInstances()))}finally{this.context.viewport=e,this.props=t,this.clearChangeFlags(),this.internalState.needsUpdate=!1,this.internalState.resetOldProps()}}_finalize(){Oa("layer.finalize",this),this.finalizeState(this.context);for(const t of this.props.extensions)t.finalizeState.call(this,t)}drawLayer({moduleParameters:t=null,uniforms:e={},parameters:i={}}){this._updateAttributeTransition();const n=this.props;this.props=this.internalState.propsInTransition||n;const{opacity:r}=this.props;e.opacity=Math.pow(r,1/2.2);try{t&&this.setModuleParameters(t);const{getPolygonOffset:r}=this.props,s=r&&r(e)||[0,0];Object(Nu.c)(this.context.gl,{polygonOffset:s}),Object(Nu.d)(this.context.gl,i,()=>{const n={moduleParameters:t,uniforms:e,parameters:i,context:this.context};for(const t of this.props.extensions)t.draw.call(this,n,t);this.draw(n)})}finally{this.props=n}}getChangeFlags(){return this.internalState.changeFlags}setChangeFlags(t){const{changeFlags:e}=this.internalState;for(const i in t)if(t[i]){let n=!1;switch(i){case"dataChanged":Array.isArray(e[i])&&(e[i]=Array.isArray(t[i])?e[i].concat(t[i]):t[i],n=!0);default:e[i]||(e[i]=t[i],n=!0)}n&&Oa("layer.changeFlag",this,i,t)}const i=e.dataChanged||e.updateTriggersChanged||e.propsChanged||e.extensionsChanged;e.propsOrDataChanged=i,e.somethingChanged=i||t.viewportChanged||t.stateChanged}clearChangeFlags(){this.internalState.changeFlags={dataChanged:!1,propsChanged:!1,updateTriggersChanged:!1,viewportChanged:!1,stateChanged:!1,extensionsChanged:!1,propsOrDataChanged:!1,somethingChanged:!1}}diffProps(t,e){const i=km(t,e);if(i.updateTriggersChanged)for(const t in i.updateTriggersChanged)i.updateTriggersChanged[t]&&this.invalidateAttribute(t);if(i.transitionsChanged)for(const n in i.transitionsChanged)this.internalState.uniformTransitions.add(n,e[n],t[n],t.transitions[n]);return this.setChangeFlags(i)}validateProps(){!function(t){const e=Wm(t);for(const i in e){const n=e[i],{validate:r}=n;if(r&&!r(t[i],n))throw new Error("Invalid prop ".concat(i,": ").concat(t[i]))}}(this.props)}setModuleParameters(t){for(const e of this.getModels())e.updateModuleSettings(t)}updateAutoHighlight(t){this.props.autoHighlight&&!Number.isInteger(this.props.highlightedObjectIndex)&&this._updateAutoHighlight(t)}_updateAutoHighlight(t){const e={pickingSelectedColor:t.picked?t.color:null},{highlightColor:i}=this.props;t.picked&&"function"==typeof i&&(e.pickingHighlightColor=i(t)),this.setModuleParameters(e),this.setNeedsRedraw()}_updateModules({props:t,oldProps:e},i){const{autoHighlight:n,highlightedObjectIndex:r,highlightColor:s}=t;if(i||e.autoHighlight!==n||e.highlightedObjectIndex!==r||e.highlightColor!==s){const t={};n||(t.pickingSelectedColor=null),Array.isArray(s)&&(t.pickingHighlightColor=s),Number.isInteger(r)&&(t.pickingSelectedColor=r>=0?this.encodePickingColor(r):null),this.setModuleParameters(t)}}_getUpdateParams(){return{props:this.props,oldProps:this.internalState.getOldProps(),context:this.context,changeFlags:this.internalState.changeFlags}}_getNeedsRedraw(t){if(!this.internalState)return!1;let e=!1;e=e||this.internalState.needsRedraw&&this.id,this.internalState.needsRedraw=this.internalState.needsRedraw&&!t.clearRedrawFlags;const i=this.getAttributeManager(),n=i&&i.getNeedsRedraw(t);return e=e||n,e}_getAttributeManager(){return new Bm(this.context.gl,{id:this.props.id,stats:this.context.stats,timeline:this.context.timeline})}_initState(){eg(!this.internalState&&!this.state),eg(isFinite(this.props.coordinateSystem));const t=this._getAttributeManager();t&&t.addInstanced({instancePickingColors:{type:5121,size:3,noAlloc:!0,update:this.calculateInstancePickingColors}}),this.internalState=new gy({attributeManager:t,layer:this}),this.clearChangeFlags(),this.state={},Object.defineProperty(this.state,"attributeManager",{get:()=>(Ta.deprecated("layer.state.attributeManager","layer.getAttributeManager()"),t)}),this.internalState.layer=this,this.internalState.uniformTransitions=new Nm(this.context.timeline),this.internalState.onAsyncPropUpdated=this._onAsyncPropUpdated.bind(this),this.internalState.setAsyncProps(this.props)}_transferState(t){Oa("layer.matched",this,this===t);const{state:e,internalState:i}=t;this!==t&&(this.internalState=i,this.internalState.layer=this,this.state=e,this.internalState.setAsyncProps(this.props),this.diffProps(this.props,this.internalState.getOldProps()))}_onAsyncPropUpdated(){this.diffProps(this.props,this.internalState.getOldProps()),this.setNeedsUpdate()}}by.layerName="Layer",by.defaultProps=yy;class Py extends by{get isComposite(){return!0}get isLoaded(){return super.isLoaded&&this.getSubLayers().every(t=>t.isLoaded)}getSubLayers(){return this.internalState&&this.internalState.subLayers||[]}initializeState(){}setState(t){super.setState(t),this.setNeedsUpdate()}getPickingInfo({info:t}){const{object:e}=t;return e&&e.__source&&e.__source.parent&&e.__source.parent.id===this.id?(t.object=e.__source.object,t.index=e.__source.index,t):t}renderLayers(){return null}filterSubLayer(t){return!0}shouldRenderSubLayer(t,e){return e&&e.length}getSubLayerClass(t,e){const{_subLayerProps:i}=this.props;return i&&i[t]&&i[t].type||e}getSubLayerRow(t,e,i){return t.__source={parent:this,object:e,index:i},t}getSubLayerAccessor(t){if("function"==typeof t){const e={data:this.props.data,target:[]};return(i,n)=>i&&i.__source?(e.index=i.__source.index,t(i.__source.object,e)):t(i,n)}return t}getSubLayerProps(t={}){const{opacity:e,pickable:i,visible:n,parameters:r,getPolygonOffset:s,highlightedObjectIndex:o,autoHighlight:a,highlightColor:l,coordinateSystem:h,coordinateOrigin:u,wrapLongitude:c,positionFormat:d,modelMatrix:g,extensions:f,fetch:p,operation:m,_subLayerProps:y}=this.props,b={opacity:e,pickable:i,visible:n,parameters:r,getPolygonOffset:s,highlightedObjectIndex:o,autoHighlight:a,highlightColor:l,coordinateSystem:h,coordinateOrigin:u,wrapLongitude:c,positionFormat:d,modelMatrix:g,extensions:f,fetch:p,operation:m},P=y&&y[t.id],v=P&&P.updateTriggers,S=t.id||"sublayer";if(P){const e=this.constructor._propTypes,i=t.type?t.type._propTypes:{};for(const t in P){const n=i[t]||e[t];n&&"accessor"===n.type&&(P[t]=this.getSubLayerAccessor(P[t]))}}Object.assign(b,t,P),b.id="".concat(this.props.id,"-").concat(S),b.updateTriggers={all:this.props.updateTriggers.all,...t.updateTriggers,...v};for(const t of f){const e=t.getSubLayerProps.call(this,t);e&&Object.assign(b,e,{updateTriggers:Object.assign(b.updateTriggers,e.updateTriggers)})}return b}_updateAutoHighlight(t){for(const e of this.getSubLayers())e.updateAutoHighlight(t)}_getAttributeManager(){return null}_renderLayers(){let{subLayers:t}=this.internalState;const e=!t||this.needsUpdate();e&&(t=this.renderLayers(),t=_a(t,Boolean),this.internalState.subLayers=t),Oa("compositeLayer.renderLayers",this,e,t);for(const e of t)e.parent=this}}Py.layerName="CompositeLayer";var vy={name:"project32",dependencies:[Wd],vs:"\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n"},Sy="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";const Cy={lightSources:{}};function wy({color:t=[0,0,0],intensity:e=1}={}){return t.map(t=>t*e/255)}const Ey={name:"lights",vs:Sy,fs:Sy,getUniforms:function t(e=Cy){if("lightSources"in e){const{ambientLight:t,pointLights:i,directionalLights:n}=e.lightSources||{};return t||i&&i.length>0||n&&n.length>0?Object.assign({},function({ambientLight:t,pointLights:e=[],directionalLights:i=[]}){const n={};return n["lighting_uAmbientLight.color"]=t?wy(t):[0,0,0],e.forEach((t,e)=>{n[`lighting_uPointLight[${e}].color`]=wy(t),n[`lighting_uPointLight[${e}].position`]=t.position,n[`lighting_uPointLight[${e}].attenuation`]=t.attenuation||[1,0,0]}),n.lighting_uPointLightCount=e.length,i.forEach((t,e)=>{n[`lighting_uDirectionalLight[${e}].color`]=wy(t),n[`lighting_uDirectionalLight[${e}].direction`]=t.direction}),n.lighting_uDirectionalLightCount=i.length,n}({ambientLight:t,pointLights:i,directionalLights:n}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in e){const i={pointLights:[],directionalLights:[]};for(const t of e.lights||[])switch(t.type){case"ambient":i.ambientLight=t;break;case"directional":i.directionalLights.push(t);break;case"point":i.pointLights.push(t)}return t({lightSources:i})}return{}},defines:{MAX_LIGHTS:3}};var xy="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";const Ay={};function Ty(t=Ay){if(!("material"in t))return{};const{material:e}=t;return e?function(t){const{ambient:e=.35,diffuse:i=.6,shininess:n=32,specularColor:r=[30,30,30]}=t;return{lighting_uAmbient:e,lighting_uDiffuse:i,lighting_uShininess:n,lighting_uSpecularColor:r.map(t=>t/255)}}(e):{lighting_uEnabled:!1}}const Iy={name:"gouraud-lighting",dependencies:[Ey],vs:xy,defines:{LIGHTING_VERTEX:1},getUniforms:Ty},Oy={pickingSelectedColor:null,pickingHighlightColor:new Uint8Array([0,255,255,255]),pickingActive:!1,pickingAttribute:!1};var _y={inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ","vs:DECKGL_FILTER_COLOR":"\n  picking_setPickingColor(geometry.pickingColor);\n  ","fs:DECKGL_FILTER_COLOR":{order:99,injection:"\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "}},...{name:"picking",vs:"uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n",getUniforms:function(t=Oy){const e={};if(void 0!==t.pickingSelectedColor)if(t.pickingSelectedColor){const i=t.pickingSelectedColor.slice(0,3);e.picking_uSelectedColorValid=1,e.picking_uSelectedColor=i}else e.picking_uSelectedColorValid=0;if(t.pickingHighlightColor){const i=Array.from(t.pickingHighlightColor,t=>t/255);Number.isFinite(i[3])||(i[3]=1),e.picking_uHighlightColor=i}return void 0!==t.pickingActive&&(e.picking_uActive=Boolean(t.pickingActive),e.picking_uAttribute=Boolean(t.pickingAttribute)),e}}};const Ly={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6};class Ry{static get DRAW_MODE(){return Ly}constructor(t={}){const{id:e=ic("geometry"),drawMode:i=Ly.TRIANGLES,attributes:n={},indices:r=null,vertexCount:s=null}=t;this.id=e,this.drawMode=0|i,this.attributes={},this.userData={},this._setAttributes(n,r),this.vertexCount=s||this._calculateVertexCount(this.attributes,this.indices)}get mode(){return this.drawMode}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(t){return`Geometry ${this.id} attribute ${t}`}_setAttributes(t,e){e&&(this.indices=ArrayBuffer.isView(e)?{value:e,size:1}:e);for(const e in t){let i=t[e];i=ArrayBuffer.isView(i)?{value:i}:i,$u(ArrayBuffer.isView(i.value),this._print(e)+": must be typed array or object with value as typed array"),"POSITION"!==e&&"positions"!==e||i.size||(i.size=3),"indices"===e?($u(!this.indices),this.indices=i):this.attributes[e]=i}return this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this}_calculateVertexCount(t,e){if(e)return e.value.length;let i=1/0;for(const e in t){const n=t[e],{value:r,size:s,constant:o}=n;!o&&r&&s>=1&&(i=Math.min(i,r.length/s))}return $u(Number.isFinite(i)),i}}var By=i(70),My=i.n(By);const Fy=1,Dy=-1;function Ny(t,e,i={}){return function(t,e={}){return Math.sign(ky(t,e))}(t,i)!==e&&(function(t,e){const{start:i=0,end:n=t.length,size:r=2}=e,s=(n-i)/r,o=Math.floor(s/2);for(let e=0;e<o;++e){const n=i+e*r,o=i+(s-1-e)*r;for(let e=0;e<r;++e){const i=t[n+e];t[n+e]=t[o+e],t[o+e]=i}}}(t,i),!0)}function ky(t,e={}){const{start:i=0,end:n=t.length}=e,r=e.size||2;let s=0;for(let e=i,o=n-r;e<n;e+=r)s+=(t[e]-t[o])*(t[e+1]+t[o+1]),o=e;return s/2}function Vy(t,e){const i=e.length,n=t.length;if(n>0){let r=!0;for(let s=0;s<i;s++)if(t[n-i+s]!==e[s]){r=!1;break}if(r)return!1}for(let r=0;r<i;r++)t[n+r]=e[r];return!0}function Gy(t,e){const i=e.length;for(let n=0;n<i;n++)t[n]=e[n]}function zy(t,e,i,n,r=[]){const s=n+e*i;for(let e=0;e<i;e++)r[e]=t[s+e];return r}function jy(t,e,i,n,r=[]){let s,o;if(8&i)s=(n[3]-t[1])/(e[1]-t[1]),o=3;else if(4&i)s=(n[1]-t[1])/(e[1]-t[1]),o=1;else if(2&i)s=(n[2]-t[0])/(e[0]-t[0]),o=2;else{if(!(1&i))return null;s=(n[0]-t[0])/(e[0]-t[0]),o=0}for(let i=0;i<t.length;i++)r[i]=(1&o)===i?n[o]:s*(e[i]-t[i])+t[i];return r}function Uy(t,e){let i=0;return t[0]<e[0]?i|=1:t[0]>e[2]&&(i|=2),t[1]<e[1]?i|=4:t[1]>e[3]&&(i|=8),i}function Wy(t,e={}){const{size:i=2,broken:n=!1,gridResolution:r=10,gridOffset:s=[0,0],startIndex:o=0,endIndex:a=t.length}=e,l=(a-o)/i;let h=[];const u=[h],c=zy(t,0,i,o);let d,g;const f=Yy(c,r,s,[]),p=[];Vy(h,c);for(let e=1;e<l;e++){for(d=zy(t,e,i,o,d),g=Uy(d,f);g;){jy(c,d,g,f,p);const t=Uy(p,f);t&&(jy(c,p,t,f,p),g=t),Vy(h,p),Gy(c,p),Qy(f,r,g),n&&h.length>i&&(h=[],u.push(h),Vy(h,c)),g=Uy(d,f)}Vy(h,d),Gy(c,d)}return n?u:u[0]}function Hy(t,e){for(let i=0;i<e.length;i++)t.push(e[i]);return t}function qy(t,e,i={}){if(!t.length)return[];const{size:n=2,gridResolution:r=10,gridOffset:s=[0,0],edgeTypes:o=!1}=i,a=[],l=[{pos:t,types:o&&new Array(t.length/n).fill(1),holes:e||[]}],h=[[],[]];let u=[];for(;l.length;){const{pos:t,types:e,holes:i}=l.shift();Zy(t,n,i[0]||t.length,h),u=Yy(h[0],r,s,u);const c=Uy(h[1],u);if(c){let r=Xy(t,e,n,0,i[0]||t.length,u,c);const s={pos:r[0].pos,types:r[0].types,holes:[]},a={pos:r[1].pos,types:r[1].types,holes:[]};l.push(s,a);for(let l=0;l<i.length;l++)r=Xy(t,e,n,i[l],i[l+1]||t.length,u,c),r[0]&&(s.holes.push(s.pos.length),s.pos=Hy(s.pos,r[0].pos),o&&(s.types=Hy(s.types,r[0].types))),r[1]&&(a.holes.push(a.pos.length),a.pos=Hy(a.pos,r[1].pos),o&&(a.types=Hy(a.types,r[1].types)))}else{const n={positions:t};o&&(n.edgeTypes=e),i.length&&(n.holeIndices=i),a.push(n)}}return a}function Xy(t,e,i,n,r,s,o){const a=(r-n)/i,l=[],h=[],u=[],c=[],d=[];let g,f,p;const m=zy(t,a-1,i,n);let y=Math.sign(8&o?m[1]-s[3]:m[0]-s[2]),b=e&&e[a-1],P=0,v=0;for(let r=0;r<a;r++)g=zy(t,r,i,n,g),f=Math.sign(8&o?g[1]-s[3]:g[0]-s[2]),p=e&&e[n/i+r],f&&y&&y!==f&&(jy(m,g,o,s,d),Vy(l,d)&&u.push(b),Vy(h,d)&&c.push(b)),f<=0?(Vy(l,g)&&u.push(p),P-=f):u.length&&(u[u.length-1]=0),f>=0?(Vy(h,g)&&c.push(p),v+=f):c.length&&(c[c.length-1]=0),Gy(m,g),y=f,b=p;return[P?{pos:l,types:e&&u}:null,v?{pos:h,types:e&&c}:null]}function Yy(t,e,i,n){const r=Math.floor((t[0]-i[0])/e)*e+i[0],s=Math.floor((t[1]-i[1])/e)*e+i[1];return n[0]=r,n[1]=s,n[2]=r+e,n[3]=s+e,n}function Qy(t,e,i){8&i?(t[1]+=e,t[3]+=e):4&i?(t[1]-=e,t[3]-=e):2&i?(t[0]+=e,t[2]+=e):1&i&&(t[0]-=e,t[2]-=e)}function Zy(t,e,i,n){let r=1/0,s=-1/0,o=1/0,a=-1/0;for(let n=0;n<i;n+=e){const e=t[n],i=t[n+1];r=e<r?e:r,s=e>s?e:s,o=i<o?i:o,a=i>a?i:a}return n[0][0]=r,n[0][1]=o,n[1][0]=s,n[1][1]=a,n}function Ky(t,e,i,n){let r=-1,s=-1;for(let o=i+1;o<n;o+=e){const e=Math.abs(t[o]);e>r&&(r=e,s=o-1)}return s}function $y(t,e,i,n,r=85.051129){const s=t[i],o=t[n-e];if(Math.abs(s-o)>180){const n=zy(t,0,e,i);n[0]+=360*Math.round((o-s)/360),Vy(t,n),n[1]=Math.sign(n[1])*r,Vy(t,n),n[0]=s,Vy(t,n)}}function Jy(t,e,i,n){let r,s=t[0];for(let o=i;o<n;o+=e){r=t[o];const e=r-s;(e>180||e<-180)&&(r-=360*Math.round(e/360)),t[o]=s=r}}function tb(t,e){let i;const n=t.length/e;for(let r=0;r<n&&(i=t[r*e],(i+180)%360==0);r++);const r=360*-Math.round(i/360);if(0!==r)for(let i=0;i<n;i++)t[i*e]+=r}const eb=Fy,ib=Dy,nb={isClosed:!0};function rb(t,e,i,n,r){let s=e;const o=i.length;for(let e=0;e<o;e++)for(let r=0;r<n;r++)t[s++]=i[e][r]||0;if(!function(t){const e=t[0],i=t[t.length-1];return e[0]===i[0]&&e[1]===i[1]&&e[2]===i[2]}(i))for(let e=0;e<n;e++)t[s++]=i[0][e]||0;return nb.start=e,nb.end=s,nb.size=n,Ny(t,r,nb),s}function sb(t,e,i,n,r=0,s,o){const a=(s=s||i.length)-r;if(a<=0)return e;let l=e;for(let e=0;e<a;e++)t[l++]=i[r+e];if(!function(t,e,i,n){for(let r=0;r<e;r++)if(t[i+r]!==t[n-e+r])return!1;return!0}(i,n,r,s))for(let e=0;e<n;e++)t[l++]=i[r+e];return nb.start=e,nb.end=l,nb.size=n,Ny(t,o,nb),l}function ob(t,e){!function(t){if(t=t&&t.positions||t,!Array.isArray(t)&&!ArrayBuffer.isView(t))throw new Error("invalid polygon")}(t);const i=[],n=[];if(t.positions){const{positions:r,holeIndices:s}=t;if(s){let t=0;for(let o=0;o<=s.length;o++)t=sb(i,t,r,e,s[o-1],s[o],0===o?eb:ib),n.push(t);return n.pop(),{positions:i,holeIndices:n}}t=r}if(Number.isFinite(t[0]))return sb(i,0,t,e,0,i.length,eb),i;if(!function(t){return t.length>=1&&t[0].length>=2&&Number.isFinite(t[0][0])}(t)){let r=0;for(const[s,o]of t.entries())r=rb(i,r,o,e,0===s?eb:ib),n.push(r);return n.pop(),{positions:i,holeIndices:n}}return rb(i,0,t,e,eb),i}class ab{constructor(t={}){const{attributes:e={}}=t;this.typedArrayManager=rh,this.indexStarts=null,this.vertexStarts=null,this.vertexCount=0,this.instanceCount=0,this.attributes={},this._attributeDefs=e,this.opts=t,this.updateGeometry(t),Object.seal(this)}updateGeometry(t){Object.assign(this.opts,t);const{data:e,buffers:i={},getGeometry:n,geometryBuffer:r,positionFormat:s,dataChanged:o,normalize:a=!0}=this.opts;if(this.data=e,this.getGeometry=n,this.positionSize=r&&r.size||("XY"===s?2:3),this.buffers=i,this.normalize=a,r&&(eg(e.startIndices),this.getGeometry=this.getGeometryFromBuffer(r),a||(i.positions=r)),this.geometryBuffer=i.positions,Array.isArray(o))for(const t of o)this._rebuildGeometry(t);else this._rebuildGeometry()}updatePartialGeometry({startRow:t,endRow:e}){this._rebuildGeometry({startRow:t,endRow:e})}normalizeGeometry(t){return t}updateGeometryAttributes(t,e,i){throw new Error("Not implemented")}getGeometrySize(t){throw new Error("Not implemented")}getGeometryFromBuffer(t){const e=t.value||t;return eg(ArrayBuffer.isView(e)),Wp(e,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices})}_allocate(t,e){const{attributes:i,buffers:n,_attributeDefs:r,typedArrayManager:s}=this;for(const o in r)if(o in n)s.release(i[o]),i[o]=null;else{const n=r[o];n.copy=e,i[o]=s.allocate(i[o],t,n)}}_forEachGeometry(t,e,i){const{data:n,getGeometry:r}=this,{iterable:s,objectInfo:o}=jp(n,e,i);for(const e of s){o.index++;t(r(e,o),o.index)}}_rebuildGeometry(t){if(!this.data||!this.getGeometry)return;let{indexStarts:e,vertexStarts:i,instanceCount:n}=this;const{data:r,geometryBuffer:s}=this,{startRow:o=0,endRow:a=1/0}=t||{},l={};if(t||(e=[0],i=[0]),this.normalize||!s)this._forEachGeometry((t,e)=>{t=this.normalizeGeometry(t),l[e]=t,i[e+1]=i[e]+this.getGeometrySize(t)},o,a),n=i[i.length-1];else if(s.buffer instanceof bc){const t=s.stride||4*this.positionSize;i=r.startIndices,n=i[r.length]||s.buffer.byteLength/t}else{const t=s.value||s,e=s.stride/t.BYTES_PER_ELEMENT||this.positionSize;i=r.startIndices,n=i[r.length]||t.length/e}this._allocate(n,Boolean(t)),this.indexStarts=e,this.vertexStarts=i,this.instanceCount=n;const h={};this._forEachGeometry((t,r)=>{t=l[r]||t,h.vertexStart=i[r],h.indexStart=e[r];const s=r<i.length-1?i[r+1]:n;h.geometrySize=s-i[r],h.geometryIndex=r,this.updateGeometryAttributes(t,h)},o,a),this.vertexCount=e[e.length-1]}}class lb extends ab{constructor(t){const{fp64:e,IndexType:i=Uint32Array}=t;super({...t,attributes:{positions:{size:3,type:e?Float64Array:Float32Array},vertexValid:{type:Uint8ClampedArray,size:1},indices:{type:i,size:1}}})}get(t){const{attributes:e}=this;return"indices"===t?e.indices&&e.indices.subarray(0,this.vertexCount):e[t]}updateGeometry(t){super.updateGeometry(t);const e=this.buffers.indices;e&&(this.vertexCount=(e.value||e).length)}normalizeGeometry(t){if(this.normalize){if(t=ob(t,this.positionSize),this.opts.resolution)return qy(t.positions||t,t.holeIndices,{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0});if(this.opts.wrapLongitude)return function(t,e,i={}){const{size:n=2,normalize:r=!0,edgeTypes:s=!1}=i;e=e||[];const o=[],a=[];let l=0,h=0;for(let r=0;r<=e.length;r++){const s=e[r]||t.length,u=h,c=Ky(t,n,l,s);for(let e=c;e<s;e++)o[h++]=t[e];for(let e=l;e<c;e++)o[h++]=t[e];Jy(o,n,u,h),$y(o,n,u,h,i.maxLatitude),l=s,a[r]=h}a.pop();const u=qy(o,a,{size:n,gridResolution:360,gridOffset:[-180,-180],edgeTypes:s});if(r)for(const t of u)tb(t.positions,n);return u}(t.positions||t,t.holeIndices,{size:this.positionSize,maxLatitude:86,edgeTypes:!0})}return t}getGeometrySize(t){if(Array.isArray(t)&&!Number.isFinite(t[0])){let e=0;for(const i of t)e+=this.getGeometrySize(i);return e}return(t.positions||t).length/this.positionSize}getGeometryFromBuffer(t){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(t):()=>null}updateGeometryAttributes(t,e){if(Array.isArray(t)&&!Number.isFinite(t[0]))for(const i of t){const t=this.getGeometrySize(i);e.geometrySize=t,this.updateGeometryAttributes(i,e),e.vertexStart+=t,e.indexStart=this.indexStarts[e.geometryIndex+1]}else this._updateIndices(t,e),this._updatePositions(t,e),this._updateVertexValid(t,e)}_updateIndices(t,{geometryIndex:e,vertexStart:i,indexStart:n}){const{attributes:r,indexStarts:s,typedArrayManager:o}=this;let a=r.indices;if(!a)return;let l=n;const h=function(t,e,i){let n=null;t.holeIndices&&(n=t.holeIndices.map(t=>t/e));let r=t.positions||t;if(i){const t=r.length;r=r.slice();const n=[];for(let s=0;s<t;s+=e){n[0]=r[s],n[1]=r[s+1];const t=i(n);r[s]=t[0],r[s+1]=t[1]}}return My()(r,n,e)}(t,this.positionSize,this.opts.preproject);a=o.allocate(a,n+h.length,{copy:!0});for(let t=0;t<h.length;t++)a[l++]=h[t]+i;s[e+1]=n+h.length,r.indices=a}_updatePositions(t,{vertexStart:e,geometrySize:i}){const{attributes:{positions:n},positionSize:r}=this;if(!n)return;const s=t.positions||t;for(let t=e,o=0;o<i;t++,o++){const e=s[o*r],i=s[o*r+1],a=r>2?s[o*r+2]:0;n[3*t]=e,n[3*t+1]=i,n[3*t+2]=a}}_updateVertexValid(t,{vertexStart:e,geometrySize:i}){const{attributes:{vertexValid:n},positionSize:r}=this,s=t&&t.holeIndices;if(t&&t.edgeTypes?n.set(t.edgeTypes,e):n.fill(1,e,e+i),s)for(let t=0;t<s.length;t++)n[e+s[t]/r-1]=0;n[e+i-1]=0}}var hb="\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",ub="#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(hb,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n"),cb="#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(hb,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n");const db=[0,0,0,255],gb={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:t=>t.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:db},getLineColor:{type:"accessor",value:db},material:!0},fb={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class pb extends by{getShaders(t){return super.getShaders({vs:"top"===t?ub:cb,fs:"#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",defines:{RING_WINDING_ORDER_CW:this.props._normalize||"CCW"!==this.props._windingOrder?1:0},modules:[vy,Iy,_y]})}get wrapLongitude(){return!1}initializeState(){const{gl:t,viewport:e}=this.context;let{coordinateSystem:i}=this.props;e.isGeospatial&&i===Wh.DEFAULT&&(i=Wh.LNGLAT),this.setState({numInstances:0,polygonTesselator:new lb({preproject:i===Wh.LNGLAT&&e.projectFlat,fp64:this.use64bitPositions(),IndexType:!t||Uc(t,zc)?Uint32Array:Uint16Array})});const n=this.getAttributeManager();n.remove(["instancePickingColors"]),n.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:!0},positions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:fb,accessor:"getPolygon",update:this.calculatePositions,noAlloc:!0,shaderAttributes:{positions:{vertexOffset:0,divisor:0},instancePositions:{vertexOffset:0,divisor:1},nextPositions:{vertexOffset:1,divisor:1}}},vertexValid:{size:1,divisor:1,type:5121,update:this.calculateVertexValid,noAlloc:!0},elevations:{size:1,transition:fb,accessor:"getElevation",shaderAttributes:{elevations:{divisor:0},instanceElevations:{divisor:1}}},fillColors:{alias:"colors",size:this.props.colorFormat.length,type:5121,normalized:!0,transition:fb,accessor:"getFillColor",defaultValue:db,shaderAttributes:{fillColors:{divisor:0},instanceFillColors:{divisor:1}}},lineColors:{alias:"colors",size:this.props.colorFormat.length,type:5121,normalized:!0,transition:fb,accessor:"getLineColor",defaultValue:db,shaderAttributes:{lineColors:{divisor:0},instanceLineColors:{divisor:1}}},pickingColors:{size:3,type:5121,accessor:(t,{index:e,target:i})=>this.encodePickingColor(t&&t.__source?t.__source.index:e,i),shaderAttributes:{pickingColors:{divisor:0},instancePickingColors:{divisor:1}}}})}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i}=e,{data:n}=this.props;return n[0]&&n[0].__source&&(e.object=n.find(t=>t.__source.index===i)),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else this._disablePickingIndex(t)}draw({uniforms:t}){const{extruded:e,filled:i,wireframe:n,elevationScale:r}=this.props,{topModel:s,sideModel:o,polygonTesselator:a}=this.state,l={...t,extruded:Boolean(e),elevationScale:r};o&&(o.setInstanceCount(a.instanceCount-1),o.setUniforms(l),n&&(o.setDrawMode(3),o.setUniforms({isWireframe:!0}).draw()),i&&(o.setDrawMode(6),o.setUniforms({isWireframe:!1}).draw())),s&&(s.setVertexCount(a.vertexCount),s.setUniforms(l).draw())}updateState(t){super.updateState(t),this.updateGeometry(t);const{props:e,oldProps:i,changeFlags:n}=t,r=this.getAttributeManager();var s;(n.extensionsChanged||e.filled!==i.filled||e.extruded!==i.extruded)&&(null===(s=this.state.models)||void 0===s||s.forEach(t=>t.delete()),this.setState(this._getModels(this.context.gl)),r.invalidateAll())}updateGeometry({props:t,oldProps:e,changeFlags:i}){if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPolygon)){const{polygonTesselator:e}=this.state,n=t.data.attributes||{};e.updateGeometry({data:t.data,normalize:t._normalize,geometryBuffer:n.getPolygon,buffers:n,getGeometry:t.getPolygon,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:i.dataChanged}),this.setState({numInstances:e.instanceCount,startIndices:e.vertexStarts}),i.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(t){const{id:e,filled:i,extruded:n}=this.props;let r,s;if(i){const i=this.getShaders("top");i.defines.NON_INSTANCED_MODEL=1,r=new Om(t,{...i,id:"".concat(e,"-top"),drawMode:4,attributes:{vertexPositions:new Float32Array([0,1])},uniforms:{isWireframe:!1,isSideVertex:!1},vertexCount:0,isIndexed:!0})}return n&&(s=new Om(t,{...this.getShaders("side"),id:"".concat(e,"-side"),geometry:new Ry({drawMode:1,vertexCount:4,attributes:{vertexPositions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),instanceCount:0,isInstanced:1}),s.userData.excludeAttributes={indices:!0}),{models:[s,r].filter(Boolean),topModel:r,sideModel:s}}calculateIndices(t){const{polygonTesselator:e}=this.state;t.startIndices=e.indexStarts,t.value=e.get("indices")}calculatePositions(t){const{polygonTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateVertexValid(t){t.value=this.state.polygonTesselator.get("vertexValid")}}function mb(t,e,i,n){let r=t;if(Array.isArray(t[0])){const i=t.length*e;r=new Array(i);for(let i=0;i<t.length;i++)for(let n=0;n<e;n++)r[i*e+n]=t[i][n]||0}return i?Wy(r,{size:e,gridResolution:i}):n?function(t,e={}){const{size:i=2,startIndex:n=0,endIndex:r=t.length,normalize:s=!0}=e,o=t.slice(n,r);Jy(o,i,0,r-n);const a=Wy(o,{size:i,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(s)for(const t of a)tb(t,i);return a}(r,{size:e}):r}pb.layerName="SolidPolygonLayer",pb.defaultProps=gb;class yb extends ab{constructor(t){super({...t,attributes:{positions:{size:3,padding:18,initialize:!0,type:t.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}getGeometryFromBuffer(t){return this.normalize?super.getGeometryFromBuffer(t):()=>null}normalizeGeometry(t){return this.normalize?mb(t,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):t}get(t){return this.attributes[t]}getGeometrySize(t){if(Array.isArray(t[0])){let e=0;for(const i of t)e+=this.getGeometrySize(i);return e}const e=this.getPathLength(t);return e<2?0:this.isClosed(t)?e<3?0:e+2:e}updateGeometryAttributes(t,e){if(0!==e.geometrySize)if(t&&Array.isArray(t[0]))for(const i of t){const t=this.getGeometrySize(i);e.geometrySize=t,this.updateGeometryAttributes(i,e),e.vertexStart+=t}else this._updateSegmentTypes(t,e),this._updatePositions(t,e)}_updateSegmentTypes(t,e){const{segmentTypes:i}=this.attributes,n=this.isClosed(t),{vertexStart:r,geometrySize:s}=e;i.fill(0,r,r+s),n?(i[r]=4,i[r+s-2]=4):(i[r]+=1,i[r+s-2]+=2),i[r+s-1]=4}_updatePositions(t,e){const{positions:i}=this.attributes;if(!i)return;const{vertexStart:n,geometrySize:r}=e,s=new Array(3);for(let e=n,o=0;o<r;e++,o++)this.getPointOnPath(t,o,s),i[3*e]=s[0],i[3*e+1]=s[1],i[3*e+2]=s[2]}getPathLength(t){return t.length/this.positionSize}getPointOnPath(t,e,i=[]){const{positionSize:n}=this;e*n>=t.length&&(e+=1-t.length/n);const r=e*n;return i[0]=t[r],i[1]=t[r+1],i[2]=3===n&&t[r+2]||0,i}isClosed(t){if(!this.normalize)return this.opts.loop;const{positionSize:e}=this,i=t.length-e;return t[0]===t[i]&&t[1]===t[i+1]&&(2===e||t[2]===t[i+2])}}const bb=[0,0,0,255],Pb={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:t=>t.path},getColor:{type:"accessor",value:bb},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},vb={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class Sb extends by{getShaders(){return super.getShaders({vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[vy,_y]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({positions:{size:3,vertexOffset:1,type:5130,fp64:this.use64bitPositions(),transition:vb,accessor:"getPath",update:this.calculatePositions,noAlloc:!0,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:!0},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:vb,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:vb,defaultValue:bb},instancePickingColors:{size:3,type:5121,accessor:(t,{index:e,target:i})=>this.encodePickingColor(t&&t.__source?t.__source.index:e,i)}}),this.setState({pathTesselator:new yb({fp64:this.use64bitPositions()})}),this.props.getDashArray&&!this.props.extensions.length&&Ta.removed("getDashArray","PathStyleExtension")()}updateState({oldProps:t,props:e,changeFlags:i}){super.updateState({props:e,oldProps:t,changeFlags:i});const n=this.getAttributeManager();if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPath)){const{pathTesselator:t}=this.state,r=e.data.attributes||{};t.updateGeometry({data:e.data,geometryBuffer:r.getPath,buffers:r,normalize:!e._pathType,loop:"loop"===e._pathType,getGeometry:e.getPath,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:i.dataChanged}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),i.dataChanged||n.invalidateAll()}if(i.extensionsChanged){var r;const{gl:t}=this.context;null===(r=this.state.model)||void 0===r||r.delete(),this.state.model=this._getModel(t),n.invalidateAll()}}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i}=e,{data:n}=this.props;return n[0]&&n[0].__source&&(e.object=n.find(t=>t.__source.index===i)),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else this._disablePickingIndex(t)}draw({uniforms:t}){const{jointRounded:e,capRounded:i,billboard:n,miterLimit:r,widthUnits:s,widthScale:o,widthMinPixels:a,widthMaxPixels:l}=this.props;this.state.model.setUniforms(t).setUniforms({jointType:Number(e),capType:Number(i),billboard:n,widthUnits:qh[s],widthScale:o,miterLimit:r,widthMinPixels:a,widthMaxPixels:l}).draw()}_getModel(t){return new Om(t,{...this.getShaders(),id:this.props.id,geometry:new Ry({drawMode:4,attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0})}calculatePositions(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateSegmentTypes(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("segmentTypes")}}Sb.layerName="PathLayer",Sb.defaultProps=Pb;const Cb=[0,0,0,255],wb={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,_normalize:!0,_windingOrder:"CW",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,getPolygon:{type:"accessor",value:t=>t.polygon},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:Cb},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0};class Eb extends Py{initializeState(){this.state={paths:[]},this.props.getLineDashArray&&Ta.removed("getLineDashArray","PathStyleExtension")()}updateState({oldProps:t,props:e,changeFlags:i}){const n=i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPolygon);if(n&&Array.isArray(i.dataChanged)){const t=this.state.paths.slice(),e=i.dataChanged.map(e=>function({data:t,getIndex:e,dataRange:i,replace:n}){const{startRow:r=0,endRow:s=1/0}=i,o=t.length;let a=o,l=o;for(let i=0;i<o;i++){const n=e(t[i]);if(a>i&&n>=r&&(a=i),n>=s){l=i;break}}let h=a;const u=l-a!==n.length,c=u&&t.slice(l);for(let e=0;e<n.length;e++)t[h++]=n[e];if(u){for(let e=0;e<c.length;e++)t[h++]=c[e];t.length=h}return{startRow:a,endRow:a+n.length}}({data:t,getIndex:t=>t.__source.index,dataRange:e,replace:this._getPaths(e)}));this.setState({paths:t,pathsDiff:e})}else n&&this.setState({paths:this._getPaths(),pathsDiff:null})}_getPaths(t={}){const{data:e,getPolygon:i,positionFormat:n,_normalize:r}=this.props,s=[],o="XY"===n?2:3,{startRow:a,endRow:l}=t,{iterable:h,objectInfo:u}=jp(e,a,l);for(const t of h){u.index++;let e=i(t,u);r&&(e=ob(e,o));const{holeIndices:n}=e,a=e.positions||e;if(n)for(let e=0;e<=n.length;e++){const i=a.slice(n[e-1]||0,n[e]||a.length);s.push(this.getSubLayerRow({path:i},t,u.index))}else s.push(this.getSubLayerRow({path:a},t,u.index))}return s}renderLayers(){const{data:t,_dataDiff:e,stroked:i,filled:n,extruded:r,wireframe:s,_normalize:o,_windingOrder:a,elevationScale:l,transitions:h,positionFormat:u}=this.props,{lineWidthUnits:c,lineWidthScale:d,lineWidthMinPixels:g,lineWidthMaxPixels:f,lineJointRounded:p,lineMiterLimit:m,lineDashJustified:y}=this.props,{getFillColor:b,getLineColor:P,getLineWidth:v,getLineDashArray:S,getElevation:C,getPolygon:w,updateTriggers:E,material:x}=this.props,{paths:A,pathsDiff:T}=this.state,I=this.getSubLayerClass("fill",pb),O=this.getSubLayerClass("stroke",Sb),_=this.shouldRenderSubLayer("fill",A)&&new I({_dataDiff:e,extruded:r,elevationScale:l,filled:n,wireframe:s,_normalize:o,_windingOrder:a,getElevation:C,getFillColor:b,getLineColor:r&&s?P:Cb,material:x,transitions:h},this.getSubLayerProps({id:"fill",updateTriggers:{getPolygon:E.getPolygon,getElevation:E.getElevation,getFillColor:E.getFillColor,lineColors:r&&s,getLineColor:E.getLineColor}}),{data:t,positionFormat:u,getPolygon:w});return[!r&&_,!r&&i&&this.shouldRenderSubLayer("stroke",A)&&new O({_dataDiff:T&&(()=>T),widthUnits:c,widthScale:d,widthMinPixels:g,widthMaxPixels:f,jointRounded:p,miterLimit:m,dashJustified:y,_pathType:"loop",transitions:h&&{getWidth:h.getLineWidth,getColor:h.getLineColor,getPath:h.getPolygon},getColor:this.getSubLayerAccessor(P),getWidth:this.getSubLayerAccessor(v),getDashArray:this.getSubLayerAccessor(S)},this.getSubLayerProps({id:"stroke",updateTriggers:{getWidth:E.getLineWidth,getColor:E.getLineColor,getDashArray:E.getLineDashArray}}),{data:A,positionFormat:u,getPath:t=>t.path}),r&&_]}}Eb.layerName="PolygonLayer",Eb.defaultProps=wb;const xb=()=>{},Ab={10241:9987,10240:9729,10242:33071,10243:33071};function Tb(t,e,i,n){return i===e.width&&n===e.height?e:(t.canvas.height=n,t.canvas.width=i,t.clearRect(0,0,t.canvas.width,t.canvas.height),t.drawImage(e,0,0,e.width,e.height,0,0,i,n),t.canvas)}function Ib(t){return t&&(t.id||t.url)}function Ob(t,e,i,n){const r=e.width,s=e.height,o=Fc(e,{width:i,height:n});return function(t,e,i={}){const{sourceX:n=0,sourceY:r=0,targetMipmaplevel:s=0,targetInternalFormat:o=6408}=i;let{targetX:a,targetY:l,targetZ:h,width:u,height:c}=i;const{framebuffer:d,deleteFramebuffer:g}=Vc(t);$u(d);const{gl:f,handle:p}=d,m=void 0!==a||void 0!==l||void 0!==h;a=a||0,l=l||0,h=h||0;const y=f.bindFramebuffer(36160,p);$u(e);let b=null;if(e instanceof Ec&&(b=e,u=Number.isFinite(u)?u:b.width,c=Number.isFinite(c)?c:b.height,b.bind(0),e=b.target),m)switch(e){case 3553:case 34067:f.copyTexSubImage2D(e,s,a,l,n,r,u,c);break;case 35866:case 32879:Object(Du.a)(f).copyTexSubImage3D(e,s,a,l,h,n,r,u,c)}else f.copyTexImage2D(e,s,o,n,r,u,c,0);b&&b.unbind(),f.bindFramebuffer(36160,y||null),g&&d.delete()}(e,o,{targetY:0,width:r,height:s}),e.delete(),o}function _b(t,e,i){for(let n=0;n<e.length;n++){const{icon:r,xOffset:s}=e[n];t[Ib(r)]={...r,x:s,y:i}}}class Lb{constructor(t,{onUpdate:e=xb,onError:i=xb}){this.gl=t,this.onUpdate=e,this.onError=i,this._loadOptions=null,this._getIcon=null,this._texture=null,this._externalTexture=null,this._mapping={},this._pendingCount=0,this._autoPacking=!1,this._xOffset=0,this._yOffset=0,this._rowHeight=0,this._buffer=4,this._canvasWidth=1024,this._canvasHeight=0,this._canvas=null}finalize(){var t;null===(t=this._texture)||void 0===t||t.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(t){const e=this._autoPacking?Ib(t):t;return this._mapping[e]||{}}setProps({loadOptions:t,autoPacking:e,iconAtlas:i,iconMapping:n,data:r,getIcon:s}){t&&(this._loadOptions=t),void 0!==e&&(this._autoPacking=e),s&&(this._getIcon=s),n&&(this._mapping=n),i&&this._updateIconAtlas(i),this._autoPacking&&(r||s)&&"undefined"!=typeof document&&(this._canvas=this._canvas||document.createElement("canvas"),this._updateAutoPacking(r))}get isLoaded(){return 0===this._pendingCount}_updateIconAtlas(t){var e;null===(e=this._texture)||void 0===e||e.delete(),this._texture=null,this._externalTexture=t,this.onUpdate()}_updateAutoPacking(t){const e=Object.values(function(t,e,i){if(!t||!e)return null;i=i||{};const n={},{iterable:r,objectInfo:s}=jp(t);for(const t of r){s.index++;const r=e(t,s),o=Ib(r);if(!r)throw new Error("Icon is missing.");if(!r.url)throw new Error("Icon url is missing.");n[o]||i[o]&&r.url===i[o].url||(n[o]={...r,source:t,sourceIndex:s.index})}return n}(t,this._getIcon,this._mapping)||{});if(e.length>0){const{mapping:t,xOffset:i,yOffset:n,rowHeight:r,canvasHeight:s}=function({icons:t,buffer:e,mapping:i={},xOffset:n=0,yOffset:r=0,rowHeight:s=0,canvasWidth:o}){let a=[];for(let l=0;l<t.length;l++){const h=t[l];if(!i[Ib(h)]){const{height:t,width:l}=h;n+l+e>o&&(_b(i,a,r),n=0,r=s+r+e,s=0,a=[]),a.push({icon:h,xOffset:n}),n=n+l+e,s=Math.max(s,t)}}return a.length>0&&_b(i,a,r),{mapping:i,rowHeight:s,xOffset:n,yOffset:r,canvasWidth:o,canvasHeight:(l=s+r+e,Math.pow(2,Math.ceil(Math.log2(l))))};var l}({icons:e,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=r,this._mapping=t,this._xOffset=i,this._yOffset=n,this._canvasHeight=s,this._texture||(this._texture=new Ac(this.gl,{width:this._canvasWidth,height:this._canvasHeight,parameters:Ab})),this._texture.height!==this._canvasHeight&&(this._texture=Ob(this.gl,this._texture,this._canvasWidth,this._canvasHeight)),this.onUpdate(),this._loadIcons(e)}}_loadIcons(t){const e=this._canvas.getContext("2d");for(const i of t)this._pendingCount++,eh(i.url,Jf,this._loadOptions).then(t=>{const n=Ib(i),{x:r,y:s,width:o,height:a}=this._mapping[n],l=Tb(e,t,o,a);this._texture.setSubImageData({data:l,x:r,y:s,width:o,height:a}),this._texture.generateMipmap(),this.onUpdate()}).catch(t=>{this.onError({url:i.url,source:i.source,sourceIndex:i.sourceIndex,loadOptions:this._loadOptions,error:t})}).finally(()=>{this._pendingCount--})}}const Rb=[0,0,0,255],Bb={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:t=>t.position},getIcon:{type:"accessor",value:t=>t.icon},getColor:{type:"accessor",value:Rb},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,compare:!1,optional:!0}};class Mb extends by{getShaders(){return super.getShaders({vs:"#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n",fs:"#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[vy,_y]})}initializeState(){this.state={iconManager:new Lb(this.context.gl,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})};this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:5121,accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:Rb},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState({oldProps:t,props:e,changeFlags:i}){super.updateState({props:e,oldProps:t,changeFlags:i});const n=this.getAttributeManager(),{iconAtlas:r,iconMapping:s,data:o,getIcon:a}=e,{iconManager:l}=this.state;l.setProps({loadOptions:e.loadOptions});let h=!1;if(r||this.internalState.isAsyncPropLoading("iconAtlas")?(t.iconAtlas!==e.iconAtlas&&l.setProps({iconAtlas:r,autoPacking:!1}),t.iconMapping!==e.iconMapping&&(l.setProps({iconMapping:s}),h=!0)):l.setProps({autoPacking:!0}),(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getIcon))&&l.setProps({data:o,getIcon:a}),h&&(n.invalidate("instanceOffsets"),n.invalidate("instanceIconFrames"),n.invalidate("instanceColorModes")),i.extensionsChanged){var u;const{gl:t}=this.context;null===(u=this.state.model)||void 0===u||u.delete(),this.state.model=this._getModel(t),n.invalidateAll()}}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(){super.finalizeState(),this.state.iconManager.finalize()}draw({uniforms:t}){const{sizeScale:e,sizeMinPixels:i,sizeMaxPixels:n,sizeUnits:r,billboard:s,alphaCutoff:o}=this.props,{iconManager:a}=this.state,l=a.getTexture();l&&this.state.model.setUniforms(t).setUniforms({iconsTexture:l,iconsTextureDim:[l.width,l.height],sizeUnits:qh[r],sizeScale:e,sizeMinPixels:i,sizeMaxPixels:n,billboard:s,alphaCutoff:o}).draw()}_getModel(t){return new Om(t,{...this.getShaders(),id:this.props.id,geometry:new Ry({drawMode:6,attributes:{positions:{size:2,value:new Float32Array([-1,-1,-1,1,1,1,1,-1])}}}),isInstanced:!0})}_onUpdate(){this.setNeedsRedraw()}_onError(t){const{onIconError:e}=this.getCurrentLayer().props;e?e(t):Ta.error(t.error)()}getInstanceOffset(t){const e=this.state.iconManager.getIconMapping(t);return[e.width/2-e.anchorX||0,e.height/2-e.anchorY||0]}getInstanceColorMode(t){return this.state.iconManager.getIconMapping(t).mask?1:0}getInstanceIconFrame(t){const e=this.state.iconManager.getIconMapping(t);return[e.x||0,e.y||0,e.width||0,e.height||0]}}Mb.layerName="IconLayer",Mb.defaultProps=Bb;const Fb=[];class Db extends Mb{getShaders(){return{...super.getShaders(),fs:"#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float buffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(buffer - gamma, buffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n"}}initializeState(){super.initializeState();this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:5121,size:3,accessor:(t,{index:e,target:i})=>this.encodePickingColor(e,i)}})}updateState(t){super.updateState(t);const{props:e,oldProps:i}=t;let{outlineColor:n}=e;n!==i.outlineColor&&(n=n.map(t=>t/255),n[3]=Number.isFinite(n[3])?n[3]:1,this.setState({outlineColor:n})),!e.sdf&&e.outlineWidth&&Ta.warn("".concat(this.id,": fontSettings.sdf is required to render outline"))()}draw(t){const{sdf:e,smoothing:i,outlineWidth:n}=this.props,{outlineColor:r}=this.state;t.uniforms={...t.uniforms,buffer:.75,outlineBuffer:n?Math.max(i,.75*(1-n)):-1,gamma:i,sdf:Boolean(e),outlineColor:r},super.draw(t)}getInstanceOffset(t){return t?Array.from(t).map(t=>super.getInstanceOffset(t)):Fb}getInstanceColorMode(t){return 1}getInstanceIconFrame(t){return t?Array.from(t).map(t=>super.getInstanceIconFrame(t)):Fb}}Db.layerName="MultiIconLayer",Db.defaultProps={getIconOffsets:{type:"accessor",value:t=>t.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}};var Nb=i(71),kb=i.n(Nb);const Vb=[];function Gb(t,e,i,n){let r=0;for(let s=e;s<i;s++){const e=t[s];let i=null;const o=n&&n[e];o&&(i=o.width),r+=i}return r}function zb(t,e,i,n,r,s){let o=e,a=0;for(let l=e;l<i;l++){const e=Gb(t,l,l+1,r);a+e>n&&(o<l&&s.push(l),o=l,a=0),a+=e}return a}function jb(t,e,i,n,r=0,s){void 0===s&&(s=t.length);const o=[];return"break-all"===e?zb(t,r,s,i,n,o):function(t,e,i,n,r,s){let o=e,a=e,l=e,h=0;for(let u=e;u<i;u++)if(" "===t[u]?l=u+1:" "!==t[u+1]&&u+1!==i||(l=u+1),l>a){let e=Gb(t,a,l,r);h+e>n&&(o<a&&(s.push(a),o=a,h=0),e>n&&(e=zb(t,a,l,n,r,s),o=s[s.length-1])),a=l,h+=e}}(t,r,s,i,n,o),o}function Ub(t,e,i,n,r,s){let o=0,a=0;for(let s=e;s<i;s++){const e=t[s],i=n[e];i?(a||(a=i.height),r[s]=o+i.width/2,o+=i.width):(Ta.warn("Missing character: ".concat(e," (").concat(e.codePointAt(0),")"))(),r[s]=o,o+=32)}s[0]=o,s[1]=a}function Wb(t,e,i,n,r){const s=(t=Array.from(t)).length,o=new Array(s),a=new Array(s),l=new Array(s),h=("break-word"===i||"break-all"===i)&&isFinite(n)&&n>0,u=[0,0],c=[];let d=0,g=0,f=0;for(let p=0;p<=s;p++){const m=t[p];if("\n"!==m&&p!==s||(f=p),f>g){const s=h?jb(t,i,n,r,g,f):Vb;for(let i=0;i<=s.length;i++){const n=0===i?g:s[i-1],h=i<s.length?s[i]:f;Ub(t,n,h,r,o,c);for(let t=n;t<h;t++)a[t]=d+c[1]/2,l[t]=c[0];d+=c[1]*e,u[0]=Math.max(u[0],c[0])}g=f}"\n"===m&&(o[g]=0,a[g]=0,l[g]=0,g++)}return u[1]=d,{x:o,y:a,rowWidth:l,size:u}}class Hb{constructor(t=5){this.limit=t,this.clear()}clear(){this._cache={},this._order=[]}get(t){const e=this._cache[t];return e&&(this._deleteOrder(t),this._appendOrder(t)),e}set(t,e){this._cache[t]?(this.delete(t),this._cache[t]=e,this._appendOrder(t)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[t]=e,this._appendOrder(t))}delete(t){this._cache[t]&&(this._deleteCache(t),this._deleteOrder(t))}_deleteCache(t){delete this._cache[t]}_deleteOrder(t){const e=this._order.findIndex(e=>e===t);e>=0&&this._order.splice(e,1)}_appendOrder(t){this._order.push(t)}}const qb=function(){const t=[];for(let e=32;e<128;e++)t.push(String.fromCharCode(e));return t}();let Xb=new Hb(3);const Yb=["fontFamily","fontWeight","characterSet","fontSize","sdf","buffer","cutoff","radius"];function Qb(t,e){for(let i=0;i<t.length;i++)e.data[4*i+3]=t[i]}function Zb(t,e,i,n){t.font="".concat(n," ").concat(i,"px ").concat(e),t.fillStyle="#000",t.textBaseline="baseline",t.textAlign="left"}class Kb{constructor(){this.props={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:qb,fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12},this._key=null,this._atlas=null}get texture(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){return 1.2}setProps(t={}){Yb.forEach(e=>{e in t&&(this.props[e]=t[e])});const e=this._key;this._key=this._getKey();const i=function(t,e){const i=Xb.get(t);if(!i)return e;const n=[],r=i.mapping;let s=Object.keys(r);s=new Set(s);let o=e;return o instanceof Array&&(o=new Set(o)),o.forEach(t=>{s.has(t)||n.push(t)}),n}(this._key,this.props.characterSet),n=Xb.get(this._key);if(n&&0===i.length)return void(this._key!==e&&(this._atlas=n));const r=this._generateFontAtlas(this._key,i,n);this._atlas=r,Xb.set(this._key,r)}_generateFontAtlas(t,e,i){const{fontFamily:n,fontWeight:r,fontSize:s,buffer:o,sdf:a,radius:l,cutoff:h}=this.props;let u=i&&i.data;u||(u=document.createElement("canvas"),u.width=1024);const c=u.getContext("2d");Zb(c,n,s,r);const{mapping:d,canvasHeight:g,xOffset:f,yOffset:p}=function({characterSet:t,getFontWidth:e,fontHeight:i,buffer:n,maxCanvasWidth:r,mapping:s={},xOffset:o=0,yOffset:a=0}){let l=0,h=o,u=0;for(const o of t)if(!s[o]){const t=e(o,u++);h+t+2*n>r&&(h=0,l++),s[o]={x:h+n,y:a+l*(i+2*n)+n,width:t,height:i},h+=t+2*n}const c=i+2*n;return{mapping:s,xOffset:h,yOffset:a+l*c,canvasHeight:(d=a+(l+1)*c,Math.pow(2,Math.ceil(Math.log2(d))))};var d}({getFontWidth:t=>c.measureText(t).width,fontHeight:1.2*s,buffer:o,characterSet:e,maxCanvasWidth:1024,...i&&{mapping:i.mapping,xOffset:i.xOffset,yOffset:i.yOffset}});if(u.height!==g){const t=c.getImageData(0,0,u.width,u.height);u.height=g,c.putImageData(t,0,0)}if(Zb(c,n,s,r),a){const t=new kb.a(s,o,l,h,n,r),i=c.getImageData(0,0,t.size,t.size);for(const n of e)Qb(t.draw(n),i),c.putImageData(i,d[n].x-o,d[n].y+o)}else for(const t of e)c.fillText(t,d[t].x,d[t].y+.9*s);return{xOffset:f,yOffset:p,mapping:d,data:u,width:u.width,height:u.height}}_getKey(){const{fontFamily:t,fontWeight:e,fontSize:i,buffer:n,sdf:r,radius:s,cutoff:o}=this.props;return r?"".concat(t," ").concat(e," ").concat(i," ").concat(n," ").concat(s," ").concat(o):"".concat(t," ").concat(e," ").concat(i," ").concat(n)}}const $b={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:t=>t.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}};class Jb extends by{getShaders(){return super.getShaders({vs:"#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[vy,_y]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState({props:t,oldProps:e,changeFlags:i}){if(super.updateState({props:t,oldProps:e,changeFlags:i}),i.extensionsChanged){var n;const{gl:t}=this.context;null===(n=this.state.model)||void 0===n||n.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw({uniforms:t}){const{billboard:e,sizeScale:i,sizeUnits:n,sizeMinPixels:r,sizeMaxPixels:s,getLineWidth:o}=this.props;let{padding:a}=this.props;a.length<4&&(a=[a[0],a[1],a[0],a[1]]),this.state.model.setUniforms(t).setUniforms({billboard:e,stroked:Boolean(o),padding:a,sizeUnits:qh[n],sizeScale:i,sizeMinPixels:r,sizeMaxPixels:s}).draw()}_getModel(t){return new Om(t,{...this.getShaders(),id:this.props.id,geometry:new Ry({drawMode:6,vertexCount:4,attributes:{positions:{size:2,value:new Float32Array([0,0,1,0,1,1,0,1])}}}),isInstanced:!0})}}Jb.layerName="TextBackgroundLayer",Jb.defaultProps=$b;const tP={fontSize:64,buffer:4,sdf:!1,radius:12,cutoff:.25,smoothing:.1},eP={start:1,middle:0,end:-1},iP={top:1,center:0,bottom:-1},nP=[0,0,0,255],rP=["fontSize","buffer","sdf","radius","cutoff"],sP={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:nP},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:qb},fontFamily:"Monaco, monospace",fontWeight:"normal",lineHeight:1,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:nP},fontSettings:{},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:t=>t.text},getPosition:{type:"accessor",value:t=>t.position},getColor:{type:"accessor",value:nP},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}};class oP extends Py{initializeState(){this.state={styleVersion:0,fontAtlasManager:new Kb}}updateState({props:t,oldProps:e,changeFlags:i}){const n=i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getText),r=this.state.characterSet;n&&this._updateText();const s=r!==this.state.characterSet||this._fontChanged(e,t);s&&this._updateFontAtlas(e,t);(s||t.lineHeight!==e.lineHeight||t.wordBreak!==e.wordBreak||t.maxWidth!==e.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo({info:t}){return t.object=t.index>=0?this.props.data[t.index]:null,t}_updateFontAtlas(t,e){const{fontSettings:i,fontFamily:n,fontWeight:r}=e,{fontAtlasManager:s,characterSet:o}=this.state;s.setProps({...tP,...i,characterSet:o,fontFamily:n,fontWeight:r})}_fontChanged(t,e){if(t.fontFamily!==e.fontFamily||t.fontWeight!==e.fontWeight)return!0;if(t.fontSettings===e.fontSettings)return!1;const i=t.fontSettings||{},n=e.fontSettings||{};return rP.some(t=>i[t]!==n[t])}_updateText(){const{data:t,characterSet:e}=this.props,i=t.attributes&&t.attributes.getText;let n,{getText:r}=this.props,{startIndices:s}=t;const o="auto"===e&&new Set;if(i&&s){const{texts:e,characterCount:a}=function({value:t,length:e,stride:i,offset:n,startIndices:r,characterSet:s}){const o=t.BYTES_PER_ELEMENT,a=i?i/o:1,l=n?n/o:0,h=r[e]||Math.ceil((t.length-l)/a),u=s&&new Set,c=new Array(e);let d=t;if(a>1||l>0){d=new t.constructor(h);for(let e=0;e<h;e++)d[e]=t[e*a+l]}for(let t=0;t<e;t++){const e=r[t],i=r[t+1]||h,n=d.subarray(e,i);c[t]=String.fromCodePoint.apply(null,n),u&&n.forEach(u.add,u)}if(u)for(const t of u)s.add(String.fromCodePoint(t));return{texts:c,characterCount:h}}({...ArrayBuffer.isView(i)?{value:i}:i,length:t.length,startIndices:s,characterSet:o});n=a,r=(t,{index:i})=>e[i]}else{const{iterable:e,objectInfo:i}=jp(t);s=[0],n=0;for(const t of e){i.index++;const e=Array.from(r(t,i)||"");o&&e.forEach(o.add,o),n+=e.length,s.push(n)}}this.setState({getText:r,startIndices:s,numInstances:n,characterSet:o||e})}getBoundingRect(t,e){const i=this.state.fontAtlasManager.mapping,{getText:n}=this.state,{wordBreak:r,maxWidth:s,lineHeight:o,getTextAnchor:a,getAlignmentBaseline:l}=this.props,h=n(t,e)||"",{size:[u,c]}=Wb(h,o,r,s,i);return[(eP["function"==typeof a?a(t,e):a]-1)*u/2,(iP["function"==typeof l?l(t,e):l]-1)*c/2,u,c]}getIconOffsets(t,e){const i=this.state.fontAtlasManager.mapping,{getText:n}=this.state,{wordBreak:r,maxWidth:s,lineHeight:o,getTextAnchor:a,getAlignmentBaseline:l}=this.props,h=n(t,e)||"",{x:u,y:c,rowWidth:d,size:[g,f]}=Wb(h,o,r,s,i),p=eP["function"==typeof a?a(t,e):a],m=iP["function"==typeof l?l(t,e):l],y=u.length,b=new Array(2*y);let P=0;for(let t=0;t<y;t++){const e=(1-p)*(g-d[t])/2;b[P++]=(p-1)*g/2+e+u[t],b[P++]=(m-1)*f/2+c[t]}return b}renderLayers(){const{startIndices:t,numInstances:e,getText:i,fontAtlasManager:{scale:n,texture:r,mapping:s},styleVersion:o}=this.state,{data:a,_dataDiff:l,getPosition:h,getColor:u,getSize:c,getAngle:d,getPixelOffset:g,getBackgroundColor:f,getBorderColor:p,getBorderWidth:m,backgroundPadding:y,background:b,billboard:P,fontSettings:v,outlineWidth:S,outlineColor:C,sizeScale:w,sizeUnits:E,sizeMinPixels:x,sizeMaxPixels:A,transitions:T,updateTriggers:I}=this.props,O=this.getSubLayerClass("characters",Db),_=this.getSubLayerClass("background",Jb);return[b&&new _({getFillColor:f,getLineColor:p,getLineWidth:m,padding:y,getPosition:h,getSize:c,getAngle:d,getPixelOffset:g,billboard:P,sizeScale:w/this.state.fontAtlasManager.props.fontSize,sizeUnits:E,sizeMinPixels:x,sizeMaxPixels:A,transitions:T&&{getPosition:T.getPosition,getAngle:T.getAngle,getSize:T.getSize,getFillColor:T.getBackgroundColor,getLineColor:T.getBorderColor,getLineWidth:T.getBorderWidth,getPixelOffset:T.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:I.getPosition,getAngle:I.getAngle,getSize:I.getSize,getFillColor:I.getBackgroundColor,getLineColor:I.getBorderColor,getLineWidth:I.getBorderWidth,getPixelOffset:I.getPixelOffset,getBoundingRect:{getText:I.getText,getTextAnchor:I.getTextAnchor,getAlignmentBaseline:I.getAlignmentBaseline,styleVersion:o}}}),{data:a.attributes&&a.attributes.background?{length:a.length,attributes:a.attributes.background}:a,_dataDiff:l,autoHighlight:!1,getBoundingRect:this.getBoundingRect.bind(this)}),new O({sdf:v.sdf,smoothing:Number.isFinite(v.smoothing)?v.smoothing:tP.smoothing,outlineWidth:S,outlineColor:C,iconAtlas:r,iconMapping:s,getPosition:h,getColor:u,getSize:c,getAngle:d,getPixelOffset:g,billboard:P,sizeScale:w*n,sizeUnits:E,sizeMinPixels:x*n,sizeMaxPixels:A*n,transitions:T&&{getPosition:T.getPosition,getAngle:T.getAngle,getColor:T.getColor,getSize:T.getSize,getPixelOffset:T.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{getIcon:I.getText,getPosition:I.getPosition,getAngle:I.getAngle,getColor:I.getColor,getSize:I.getSize,getPixelOffset:I.getPixelOffset,getIconOffsets:{getText:I.getText,getTextAnchor:I.getTextAnchor,getAlignmentBaseline:I.getAlignmentBaseline,styleVersion:o}}}),{data:a,_dataDiff:l,startIndices:t,numInstances:e,getIconOffsets:this.getIconOffsets.bind(this),getIcon:i})]}static set fontAtlasCacheLimit(t){!function(t){Ta.assert(Number.isFinite(t)&&t>=3,"Invalid cache limit"),Xb=new Hb(t)}(t)}}oP.layerName="TextLayer",oP.defaultProps=sP;class aP extends Py{renderLayers(){const{updateTriggers:t={}}=this.props;return[new Eb(this.props,this.getSubLayerProps({id:"boundary",updateTriggers:{getPath:t.getPath,getWidth:t.getWidth,getColor:t.getColor},widthUnits:"pixels"}),{getPolygon:t=>Array.from(N(t.boundaryCurve,.1)).map(t=>[t.x,t.y]),getLineColor:lP,getFillColor:hP}),new oP(this.props,this.getSubLayerProps({id:"label",updateTriggers:{getText:t.getText,getSize:t.getSize,getWidth:t.getWidth,getColor:t.getColor}}),{dataTransform:t=>t.filter(t=>!(t instanceof yt)||t.labelSize),getPosition:t=>function(t){if(t instanceof yt){const e=t.boundingBox;return[e.center.x,e.bottom+t.labelSize.height/2+2]}return[t.center.x,t.center.y]}(t),getText:t=>bo.getDrawingObj(t.node).labelText,getColor:lP,sizeUnits:"common"})]}}function lP(t){const e=mo.getDrawingObj(t.node);if(e){const t=e.color;if(t)return[t.R,t.G,t.B,t.A]}return[0,0,0,255]}function hP(t){const e=mo.getDrawingObj(t.node);if(e){const t=e.fillColor;if(t)return[t.R,t.G,t.B,t.A]}return[0,0,0,0]}aP.defaultProps={...Sb.defaultProps,...oP.defaultProps};const uP=eh("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIGJhc2VQcm9maWxlPSJ0aW55IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgNjQgMzIiIG92ZXJmbG93PSJ2aXNpYmxlIiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+IDxyZWN0IGZpbGw9Im5vbmUiIHdpZHRoPSI4IiBoZWlnaHQ9IjE2Ii8+IDxwb2x5Z29uIHBvaW50cz0iMS42NSwxNC4zNSAwLjk0LDEzLjY1IDYuNTksOCAwLjk0LDIuMzUgMS42NSwxLjY1IDgsOCAJIi8+CjwvZz4KPGc+IDxyZWN0IHg9IjgiIGZpbGw9Im5vbmUiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiLz4gPHBvbHlnb24gcG9pbnRzPSIxMi42NSw3LjM1IDExLjk0LDYuNjUgMTQuNTksNCAxMS45NCwxLjM1IDEyLjY1LDAuNjUgMTYsNCAJIi8+CjwvZz4KPGc+IDxyZWN0IHg9IjgiIHk9IjgiIGZpbGw9Im5vbmUiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiLz4gPHBvbHlsaW5lIHBvaW50cz0iMTQuNTksMTIgMTEuOTQsOS4zNSAxMi42NSw4LjY1IDE2LDEyIAkiLz4KPC9nPgo8Zz4gPHJlY3QgeD0iMTYiIGZpbGw9Im5vbmUiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiLz4gPHBvbHlsaW5lIHBvaW50cz0iMjAsMSAyNCw0IDIwLDcgCSIvPgo8L2c+CjxnPiA8cmVjdCB4PSI0OCIgZmlsbD0ibm9uZSIgd2lkdGg9IjgiIGhlaWdodD0iOCIvPiA8cGF0aCBkPSJNNTAsM2MwLjU1LDAsMSwwLjQ1LDEsMXMtMC40NSwxLTEsMXMtMS0wLjQ1LTEtMVM0OS40NSwzLDUwLDMgTTUwLDJjLTEuMSwwLTIsMC45LTIsMnMwLjksMiwyLDJzMi0wLjksMi0yUzUxLjEsMiw1MCwyIEw1MCwyeiIvPgo8L2c+CjxnPiA8cmVjdCB4PSI0OCIgeT0iOCIgZmlsbD0ibm9uZSIgd2lkdGg9IjgiIGhlaWdodD0iOCIvPiA8cGF0aCBkPSJNNTEsMTBjMS4xLDAsMiwwLjksMiwycy0wLjksMi0yLDJzLTItMC45LTItMlM0OS45LDEwLDUxLDEwIE01MSw5Yy0xLjY2LDAtMywxLjM0LTMsM3MxLjM0LDMsMywzczMtMS4zNCwzLTNTNTIuNjYsOSw1MSw5IEw1MSw5eiIvPgo8L2c+CjxnPiA8cmVjdCB4PSIzMiIgZmlsbD0ibm9uZSIgd2lkdGg9IjgiIGhlaWdodD0iMTYiLz4gPHBvbHlsaW5lIHBvaW50cz0iMzYsMyA0MCw4IDM2LDEzIAkiLz4KPC9nPgo8Zz4gPHJlY3QgeD0iMjQiIGZpbGw9Im5vbmUiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiLz4gPHBvbHlsaW5lIHBvaW50cz0iMjYsMiAzMiw0IDI2LDYgCSIvPgo8L2c+CjxnPiA8cmVjdCB4PSIxNiIgeT0iOCIgZmlsbD0ibm9uZSIgd2lkdGg9IjgiIGhlaWdodD0iOCIvPiA8cG9seWxpbmUgcG9pbnRzPSIyMCw5IDI0LDEyIDIwLDEyIAkiLz4KPC9nPgo8Zz4gPHJlY3QgeD0iMjQiIHk9IjgiIGZpbGw9Im5vbmUiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiLz4gPHBvbHlsaW5lIHBvaW50cz0iMjYsMTAgMzIsMTIgMjYsMTIgCSIvPgo8L2c+CjxnPiA8cmVjdCB4PSI1NiIgZmlsbD0ibm9uZSIgd2lkdGg9IjgiIGhlaWdodD0iOCIvPiA8Y2lyY2xlIGN4PSI1OCIgY3k9IjQiIHI9IjIiLz4KPC9nPgo8Zz4gPHJlY3QgeD0iNTYiIHk9IjgiIGZpbGw9Im5vbmUiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiLz4gPGNpcmNsZSBjeD0iNTkiIGN5PSIxMiIgcj0iMyIvPgo8L2c+Cjwvc3ZnPgo=",Jf,{imagebitmap:{resizeWidth:1024,resizeHeight:512}}),cP=function(t,e){for(const i in t){const n=t[i];n.x*=e,n.y*=e,n.width*=e,n.height*=e,n.anchorX&&(n.anchorX*=e),n.anchorY&&(n.anchorY*=e)}return t}({caret:{mask:!0,x:32,y:0,width:32,height:32,anchorX:32},"half-caret":{mask:!0,x:32,y:32,width:32,height:32,anchorX:32},"caret-lg":{mask:!0,x:0,y:0,width:32,height:64,anchorX:32},triangle:{mask:!0,x:64,y:0,width:32,height:32,anchorX:32},"triangle-ex":{mask:!0,x:64,y:0,width:32,height:32},"half-triangle":{mask:!0,x:64,y:32,width:32,height:32,anchorX:32},"half-triangle-ex":{mask:!0,x:64,y:32,width:32,height:32},"triangle-n":{mask:!0,x:104,y:4,width:24,height:24,anchorX:24},"triangle-n-ex":{mask:!0,x:96,y:0,width:32,height:32,anchorX:8},"half-triangle-n":{mask:!0,x:96,y:32,width:32,height:32,anchorX:32},"half-triangle-n-ex":{mask:!0,x:96,y:32,width:32,height:32,anchorX:8},"triangle-w":{mask:!0,x:128,y:0,width:32,height:64,anchorX:32},"triangle-w-ex":{mask:!0,x:128,y:0,width:32,height:64},"circle-ex":{mask:!0,x:192,y:0,width:32,height:32,anchorX:0},"circle-lg-ex":{mask:!0,x:192,y:32,width:32,height:32,anchorX:0},dot:{mask:!0,x:224,y:0,width:32,height:32,anchorX:8},"dot-ex":{mask:!0,x:224,y:0,width:32,height:32,anchorX:0},"dot-lg":{mask:!0,x:224,y:32,width:32,height:32,anchorX:12},"dot-lg-ex":{mask:!0,x:224,y:32,width:32,height:32,anchorX:0}},4);class dP extends Py{updateState(t){if(super.updateState(t),t.changeFlags.dataChanged){const e=[];for(const i of t.props.data){const t=i;t.sourceArrowhead&&e.push({edge:i,type:"triangle-n",tip:t.sourceArrowhead.tipPosition,end:t.curve.start}),t.targetArrowhead&&e.push({edge:i,type:"triangle-n",tip:t.targetArrowhead.tipPosition,end:t.curve.end})}this.setState({arrows:e})}}renderLayers(){const t=this.props,{updateTriggers:e={}}=t;return[new Sb(t,this.getSubLayerProps({id:"path",updateTriggers:{getPath:e.getPath,getWidth:e.getWidth,getColor:e.getColor}}),{getPath:t=>Array.from(N(t.curve,.01)).map(t=>[t.x,t.y]),getColor:gP,widthUnits:"pixels"}),new Mb(this.getSubLayerProps({id:"arrow",updateTriggers:{getPosition:e.getPath,getColor:e.getColor}}),{data:this.state.arrows,iconAtlas:uP,iconMapping:cP,getPosition:t=>[t.tip.x,t.tip.y],getColor:t=>gP(t.edge),getIcon:t=>t.type,getSize:t=>function(t,e){const i=t.x-e.x,n=t.y-e.y;return Math.sqrt(i*i+n*n)}(t.tip,t.end),getAngle:t=>function(t,e){const i=t.x-e.x,n=t.y-e.y;return-Math.atan2(n,i)/Math.PI*180}(t.tip,t.end),sizeUnits:"common"})]}}function gP(t){const e=mo.getDrawingObj(t.edge);if(e){const t=e.color;if(t)return[t.R,t.G,t.B]}return[0,0,0]}function fP(t){return t?new V(8*t.length+8,20):null}function pP(t,e=fP){let i=yt.getGeom(t.graph);null!=i&&null!=i.layoutSettings&&i.layoutSettings.runRoutingOnly||(i=t.createGeometry(e));for(const t of i.subgraphs())n(t);return n(i),gs(i,null),i;function n(e){if(null!=e.layoutSettings)return;let i=!1;for(const t of e.edges())if(null!=t.sourceArrowhead||null!=t.targetArrowhead){i=!0;break}const n=e.graph.shallowNodeCount>500||e.graph.nodeCollection.edgeCount>500;if(i&&!n){const i=e.layoutSettings=new Ut;t.rankdir&&(i.layerDirection=t.rankdir)}else e.layoutSettings=new cs}}function mP(t,e,i){i[t]=i[t]||[],i[t].indexOf(e)<0&&i[t].push(e)}function yP(t,e,i){if(i[t]){const n=i[t].indexOf(e);n>=0&&i[t].splice(n,1)}}dP.defaultProps={...Sb.defaultProps};class bP{constructor(t){this.focus=-1,this.items=[],this.options={getLabel:t=>t.toString(),renderItem:(t,e)=>{if(!e)return t;const i=t.toLowerCase().indexOf(e);return`${t.slice(0,i)}<b>${t.slice(i,i+e.length)}</b>${t.slice(i+e.length)}`},filterItem:(t,e)=>{if(!e)return 1;const i=t.toLowerCase().indexOf(e);return 0===i?2:i>0?1:0},onSelect:()=>{},buffer:2,itemHeight:32,maxHeight:240},this._active=!1,this._topOffset=0,this._keyword="",this._filteredItems=[],this._items=[],this._onScroll=()=>{const{itemHeight:t,buffer:e,getLabel:i,renderItem:n}=this.options,r=this._flyout.scrollTop;this._topOffset=Math.max(0,Math.floor(r/t)-e),this._scroller.style.paddingTop=this._topOffset*t+"px";for(let t=0;t<this._items.length;t++){const e=this._items[t],r=t+this._topOffset;r===this.focus?e.classList.add("focus"):e.classList.remove("focus");const s=this._filteredItems[r];if(s){const t=i(s);e.innerHTML=n(t,this._keyword,s)}}};const e=document.createElement("style");e.innerText='\n  .search-control { pointer-events: all; font-family: "Segoe UI", Helvetica, Arial, sans-serif; font-size: 14px; position: absolute; top: 0; right: 0; margin: 20px; width: 200px; }\n  .search-control-input { font-family: "Segoe UI", Helvetica, Arial, sans-serif; font-size: 14px; padding: 8px; width: 100%; }\n  .search-control-options { background: #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.3); padding: 12px 0; margin-top: 4px; overflow-x: hidden; overflow-y: auto; }\n  .search-control-option { padding: 0 12px; line-height: 32px; white-space: nowrap; color: #000; cursor: pointer; }\n  .search-control-option:hover { background: #f8f8f8; }\n  .search-control-option.focus { color: #08f; background: #f8f8f8; }\n',document.head.appendChild(e),this._stylesheet=e;const i=document.createElement("div");i.className="search-control";const n=document.createElement("input");n.placeholder="Search...",n.className="search-control-input",i.appendChild(n),n.addEventListener("focus",()=>{n.value="",this._keyword="",this._active=!0,this._updateFilter()}),n.addEventListener("blur",()=>{setTimeout(()=>{this._active=!1,this._updateUI()},200)}),n.addEventListener("input",t=>{this._keyword=n.value.toLowerCase(),this._updateFilter()}),n.addEventListener("keydown",t=>{switch(t.key){case"ArrowDown":t.preventDefault(),this.focus=Math.min(this._filteredItems.length-1,this.focus+1),this._updateUI();break;case"ArrowUp":t.preventDefault(),this.focus=Math.max(0,this.focus-1),this._updateUI();break;case"Enter":this._select(this.focus)}}),this._textbox=n;const r=document.createElement("div");r.className="search-control-options",r.addEventListener("scroll",this._onScroll),i.appendChild(r);const s=document.createElement("div");s.style.boxSizing="border-box",s.style.overflow="hidden",r.appendChild(s),this._flyout=r,this._scroller=s,this.element=i,this.setOptions(t)}delete(){this.items=null,this._stylesheet.remove(),this._stylesheet=null,this.element.remove(),this.element=null,this._scroller=null,this._flyout=null}setOptions(t){Object.assign(this.options,t);const e=Math.ceil(this.options.maxHeight/this.options.itemHeight)+2*this.options.buffer,i=this._items;if(i.length!==e){for(let t=i.length;t<e;t++){const e=this._makeItem(t);i.push(e)}for(let t=i.length;t>e;t--)i[t-1].remove()}this._updateFilter()}update(t){this.items=t,this._textbox.value="",this._keyword="",this._updateFilter()}_updateFilter(){const{getLabel:t,filterItem:e}=this.options,i=this.items.map(i=>{const n=t(i);return e(n,this._keyword,i)}),n=Array.from(i,(t,e)=>e).filter(t=>i[t]);n.sort((t,e)=>i[e]-i[t]),this._filteredItems=n.map(t=>this.items[t]),this.focus=0,this._updateUI()}_select(t){const e=this._filteredItems[t];e&&(this.options.onSelect(e),this._textbox.value=this.options.getLabel(e),this._textbox.blur())}_updateUI(){if(!this._active)return void(this._flyout.style.display="none");this._flyout.style.display="block",this._flyout.style.maxHeight=this.options.maxHeight+"px";const{itemHeight:t,maxHeight:e}=this.options,i=this._filteredItems.length,n=Math.floor(e/t),r=Math.max(0,(this.focus+2-n)*t),s=Math.min(Math.max(0,i*t-e),Math.max(0,this.focus-1)*t);let o=this._flyout.scrollTop;o<r&&(o=r),o>s&&(o=s),this._scroller.style.height=i*t+"px";for(let t=0;t<this._items.length;t++){this._items[t].style.display=t<i?"block":"none"}this._flyout.scrollTo({left:0,top:o,behavior:"smooth"}),this._onScroll()}_makeItem(t){const e=document.createElement("div");return e.className="search-control-option",e.style.height=this.options.itemHeight+"px",this._scroller.appendChild(e),e.addEventListener("click",()=>{this._select(t+this._topOffset)}),e}}const PP=new class extends class{constructor(){this._listeners={},this._onceListeners={}}on(t,e){mP(t,e,this._listeners)}once(t,e){mP(t,e,this._onceListeners)}off(t,e){yP(t,e,this._listeners),yP(t,e,this._onceListeners)}emit(t){var e,i;let n;n="string"==typeof t?{type:t}:t;const r=n.type;if(!this._listens(r))return;n.target=this;const s=(null===(e=this._listeners[r])||void 0===e?void 0:e.slice())||[];for(const t of s)t.call(this,n);const o=(null===(i=this._onceListeners[r])||void 0===i?void 0:i.slice())||[];for(const t of o)yP(r,t,this._onceListeners),t.call(this,n)}_listens(t){return this._listeners[t]&&this._listeners[t].length>0||this._onceListeners[t]&&this._onceListeners[t].length>0}}{constructor(t=document.body){super(),this._controls=[],t.style.position="relative";const e=Array.from({length:2},()=>{const e=document.createElement("div");return Object.assign(e.style,{position:"absolute",top:0,bottom:0,left:0,right:0}),t.appendChild(e)});this._deck=new Dp({parent:e[0],views:[new bf({maxZoom:4})],initialViewState:{target:[0,0,0],zoom:0},controller:!0,onLoad:()=>{this.emit("load"),this._update()}}),e[1].style.pointerEvents="none",this._controlsContainer=e[1]}get drawingGraph(){return this._drawingGraph}addControl(t){if(this._controls.indexOf(t)<0){this._controls.push(t),t.onAdd(this);const e=t.getElement();e&&this._controlsContainer.appendChild(e)}}removeControl(t){const e=this._controls.indexOf(t);if(e>=0){const i=t.getElement();i&&i.remove(),t.onRemove(this),this._controls.splice(e,1)}}get graph(){return this._geomGraph}get layoutOptions(){const t=yt.getGeom(this._drawingGraph.graph);return null==t?null:t.layoutSettings}setGraph(t=this._drawingGraph){this._drawingGraph=t,this._deck.layerManager&&this._update()}zoomTo(t){const e=Math.min(this._deck.width/t.width,this._deck.height/t.height),i=Math.min(Math.log2(e)-1,4);this._deck.setProps({initialViewState:{target:[t.center.x,t.center.y,0],zoom:i,transitionInterpolator:new Pg(["target","zoom"]),transitionDuration:1e3}})}_update(){if(!this._drawingGraph)return;const t=this._geomGraph=pP(this._drawingGraph),e=t.boundingBox.center,i=new dP({id:"edges",data:Array.from(t.deepEdges()),getWidth:1}),n=new aP({id:"nodeBoundaries",data:Array.from(t.deepNodes()),getWidth:1,getSize:14,sizeMaxPixels:24,onClick:(t,e)=>function(t,e){console.log(t),console.log(e);const i=t.object;i.center=i.center.add(new E(100,0))}(t,e),pickable:!0});this._deck.setProps({initialViewState:{target:[e.x,e.y,0],zoom:0},layers:[n,i]}),this.emit({type:"graphload",data:t})}};PP.addControl(new class{constructor(){this._nodes=[],this._onGraphLoad=t=>{this._updateNodeList(t.data)}}onAdd(t){t.on("graphload",this._onGraphLoad),this._dropdown=new bP({getLabel:t=>t.id,onSelect:e=>{t.zoomTo(e.boundingBox)}}),this._updateNodeList(t.graph)}onRemove(t){t.off("graphload",this._onGraphLoad),this._dropdown.delete(),this._dropdown=null}getElement(){return this._dropdown.element}_updateNodeList(t){this._nodes=t?Array.from(t.deepNodes()):[],this._dropdown.update(this._nodes)}});const vP=document.getElementById("rs");vP.onchange=function(){(function(){const t=vP.options[vP.selectedIndex].value,e=yt.getGeom(PP.drawingGraph.graph).layoutSettings;switch(t){case"rectilinear":e.edgeRoutingSettings.EdgeRoutingMode=It.Rectilinear,e.edgeRoutingSettings.BundlingSettings=null,e.runRoutingOnly=!0;break;case"splines":e.edgeRoutingSettings.EdgeRoutingMode=It.Spline,e.edgeRoutingSettings.BundlingSettings=null,e.runRoutingOnly=!0;break;case"bundles":e.edgeRoutingSettings.EdgeRoutingMode=It.SplineBundling,e.runRoutingOnly=!0;break;case"straight":e.edgeRoutingSettings.EdgeRoutingMode=It.StraightLine,e.edgeRoutingSettings.BundlingSettings=null,e.runRoutingOnly=!0;break;case"default":e.edgeRoutingSettings.BundlingSettings=null,e instanceof Ut?(e.edgeRoutingSettings.EdgeRoutingMode=It.SugiyamaSplines,e.runRoutingOnly=!1):(e.edgeRoutingSettings.EdgeRoutingMode=It.Spline,e.runRoutingOnly=!0)}})(),PP.setGraph()};const SP=document.getElementById("gv");SP.onchange=function(){const t=SP.options[SP.selectedIndex].value;fetch("https://raw.githubusercontent.com/microsoft/msagljs/main/modules/core/test/data/graphvis/"+t).then(t=>t.text()).then(t=>{PP.setGraph(Bo(t))})},function(t,e){const i=document.getElementById(t);i.ondragover=t=>{t.preventDefault(),i.classList.add("active")},i.ondragleave=()=>{i.classList.remove("active")},i.ondrop=t=>{t.preventDefault(),i.classList.remove("active");const n=t.dataTransfer.items[0];"file"===n.kind&&e(n.getAsFile())},i.onclick=()=>{const t=document.createElement("input");t.type="file",t.onchange=()=>t.files.length&&e(t.files[0]),t.click()}}("drop-target",async t=>{const e=await async function(t){const e=Bo(await t.text());return e.graph.id=t.name,e}(t);PP.setGraph(e),document.getElementById("graph-name").innerText=e.graph.id}),(async()=>{const t=await async function(){const t=await fetch("https://gist.githubusercontent.com/mohdsanadzakirizvi/6fc325042ce110e1afc1a7124d087130/raw/ab9a310cfc2003f26131a7149950947645391e28/got_social_graph.json"),e=await t.json(),i=new p("got_social_graph.json"),n={};for(const t of e.nodes){n[t.id]=t;const e=i.addNode(new g(t.character)),r=new bo(e);r.labelText=t.character,r.ShapeEnum=Ps.box,r.color="Arya"==r.labelText?po.Red:po.Black}for(const t of e.links){const e=i.setEdge(n[t.source].character,n[t.target].character),r=new vo(e);Yo(e)&&(r.color=po.Blue),r.arrowtail=bs.none,r.arrowhead=bs.none,r.directed=!1}return new Po(i)}();PP.setGraph(t),document.getElementById("graph-name").innerText=t.id})()}]);